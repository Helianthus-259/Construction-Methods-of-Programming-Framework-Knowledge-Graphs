{
  "relationships": [
    {
      "head": "org.springframework.core.type.StandardMethodMetadata#getReturnTypeName()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getReturnTypeName",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.core.type.StandardMethodMetadata#getReturnTypeName()",
      "head_type": "method",
      "relation": "have",
      "tail": "getReturnTypeName",
      "tail_type": "useSampleCode"
    },
    {
      "head": "getReturnTypeName",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "tail": "org.springframework.core.type.StandardMethodMetadata",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.core.type.StandardMethodMetadata#getAllAnnotationAttributes(String,boolean)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getAllAnnotationAttributes",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.core.type.StandardMethodMetadata#getAllAnnotationAttributes(String,boolean)",
      "head_type": "method",
      "relation": "have",
      "tail": "getAllAnnotationAttributes(String,boolean) Sample Code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "getAllAnnotationAttributes(String,boolean) Sample Code",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "getAllAnnotationAttributes(String,boolean) Code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.AutoPopulatingList#containsAll(Collection<?>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "check if a collection contains all elements of another collection",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.AutoPopulatingList#containsAll(Collection<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method checks if the backing list contains all elements of the specified collection.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.AutoPopulatingList#containsAll(Collection<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "The method utilizes the containsAll method of the backing list to determine if all elements are present.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.AutoPopulatingList#containsAll(Collection<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "package com.example;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\n\npublic class AutoPopulatingListExample {\n    public static void main(String[] args) {\n        List<String> backingList = new ArrayList<>();\n        backingList.add(\"apple\");\n        backingList.add(\"banana\");\n        backingList.add(\"cherry\");\n\n        Collection<String> c = new ArrayList<>();\n        c.add(\"apple\");\n        c.add(\"banana\");\n\n        AutoPopulatingList<String> autoList = new AutoPopulatingList<>(backingList);\n        boolean result = autoList.containsAll(c);\n        System.out.println(\"Contains all elements: \" + result);\n    }\n}\n\nclass AutoPopulatingList<E> extends ArrayList<E> {\n    private List<E> backingList;\n\n    public AutoPopulatingList(List<E> backingList) {\n        this.backingList = backingList;\n    }\n\n    @Override\n    public boolean containsAll(Collection<?> c) {\n        return this.backingList.containsAll(c);\n    }\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.AutoPopulatingList#remove(int)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "removeElement",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.AutoPopulatingList#remove(int)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.AutoPopulatingList",
      "tail_type": "class"
    },
    {
      "head": "removeElement",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "org.springframework.util.AutoPopulatingList",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.AutoPopulatingList",
      "head_type": "class",
      "relation": "designPrincipleInterpretation",
      "tail": "The AutoPopulatingList class is designed to automatically populate elements as they are added, ensuring that the list maintains a consistent state without manual intervention.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.AutoPopulatingList",
      "head_type": "class",
      "relation": "relatedConceptInterpretation",
      "tail": "AutoPopulatingList is a specialized list implementation that automatically populates elements based on a backing list. It ensures that elements are automatically populated and maintained in a consistent state.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.AutoPopulatingList#remove(int)",
      "head_type": "method",
      "relation": "useSampleCode",
      "tail": "package com.example;\n\nimport org.springframework.util.AutoPopulatingList;\n\npublic class Main {\n    public static void main(String[] args) {\n        AutoPopulatingList<String> list = new AutoPopulatingList<>();\n        list.add(\"Element 1\");\n        list.add(\"Element 2\");\n        list.add(\"Element 3\");\n        \n        System.out.println(\"Original List: \" + list);\n        \n        list.remove(1); // Removes the element at index 1\n        \n        System.out.println(\"List after removal: \" + list);\n    }\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ClassUtils#isVisible(Class<?>,ClassLoader)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "checkClassVisibility",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ClassUtils#isVisible(Class<?>,ClassLoader)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "nullClassLoaderAlwaysVisible",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ClassUtils#isVisible(Class<?>,ClassLoader)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "interfaceVisibilityCheck",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ClassUtils#isVisible(Class<?>,ClassLoader)",
      "head_type": "method",
      "relation": "have",
      "tail": "sampleCodeForVisibilityCheck",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ClassUtils#isVisible(Class<?>,ClassLoader)",
      "head_type": "method",
      "relation": "have",
      "tail": "classVisibilityExplanation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#isVisible(Class<?>,ClassLoader)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrinciplesOfClassVisibility",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#isVisible(Class<?>,ClassLoader)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.ClassUtils",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.CollectionUtils#findValueOfType(Collection<?>,Class<?>[])",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "find a single value of one of the given types in the given Collection",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.CollectionUtils#findValueOfType(Collection<?>,Class<?>[])",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "isEmpty(collection) || ObjectUtils.isEmpty(types)",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.CollectionUtils#findValueOfType(Collection<?>,Class<?>[])",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "searching the Collection for a value of the first type, then searching for a value of the second type, etc.",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.CollectionUtils#findValueOfType(Collection<?>,Class<?>[])",
      "head_type": "method",
      "relation": "have",
      "tail": "public static Object findValueOfType(Collection<?> collection, Class<?>[] types) {\n    if (isEmpty(collection) || ObjectUtils.isEmpty(types)) {\n        return null;\n    }\n    for (Class<?> type : types) {\n        Object value = findValueOfType(collection, type);\n        if (value != null) {\n            return value;\n        }\n    }\n    return null;\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.CollectionUtils#findValueOfType(Collection<?>,Class<?>[])",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.CollectionUtils#findValueOfType(Collection<?>,Class<?>[])",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.CollectionUtils",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.CollectionUtils#findValueOfType(Collection<?>,Class<?>[])",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.comparator.InstanceComparator#compare(T,T)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "compare two instances",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.comparator.InstanceComparator#compare(T,T)",
      "head_type": "method",
      "relation": "have",
      "tail": "compare two instances sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "compare two instances sample code",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "java\n@Override\npublic int compare(T o1, T o2) {\n    int i1 = getOrder(o1);\n    int i2 = getOrder(o2);\n    return (Integer.compare(i1, i2));\n}\n",
      "tail_type": "code"
    },
    {
      "head": "org.springframework.util.CompositeCollection#clear()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "clearing contents",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.CompositeCollection#clear()",
      "head_type": "method",
      "relation": "have",
      "tail": "Clears the contents of both the first and second collections.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.CompositeCollection#clear()",
      "head_type": "method",
      "relation": "have",
      "tail": "public void clear() { this.first.clear(); this.second.clear(); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.CompositeCollection#clear()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.CompositeCollection",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.ConcurrentLruCache#size()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "Return the current size of the cache",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ConcurrentLruCache#size()",
      "head_type": "method",
      "relation": "have",
      "tail": "Return the current size of the cache",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ConcurrentLruCache#size()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.ConcurrentLruCache",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.ConcurrentLruCache#size()",
      "head_type": "method",
      "relation": "have",
      "tail": "Return the current size of the cache",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ConcurrentLruCache#size()",
      "head_type": "method",
      "relation": "have",
      "tail": "Return the current size of the cache",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ConcurrentReferenceHashMap#getSegment(int)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getSegment",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ConcurrentReferenceHashMap#getSegment(int)",
      "head_type": "method",
      "relation": "have",
      "tail": "getSegment(int index) { return this.segments[index]; }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ConcurrentReferenceHashMap",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.ConcurrentReferenceHashMap#getSegment(int)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.ConcurrentReferenceHashMap#get(Object)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": " retrieval of values associated with a key",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ConcurrentReferenceHashMap#get(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "thread-safe retrieval of values",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ConcurrentReferenceHashMap#get(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "null value handling",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ConcurrentReferenceHashMap#get(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "ConcurrentReferenceHashMap",
      "tail_type": "class"
    },
    {
      "head": "ConcurrentReferenceHashMap",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "thread-safe operations",
      "tail_type": "apiFunction"
    },
    {
      "head": "ConcurrentReferenceHashMap",
      "head_type": "class",
      "relation": "have",
      "tail": "memory-sensitive cache",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "ConcurrentReferenceHashMap",
      "head_type": "class",
      "relation": "have",
      "tail": "minimize memory footprint",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "ConcurrentReferenceHashMap",
      "head_type": "class",
      "relation": "have",
      "tail": "use of reference objects for key and value",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ConcurrentReferenceHashMap#putIfAbsent(K,V)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "putIfAbsent",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ConcurrentReferenceHashMap#putIfAbsent(K,V)",
      "head_type": "method",
      "relation": "have",
      "tail": "putIfAbsent complete sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "putIfAbsent complete sample code",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "org.springframework.util.ConcurrentReferenceHashMap#putIfAbsent(K,V) sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ConcurrentReferenceHashMap#doTask(Object,Task<T>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "execute task",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ConcurrentReferenceHashMap#doTask(Object,Task<T>)",
      "head_type": "method",
      "relation": "have",
      "tail": "execute task with key and hash",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ConcurrentReferenceHashMap#doTask(Object,Task<T>)",
      "head_type": "method",
      "relation": "have",
      "tail": "private <T> T doTask(@Nullable Object key, Task<T> task) { int hash = getHash(key); return getSegmentForHash(hash).doTask(hash, key, task); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ConcurrentReferenceHashMap#doTask(Object,Task<T>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.ConcurrentReferenceHashMap",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.ConcurrentReferenceHashMap#doTask(Object,Task<T>)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ConcurrentReferenceHashMap#doTask(Object,Task<T>)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.DigestUtils#md5DigestAsHex(byte[])",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "MD5 digest calculation",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.DigestUtils#md5DigestAsHex(byte[])",
      "head_type": "method",
      "relation": "have",
      "tail": "Return a hexadecimal string representation of the MD5 digest of the given bytes.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.DigestUtils#md5DigestAsHex(byte[])",
      "head_type": "method",
      "relation": "have",
      "tail": "The method takes an array of bytes as input and returns a string that represents the MD5 hash of those bytes in hexadecimal format.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.DigestUtils#md5DigestAsHex(byte[])",
      "head_type": "method",
      "relation": "have",
      "tail": "public static String md5DigestAsHex(byte[] bytes) {\n    return digestAsHexString(MD5_ALGORITHM_NAME, bytes);\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.DigestUtils#appendMd5DigestAsHex(InputStream,StringBuilder)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "append hexadecimal MD5 digest",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.DigestUtils#appendMd5DigestAsHex(InputStream,StringBuilder)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "input stream not closed",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.DigestUtils#appendMd5DigestAsHex(InputStream,StringBuilder)",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.DigestUtils#appendMd5DigestAsHex(InputStream,StringBuilder)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.DigestUtils#appendMd5DigestAsHex(InputStream,StringBuilder)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "append hexadecimal MD5 digest",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "input stream processing",
      "tail_type": "useScenario"
    },
    {
      "head": "input stream not closed",
      "head_type": "useConstraint",
      "relation": "associated_with",
      "tail": "MD5 digest calculation",
      "tail_type": "apiFunction"
    },
    {
      "head": "relatedConceptInterpretation",
      "head_type": "relatedConceptInterpretation",
      "relation": "associated_with",
      "tail": "MD5 digest",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "designPrincipleInterpretation",
      "head_type": "designPrincipleInterpretation",
      "relation": "associated_with",
      "tail": "MD5 digest",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.FastByteArrayOutputStream#close()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "closeStream",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.FastByteArrayOutputStream#close()",
      "head_type": "method",
      "relation": "have",
      "tail": "closeStreamSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "closeStreamSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "closeStreamCompleteExample",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.FastByteArrayOutputStream#toString(Charset)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "Convert stream contents to string using Charset",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.FastByteArrayOutputStream#toString(Charset)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "Charset must be specified",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.FastByteArrayOutputStream#toString(Charset)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "Decoding bytes to string",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.FastByteArrayOutputStream#toString(Charset)",
      "head_type": "method",
      "relation": "have",
      "tail": "Convert this stream's contents to a string by decoding the bytes using the specified Charset.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.FastByteArrayOutputStream#toString(Charset)",
      "head_type": "method",
      "relation": "have",
      "tail": "Efficiently convert byte stream to String using specified Charset.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.FastByteArrayOutputStream#toString(Charset)",
      "head_type": "method",
      "relation": "have",
      "tail": "package com.example.demo;\n\nimport java.io.ByteArrayOutputStream;\nimport java.nio.charset.Charset;\nimport java.nio.charset.StandardCharsets;\n\npublic class Main {\n    public static void main(String[] args) {\n        FastByteArrayOutputStream fastByteArrayOutputStream = new FastByteArrayOutputStream();\n        fastByteArrayOutputStream.write(\"Hello, World!\".getBytes(StandardCharsets.UTF_8));\n        Charset charset = Charset.forName(\"UTF-8\");\n        String result = fastByteArrayOutputStream.toString(charset);\n        System.out.println(result);\n    }\n}\n",
      "tail_type": "useSampleCode"
    },
    {
      "head": "Convert stream contents to string using Charset",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "org.springframework.util.FastByteArrayOutputStream#toString(Charset)",
      "tail_type": "method"
    },
    {
      "head": "Charset must be specified",
      "head_type": "useConstraint",
      "relation": "associated_with",
      "tail": "org.springframework.util.FastByteArrayOutputStream#toString(Charset)",
      "tail_type": "method"
    },
    {
      "head": "Decoding bytes to string",
      "head_type": "useScenario",
      "relation": "associated_with",
      "tail": "org.springframework.util.FastByteArrayOutputStream#toString(Charset)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.FileCopyUtils#copy(byte[],OutputStream)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "copy contents of byte array to OutputStream",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.FileCopyUtils#copy(byte[],OutputStream)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "input byte array must be specified",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.FileCopyUtils#copy(byte[],OutputStream)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "OutputStream must be specified",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.FileCopyUtils#copy(byte[],OutputStream)",
      "head_type": "method",
      "relation": "have",
      "tail": "copy contents of byte array to OutputStream sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.FileCopyUtils#copy(byte[],OutputStream)",
      "head_type": "method",
      "relation": "have",
      "tail": "copy contents of byte array to OutputStream related concept interpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.FileCopyUtils#copy(byte[],OutputStream)",
      "head_type": "method",
      "relation": "have",
      "tail": "copy contents of byte array to OutputStream design principle interpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.FileCopyUtils#copy(byte[],OutputStream)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "java.io.IOException",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.FileCopyUtils#copy(byte[],OutputStream)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "java.io.OutputStream",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.FileCopyUtils#copy(byte[],OutputStream)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.Assert",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.FilteredCollection",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "filtered collection",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.FilteredCollection",
      "head_type": "class",
      "relation": "constrained_by",
      "tail": "elements must match a predicate",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.FilteredCollection",
      "head_type": "class",
      "relation": "applied_to",
      "tail": "filtering elements in a collection",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.FilteredCollection",
      "head_type": "class",
      "relation": "have",
      "tail": "sample code for using FilteredCollection",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.FilteredCollection",
      "head_type": "class",
      "relation": "have",
      "tail": "related concept interpretation for FilteredCollection",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.FilteredCollection",
      "head_type": "class",
      "relation": "have",
      "tail": "design principle interpretation for FilteredCollection",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.FilteredCollection",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "CompositeMap",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.function.SupplierUtils",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "resolveSupplier",
      "tail_type": "apiFunction"
    },
    {
      "head": "resolveSupplier",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "resolveSupplierSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "resolveSupplier",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "supplierNotNull",
      "tail_type": "useConstraint"
    },
    {
      "head": "resolveSupplier",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "supplierResolution",
      "tail_type": "useScenario"
    },
    {
      "head": "resolveSupplier",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "supplierResolutionInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.function.SupplierUtils",
      "head_type": "class",
      "relation": "have",
      "tail": "supplierUtilsDesignPrinciple",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.function.SupplierUtils",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "java.util.function.Supplier",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.function.ThrowingConsumer#throwing(BiFunction<String,Exception,RuntimeException>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "exception wrapping",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.function.ThrowingConsumer#throwing(BiFunction<String,Exception,RuntimeException>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "exceptionWrapper must not be null",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.function.ThrowingConsumer#throwing(BiFunction<String,Exception,RuntimeException>)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "handling checked exceptions in functional interfaces",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.function.ThrowingConsumer#throwing(BiFunction<String,Exception,RuntimeException>)",
      "head_type": "method",
      "relation": "have",
      "tail": "return a new ThrowingConsumer instance",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.function.ThrowingConsumer#throwing(BiFunction<String,Exception,RuntimeException>)",
      "head_type": "method",
      "relation": "have",
      "tail": "related concept interpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.function.ThrowingConsumer#throwing(BiFunction<String,Exception,RuntimeException>)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle interpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.function.ThrowingConsumer#throwing(BiFunction<String,Exception,RuntimeException>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.function.ThrowingConsumer",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.LinkedCaseInsensitiveMap#put(String,V)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "put",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.LinkedCaseInsensitiveMap#put(String,V)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.LinkedCaseInsensitiveMap",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.LinkedCaseInsensitiveMap#put(String,V)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.LinkedCaseInsensitiveMap#put(String,V)_useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.LinkedCaseInsensitiveMap#put(String,V)_useSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "org.springframework.util.LinkedCaseInsensitiveMap#put(String,V)_useSampleCode_content",
      "tail_type": "content"
    },
    {
      "head": "org.springframework.util.ValuesIterator",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "next",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ValuesIterator",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "nextEntry",
      "tail_type": "apiFunction"
    },
    {
      "head": "next",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "return nextEntry().getValue()",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ValuesIterator",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "nextEntry",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ValuesIterator",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "getValue",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MethodInvoker#getTargetMethod()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getTargetMethod",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MethodInvoker#getTargetMethod()",
      "head_type": "method",
      "relation": "have",
      "tail": "Return the name of the method to be invoked.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.MethodInvoker",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.MethodInvoker#getTargetMethod()",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.MimeType#isWildcardType()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "wildcard type checking",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MimeType#isWildcardType()",
      "head_type": "method",
      "relation": "have",
      "tail": "The method checks if the MIME type is a wildcard type represented by '*'.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.MimeType#isWildcardType()",
      "head_type": "method",
      "relation": "have",
      "tail": "Design principle: Simplify common operations on MIME types.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.MimeType#isWildcardType()",
      "head_type": "method",
      "relation": "have",
      "tail": "public boolean isWildcardType() {\n    return WILDCARD_TYPE.equals(getType());\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.MimeType#parametersAreEqual(MimeType)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "MimeType parameter comparison",
      "tail_type": "apiFunction"
    },
    {
      "head": "MimeType parameter comparison",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "case-insensitive Charset comparison",
      "tail_type": "useConstraint"
    },
    {
      "head": "MimeType parameter comparison",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "MimeType equality determination",
      "tail_type": "useScenario"
    },
    {
      "head": "MimeType parameter comparison",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "MimeType parameter comparison sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "MimeType parameter comparison",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "MimeType parameter comparison related concept interpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "MimeType parameter comparison",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "MimeType parameter comparison design principle interpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.MimeType#parametersAreEqual(MimeType)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.MimeType",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.MultiToSingleValueMapAdapter#remove(Object)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "removeValue",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MultiToSingleValueMapAdapter#remove(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.MultiToSingleValueMapAdapter#remove(Object) useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.MultiToSingleValueMapAdapter#remove(Object)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.MultiToSingleValueMapAdapter",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.MultiToSingleValueMapAdapter#remove(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.MultiToSingleValueMapAdapter#remove(Object) relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.MultiToSingleValueMapAdapter#remove(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.MultiToSingleValueMapAdapter#remove(Object) designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.MultiValueMapAdapter#forEach(BiConsumer<? super K,? super List<V>>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "forEach",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MultiValueMapAdapter#forEach(BiConsumer<? super K,? super List<V>>)",
      "head_type": "method",
      "relation": "have",
      "tail": "Iterates over each key-value pair in the target map",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.MultiValueMapAdapter#forEach(BiConsumer<? super K,? super List<V>>)",
      "head_type": "method",
      "relation": "have",
      "tail": "public void forEach(BiConsumer<? super K, ? super List<V>> action) { this.targetMap.forEach(action); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.MultiValueMapAdapter#forEach(BiConsumer<? super K,? super List<V>>)",
      "head_type": "method",
      "relation": "have",
      "tail": "Delegation to targetMap for iteration",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.MultiValueMapAdapter#toString()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "toString()",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MultiValueMapAdapter#toString()",
      "head_type": "method",
      "relation": "have",
      "tail": "Converts the MultiValueMap to a String representation.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.MultiValueMapAdapter#toString()",
      "head_type": "method",
      "relation": "have",
      "tail": "public String toString() {\n    return this.targetMap.toString();\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.NumberUtils#parseNumber(String,Class<T>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "parseNumber",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.NumberUtils#parseNumber(String,Class<T>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "IllegalArgumentException if the target class is not supported",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.NumberUtils#parseNumber(String,Class<T>)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "parsing a Number instance from a given text",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.NumberUtils#parseNumber(String,Class<T>)",
      "head_type": "method",
      "relation": "have",
      "tail": "complete sample code for using parseNumber",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.NumberUtils#parseNumber(String,Class<T>)",
      "head_type": "method",
      "relation": "have",
      "tail": "related concept interpretation for parseNumber",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.NumberUtils#parseNumber(String,Class<T>)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle interpretation for parseNumber",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "parseNumber",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "org.springframework.util.NumberUtils",
      "tail_type": "class"
    },
    {
      "head": "useSampleCode",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "tail": "org.springframework.util.NumberUtils#parseNumber(String,Class<T>)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#invokeMethod(Method,Object,Object)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "reflectionMethodInvocation",
      "tail_type": "apiFunction"
    },
    {
      "head": "reflectionMethodInvocation",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "nullTargetForStaticMethod",
      "tail_type": "useConstraint"
    },
    {
      "head": "reflectionMethodInvocation",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "dynamicMethodInvocation",
      "tail_type": "useScenario"
    },
    {
      "head": "reflectionMethodInvocation",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "reflectionExceptionHandling",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "reflectionMethodInvocation",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "designPrincipleOfReflection",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#invokeMethod(Method,Object,Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "sampleCodeForReflectionUtilsInvokeMethod",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#invokeMethod(Method,Object,Object)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.ReflectionUtils",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.SimpleIdGenerator#generateId()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "generate unique identifier",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.SimpleIdGenerator#generateId()",
      "head_type": "method",
      "relation": "have",
      "tail": "Generates a unique identifier using UUID with the least significant bits incremented.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.SimpleIdGenerator#generateId()",
      "head_type": "method",
      "relation": "have",
      "tail": "public UUID generateId() { return new UUID(0, this.leastSigBits.incrementAndGet()); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.SimpleIdGenerator",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.SimpleIdGenerator#generateId()",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.StringUtils#trimWhitespace(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "trim leading and trailing whitespace",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils#trimWhitespace(String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "deprecated since 6.0",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.StringUtils#trimWhitespace(String)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "given String",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.StringUtils#trimWhitespace(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for trimming whitespace",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.StringUtils#trimWhitespace(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "interpretation of Character#isWhitespace",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.StringUtils#trimWhitespace(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle of deprecation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.StringUtils#trimWhitespace(String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "String#strip()",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.TypeUtils#isAssignable(WildcardType,Type)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "Type Assignability Check",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.TypeUtils#isAssignable(WildcardType,Type)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "Type Compatibility",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.TypeUtils#isAssignable(WildcardType,Type)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "Generic Type Handling",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.TypeUtils#isAssignable(WildcardType,Type)",
      "head_type": "method",
      "relation": "have",
      "tail": "Type Assignability Check Sample Code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "Type Assignability Check Sample Code",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "Complete Example for Type Assignability",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.TypeUtils#isAssignable(WildcardType,Type)",
      "head_type": "method",
      "relation": "have",
      "tail": "Type Assignability Explanation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "Type Assignability Explanation",
      "head_type": "relatedConceptInterpretation",
      "relation": "have",
      "tail": "Detailed Explanation of Type Assignability",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.TypeUtils#isAssignable(WildcardType,Type)",
      "head_type": "method",
      "relation": "have",
      "tail": "Design Principles of Type Assignability",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "Design Principles of Type Assignability",
      "head_type": "designPrincipleInterpretation",
      "relation": "have",
      "tail": "Principles Behind Type Assignability",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.TypeUtils#isAssignable(WildcardType,Type)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.TypeUtils",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySet#spliterator()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "spliterator",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySet#spliterator()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.UnmodifiableEntrySet",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySet#spliterator()",
      "head_type": "method",
      "relation": "have",
      "tail": "UnmodifiableEntrySpliterator",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueCollection#add(List<V>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "add elements to collection",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueCollection#add(List<V>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "unsupported operation",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueCollection#add(List<V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "throwing UnsupportedOperationException",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueCollection#add(List<V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "ensuring immutability of the collection",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLReader#getFeature(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getFeature",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLReader#getFeature(String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "SAXNotRecognizedException",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLReader#getFeature(String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "SAXNotSupportedException",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLReader#getFeature(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "This implementation throws a SAXNotRecognizedException exception for any feature outside the \"http://xml.org/sax/features/\" namespace and returns false for any feature within.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLReader#getFeature(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "public boolean getFeature(String name) throws SAXNotRecognizedException, SAXNotSupportedException { if (name.startsWith(\"http://xml.org/sax/features/\")) { return false; } else { throw new SAXNotRecognizedException(name); } }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLStreamReader#hasNext()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "check if there are more events",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLStreamReader#hasNext()",
      "head_type": "method",
      "relation": "have",
      "tail": "This method checks if there are more events to be read from the XML document.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLStreamReader#hasNext()",
      "head_type": "method",
      "relation": "have",
      "tail": "The design principle behind this method is to provide a way to determine if the end of the XML document has been reached.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLStreamReader#hasNext()",
      "head_type": "method",
      "relation": "have",
      "tail": "package com.healthMgr.common.email;\nimport java.util.Iterator;\nimport org.springframework.util.xml.AbstractXMLStreamReader;\n\npublic class XMLReaderExample {\n    public static void main(String[] args) {\n        AbstractXMLStreamReader reader = new AbstractXMLStreamReader() {\n            @Override\n            public boolean hasNext() {\n                return getEventType() != END_DOCUMENT;\n            }\n        };\n    }\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.StaxEventHandler#endElementInternal(QName,Map<String,String>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "endElementInternal",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxEventHandler#endElementInternal(QName,Map<String,String>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.StaxEventHandler",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.StaxEventHandler",
      "head_type": "class",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxEventHandler",
      "head_type": "class",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxEventHandler#endElementInternal(QName,Map<String,String>)",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.StaxEventXMLReader#getAttributes(StartElement)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "parse XML attributes",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxEventXMLReader#getAttributes(StartElement)",
      "head_type": "method",
      "relation": "have",
      "tail": "extracts attributes from XML StartElement",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.xml.StaxEventXMLReader#getAttributes(StartElement)",
      "head_type": "method",
      "relation": "have",
      "tail": "private Attributes getAttributes(StartElement event) {\n    AttributesImpl attributes = new AttributesImpl();\n    for (Iterator i = event.getAttributes(); i.hasNext(); ) {\n        Attribute attribute = (Attribute) i.next();\n        QName qName = attribute.getName();\n        String namespace = qName.getNamespaceURI();\n        if (namespace == null || !hasNamespacesFeature()) {\n            namespace = \"\";\n        }\n        String type = attribute.getDTDType();\n        if (type == null) {\n            type = \"CDATA\";\n        }\n        attributes.addAttribute(namespace, qName.getLocalPart(), toQualifiedName(qName), type, attribute.getValue());\n    }\n    if (hasNamespacePrefixesFeature()) {\n        for (Iterator i = event.getNamespaces(); i.hasNext(); ) {\n            Namespace namespace = (Namespace) i.next();\n            String prefix = namespace.getPrefix();\n            String namespaceUri = namespace.getNamespaceURI();\n            String qName;\n            if (StringUtils.hasLength(prefix)) {\n                qName = \"xmlns:\" + prefix;\n            } else {\n                qName = \"xmlns\";\n            }\n            attributes.addAttribute(\"\", \"\", qName, \"CDATA\", namespaceUri);\n        }\n    }\n    return attributes;\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.StaxEventXMLReader#getAttributes(StartElement)",
      "head_type": "method",
      "relation": "have",
      "tail": "attributes are extracted and returned as an instance of Attributes",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxEventXMLReader#getAttributes(StartElement)",
      "head_type": "method",
      "relation": "have",
      "tail": "design follows StAX parsing principles for efficiency",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxEventXMLReader",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.StaxEventXMLReader#getAttributes(StartElement)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamXMLReader#handleEntityReference()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "handleEntityReference",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamXMLReader#handleEntityReference()",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.xml.StaxStreamXMLReader",
      "tail_type": "class"
    },
    {
      "head": "handleEntityReference",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.StaxStreamXMLReader",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamXMLReader",
      "head_type": "class",
      "relation": "have",
      "tail": "handleEntityReference",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamXMLReader#handleEntityReference()",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils#createCustomStaxSource(XMLStreamReader)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "createCustomStaxSource",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils#createCustomStaxSource(XMLStreamReader)",
      "head_type": "method",
      "relation": "have",
      "tail": "createCustomStaxSource Sample Code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "createCustomStaxSource Sample Code",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "Complete createCustomStaxSource Example",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils#createCustomStaxSource(XMLStreamReader)",
      "head_type": "method",
      "relation": "have",
      "tail": "Related Concept Interpretation for createCustomStaxSource",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "Related Concept Interpretation for createCustomStaxSource",
      "head_type": "relatedConceptInterpretation",
      "relation": "have",
      "tail": "Detailed Explanation of StAX Source",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils#createCustomStaxSource(XMLStreamReader)",
      "head_type": "method",
      "relation": "have",
      "tail": "Design Principle Interpretation for createCustomStaxSource",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "Design Principle Interpretation for createCustomStaxSource",
      "head_type": "designPrincipleInterpretation",
      "relation": "have",
      "tail": "Principles Behind Custom StAX Source Creation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "createCustomStaxSource",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.StaxUtils#createCustomStaxSource(XMLStreamReader)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils#createCustomStaxResult(XMLStreamWriter)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "createCustomStaxResult",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils#createCustomStaxResult(XMLStreamWriter)",
      "head_type": "method",
      "relation": "have",
      "tail": "Create a custom, non-JAXP 1.4 StAX Result for the given XMLStreamWriter.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils#createCustomStaxResult(XMLStreamWriter)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is designed to wrap an XMLStreamWriter into a Result object, which is not part of the standard JAXP 1.4 StAX API.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils#createCustomStaxResult(XMLStreamWriter)",
      "head_type": "method",
      "relation": "have",
      "tail": "public static Result createCustomStaxResult(XMLStreamWriter streamWriter) {\n    return new StaxResult(streamWriter);\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "createCustomStaxResult",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "XMLStreamWriter",
      "tail_type": "useScenario"
    },
    {
      "head": "createCustomStaxResult",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "The XMLStreamWriter must be non-null.",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamReader",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getVersion()",
      "tail_type": "apiFunction"
    },
    {
      "head": "getVersion()",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "getVersion() useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "getVersion() useSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "getVersion() useSampleCode content",
      "tail_type": "content"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter#getPrefix(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getPrefix",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter#getPrefix(String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.XMLEventStreamWriter",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter",
      "head_type": "class",
      "relation": "have",
      "tail": "getPrefix(String) method",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter#getProperty(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getProperty",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter#getProperty(String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "IllegalArgumentException",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter#getProperty(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter#getProperty(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter#getProperty(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "getProperty",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.XMLEventStreamWriter",
      "tail_type": "class"
    },
    {
      "head": "IllegalArgumentException",
      "head_type": "useConstraint",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.XMLEventStreamWriter",
      "tail_type": "class"
    },
    {
      "head": "useSampleCode",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.XMLEventStreamWriter",
      "tail_type": "class"
    },
    {
      "head": "relatedConceptInterpretation",
      "head_type": "relatedConceptInterpretation",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.XMLEventStreamWriter",
      "tail_type": "class"
    },
    {
      "head": "designPrincipleInterpretation",
      "head_type": "designPrincipleInterpretation",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.XMLEventStreamWriter",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter#writeCharacters(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "writeCharacters",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter#writeCharacters(String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.XMLEventStreamWriter",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter",
      "head_type": "class",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter",
      "head_type": "class",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "writeCharacters",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#isAccessibleWhenPackagePrivateVisibilityInSamePackage()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "Access Control Test",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#isAccessibleWhenPackagePrivateVisibilityInSamePackage()",
      "head_type": "method",
      "relation": "have",
      "tail": "Access Control Sample Code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "Access Control Sample Code",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "Complete Access Control Example",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.FileSystemGeneratedFilesTests#addFilesCopiesToFileSystem()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "addSourceFile",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.FileSystemGeneratedFilesTests#addFilesCopiesToFileSystem()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "addResourceFile",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.FileSystemGeneratedFilesTests#addFilesCopiesToFileSystem()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "addClassFile",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.FileSystemGeneratedFilesTests#addFilesCopiesToFileSystem()",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.FileSystemGeneratedFilesTests#addFilesCopiesToFileSystem()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "FileSystemGeneratedFiles",
      "tail_type": "class"
    },
    {
      "head": "FileSystemGeneratedFiles",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "addSourceFile",
      "tail_type": "apiFunction"
    },
    {
      "head": "FileSystemGeneratedFiles",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "addResourceFile",
      "tail_type": "apiFunction"
    },
    {
      "head": "FileSystemGeneratedFiles",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "addClassFile",
      "tail_type": "apiFunction"
    },
    {
      "head": "FileSystemGeneratedFiles",
      "head_type": "class",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "FileSystemGeneratedFiles",
      "head_type": "class",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.FileSystemGeneratedFilesTests#createWhenRootsIsNullThrowsException()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "throw IllegalArgumentException when roots is null",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.FileSystemGeneratedFilesTests#createWhenRootsIsNullThrowsException()",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for creating FileSystemGeneratedFiles with null roots",
      "tail_type": "useSampleCode"
    },
    {
      "head": "sample code for creating FileSystemGeneratedFiles with null roots",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "complete example of using FileSystemGeneratedFiles with null roots",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassesTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getOrAddForFeatureWhenNewReturnsGeneratedClass",
      "tail_type": "apiFunction"
    },
    {
      "head": "getOrAddForFeatureWhenNewReturnsGeneratedClass",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "getOrAddForFeatureWhenNewReturnsGeneratedClass() Sample Code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "getOrAddForFeatureWhenNewReturnsGeneratedClass() Sample Code",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "Complete Example Code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getEnclosingNameOnTopLevelClassReturnsNull",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getEnclosingNameOnInnerClassReturnsParent",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getNameReturnsName",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "reserveMethodNamesWhenNameUsedThrowsException",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "reserveMethodNamesReservesNames",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "generateMethodNameWhenAllEmptyPartsGeneratesSetName",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getOrAddWhenRepeatReturnsSameGeneratedClass",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "generateJavaFileIsAnnotatedWithGenerated",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "generateJavaFileIncludesGeneratedMethods",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "generateJavaFileIncludesDeclaredClasses",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "generateJavaFileOnInnerClassThrowsException",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassTests",
      "head_type": "class",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassTests",
      "head_type": "class",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "getEnclosingNameOnTopLevelClassReturnsNull",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "topLevelClass",
      "tail_type": "useScenario"
    },
    {
      "head": "getEnclosingNameOnInnerClassReturnsParent",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "innerClass",
      "tail_type": "useScenario"
    },
    {
      "head": "getNameReturnsName",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "nameRetrieval",
      "tail_type": "useScenario"
    },
    {
      "head": "reserveMethodNamesWhenNameUsedThrowsException",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "methodReservation",
      "tail_type": "useScenario"
    },
    {
      "head": "reserveMethodNamesReservesNames",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "methodReservation",
      "tail_type": "useScenario"
    },
    {
      "head": "generateMethodNameWhenAllEmptyPartsGeneratesSetName",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "methodNameGeneration",
      "tail_type": "useScenario"
    },
    {
      "head": "getOrAddWhenRepeatReturnsSameGeneratedClass",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "classGeneration",
      "tail_type": "useScenario"
    },
    {
      "head": "generateJavaFileIsAnnotatedWithGenerated",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "javaFileGeneration",
      "tail_type": "useScenario"
    },
    {
      "head": "generateJavaFileIncludesGeneratedMethods",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "javaFileGeneration",
      "tail_type": "useScenario"
    },
    {
      "head": "generateJavaFileIncludesDeclaredClasses",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "javaFileGeneration",
      "tail_type": "useScenario"
    },
    {
      "head": "generateJavaFileOnInnerClassThrowsException",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "innerClassJavaFileGeneration",
      "tail_type": "useScenario"
    },
    {
      "head": "getEnclosingNameOnTopLevelClassReturnsNull",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "getEnclosingNameOnInnerClassReturnsParent",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "getNameReturnsName",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "reserveMethodNamesWhenNameUsedThrowsException",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "reserveMethodNamesReservesNames",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "generateMethodNameWhenAllEmptyPartsGeneratesSetName",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "getOrAddWhenRepeatReturnsSameGeneratedClass",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "generateJavaFileIsAnnotatedWithGenerated",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "generateJavaFileIncludesGeneratedMethods",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "generateJavaFileIncludesDeclaredClasses",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "generateJavaFileOnInnerClassThrowsException",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.TestGeneratedFiles#setFileHandler(TestFileHandler)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "file handler setting",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.TestGeneratedFiles#setFileHandler(TestFileHandler)",
      "head_type": "method",
      "relation": "have",
      "tail": "void setFileHandler(TestFileHandler fileHandler) { this.fileHandler = fileHandler; }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.TestGeneratedFiles#setFileHandler(TestFileHandler)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.TestGeneratedFiles",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.TestGeneratedFiles",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "file handler management",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.TestGeneratedFiles",
      "head_type": "class",
      "relation": "have",
      "tail": "related to file handler operations",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.TestGeneratedFiles",
      "head_type": "class",
      "relation": "have",
      "tail": "design principle focuses on managing file handlers efficiently",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedTypeReferenceTests#reflectionTargetNames()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "generate type reference",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedTypeReferenceTests#reflectionTargetNames()",
      "head_type": "method",
      "relation": "have",
      "tail": "generate type reference sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "generate type reference sample code",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "java\nimport org.junit.jupiter.api.extension.ExtendWith;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.Arguments;\nimport org.junit.jupiter.params.provider.MethodSource;\nimport org.springframework.aot.generate.GeneratedTypeReference;\nimport org.springframework.aot.generate.GeneratedTypeReferenceTests;\nimport org.springframework.aot.generate.TypeReference;\nimport org.springframework.aot.generate.TypeReferenceTests;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.annotation.AnnotationConfigApplicationContext;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.core.env.StandardEnvironment;\nimport org.springframework.core.io.DefaultResourceLoader;\nimport org.springframework.core.io.ResourceLoader;\nimport org.springframework.core.type.AnnotationMetadata;\nimport org.springframework.core.type.MethodMetadata;\nimport org.springframework.core.type.classreading.MetadataReaderFactory;\nimport org.springframework.core.type.classreading.SimpleMetadataReaderFactory;\nimport org.springframework.stereotype.Component;\nimport org.springframework.test.context.junit.jupiter.SpringExtension;\n\n@ExtendWith(SpringExtension.class)\npublic class GeneratedTypeReferenceTests {\n\n    @ParameterizedTest\n    @MethodSource\n    public void reflectionTargetNames(String expected, TypeReference<?> typeReference) {\n        // Your test implementation here\n    }\n\n    public static Stream<Arguments> reflectionTargetNames() {\n        return Stream.of(\n            Arguments.of(\"com.example.Test\", GeneratedTypeReference.of(ClassName.get(\"com.example\", \"Test\"))),\n            Arguments.of(\"com.example.Test$Inner\", GeneratedTypeReference.of(ClassName.get(\"com.example\", \"Test\", \"Inner\")))\n        );\n    }\n}\n",
      "tail_type": "String"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedTypeReferenceTests#reflectionTargetNames()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.GeneratedTypeReference",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedTypeReferenceTests#reflectionTargetNames()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.GeneratedTypeReferenceTests",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedTypeReferenceTests#reflectionTargetNames()",
      "head_type": "method",
      "relation": "have",
      "tail": "generate type reference related concept interpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "generate type reference related concept interpretation",
      "head_type": "relatedConceptInterpretation",
      "relation": "have",
      "tail": "GeneratedTypeReference is used to create type references for classes and inner classes dynamically. It is useful in scenarios where reflection is used to determine class types at runtime.",
      "tail_type": "String"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedTypeReferenceTests#reflectionTargetNames()",
      "head_type": "method",
      "relation": "have",
      "tail": "generate type reference design principle interpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "generate type reference design principle interpretation",
      "head_type": "designPrincipleInterpretation",
      "relation": "have",
      "tail": "The design principle behind GeneratedTypeReference is to provide a flexible and efficient way to handle type references, especially in environments where class information is not available at compile time.",
      "tail_type": "String"
    },
    {
      "head": "org.springframework.aot.generate.ValueCodeGeneratorTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "generateCode",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.ValueCodeGeneratorTests",
      "head_type": "class",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.ValueCodeGeneratorTests",
      "head_type": "class",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "generateCode",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "generateWhenNull",
      "tail_type": "useScenario"
    },
    {
      "head": "generateCode",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "generateWhenBoolean",
      "tail_type": "useScenario"
    },
    {
      "head": "generateCode",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "generateWhenByte",
      "tail_type": "useScenario"
    },
    {
      "head": "generateCode",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "generateWhenShort",
      "tail_type": "useScenario"
    },
    {
      "head": "generateCode",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "generateWhenInt",
      "tail_type": "useScenario"
    },
    {
      "head": "generateCode",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "generateWhenLong",
      "tail_type": "useScenario"
    },
    {
      "head": "generateCode",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "generateWhenFloat",
      "tail_type": "useScenario"
    },
    {
      "head": "generateCode",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "generateWhenDouble",
      "tail_type": "useScenario"
    },
    {
      "head": "generateCode",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "generateWhenChar",
      "tail_type": "useScenario"
    },
    {
      "head": "generateCode",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "generateWhenString",
      "tail_type": "useScenario"
    },
    {
      "head": "generateCode",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "generateWhenCharset",
      "tail_type": "useScenario"
    },
    {
      "head": "generateCode",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "generateWhenEnum",
      "tail_type": "useScenario"
    },
    {
      "head": "generateCode",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "generateWhenClass",
      "tail_type": "useScenario"
    },
    {
      "head": "generateCode",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "generateWhenSimpleResolvableType",
      "tail_type": "useScenario"
    },
    {
      "head": "generateCode",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "generateWhenNoneResolvableType",
      "tail_type": "useScenario"
    },
    {
      "head": "generateCode",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "generateWhenGenericResolvableType",
      "tail_type": "useScenario"
    },
    {
      "head": "generateCode",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "generateWhenNestedGenericResolvableType",
      "tail_type": "useScenario"
    },
    {
      "head": "generateCode",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "generateWhenUnresolvedGenericType",
      "tail_type": "useScenario"
    },
    {
      "head": "generateCode",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "generateWhenUnresolvedNestedGenericType",
      "tail_type": "useScenario"
    },
    {
      "head": "generateCode",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "generateWhenPrimitiveArray",
      "tail_type": "useScenario"
    },
    {
      "head": "generateCode",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "generateWhenWrapperArray",
      "tail_type": "useScenario"
    },
    {
      "head": "generateCode",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "generateWhenClassArray",
      "tail_type": "useScenario"
    },
    {
      "head": "generateCode",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "generateWhenStringList",
      "tail_type": "useScenario"
    },
    {
      "head": "generateCode",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "generateWhenEmptyList",
      "tail_type": "useScenario"
    },
    {
      "head": "generateCode",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "generateWhenStringSet",
      "tail_type": "useScenario"
    },
    {
      "head": "generateCode",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "generateWhenEmptySet",
      "tail_type": "useScenario"
    },
    {
      "head": "generateCode",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "generateWhenLinkedHashSet",
      "tail_type": "useScenario"
    },
    {
      "head": "generateCode",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "generateWhenSetOfClass",
      "tail_type": "useScenario"
    },
    {
      "head": "generateCode",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "generateWhenSmallMap",
      "tail_type": "useScenario"
    },
    {
      "head": "generateCode",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "generateWhenMapWithOverTenElements",
      "tail_type": "useScenario"
    },
    {
      "head": "generateCode",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "generateWhenUnsupportedValue",
      "tail_type": "useScenario"
    },
    {
      "head": "generateCode",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "generateWhenUnsupportedDataTypeThrowsException",
      "tail_type": "useScenario"
    },
    {
      "head": "generateCode",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "generateWhenListOfUnsupportedElement",
      "tail_type": "useScenario"
    },
    {
      "head": "generateCode",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.ValueCodeGeneratorTests",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "ValueCodeGenerator",
      "tail_type": "class"
    },
    {
      "head": "generateCode",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "useConstraint",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.aot.generate.ConfigurationTests#createWithListOfDelegatesInvokeThemInOrder()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "createWithListOfDelegatesInvokeThemInOrder",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.ConfigurationTests#createWithListOfDelegatesInvokeThemInOrder()",
      "head_type": "method",
      "relation": "have",
      "tail": "createWithListOfDelegatesInvokeThemInOrderSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "createWithListOfDelegatesInvokeThemInOrderSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "createWithListOfDelegatesInvokeThemInOrderSampleCodeContent",
      "tail_type": "useSampleCodeContent"
    },
    {
      "head": "org.springframework.aot.generate.PrimitiveTests#generateWhenBoolean()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "generateCode",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.PrimitiveTests#generateWhenBoolean()",
      "head_type": "method",
      "relation": "have",
      "tail": "generateWhenBooleanSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "generateWhenBooleanSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "generateWhenBooleanCompleteSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.PrimitiveTests#generatedWhenUnicodeEscapedCharReturnsEscaped()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "testEscaped",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.PrimitiveTests#generatedWhenUnicodeEscapedCharReturnsEscaped()",
      "head_type": "method",
      "relation": "have",
      "tail": "void generatedWhenUnicodeEscapedCharReturnsEscaped() { testEscaped('\\u007f', \"'\\\\u007f'\"); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.PrimitiveTests#generatedWhenUnicodeEscapedCharReturnsEscaped()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.PrimitiveTests",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.CharsetTests#generateWhenCharset()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "generateCode",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.CharsetTests#generateWhenCharset()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "resolve",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.CharsetTests#generateWhenCharset()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "hasImport",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.CharsetTests#generateWhenCharset()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "hasValueCode",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.CharsetTests#generateWhenCharset()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "Charset.class",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.CharsetTests#generateWhenCharset()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "StandardCharsets.UTF_8",
      "tail_type": "class"
    },
    {
      "head": "generateCode",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "resolve",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "hasImport",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "hasValueCode",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "useSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "sample code",
      "tail_type": "string"
    },
    {
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldProcessAnnotationOnType()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "processAnnotationOnType",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldProcessAnnotationOnType()",
      "head_type": "method",
      "relation": "have",
      "tail": "SampleTypeAnnotatedBean",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldProcessAnnotationOnType()",
      "head_type": "method",
      "relation": "have",
      "tail": "runtimeHints",
      "tail_type": "useSampleCode"
    },
    {
      "head": "runtimeHints",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "tail": "org.springframework.aot.hint.RuntimeHints",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldProcessAnnotationOnType()",
      "head_type": "method",
      "relation": "have",
      "tail": "reflectionTypeHint",
      "tail_type": "useSampleCode"
    },
    {
      "head": "reflectionTypeHint",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "tail": "org.springframework.aot.hint.TypeHint",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldProcessAnnotationOnType()",
      "head_type": "method",
      "relation": "have",
      "tail": "assertThatNotNull",
      "tail_type": "useSampleCode"
    },
    {
      "head": "assertThatNotNull",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "tail": "org.hamcrest.MatcherAssert",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldProcessAnnotationOnType()",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "relatedConceptInterpretation",
      "head_type": "relatedConceptInterpretation",
      "relation": "associated_with",
      "tail": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldProcessAnnotationOnType()",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldProcessAnnotationOnType()",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "designPrincipleInterpretation",
      "head_type": "designPrincipleInterpretation",
      "relation": "associated_with",
      "tail": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldProcessAnnotationOnType()",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.aot.hint.annotation.MethodLevelAnnotatedBean#method()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "reflection binding registration",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.hint.annotation.MethodLevelAnnotatedBean#method()",
      "head_type": "method",
      "relation": "have",
      "tail": "reflection binding registration sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "reflection binding registration sample code",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "complete sample code for reflection binding registration",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.core.type.StandardMethodMetadata#getAnnotations()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getAnnotations",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.core.type.StandardMethodMetadata#getAnnotations()",
      "head_type": "method",
      "relation": "have",
      "tail": "MergedAnnotations",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.core.type.StandardMethodMetadata#getAnnotations()",
      "head_type": "method",
      "relation": "have",
      "tail": "this.mergedAnnotations",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.core.type.StandardMethodMetadata#getAnnotations()",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.core.type.StandardMethodMetadata#getAnnotations()",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#getPatternComparator(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "sortingPatternsByExplicitness",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#getPatternComparator(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#getPatternComparator(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#getPatternComparator(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.AntPathMatcher",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.AntPathMatcher#getPatternComparator(String)",
      "tail_type": "method"
    },
    {
      "head": "sortingPatternsByExplicitness",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "useScenario",
      "tail_type": "useScenario"
    },
    {
      "head": "sortingPatternsByExplicitness",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "pathSpecificity",
      "tail_type": "useConstraint"
    },
    {
      "head": "useSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "sampleCode",
      "tail_type": "sampleCode"
    },
    {
      "head": "relatedConceptInterpretation",
      "head_type": "relatedConceptInterpretation",
      "relation": "have",
      "tail": "conceptDescription",
      "tail_type": "conceptDescription"
    },
    {
      "head": "designPrincipleInterpretation",
      "head_type": "designPrincipleInterpretation",
      "relation": "have",
      "tail": "designPrinciple",
      "tail_type": "designPrinciple"
    },
    {
      "head": "org.springframework.util.Assert#notNull(Object,String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "assertNotNull",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.Assert#notNull(Object,String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "objectNotNull",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.Assert#notNull(Object,String)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "checkObjectNotNull",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.Assert#notNull(Object,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.Assert#notNull(Object,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.Assert#notNull(Object,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.Assert#notNull(Object,String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "IllegalArgumentException",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.Assert#hasText(String,Supplier<String>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "assert valid text content",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.Assert#hasText(String,Supplier<String>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "text must not be null and must contain at least one non-whitespace character",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.Assert#hasText(String,Supplier<String>)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "check if a string contains valid text content",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.Assert#hasText(String,Supplier<String>)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for using Assert.hasText",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.Assert#hasText(String,Supplier<String>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "StringUtils#hasText",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.Assert#hasText(String,Supplier<String>)",
      "head_type": "method",
      "relation": "have",
      "tail": "interpretation of IllegalArgumentException",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.Assert#hasText(String,Supplier<String>)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle of Assert class",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.AutoPopulatingList#removeAll(Collection<?>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "removeAll",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.AutoPopulatingList#removeAll(Collection<?>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "AutoPopulatingList",
      "tail_type": "class"
    },
    {
      "head": "removeAll",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "org.springframework.util.AutoPopulatingList#removeAll(Collection<?>)",
      "tail_type": "useSampleCode"
    },
    {
      "head": "AutoPopulatingList",
      "head_type": "class",
      "relation": "have",
      "tail": "org.springframework.util.AutoPopulatingList#removeAll(Collection<?>)",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ClassUtils#isPrimitiveWrapperArray(Class<?>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "check if class represents array of primitive wrappers",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ClassUtils#isPrimitiveWrapperArray(Class<?>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "class must not be null",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ClassUtils#isPrimitiveWrapperArray(Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for checking array of primitive wrappers",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ClassUtils#isPrimitiveWrapperArray(Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "related concept interpretation for primitive wrapper arrays",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#isPrimitiveWrapperArray(Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle interpretation for primitive wrapper array checking",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#isPrimitiveWrapperArray(Class<?>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.ClassUtils",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.CommonsLogWriter#write(char)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "logging",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.CommonsLogWriter#write(char)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is used to write a single character to the log, buffering it until a newline character is encountered, at which point the entire buffer is logged and cleared.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.CommonsLogWriter#write(char)",
      "head_type": "method",
      "relation": "have",
      "tail": "public void write(char ch) {\n    if (ch == '\\n' && this.buffer.length() > 0) {\n        logger.debug(this.buffer.toString());\n        this.buffer.setLength(0);\n    } else {\n        this.buffer.append(ch);\n    }\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.CommonsLogWriter#write(char)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method follows the principle of buffering and conditional logging, ensuring that only complete log messages are recorded.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.comparator.NullSafeComparator#equals(Object)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "Null Safe Comparison",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.comparator.NullSafeComparator#equals(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.comparator.NullSafeComparator#equals(Object) Sample Code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.comparator.NullSafeComparator#equals(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.comparator.NullSafeComparator#equals(Object) Related Concept Interpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.comparator.NullSafeComparator#equals(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.comparator.NullSafeComparator#equals(Object) Design Principle Interpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.comparator.NullSafeComparator#equals(Object)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.comparator.NullSafeComparator",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.concurrent.FutureAdapter#adapt(S)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "adapt adaptee's result",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.concurrent.FutureAdapter#adapt(S)",
      "head_type": "method",
      "relation": "have",
      "tail": "Adapts the given adaptee's result into T.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.concurrent.FutureAdapter#adapt(S)",
      "head_type": "method",
      "relation": "have",
      "tail": "The method adapt(S) is designed to transform the result of the adaptee into type T.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.concurrent.FutureAdapter#adapt(S)",
      "head_type": "method",
      "relation": "have",
      "tail": "protected abstract T adapt(S adapteeResult) throws ExecutionException;",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.WriteOperations",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "add",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.WriteOperations",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "drain",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.WriteOperations",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "drainAll",
      "tail_type": "apiFunction"
    },
    {
      "head": "add",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "drain",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "drainAll",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.WriteOperations",
      "head_type": "class",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.WriteOperations",
      "head_type": "class",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.Segment#getIndex(int,Reference<K,V>[])",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "hashing",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.Segment#getIndex(int,Reference<K,V>[])",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "index calculation",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.Segment#getIndex(int,Reference<K,V>[])",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "array length masking",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.Segment#getIndex(int,Reference<K,V>[])",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.Segment#getIndex(int,Reference<K,V>[])",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.Segment#getIndex(int,Reference<K,V>[])",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "hashing",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "hash collision",
      "tail_type": "useConstraint"
    },
    {
      "head": "index calculation",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "array indexing",
      "tail_type": "useScenario"
    },
    {
      "head": "array length masking",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "open addressing",
      "tail_type": "useScenario"
    },
    {
      "head": "useSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "complete sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "relatedConceptInterpretation",
      "head_type": "relatedConceptInterpretation",
      "relation": "have",
      "tail": "hash table",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "designPrincipleInterpretation",
      "head_type": "designPrincipleInterpretation",
      "relation": "have",
      "tail": "consistent hashing",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.CustomizableThreadCreator#getThreadPriority()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getThreadPriority",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.CustomizableThreadCreator#getThreadPriority()",
      "head_type": "method",
      "relation": "have",
      "tail": "Return the priority of the threads that this factory creates.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.CustomizableThreadCreator",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.CustomizableThreadCreator#getThreadPriority()",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.FileCopyUtils#copy(byte[],File)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "copy contents of byte array to file",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.FileCopyUtils#copy(byte[],File)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "input byte array must be specified",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.FileCopyUtils#copy(byte[],File)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "output File must be specified",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.FileCopyUtils#copy(byte[],File)",
      "head_type": "method",
      "relation": "have",
      "tail": "copy contents of byte array to file sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.FileCopyUtils#copy(byte[],File)",
      "head_type": "method",
      "relation": "have",
      "tail": "copy contents of byte array to file related concept interpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.FileCopyUtils#copy(byte[],File)",
      "head_type": "method",
      "relation": "have",
      "tail": "copy contents of byte array to file design principle interpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.FileCopyUtils",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.FileCopyUtils#copy(byte[],File)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.FilteredSet#hashCode()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "calculateHashCode",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.FilteredSet#hashCode()",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.FilteredSet",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.FilteredSet#hashCode()",
      "head_type": "method",
      "relation": "have",
      "tail": "Iterate through elements to compute hash code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.FilteredSet#hashCode()",
      "head_type": "method",
      "relation": "have",
      "tail": "Ensure elements are not null before computing hash code",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.FilteredSet#hashCode()",
      "head_type": "method",
      "relation": "have",
      "tail": "Override hashCode method for custom set behavior",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.FilteredSet#hashCode()",
      "head_type": "method",
      "relation": "have",
      "tail": "Efficiently compute hash code for a filtered set",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.function.ThrowingConsumer#accept(T,BiFunction<String,Exception,RuntimeException>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "exception wrapping",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.function.ThrowingConsumer#accept(T,BiFunction<String,Exception,RuntimeException>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "exceptionWrapper must not be null",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.function.ThrowingConsumer#accept(T,BiFunction<String,Exception,RuntimeException>)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "handling checked exceptions",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.function.ThrowingConsumer#accept(T,BiFunction<String,Exception,RuntimeException>)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.function.ThrowingConsumer#accept(T,BiFunction<String,Exception,RuntimeException>) sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.function.ThrowingConsumer#accept(T,BiFunction<String,Exception,RuntimeException>)",
      "head_type": "method",
      "relation": "have",
      "tail": "exception wrapping explanation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.function.ThrowingConsumer#accept(T,BiFunction<String,Exception,RuntimeException>)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle of exception handling",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.function.ThrowingConsumer#accept(T,BiFunction<String,Exception,RuntimeException>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.function.ThrowingConsumer",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.IdGenerator#generateId()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "generate a new identifier",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.IdGenerator#generateId()",
      "head_type": "method",
      "relation": "have",
      "tail": "Generate a new identifier.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.IdGenerator#generateId()",
      "head_type": "method",
      "relation": "have",
      "tail": "Return the generated identifier.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.IdGenerator#generateId()",
      "head_type": "method",
      "relation": "have",
      "tail": "package com.example;\n\nimport java.util.UUID;\n\npublic class Main {\n    public static void main(String[] args) {\n        UUID id = org.springframework.util.IdGenerator.generateId();\n        System.out.println(id);\n    }\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.EntrySet#size()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "sizeCalculation",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.EntrySet#size()",
      "head_type": "method",
      "relation": "have",
      "tail": "DelegateSizeMethodCall",
      "tail_type": "useSampleCode"
    },
    {
      "head": "DelegateSizeMethodCall",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "tail": "org.springframework.util.EntrySet",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.EntrySet#size()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.EntrySet",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.EntryIterator#hasNext()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "checkNextElementAvailability",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.EntryIterator#hasNext()",
      "head_type": "method",
      "relation": "have",
      "tail": "Delegate to underlying iterator to determine if more elements exist",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.EntryIterator#hasNext()",
      "head_type": "method",
      "relation": "have",
      "tail": "Design follows the principle of delegation for iteration control",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.EntryIterator#hasNext()",
      "head_type": "method",
      "relation": "have",
      "tail": "public boolean hasNext() {\n    return this.delegate.hasNext();\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.MimeType#appendTo(Map<String,String>,StringBuilder)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "appending parameters to StringBuilder",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MimeType#appendTo(Map<String,String>,StringBuilder)",
      "head_type": "method",
      "relation": "have",
      "tail": "appending parameters to StringBuilder sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "appending parameters to StringBuilder sample code",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "private void appendTo(Map<String, String> map, StringBuilder builder) {\n    map.forEach((key, val) -> {\n        builder.append(';');\n        builder.append(key);\n        builder.append('=');\n        builder.append(val);\n    });\n}",
      "tail_type": "code"
    },
    {
      "head": "org.springframework.util.MultiToSingleValueMapAdapter#entrySet()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "entrySetConversion",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MultiToSingleValueMapAdapter#entrySet()",
      "head_type": "method",
      "relation": "have",
      "tail": "entrySetConversionSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "entrySetConversionSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "entrySetConversionSampleCodeContent",
      "tail_type": "useSampleCodeContent"
    },
    {
      "head": "org.springframework.util.MultiToSingleValueMapAdapter#entrySet()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.MultiToSingleValueMapAdapter",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.MultiToSingleValueMapAdapter",
      "head_type": "class",
      "relation": "have",
      "tail": "MultiToSingleValueMapAdapterRelatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "MultiToSingleValueMapAdapterRelatedConceptInterpretation",
      "head_type": "relatedConceptInterpretation",
      "relation": "have",
      "tail": "MultiToSingleValueMapAdapterRelatedConceptInterpretationContent",
      "tail_type": "relatedConceptInterpretationContent"
    },
    {
      "head": "org.springframework.util.MultiToSingleValueMapAdapter",
      "head_type": "class",
      "relation": "have",
      "tail": "MultiToSingleValueMapAdapterDesignPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "MultiToSingleValueMapAdapterDesignPrincipleInterpretation",
      "head_type": "designPrincipleInterpretation",
      "relation": "have",
      "tail": "MultiToSingleValueMapAdapterDesignPrincipleInterpretationContent",
      "tail_type": "designPrincipleInterpretationContent"
    },
    {
      "head": "org.springframework.util.TextPart#resolve(PartResolutionContext)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "resolve text",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.TextPart#resolve(PartResolutionContext)",
      "head_type": "method",
      "relation": "have",
      "tail": "resolve text sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "resolve text sample code",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "resolve text sample code content",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.PlaceholderResolutionException",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "placeholderResolution",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.PlaceholderResolutionException",
      "head_type": "class",
      "relation": "constrained_by",
      "tail": "validPlaceholderRequired",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.PlaceholderResolutionException",
      "head_type": "class",
      "relation": "applied_to",
      "tail": "resolutionFailureHandling",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.PlaceholderResolutionException",
      "head_type": "class",
      "relation": "have",
      "tail": "resolutionFailureHandlingSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.PlaceholderResolutionException",
      "head_type": "class",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.PlaceholderResolutionException",
      "head_type": "class",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.PlaceholderResolutionException",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.core.env.PropertyResolver",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#getAllDeclaredMethods(Class<?>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "introspection",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#getAllDeclaredMethods(Class<?>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "introspection failure",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#getAllDeclaredMethods(Class<?>)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "leaf class and superclass introspection",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#getAllDeclaredMethods(Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "leaf class and superclass introspection sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#getAllDeclaredMethods(Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "introspection concept interpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#getAllDeclaredMethods(Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle interpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "introspection concept interpretation",
      "head_type": "relatedConceptInterpretation",
      "relation": "associated_with",
      "tail": "introspection",
      "tail_type": "apiFunction"
    },
    {
      "head": "design principle interpretation",
      "head_type": "designPrincipleInterpretation",
      "relation": "associated_with",
      "tail": "introspection",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.RouteMatcher#getPatternComparator(Route)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "Comparator Generation",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.RouteMatcher#getPatternComparator(Route)",
      "head_type": "method",
      "relation": "have",
      "tail": "Comparator Generation for Route Patterns",
      "tail_type": "useScenario"
    },
    {
      "head": "Comparator Generation for Route Patterns",
      "head_type": "useScenario",
      "relation": "have",
      "tail": "Given a route, return a Comparator suitable for sorting patterns in order of explicitness for that route, so that more specific patterns come before more generic ones.",
      "tail_type": "useSampleCode"
    },
    {
      "head": "Comparator Generation for Route Patterns",
      "head_type": "useScenario",
      "relation": "have",
      "tail": "The Comparator returned by this method can be used to sort a list of route patterns based on their specificity. More specific patterns should be prioritized over more generic ones to ensure efficient routing.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "Comparator Generation for Route Patterns",
      "head_type": "useScenario",
      "relation": "have",
      "tail": "The design principle behind this functionality is to ensure that the routing mechanism prioritizes more specific patterns, thereby enhancing the efficiency and accuracy of route matching. This principle is crucial in scenarios where multiple patterns could potentially match a given route, and selecting the most specific one is essential for correct routing behavior.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.SingleToMultiValueMapAdapter#hashCode()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "generateHashCode",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.SingleToMultiValueMapAdapter#hashCode()",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.SingleToMultiValueMapAdapter",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.SingleToMultiValueMapAdapter#hashCode()",
      "head_type": "method",
      "relation": "have",
      "tail": "generateHashCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "generateHashCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "org.springframework.util.SingleToMultiValueMapAdapter",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.StopWatch#stop()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "stop current task",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StopWatch#stop()",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "timing methods must be called within a start/stop pair",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.StopWatch#stop()",
      "head_type": "method",
      "relation": "have",
      "tail": "undefined results if timing methods are called without start/stop pair",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.StopWatch#stop()",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for stopping a task",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.StopWatch#stop()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.StopWatch",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.StopWatch#stop()",
      "head_type": "method",
      "relation": "have",
      "tail": "related concept interpretation for stopping a task",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.StopWatch#stop()",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle interpretation for stopping a task",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.StringUtils#hasText(CharSequence)",
      "head_type": "method",
      "relation": "haveFuntion",
      "tail": "check if a CharSequence contains actual text",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils#hasText(CharSequence)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "input must be a non-null CharSequence with at least one non-whitespace character",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.StringUtils#hasText(CharSequence)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "validating user input, data processing",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.StringUtils#hasText(CharSequence)",
      "head_type": "method",
      "relation": "have",
      "tail": "StringUtils.hasText(null) = false\nStringUtils.hasText(\"\") = false\nStringUtils.hasText(\" \") = false\nStringUtils.hasText(\"12345\") = true\nStringUtils.hasText(\" 12345 \") = true",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.StringUtils#hasText(CharSequence)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.StringUtils",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.StringUtils#hasText(CharSequence)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is used to check if a given CharSequence contains actual text. It returns true if the CharSequence is not null, its length is greater than 0, and it contains at least one non-whitespace character.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.StringUtils#hasText(CharSequence)",
      "head_type": "method",
      "relation": "have",
      "tail": "The design principle of this method is to provide a simple and efficient way to check for the presence of actual text in a CharSequence, considering both null and whitespace-only cases.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.StringUtils#countOccurrencesOf(String,String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "countOccurrencesOf",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils#countOccurrencesOf(String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "countOccurrencesOf(String str, String sub)",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.StringUtils#countOccurrencesOf(String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "Counts the occurrences of a substring within a string.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.StringUtils#countOccurrencesOf(String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "Efficiently counts by iterating through the string and checking for the presence of the substring.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.StringUtils#getFilename(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "extract filename",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils#getFilename(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "Extract the filename from the given Java resource path, for example, mypath/myfile.txt -> myfile.txt.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.StringUtils#getFilename(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "The method utilizes path manipulation to isolate the filename by identifying the last occurrence of a folder separator and extracting the substring thereafter.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.StringUtils#getFilename(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "public static String getFilename(String path) {\n    if (path == null) {\n        return null;\n    }\n    int separatorIndex = path.lastIndexOf('/');\n    return (separatorIndex != -1 ? path.substring(separatorIndex + 1) : path);\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#toSingleValueMap()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "convert multi-value map to single-value map",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#toSingleValueMap()",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for converting multi-value map to single-value map",
      "tail_type": "useSampleCode"
    },
    {
      "head": "sample code for converting multi-value map to single-value map",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "complete example of converting multi-value map to single-value map",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#replace(K,List<V>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "replace",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#replace(K,List<V>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "UnsupportedOperationException",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#replace(K,List<V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "UnmodifiableMultiValueMap cannot be modified",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#replace(K,List<V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "Ensure immutability",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#replace(K,List<V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "public List<V> replace(K key, List<V> value) {\n    throw new UnsupportedOperationException();\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#computeIfAbsent(K,Function<? super K,? extends List<V>>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "computeIfAbsent",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#computeIfAbsent(K,Function<? super K,? extends List<V>>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "UnsupportedOperationException",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#computeIfAbsent(K,Function<? super K,? extends List<V>>)",
      "head_type": "method",
      "relation": "have",
      "tail": "computeIfAbsent throws UnsupportedOperationException",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#computeIfAbsent(K,Function<? super K,? extends List<V>>)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#computeIfAbsent(K,Function<? super K,? extends List<V>>)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.UnmodifiableMultiValueMap#computeIfAbsent(K,Function<? super K,? extends List<V>>)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySet#toArray()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "convert array",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySet#toArray()",
      "head_type": "method",
      "relation": "have",
      "tail": "The method toArray() converts an array.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySet#toArray()",
      "head_type": "method",
      "relation": "have",
      "tail": "public Object[] toArray() {\n    Object[] result = this.delegate.toArray();\n    filterArray(result);\n    return result;\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueSpliterator",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getExactSizeIfKnown()",
      "tail_type": "apiFunction"
    },
    {
      "head": "getExactSizeIfKnown()",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "getExactSizeIfKnown() returns the exact size if known",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "getExactSizeIfKnown()",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "Delegate pattern used for method execution",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "getExactSizeIfKnown()",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "public long getExactSizeIfKnown() { return this.delegate.getExactSizeIfKnown(); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLStreamReader",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getElementText",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLStreamReader",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getAttributeLocalName",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLStreamReader",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getAttributeNamespace",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLStreamReader",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getAttributePrefix",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLStreamReader",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getNamespaceURI",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLStreamReader",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "hasText",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLStreamReader",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getPrefix",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLStreamReader",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "hasName",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLStreamReader",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "isWhiteSpace",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLStreamReader",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "isStartElement",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLStreamReader",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "isEndElement",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLStreamReader",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "isCharacters",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLStreamReader",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "nextTag",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLStreamReader",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "require",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLStreamReader",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getAttributeValue",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLStreamReader",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "hasNext",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLStreamReader",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getLocalName",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLStreamReader",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getTextCharacters",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLStreamReader",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getTextLength",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLStreamReader",
      "head_type": "class",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLStreamReader",
      "head_type": "class",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLStreamReader",
      "head_type": "class",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.SimpleNamespaceContext#clear()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "remove all declared prefixes",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.SimpleNamespaceContext#clear()",
      "head_type": "method",
      "relation": "have",
      "tail": "Remove all declared prefixes.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.SimpleNamespaceContext#clear()",
      "head_type": "method",
      "relation": "have",
      "tail": "public void clear() {\n    this.prefixToNamespaceUri.clear();\n    this.namespaceUriToPrefixes.clear();\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.StaxEventXMLReader#handleComment(Comment)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "handleComment",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxEventXMLReader#handleComment(Comment)",
      "head_type": "method",
      "relation": "have",
      "tail": "handleComment(Comment) Sample Code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "handleComment(Comment) Sample Code",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "private void handleComment(Comment comment) throws SAXException {\n    if (getLexicalHandler() != null) {\n        char[] ch = comment.getText().toCharArray();\n        getLexicalHandler().comment(ch, 0, ch.length);\n    }\n}",
      "tail_type": "code"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils#createXMLReader(XMLStreamReader)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "create a SAX XMLReader from a StAX XMLStreamReader",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils#createXMLReader(XMLStreamReader)",
      "head_type": "method",
      "relation": "have",
      "tail": "Create a SAX XMLReader that reads from the given StAX XMLStreamReader.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils#createXMLReader(XMLStreamReader)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method facilitates the integration between SAX and StAX parsers by converting a StAX XMLStreamReader into a SAX XMLReader.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils#createXMLReader(XMLStreamReader)",
      "head_type": "method",
      "relation": "have",
      "tail": "public static XMLReader createXMLReader(XMLStreamReader streamReader) {\n    return new StaxStreamXMLReader(streamReader);\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.StaxStreamXMLReader",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamReader",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getNamespaceCount()",
      "tail_type": "apiFunction"
    },
    {
      "head": "getNamespaceCount()",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "getNamespaceCount()",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "getNamespaceCount()",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamReader",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml",
      "tail_type": "class"
    },
    {
      "head": "getNamespaceCount()",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "useStateManagement",
      "tail_type": "useConstraint"
    },
    {
      "head": "getNamespaceCount()",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "xmlParsing",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamReader#next()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "xml event stream reading",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamReader#next()",
      "head_type": "method",
      "relation": "have",
      "tail": "Reads the next XML event from the underlying event reader.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamReader#next()",
      "head_type": "method",
      "relation": "have",
      "tail": "public int next() throws XMLStreamException { this.event = this.eventReader.nextEvent(); return this.event.getEventType(); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamReader#next()",
      "head_type": "method",
      "relation": "have",
      "tail": "Efficiently reads XML events from an XML stream.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.XmlValidationModeDetector#hasOpeningTag(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "Determine if the supplied content contains an XML opening tag",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.XmlValidationModeDetector#hasOpeningTag(String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "It is expected that all comment tokens will have been consumed for the supplied content before passing the remainder to this method",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.xml.XmlValidationModeDetector#hasOpeningTag(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "private boolean hasOpeningTag(String content) { if (this.inComment) { return false; } int openTagIndex = content.indexOf('<'); return (openTagIndex > -1 && (content.length() > openTagIndex + 1) && Character.isLetter(content.charAt(openTagIndex + 1))); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.XmlValidationModeDetector#hasOpeningTag(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method checks if the given content contains an XML opening tag. It first checks if the current state is within an XML comment, in which case it returns false. Otherwise, it searches for the presence of a '<' character, indicating the start of an XML tag, and checks if the next character is a letter, ensuring it's a valid XML element start.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.XmlValidationModeDetector#hasOpeningTag(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "The design principle behind this method is to provide a robust way to detect the start of an XML element within a given string content. It ensures that XML comments are properly handled by ignoring any content within them. The method is designed to be efficient and straightforward, focusing on identifying the '<' character followed by a letter, which is a clear indicator of an XML opening tag.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.XmlValidationModeDetector",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.XmlValidationModeDetector#hasOpeningTag(String)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.xml.XmlValidationModeDetector#consumeCommentTokens(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "consume all comments in the given String and return the remaining content",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.XmlValidationModeDetector#consumeCommentTokens(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method takes the current 'in comment' parsing state into account.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.XmlValidationModeDetector#consumeCommentTokens(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "The method should handle cases where the input string contains only comments or a mix of comments and other content.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.XmlValidationModeDetector#consumeCommentTokens(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "private String consumeCommentTokens(String line) {\n    int indexOfStartComment = line.indexOf(START_COMMENT);\n    if (indexOfStartComment == -1 && !line.contains(END_COMMENT)) {\n        return line;\n    }\n    String result = \"\";\n    String currLine = line;\n    if (!this.inComment && (indexOfStartComment >= 0)) {\n        result = line.substring(0, indexOfStartComment);\n        currLine = line.substring(indexOfStartComment);\n    }\n    if ((currLine = consume(currLine)) != null) {\n        result += consumeCommentTokens(currLine);\n    }\n    return result;\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#forMemberWhenPublicConstructor()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "Access Control for Public Constructor",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#forMemberWhenPublicConstructor()",
      "head_type": "method",
      "relation": "have",
      "tail": "Sample Code for Access Control with Public Constructor",
      "tail_type": "useSampleCode"
    },
    {
      "head": "Access Control for Public Constructor",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "Sample Code for Access Control with Public Constructor",
      "tail_type": "useSampleCode"
    },
    {
      "head": "Sample Code for Access Control with Public Constructor",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "org.springframework.aot.generate.AccessControlTests#forMemberWhenPublicConstructor()",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#forMemberWhenPublicConstructor()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.AccessControl",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#forMemberWhenPublicConstructor()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.AccessControlTests",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#forMemberWhenPublicConstructor()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "PublicClass",
      "tail_type": "class"
    },
    {
      "head": "Access Control for Public Constructor",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "Detailed Explanation of Access Control",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "Access Control for Public Constructor",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "Design Principles of Access Control",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#method(Class<?>,String,Class<?>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "findMethod",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#method(Class<?>,String,Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "useSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "private static Method method(Class<?> type, String name, Class<?>... parameterTypes) {\n    Method method = ReflectionUtils.findMethod(type, name, parameterTypes);\n    assertThat(method).isNotNull();\n    return method;\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests#addSourceFileWithCharSequenceWhenClassNameIsInvalidThrowsException()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "addSourceFileWithCharSequence",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests#addSourceFileWithCharSequenceWhenClassNameIsInvalidThrowsException()",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "classNameValidity",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests#addSourceFileWithCharSequenceWhenClassNameIsInvalidThrowsException()",
      "head_type": "method",
      "relation": "have",
      "tail": "classNameValidity",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests#addSourceFileWithCharSequenceWhenClassNameIsInvalidThrowsException()",
      "head_type": "method",
      "relation": "have",
      "tail": "GeneratedFilesTests",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests#addSourceFileWithCharSequenceWhenClassNameIsInvalidThrowsException()",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests#addSourceFileWithCharSequenceWhenClassNameIsInvalidThrowsException()",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests#addSourceFileWithCharSequenceWhenClassNameIsInvalidThrowsException()",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.TestFileHandler#copy(InputStreamSource,boolean)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "copy content",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.TestFileHandler#copy(InputStreamSource,boolean)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "override option",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.TestFileHandler#copy(InputStreamSource,boolean)",
      "head_type": "method",
      "relation": "have",
      "tail": "InputStreamSource content",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.aot.generate.TestFileHandler#copy(InputStreamSource,boolean)",
      "head_type": "method",
      "relation": "have",
      "tail": "boolean override",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.aot.generate.TestFileHandler#copy(InputStreamSource,boolean)",
      "head_type": "method",
      "relation": "have",
      "tail": "protected void copy(InputStreamSource content, boolean override)",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.TestFileHandler#copy(InputStreamSource,boolean)",
      "head_type": "method",
      "relation": "have",
      "tail": "Copy content from an InputStreamSource with an option to override.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.TestFileHandler#copy(InputStreamSource,boolean)",
      "head_type": "method",
      "relation": "have",
      "tail": "Design principle of encapsulating stream handling within a method.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.PrimitiveTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "generateWhenBoolean",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.PrimitiveTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "generateWhenByte",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.PrimitiveTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "generateWhenShort",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.PrimitiveTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "generateWhenInt",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.PrimitiveTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "generateWhenLong",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.PrimitiveTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "generateWhenFloat",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.PrimitiveTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "generateWhenDouble",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.PrimitiveTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "generateWhenChar",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.PrimitiveTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "generateWhenSimpleEscapedCharReturnsEscaped",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.PrimitiveTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "generatedWhenUnicodeEscapedCharReturnsEscaped",
      "tail_type": "apiFunction"
    },
    {
      "head": "generateWhenBoolean",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "generateWhenBooleanSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "generateWhenByte",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "generateWhenByteSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "generateWhenShort",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "generateWhenShortSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "generateWhenInt",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "generateWhenIntSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "generateWhenLong",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "generateWhenLongSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "generateWhenFloat",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "generateWhenFloatSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "generateWhenDouble",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "generateWhenDoubleSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "generateWhenChar",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "generateWhenCharSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "generateWhenSimpleEscapedCharReturnsEscaped",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "generateWhenSimpleEscapedCharReturnsEscapedSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "generatedWhenUnicodeEscapedCharReturnsEscaped",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "generatedWhenUnicodeEscapedCharReturnsEscapedSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.PrimitiveTests#generateWhenDouble()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "generateCode",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.PrimitiveTests#generateWhenDouble()",
      "head_type": "method",
      "relation": "have",
      "tail": "generateWhenDoubleSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "generateWhenDoubleSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "generateWhenDoubleCompleteCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldIgnoreNonAnnotatedType()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "ignoreNonAnnotatedType",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldIgnoreNonAnnotatedType()",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests",
      "tail_type": "class"
    },
    {
      "head": "ignoreNonAnnotatedType",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests",
      "head_type": "class",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests",
      "head_type": "class",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldIgnoreNonAnnotatedType()",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.hint.annotation.SampleMultipleCustomProcessors",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "managed",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.hint.annotation.SampleMultipleCustomProcessors",
      "head_type": "class",
      "relation": "have",
      "tail": "public String managed() { return \"test\"; }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.core.type.StandardClassMetadata#isAnnotation()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "determine if the class is an annotation",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.core.type.StandardClassMetadata#isAnnotation()",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.core.type.StandardClassMetadata",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.core.type.StandardClassMetadata",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.core.type.ClassMetadata",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.core.type.StandardClassMetadata#isAnnotation()",
      "head_type": "method",
      "relation": "have",
      "tail": "This method checks if the introspected class is an annotation.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.core.type.StandardClassMetadata#isAnnotation()",
      "head_type": "method",
      "relation": "have",
      "tail": "This method utilizes the introspectedClass to determine if it represents an annotation, adhering to the principle of reflection for metadata analysis.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.core.type.StandardClassMetadata#isAnnotation()",
      "head_type": "method",
      "relation": "have",
      "tail": "java\npackage org.springframework.core.type;\n\npublic class StandardClassMetadataExample {\n    public static void main(String[] args) {\n        StandardClassMetadata metadata = new StandardClassMetadata(MyAnnotationClass.class);\n        boolean isAnnotation = metadata.isAnnotation();\n        System.out.println(\"Is MyAnnotationClass an annotation? \" + isAnnotation);\n    }\n}\n\nclass MyAnnotationClass {\n    // Example class\n}\n",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.core.type.StandardClassMetadata#isIndependent()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "checkClassIndependence",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.core.type.StandardClassMetadata#isIndependent()",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.core.type.StandardClassMetadata",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.core.type.StandardClassMetadata#isIndependent()",
      "head_type": "method",
      "relation": "have",
      "tail": "Checks if the class is independent, i.e., not an inner class or a static nested class.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.core.type.StandardClassMetadata#isIndependent()",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is used to determine if a class is independent, which means it is not an inner class or it is a static nested class. It checks if the class has an enclosing class and if the declaring class is static.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.core.type.StandardClassMetadata#isIndependent()",
      "head_type": "method",
      "relation": "have",
      "tail": "package com.example;\n\nimport org.springframework.core.type.StandardClassMetadata;\n\npublic class ExampleClass {\n    public static void main(String[] args) {\n        StandardClassMetadata metadata = new StandardClassMetadata(MyClass.class);\n        boolean isIndependent = metadata.isIndependent();\n        System.out.println(\"Is MyClass independent? \" + isIndependent);\n    }\n}\n\nclass MyClass {\n    // This is an independent class\n}\n\nclass MyInnerClass {\n    // This is an inner class\n}\n\nclass MyStaticNestedClass {\n    // This is a static nested class\n}\n",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#setTrimTokens(boolean)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "trimming tokenized paths and patterns",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#setTrimTokens(boolean)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "trimTokens must be a boolean value",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#setTrimTokens(boolean)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "path and pattern matching",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#setTrimTokens(boolean)",
      "head_type": "method",
      "relation": "have",
      "tail": "public void setTrimTokens(boolean trimTokens) { this.trimTokens = trimTokens; }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#setTrimTokens(boolean)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#setTrimTokens(boolean)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#setTrimTokens(boolean)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.AntPathMatcher",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.Assert#isTrue(boolean,Supplier<String>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "assert boolean expression",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.Assert#isTrue(boolean,Supplier<String>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "expression evaluates to false",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.Assert#isTrue(boolean,Supplier<String>)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "validate conditions in code",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.Assert#isTrue(boolean,Supplier<String>)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for asserting a condition",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.Assert#isTrue(boolean,Supplier<String>)",
      "head_type": "method",
      "relation": "have",
      "tail": "IllegalArgumentException thrown if condition fails",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.Assert#isTrue(boolean,Supplier<String>)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle for assertion methods",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.Assert#isTrue(boolean,Supplier<String>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.Assert",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.Assert#isAssignable(Class<?>,Class<?>,Supplier<String>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "type checking",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.Assert#isAssignable(Class<?>,Class<?>,Supplier<String>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "superType must not be null",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.Assert#isAssignable(Class<?>,Class<?>,Supplier<String>)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "ensuring subtype is assignable to supertype",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.Assert#isAssignable(Class<?>,Class<?>,Supplier<String>)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for isAssignable method",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.Assert#isAssignable(Class<?>,Class<?>,Supplier<String>)",
      "head_type": "method",
      "relation": "have",
      "tail": "related concept interpretation for isAssignable method",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.Assert#isAssignable(Class<?>,Class<?>,Supplier<String>)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle interpretation for isAssignable method",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.Assert#isAssignable(Class<?>,Class<?>,Supplier<String>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.Assert",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.AutoPopulatingList#get(int)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "autoPopulating",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.AutoPopulatingList#get(int)",
      "head_type": "method",
      "relation": "have",
      "tail": "autoPopulatingElementRetrieval",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.AutoPopulatingList#get(int)",
      "head_type": "method",
      "relation": "have",
      "tail": "autoPopulatingListSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "autoPopulatingListSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "org.springframework.util.AutoPopulatingList",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.AutoPopulatingList#get(int)",
      "head_type": "method",
      "relation": "have",
      "tail": "autoPopulatingListRelatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.AutoPopulatingList#get(int)",
      "head_type": "method",
      "relation": "have",
      "tail": "autoPopulatingListDesignPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.backoff.ExponentialBackOff#getMaxElapsedTime()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "get maximum elapsed time",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.backoff.ExponentialBackOff#getMaxElapsedTime()",
      "head_type": "method",
      "relation": "have",
      "tail": "Return the maximum elapsed time in milliseconds after which a call to BackOffExecution#nextBackOff() returns BackOffExecution#STOP.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.backoff.ExponentialBackOff#getMaxElapsedTime()",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is used to retrieve the maximum elapsed time in milliseconds. If the elapsed time exceeds this value, a call to BackOffExecution#nextBackOff() will return BackOffExecution#STOP, indicating that no further backoff attempts should be made.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.backoff.ExponentialBackOff",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.backoff.BackOffExecution",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.backoff.ExponentialBackOff",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.backoff.BackOffExecution#nextBackOff()",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.backoff.ExponentialBackOff",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.backoff.BackOffExecution#STOP",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.backoff.ExponentialBackOff#getMaxElapsedTime()",
      "head_type": "method",
      "relation": "have",
      "tail": "package com.example.demo;\n\nimport org.springframework.util.backoff.BackOffExecution;\nimport org.springframework.util.backoff.ExponentialBackOff;\n\npublic class ExponentialBackOffExample {\n    public static void main(String[] args) {\n        ExponentialBackOff backOff = new ExponentialBackOff();\n        backOff.setMaxElapsedTime(10000); // Set maximum elapsed time to 10 seconds\n        \n        BackOffExecution execution = backOff.start();\n        while (execution.nextBackOff() != BackOffExecution.STOP) {\n            try {\n                // Simulate an operation that may fail\n                performOperation();\n                break; // If operation succeeds, exit loop\n            } catch (Exception e) {\n                System.out.println(\"Operation failed, backing off...\");\n            }\n        }\n    }\n    \n    private static void performOperation() throws Exception {\n        // Simulate an operation that may throw an exception\n        throw new Exception(\"Operation failed\");\n    }\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.backoff.FixedBackOff#getInterval()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getInterval",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.backoff.FixedBackOff#getInterval()",
      "head_type": "method",
      "relation": "have",
      "tail": "Return the interval between two attempts in milliseconds.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.backoff.FixedBackOff",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.backoff.FixedBackOff#getInterval()",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.backoff.FixedBackOff",
      "head_type": "class",
      "relation": "designPrincipleInterpretation",
      "tail": "FixedBackOff is designed to provide a fixed interval between retry attempts, simplifying the retry mechanism by ensuring consistent delays.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.backoff.FixedBackOff",
      "head_type": "class",
      "relation": "have",
      "tail": "public long getInterval() { return this.interval; }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ClassUtils#getDefaultClassLoader()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "return the default ClassLoader",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ClassUtils#getDefaultClassLoader()",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "null ClassLoader reference accepted by Class.forName",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ClassUtils#getDefaultClassLoader()",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "class path resource loading",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ClassUtils#getDefaultClassLoader()",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for using the apiFunction",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ClassUtils#getDefaultClassLoader()",
      "head_type": "method",
      "relation": "have",
      "tail": "related concept interpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#getDefaultClassLoader()",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle interpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#getDefaultClassLoader()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "Thread",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.ClassUtils#getDefaultClassLoader()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "ClassLoader",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.ClassUtils#overrideThreadContextClassLoader(ClassLoader)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "overrideThreadContextClassLoader",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ClassUtils#overrideThreadContextClassLoader(ClassLoader)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "classLoaderEquivalence",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ClassUtils#overrideThreadContextClassLoader(ClassLoader)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "threadContextClassLoaderOverride",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ClassUtils#overrideThreadContextClassLoader(ClassLoader)",
      "head_type": "method",
      "relation": "have",
      "tail": "threadContextClassLoaderOverrideSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ClassUtils#overrideThreadContextClassLoader(ClassLoader)",
      "head_type": "method",
      "relation": "have",
      "tail": "threadContextClassLoaderOverrideConcept",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#overrideThreadContextClassLoader(ClassLoader)",
      "head_type": "method",
      "relation": "have",
      "tail": "threadContextClassLoaderOverrideDesignPrinciple",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#overrideThreadContextClassLoader(ClassLoader)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.ClassUtils",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.ClassUtils#classNamesToString(Collection<Class<?>>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "building a string from class names",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ClassUtils#classNamesToString(Collection<Class<?>>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "collection can be null",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ClassUtils#classNamesToString(Collection<Class<?>>)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "creating a string representation of a collection of classes",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ClassUtils#classNamesToString(Collection<Class<?>>)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for creating a string from class names",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ClassUtils#classNamesToString(Collection<Class<?>>)",
      "head_type": "method",
      "relation": "have",
      "tail": "related concept interpretation for creating a string from class names",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#classNamesToString(Collection<Class<?>>)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle interpretation for creating a string from class names",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#classNamesToString(Collection<Class<?>>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "java.util.AbstractCollection#toString()",
      "tail_type": "method"
    },
    {
      "head": "building a string from class names",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "sample code for creating a string from class names",
      "tail_type": "useSampleCode"
    },
    {
      "head": "building a string from class names",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "related concept interpretation for creating a string from class names",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "building a string from class names",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "design principle interpretation for creating a string from class names",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getMethodOrNull",
      "tail_type": "apiFunction"
    },
    {
      "head": "getMethodOrNull",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "org.springframework.util.ClassUtils",
      "tail_type": "class"
    },
    {
      "head": "getMethodOrNull",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "useSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "org.springframework.util.ClassUtils",
      "tail_type": "class"
    },
    {
      "head": "getMethodOrNull",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "relatedConceptInterpretation",
      "head_type": "relatedConceptInterpretation",
      "relation": "have",
      "tail": "org.springframework.util.ClassUtils",
      "tail_type": "class"
    },
    {
      "head": "getMethodOrNull",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "designPrincipleInterpretation",
      "head_type": "designPrincipleInterpretation",
      "relation": "have",
      "tail": "org.springframework.util.ClassUtils",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.CollectionUtils#newHashSet(int)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "instantiate a new HashSet with an initial capacity",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.CollectionUtils#newHashSet(int)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "expected number of elements",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.CollectionUtils#newHashSet(int)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "accommodate the specified number of elements without any immediate resize/rehash operations",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.CollectionUtils#newHashSet(int)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for using newHashSet with initial capacity",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.CollectionUtils#newHashSet(int)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "newLinkedHashSet(int)",
      "tail_type": "method"
    },
    {
      "head": "sample code for using newHashSet with initial capacity",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "complete example of using newHashSet with initial capacity",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.CollectionUtils#newHashSet(int)",
      "head_type": "method",
      "relation": "have",
      "tail": "related concept interpretation for newHashSet",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "related concept interpretation for newHashSet",
      "head_type": "relatedConceptInterpretation",
      "relation": "have",
      "tail": "detailed explanation of HashSet and initial capacity",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.CollectionUtils#newHashSet(int)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle interpretation for newHashSet",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "design principle interpretation for newHashSet",
      "head_type": "designPrincipleInterpretation",
      "relation": "have",
      "tail": "principles behind the design of newHashSet method",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.CollectionUtils#contains(Iterator<?>,Object)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "Check whether the given Iterator contains the given element",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.CollectionUtils#contains(Iterator<?>,Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "public static boolean contains(@Nullable Iterator<?> iterator, Object element) { if (iterator != null) { while (iterator.hasNext()) { Object candidate = iterator.next(); if (ObjectUtils.nullSafeEquals(candidate, element)) { return true; } } } return false; }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.CollectionUtils#contains(Iterator<?>,Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "The method checks if an iterator contains a specific element by iterating through the elements and comparing each one with the target element using a null-safe equality check.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.CollectionUtils#contains(Iterator<?>,Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "The design principle followed here is to provide a utility method that simplifies common operations on collections, enhancing code readability and maintainability.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.comparator.BooleanComparator#equals(Object)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "equality comparison",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.comparator.BooleanComparator#equals(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.comparator.BooleanComparator#equals(Object) sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.comparator.BooleanComparator#equals(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.comparator.BooleanComparator#equals(Object) related concept interpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.comparator.BooleanComparator#equals(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.comparator.BooleanComparator#equals(Object) design principle interpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.comparator.BooleanComparator#equals(Object)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.comparator.BooleanComparator",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.comparator.NullSafeComparator#hashCode()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "NullSafeComparator",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.comparator.NullSafeComparator#hashCode()",
      "head_type": "method",
      "relation": "have",
      "tail": "Calculate hash code",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.comparator.NullSafeComparator#hashCode()",
      "head_type": "method",
      "relation": "have",
      "tail": "Override method",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.comparator.NullSafeComparator#hashCode()",
      "head_type": "method",
      "relation": "have",
      "tail": "public int hashCode() { return Boolean.hashCode(this.nullsLow); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.CompositeCollection#isEmpty()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "check emptiness of composite collection",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.CompositeCollection#isEmpty()",
      "head_type": "method",
      "relation": "have",
      "tail": "Checks if both the first and second collections are empty",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.CompositeCollection#isEmpty()",
      "head_type": "method",
      "relation": "have",
      "tail": "java\npackage org.springframework.util;\n\nimport java.util.Collection;\n\npublic class CompositeCollection {\n    private Collection<?> first;\n    private Collection<?> second;\n\n    public boolean isEmpty() {\n        return this.first.isEmpty() && this.second.isEmpty();\n    }\n}\n",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.CompositeCollection#isEmpty()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.CompositeCollection",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.CompositeCollection#isEmpty()",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is used to determine if the composite collection, which consists of two collections, is empty. It returns true only if both collections are empty.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.CompositeCollection#isEmpty()",
      "head_type": "method",
      "relation": "have",
      "tail": "The design principle behind this method is to provide a convenient way to check the emptiness of a composite collection. It leverages the logical AND operation to ensure that both collections are empty before returning true, thereby enhancing the efficiency and readability of the code.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.concurrent.FutureUtils#callAsync(Callable<T>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "asynchronous task execution",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.concurrent.FutureUtils#callAsync(Callable<T>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "Callable must not be null",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.concurrent.FutureUtils#callAsync(Callable<T>)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "running tasks in the common ForkJoinPool",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.concurrent.FutureUtils#callAsync(Callable<T>)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for asynchronous execution",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.concurrent.FutureUtils#callAsync(Callable<T>)",
      "head_type": "method",
      "relation": "have",
      "tail": "explanation of CompletableFuture and Supplier",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.concurrent.FutureUtils#callAsync(Callable<T>)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principles of asynchronous programming",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.concurrent.FutureUtils#callAsync(Callable<T>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "CompletableFuture#supplyAsync(Supplier)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.concurrent.FutureUtils#callAsync(Callable<T>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "ForkJoinPool#commonPool()",
      "tail_type": "class"
    },
    {
      "head": "sample code for asynchronous execution",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "complete example of using callAsync method",
      "tail_type": "useSampleCode"
    },
    {
      "head": "explanation of CompletableFuture and Supplier",
      "head_type": "relatedConceptInterpretation",
      "relation": "have",
      "tail": "detailed explanation of CompletableFuture and Supplier",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "design principles of asynchronous programming",
      "head_type": "designPrincipleInterpretation",
      "relation": "have",
      "tail": "detailed explanation of asynchronous programming design principles",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.concurrent.FutureUtils#callAsync(Callable<T>,Executor)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "asynchronous execution",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.concurrent.FutureUtils#callAsync(Callable<T>,Executor)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "Callable and Executor must not be null",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.concurrent.FutureUtils#callAsync(Callable<T>,Executor)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "running tasks asynchronously using a given executor",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.concurrent.FutureUtils#callAsync(Callable<T>,Executor)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for asynchronous execution",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.concurrent.FutureUtils#callAsync(Callable<T>,Executor)",
      "head_type": "method",
      "relation": "have",
      "tail": "explanation of CompletableFuture and Supplier",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.concurrent.FutureUtils#callAsync(Callable<T>,Executor)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principles of asynchronous programming",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.concurrent.FutureUtils#callAsync(Callable<T>,Executor)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "CompletableFuture#supplyAsync(Supplier, Executor)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.ConcurrentLruCache#put(K,V)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "add or update cache entries",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ConcurrentLruCache#put(K,V)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "key and value must not be null",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ConcurrentLruCache#put(K,V)",
      "head_type": "method",
      "relation": "have",
      "tail": "private void put(K key, V value) {\n    Assert.notNull(key, \"key must not be null\");\n    Assert.notNull(value, \"value must not be null\");\n    final CacheEntry<V> cacheEntry = new CacheEntry<>(value, CacheEntryState.ACTIVE);\n    final Node<K, V> node = new Node<>(key, cacheEntry);\n    final Node<K, V> prior = this.cache.putIfAbsent(node.key, node);\n    if (prior == null) {\n        processWrite(new AddTask(node));\n    } else {\n        processRead(prior);\n    }\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ConcurrentLruCache#put(K,V)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.ConcurrentLruCache",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.ConcurrentLruCache#put(K,V)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ConcurrentLruCache#put(K,V)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ReadOperations#recordRead(Node<K,V>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "recordRead",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ReadOperations#recordRead(Node<K,V>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "Node<K,V>",
      "tail_type": "class"
    },
    {
      "head": "recordRead",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "useSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "org.springframework.util.ReadOperations",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.Node",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getPrevious",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.Node",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "setPrevious",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.Node",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getNext",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.Node",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "setNext",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.Node",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getValue",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.Node#setPrevious(Node<K,V>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "set previous node",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.Node#setPrevious(Node<K,V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "public void setPrevious(@Nullable Node<K, V> prev) { this.prev = prev; }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.Node#setPrevious(Node<K,V>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.Node",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.CustomizableThreadCreator#setDaemon(boolean)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "create daemon threads",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.CustomizableThreadCreator#setDaemon(boolean)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "threads which still actively execute a Runnable at the time that the application itself shuts down",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.CustomizableThreadCreator#setDaemon(boolean)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "eager shutdown of threads",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.CustomizableThreadCreator#setDaemon(boolean)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for creating daemon threads",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.CustomizableThreadCreator#setDaemon(boolean)",
      "head_type": "method",
      "relation": "have",
      "tail": "daemon threads explanation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.CustomizableThreadCreator#setDaemon(boolean)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principles for creating daemon threads",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.CustomizableThreadCreator#setDaemon(boolean)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "java.lang.Thread#setDaemon",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.DigestUtils#appendMd5DigestAsHex(byte[],StringBuilder)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "append hexadecimal MD5 digest",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.DigestUtils#appendMd5DigestAsHex(byte[],StringBuilder)",
      "head_type": "method",
      "relation": "have",
      "tail": "append a hexadecimal string representation of the MD5 digest of the given bytes to the given StringBuilder",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.DigestUtils#appendMd5DigestAsHex(byte[],StringBuilder)",
      "head_type": "method",
      "relation": "have",
      "tail": "The method takes an array of bytes as input and calculates the MD5 digest, which is then converted into a hexadecimal string and appended to the provided StringBuilder.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.DigestUtils#appendMd5DigestAsHex(byte[],StringBuilder)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is designed to efficiently append the hexadecimal representation of the MD5 digest to a StringBuilder, which can be useful for generating hashes or checksums in string format.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.FastByteArrayOutputStream#toByteArrayUnsafe()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "convertStreamContentsToByteArray",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.FastByteArrayOutputStream#toByteArrayUnsafe()",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "doNotModifyReturnedBuffer",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.FastByteArrayOutputStream#toByteArrayUnsafe()",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "returnInternalBuffer",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.FastByteArrayOutputStream#toByteArrayUnsafe()",
      "head_type": "method",
      "relation": "have",
      "tail": "returnInternalBuffer",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.FastByteArrayOutputStream#toByteArrayUnsafe()",
      "head_type": "method",
      "relation": "have",
      "tail": "conserveMemoryByUsingInternalBuffer",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.FastByteArrayOutputStream#toByteArrayUnsafe()",
      "head_type": "method",
      "relation": "have",
      "tail": "efficientMemoryManagement",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.FastByteArrayOutputStream#toByteArrayUnsafe()",
      "head_type": "method",
      "relation": "have",
      "tail": "public byte[] toByteArrayUnsafe() {    int totalSize = size();    if (totalSize == 0) {        return new byte[0];    }    resize(totalSize);    return this.buffers.getFirst();}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "convertStreamContentsToByteArray",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "org.springframework.util.FastByteArrayOutputStream#toByteArrayUnsafe()",
      "tail_type": "method"
    },
    {
      "head": "doNotModifyReturnedBuffer",
      "head_type": "useConstraint",
      "relation": "associated_with",
      "tail": "org.springframework.util.FastByteArrayOutputStream#toByteArrayUnsafe()",
      "tail_type": "method"
    },
    {
      "head": "returnInternalBuffer",
      "head_type": "useScenario",
      "relation": "associated_with",
      "tail": "org.springframework.util.FastByteArrayOutputStream#toByteArrayUnsafe()",
      "tail_type": "method"
    },
    {
      "head": "conserveMemoryByUsingInternalBuffer",
      "head_type": "relatedConceptInterpretation",
      "relation": "associated_with",
      "tail": "org.springframework.util.FastByteArrayOutputStream#toByteArrayUnsafe()",
      "tail_type": "method"
    },
    {
      "head": "efficientMemoryManagement",
      "head_type": "designPrincipleInterpretation",
      "relation": "associated_with",
      "tail": "org.springframework.util.FastByteArrayOutputStream#toByteArrayUnsafe()",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.FastByteArrayOutputStream#writeTo(OutputStream)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "write contents to OutputStream",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.FastByteArrayOutputStream#writeTo(OutputStream)",
      "head_type": "method",
      "relation": "have",
      "tail": "write the contents of this FastByteArrayOutputStream to the given OutputStream",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.FastByteArrayOutputStream#writeTo(OutputStream)",
      "head_type": "method",
      "relation": "have",
      "tail": "Write the contents of this FastByteArrayOutputStream to the given OutputStream.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.FastByteArrayOutputStream#writeTo(OutputStream)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is designed to efficiently transfer the data stored within a FastByteArrayOutputStream instance to another OutputStream, ensuring data integrity and maintaining the sequence of bytes.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.FilteredMap#entrySet()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "filtered entry set retrieval",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.FilteredMap#entrySet()",
      "head_type": "method",
      "relation": "have",
      "tail": "This method returns a set view of the mappings contained in this map. The set is dynamically filtered based on the filter associated with the parent FilteredMap.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.FilteredMap#entrySet()",
      "head_type": "method",
      "relation": "have",
      "tail": "The design principle behind this method is to provide a filtered view of the underlying map entries, ensuring that only entries that meet the filter criteria are exposed. This enhances data encapsulation and controlled access.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.FilteredMap#entrySet()",
      "head_type": "method",
      "relation": "have",
      "tail": "package com.example;\n\nimport java.util.Map;\nimport java.util.Set;\nimport org.springframework.util.FilteredMap;\n\npublic class FilteredMapExample {\n    public static void main(String[] args) {\n        Map<String, Integer> originalMap = Map.of(\"key1\", 1, \"key2\", 2, \"key3\", 3);\n        FilteredMap<String, Integer> filteredMap = new FilteredMap<>(originalMap, key -> key.contains(\"2\"));\n        Set<Map.Entry<String, Integer>> filteredEntrySet = filteredMap.entrySet();\n        filteredEntrySet.forEach(entry -> System.out.println(entry.getKey() + \": \" + entry.getValue()));\n    }\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.KeySetIterator#next()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "iterateKeySet",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.KeySetIterator#next()",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.KeySetIterator#next() returns the next key in the set",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.KeySetIterator#next()",
      "head_type": "method",
      "relation": "have",
      "tail": "public String next() { return nextEntry().getKey(); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.KeySetIterator#next()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.KeySetIterator",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.MethodInvoker",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "method invocation",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MethodInvoker",
      "head_type": "class",
      "relation": "constrained_by",
      "tail": "target method must not be non-static without a target",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.MethodInvoker",
      "head_type": "class",
      "relation": "applied_to",
      "tail": "specify a method to invoke in a declarative fashion",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.MethodInvoker",
      "head_type": "class",
      "relation": "have",
      "tail": "Helper class that allows for specifying a method to invoke in a declarative fashion, be it static or non-static.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.MethodInvoker",
      "head_type": "class",
      "relation": "have",
      "tail": "Design Principle: The class is designed to provide a flexible way to invoke methods, allowing for dynamic method selection and invocation. It encapsulates method invocation logic, separating it from the main application flow, which enhances code modularity and maintainability.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.MethodInvoker",
      "head_type": "class",
      "relation": "have",
      "tail": "package com.example;\n\nimport org.springframework.util.MethodInvoker;\n\npublic class Example {\n    public static void main(String[] args) throws Exception {\n        MethodInvoker invoker = new MethodInvoker();\n        invoker.setTargetClass(MyClass.class);\n        invoker.setTargetMethod(\"myMethod\");\n        invoker.prepare();\n        invoker.invoke();\n    }\n}\n\nclass MyClass {\n    public static void myMethod() {\n        System.out.println(\"Method invoked\");\n    }\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.MimeType#getParameters()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "return all generic parameter values",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MimeType#getParameters()",
      "head_type": "method",
      "relation": "have",
      "tail": "a read-only map (possibly empty, never null)",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.MimeType",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.MimeType#getParameters()",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.MultiToSingleValueMapAdapter#size()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "size determination",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MultiToSingleValueMapAdapter#size()",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is used to determine the size of the target map.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.MultiToSingleValueMapAdapter#size()",
      "head_type": "method",
      "relation": "have",
      "tail": "This method follows the principle of encapsulation by providing a way to access the size of the internal target map without exposing the map itself.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.MultiToSingleValueMapAdapter#size()",
      "head_type": "method",
      "relation": "have",
      "tail": "package com.example;\n\nimport org.springframework.util.MultiToSingleValueMapAdapter;\n\npublic class Main {\n    public static void main(String[] args) {\n        MultiToSingleValueMapAdapter<String, String> adapter = new MultiToSingleValueMapAdapter<>();\n        adapter.add(\"key\", \"value1\");\n        adapter.add(\"key\", \"value2\");\n        int size = adapter.size();\n        System.out.println(\"Size of the map: \" + size);\n    }\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ObjectUtils#caseInsensitiveValueOf(E[],String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "caseInsensitiveEnumValueRetrieval",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ObjectUtils#caseInsensitiveValueOf(E[],String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "IllegalArgumentExceptionOnMissingConstant",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ObjectUtils#caseInsensitiveValueOf(E[],String)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "enumValueRetrievalIgnoringCase",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ObjectUtils#caseInsensitiveValueOf(E[],String)",
      "head_type": "method",
      "relation": "have",
      "tail": "completeExampleForCaseInsensitiveEnumRetrieval",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ObjectUtils#caseInsensitiveValueOf(E[],String)",
      "head_type": "method",
      "relation": "have",
      "tail": "enumValueRetrievalIgnoringCaseExplanation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ObjectUtils#caseInsensitiveValueOf(E[],String)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrinciplesBehindCaseInsensitiveEnumRetrieval",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "caseInsensitiveEnumValueRetrieval",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "org.springframework.util.ObjectUtils",
      "tail_type": "class"
    },
    {
      "head": "IllegalArgumentExceptionOnMissingConstant",
      "head_type": "useConstraint",
      "relation": "associated_with",
      "tail": "org.springframework.util.ObjectUtils",
      "tail_type": "class"
    },
    {
      "head": "enumValueRetrievalIgnoringCase",
      "head_type": "useScenario",
      "relation": "associated_with",
      "tail": "org.springframework.util.ObjectUtils",
      "tail_type": "class"
    },
    {
      "head": "completeExampleForCaseInsensitiveEnumRetrieval",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "tail": "org.springframework.util.ObjectUtils",
      "tail_type": "class"
    },
    {
      "head": "enumValueRetrievalIgnoringCaseExplanation",
      "head_type": "relatedConceptInterpretation",
      "relation": "associated_with",
      "tail": "org.springframework.util.ObjectUtils",
      "tail_type": "class"
    },
    {
      "head": "designPrinciplesBehindCaseInsensitiveEnumRetrieval",
      "head_type": "designPrincipleInterpretation",
      "relation": "associated_with",
      "tail": "org.springframework.util.ObjectUtils",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeConciseToString(Object)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "generate null-safe concise string representation",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeConciseToString(Object)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "length of the generated string to be limited",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeConciseToString(Object)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "null object",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeConciseToString(Object)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "empty Optional",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeConciseToString(Object)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "non-empty Optional",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeConciseToString(Object)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "empty array",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeConciseToString(Object)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "Map or non-empty array",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeConciseToString(Object)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "Collection",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeConciseToString(Object)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "Class",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeConciseToString(Object)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "Charset",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeConciseToString(Object)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "TimeZone",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeConciseToString(Object)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "ZoneId",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeConciseToString(Object)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "CharSequence",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeConciseToString(Object)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "simple value type",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeConciseToString(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeConciseToString(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeConciseToString(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeConciseToString(Object)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "StringUtils#truncate(CharSequence)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeConciseToString(Object)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "ClassUtils#isSimpleValueType(Class)",
      "tail_type": "method"
    },
    {
      "head": "relatedConceptInterpretation",
      "head_type": "relatedConceptInterpretation",
      "relation": "have",
      "tail": "This method is designed to provide a concise string representation of an object, handling various scenarios such as null values, Optional objects, collections, maps, and simple value types. It ensures that the output string is not longer than a specified limit, making it useful for situations where string length needs to be controlled.",
      "tail_type": "description"
    },
    {
      "head": "designPrincipleInterpretation",
      "head_type": "designPrincipleInterpretation",
      "relation": "have",
      "tail": "The design principle behind this method is to provide a robust and flexible way to convert objects to their string representations while handling various edge cases and ensuring the output is concise and within a manageable length. This promotes better readability and performance in applications that require object string representations.",
      "tail_type": "description"
    },
    {
      "head": "useSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "java\npackage com.example;\n\nimport org.springframework.util.ObjectUtils;\n\npublic class Main {\n    public static void main(String[] args) {\n        Object obj = null;\n        System.out.println(ObjectUtils.nullSafeConciseToString(obj));\n        \n        obj = Optional.empty();\n        System.out.println(ObjectUtils.nullSafeConciseToString(obj));\n        \n        obj = Optional.of(\"Hello\");\n        System.out.println(ObjectUtils.nullSafeConciseToString(obj));\n        \n        obj = new int[] {};\n        System.out.println(ObjectUtils.nullSafeConciseToString(obj));\n        \n        obj = new int[] {1, 2, 3};\n        System.out.println(ObjectUtils.nullSafeConciseToString(obj));\n        \n        obj = List.of(1, 2, 3);\n        System.out.println(ObjectUtils.nullSafeConciseToString(obj));\n        \n        obj = Map.of(\"key\", \"value\");\n        System.out.println(ObjectUtils.nullSafeConciseToString(obj));\n        \n        obj = String.class;\n        System.out.println(ObjectUtils.nullSafeConciseToString(obj));\n        \n        obj = Charset.defaultCharset();\n        System.out.println(ObjectUtils.nullSafeConciseToString(obj));\n        \n        obj = TimeZone.getDefault();\n        System.out.println(ObjectUtils.nullSafeConciseToString(obj));\n        \n        obj = ZoneId.systemDefault();\n        System.out.println(ObjectUtils.nullSafeConciseToString(obj));\n        \n        obj = \"This is a long string that might need truncation.\";\n        System.out.println(ObjectUtils.nullSafeConciseToString(obj));\n        \n        obj = new java.util.Date();\n        System.out.println(ObjectUtils.nullSafeConciseToString(obj));\n    }\n}\n",
      "tail_type": "code"
    },
    {
      "head": "org.springframework.util.PatternMatchUtils#simpleMatch(String,String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "stringMatching",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.PatternMatchUtils#simpleMatch(String,String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "nullInputReturnsFalse",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.PatternMatchUtils#simpleMatch(String,String)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "patternMatching",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.PatternMatchUtils#simpleMatch(String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.PatternMatchUtils#simpleMatch(String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.PatternMatchUtils#simpleMatch(String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.PatternMatchUtils",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.PatternMatchUtils#simpleMatch(String,String)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.PlaceholderParser#parseSection(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "parse input value with separator",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.PlaceholderParser#parseSection(String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "input must contain a separator",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.PlaceholderParser#parseSection(String)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "splitting key and fallback from input",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.PlaceholderParser#parseSection(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "return parsed section with key and optional fallback",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.PlaceholderParser#parseSection(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "ParsedSection class",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.PlaceholderParser#parseSection(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "handling escaped separators",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.PlaceholderParser#parseSection(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle of parsing with separator handling",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.PlaceholderParser#addText(String,int,int,LinkedList<Part>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "addText",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.PlaceholderParser#addText(String,int,int,LinkedList<Part>)",
      "head_type": "method",
      "relation": "have",
      "tail": "addTextSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "addTextSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "addTextSampleCodeContent",
      "tail_type": "useSampleCodeContent"
    },
    {
      "head": "org.springframework.util.PropertyPlaceholderHelper#parseStringValue(String,PlaceholderResolver)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "parse string value",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.PropertyPlaceholderHelper#parseStringValue(String,PlaceholderResolver)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.PropertyPlaceholderHelper",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.PropertyPlaceholderHelper#parseStringValue(String,PlaceholderResolver)",
      "head_type": "method",
      "relation": "have",
      "tail": "parser.replacePlaceholders(value, placeholderResolver)",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.PropertyPlaceholderHelper",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.PropertyPlaceholderHelper#parseStringValue(String,PlaceholderResolver)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#getUniqueDeclaredMethods(Class<?>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "introspection",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#getUniqueDeclaredMethods(Class<?>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "introspection failure",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#getUniqueDeclaredMethods(Class<?>)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "class introspection",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#getUniqueDeclaredMethods(Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#getUniqueDeclaredMethods(Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "introspection",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "org.springframework.util.ReflectionUtils",
      "tail_type": "class"
    },
    {
      "head": "introspection failure",
      "head_type": "useConstraint",
      "relation": "associated_with",
      "tail": "org.springframework.util.ReflectionUtils",
      "tail_type": "class"
    },
    {
      "head": "class introspection",
      "head_type": "useScenario",
      "relation": "associated_with",
      "tail": "org.springframework.util.ReflectionUtils",
      "tail_type": "class"
    },
    {
      "head": "relatedConceptInterpretation",
      "head_type": "relatedConceptInterpretation",
      "relation": "associated_with",
      "tail": "org.springframework.util.ReflectionUtils",
      "tail_type": "class"
    },
    {
      "head": "designPrincipleInterpretation",
      "head_type": "designPrincipleInterpretation",
      "relation": "associated_with",
      "tail": "org.springframework.util.ReflectionUtils",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.ReflectionUtils",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "introspection",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ReflectionUtils",
      "head_type": "class",
      "relation": "constrained_by",
      "tail": "introspection failure",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ReflectionUtils",
      "head_type": "class",
      "relation": "applied_to",
      "tail": "class introspection",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ReflectionUtils",
      "head_type": "class",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ReflectionUtils",
      "head_type": "class",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#findDefaultMethodsOnInterfaces(Class<?>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "find default methods on interfaces",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#findDefaultMethodsOnInterfaces(Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "private static List<Method> findDefaultMethodsOnInterfaces(Class<?> clazz) { List<Method> result = null; for (Class<?> ifc : clazz.getInterfaces()) { for (Method method : ifc.getMethods()) { if (method.isDefault()) { if (result == null) { result = new ArrayList<>(); } result.add(method); } } } return result; }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#findDefaultMethodsOnInterfaces(Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method iterates over all interfaces implemented by the given class and collects all default methods defined in those interfaces.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#findDefaultMethodsOnInterfaces(Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "The method follows the principle of reflection to dynamically inspect and collect methods, ensuring flexibility and adaptability in handling various class types.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.MethodCallback",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "perform an operation using the given method",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MethodCallback",
      "head_type": "class",
      "relation": "have",
      "tail": "Action to take on each method",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.MethodCallback",
      "head_type": "class",
      "relation": "have",
      "tail": "void doWith(Method method) throws IllegalArgumentException, IllegalAccessException",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.MethodFilter",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "method filtering",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MethodFilter",
      "head_type": "class",
      "relation": "constrained_by",
      "tail": "IllegalArgumentException on null MethodFilter",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.MethodFilter",
      "head_type": "class",
      "relation": "applied_to",
      "tail": "method callback operations",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.MethodFilter",
      "head_type": "class",
      "relation": "have",
      "tail": "composite filter creation",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.MethodFilter",
      "head_type": "class",
      "relation": "have",
      "tail": "sample code for creating a composite filter",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.MethodFilter",
      "head_type": "class",
      "relation": "have",
      "tail": "MethodFilter used for filtering methods in callbacks",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.MethodFilter",
      "head_type": "class",
      "relation": "have",
      "tail": "design principle for method filtering",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.MethodFilter",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "Method",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.MethodFilter#matches(Method)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "determine whether the given method matches",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MethodFilter#matches(Method)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.MethodFilter#matches(Method)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.MethodFilter#matches(Method)",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ResourceUtils#isUrl(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "check if a resource location is a URL",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ResourceUtils#isUrl(String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "resourceLocation must be non-null",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ResourceUtils#isUrl(String)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "resource location checking",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ResourceUtils#isUrl(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for checking resource location",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ResourceUtils#isUrl(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "interpretation of URL and classpath",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ResourceUtils#isUrl(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle of URL checking",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ResourceUtils#isUrl(String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "java.net.URL",
      "tail_type": "class"
    },
    {
      "head": "check if a resource location is a URL",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "sample code for checking resource location",
      "tail_type": "useSampleCode"
    },
    {
      "head": "check if a resource location is a URL",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "interpretation of URL and classpath",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "check if a resource location is a URL",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "design principle of URL checking",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "resource location checking",
      "head_type": "useScenario",
      "relation": "have",
      "tail": "sample code for checking resource location",
      "tail_type": "useSampleCode"
    },
    {
      "head": "resource location checking",
      "head_type": "useScenario",
      "relation": "have",
      "tail": "interpretation of URL and classpath",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "resource location checking",
      "head_type": "useScenario",
      "relation": "have",
      "tail": "design principle of URL checking",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "interpretation of URL and classpath",
      "head_type": "relatedConceptInterpretation",
      "relation": "have",
      "tail": "sample code for checking resource location",
      "tail_type": "useSampleCode"
    },
    {
      "head": "interpretation of URL and classpath",
      "head_type": "relatedConceptInterpretation",
      "relation": "have",
      "tail": "design principle of URL checking",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "design principle of URL checking",
      "head_type": "designPrincipleInterpretation",
      "relation": "have",
      "tail": "sample code for checking resource location",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ResourceUtils#toURI(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "URI creation",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ResourceUtils#toURI(String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "Valid URI format",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ResourceUtils#toURI(String)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "Location string conversion",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ResourceUtils#toURI(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "URI instance creation example",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ResourceUtils#toURI(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "URI encoding explanation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ResourceUtils#toURI(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "Design principles for URI encoding",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "URI instance creation example",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "tail": "org.springframework.util.ResourceUtils#toURI(String)",
      "tail_type": "method"
    },
    {
      "head": "URI encoding explanation",
      "head_type": "relatedConceptInterpretation",
      "relation": "associated_with",
      "tail": "org.springframework.util.ResourceUtils#toURI(String)",
      "tail_type": "method"
    },
    {
      "head": "Design principles for URI encoding",
      "head_type": "designPrincipleInterpretation",
      "relation": "associated_with",
      "tail": "org.springframework.util.ResourceUtils#toURI(String)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.Route",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "parsed representation of a route",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.Route",
      "head_type": "class",
      "relation": "have",
      "tail": "The original route value",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.SingleToMultiValueMapAdapter#isEmpty()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "checkEmptiness",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.SingleToMultiValueMapAdapter#isEmpty()",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.SingleToMultiValueMapAdapter#isEmpty()",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.SingleToMultiValueMapAdapter#isEmpty()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.SingleToMultiValueMapAdapter",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.SingleToMultiValueMapAdapter#remove(Object)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "remove a key-value pair from the map",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.SingleToMultiValueMapAdapter#remove(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "public List<V> remove(Object key) { V result = this.targetMap.remove(key); return (result != null) ? Collections.singletonList(result) : null; }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.SingleToMultiValueMapAdapter#remove(Object)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.SingleToMultiValueMapAdapter",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.StopWatch#getId()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getId",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StopWatch#getId()",
      "head_type": "method",
      "relation": "have",
      "tail": "getId returns the id of this StopWatch",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.StopWatch#getId()",
      "head_type": "method",
      "relation": "have",
      "tail": "getId is used to retrieve the id of the StopWatch",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.StopWatch#getId()",
      "head_type": "method",
      "relation": "have",
      "tail": "getId follows the principle of encapsulation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.StopWatch#getId()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.StopWatch",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.StopWatch#prettyPrint(TimeUnit)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "generate a table describing tasks",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StopWatch#prettyPrint(TimeUnit)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "time unit must be specified",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.StopWatch#prettyPrint(TimeUnit)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "custom reporting",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.StopWatch#prettyPrint(TimeUnit)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for prettyPrint",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.StopWatch#prettyPrint(TimeUnit)",
      "head_type": "method",
      "relation": "have",
      "tail": "StopWatch used for timing tasks",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.StopWatch#prettyPrint(TimeUnit)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle of StopWatch",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.StopWatch#prettyPrint(TimeUnit)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "TaskInfo",
      "tail_type": "class"
    },
    {
      "head": "generate a table describing tasks",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "sample code for prettyPrint",
      "tail_type": "useSampleCode"
    },
    {
      "head": "generate a table describing tasks",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "StopWatch used for timing tasks",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "generate a table describing tasks",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "design principle of StopWatch",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.unit.DataSize#of(long,DataUnit)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "representing an amount in the specified DataUnit",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.unit.DataSize#of(long,DataUnit)",
      "head_type": "method",
      "relation": "have",
      "tail": "Obtain a DataSize representing an amount in the specified DataUnit",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.unit.DataSize#of(long,DataUnit)",
      "head_type": "method",
      "relation": "have",
      "tail": "The method returns a corresponding DataSize object representing the specified amount in the given DataUnit.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.unit.DataSize#of(long,DataUnit)",
      "head_type": "method",
      "relation": "have",
      "tail": "The method ensures that the unit is not null and calculates the size in bytes using the unit's size.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.unit.DataSize#of(long,DataUnit)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "DataSize",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.unit.DataSize#of(long,DataUnit)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "DataUnit",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#hashCode()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "calculateHashCode",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#hashCode()",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.UnmodifiableMultiValueMap#hashCode()",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#hashCode()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.UnmodifiableMultiValueMap",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySet#filterArray(Object[])",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "filterArray",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySet#filterArray(Object[])",
      "head_type": "method",
      "relation": "have",
      "tail": "filterArraySampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "filterArraySampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "Complete filterArray Example",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntry#getValue()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "unmodifiableListRetrieval",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntry#getValue()",
      "head_type": "method",
      "relation": "have",
      "tail": "This method returns an unmodifiable view of the specified list.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntry#getValue()",
      "head_type": "method",
      "relation": "have",
      "tail": "public List<V> getValue() {\n    return Collections.unmodifiableList(this.delegate.getValue());\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "unmodifiableListRetrieval",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "The returned list cannot be structurally modified.",
      "tail_type": "useConstraint"
    },
    {
      "head": "unmodifiableListRetrieval",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "Retrieving a read-only view of a list.",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueSpliterator#characteristics()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "characteristics",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueSpliterator#characteristics()",
      "head_type": "method",
      "relation": "have",
      "tail": "characteristics() method delegate call",
      "tail_type": "useSampleCode"
    },
    {
      "head": "characteristics() method delegate call",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "tail": "org.springframework.util.UnmodifiableValueSpliterator",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueSpliterator#characteristics()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.UnmodifiableValueSpliterator",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLReader#setContentHandler(ContentHandler)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "setContentHandler",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLReader#setContentHandler(ContentHandler)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "ContentHandler",
      "tail_type": "class"
    },
    {
      "head": "setContentHandler",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "setContentHandler",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "setContentHandler",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLReader#getProperty(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getProperty",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLReader#getProperty(String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "SAXNotRecognizedException",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLReader#getProperty(String)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "lexical handler",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLReader#getProperty(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "http://xml.org/sax/properties/lexical-handler",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLReader#getProperty(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLReader#getProperty(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLReader",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.AbstractXMLReader#getProperty(String)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLStreamReader#isStartElement()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "check if the current event is a start element",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLStreamReader#isStartElement()",
      "head_type": "method",
      "relation": "have",
      "tail": "getEventType() == XMLStreamConstants.START_ELEMENT",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLStreamReader#isStartElement()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.AbstractXMLStreamReader",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLStreamReader",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "parse XML start element",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLStreamReader",
      "head_type": "class",
      "relation": "have",
      "tail": "This class is designed to extend XMLStreamReader and provide additional functionalities.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLStreamReader",
      "head_type": "class",
      "relation": "have",
      "tail": "The class follows the principle of extending existing standards to provide additional utility functions.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLStreamReader#isCharacters()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "check if the current event is characters",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLStreamReader#isCharacters()",
      "head_type": "method",
      "relation": "have",
      "tail": "getEventType() == XMLStreamConstants.CHARACTERS",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLStreamReader#isCharacters()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.AbstractXMLStreamReader",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLStreamReader#isCharacters()",
      "head_type": "method",
      "relation": "have",
      "tail": "This method checks if the current event being processed by the XML stream reader is of type CHARACTERS.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLStreamReader#isCharacters()",
      "head_type": "method",
      "relation": "have",
      "tail": "This method utilizes the getEventType() method to determine the type of the current event and compares it with XMLStreamConstants.CHARACTERS to decide if it is a characters event.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.SimpleNamespaceContext#getNamespaceURI(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getNamespaceURI",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.SimpleNamespaceContext#getNamespaceURI(String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "prefixNotNull",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.xml.SimpleNamespaceContext#getNamespaceURI(String)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "xmlNamespaceRetrieval",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.xml.SimpleNamespaceContext#getNamespaceURI(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "xmlNamespaceRetrievalSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.SimpleNamespaceContext#getNamespaceURI(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "xmlNamespaceRetrievalConcept",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.SimpleNamespaceContext#getNamespaceURI(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleForGetNamespaceURI",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.SimpleNamespaceContext#getNamespaceURI(String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.SimpleNamespaceContext",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.StaxResult#getXMLEventWriter()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "apiFunction",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxResult#getXMLEventWriter()",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.StaxResult#getXMLEventWriter()",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxResult#getXMLEventWriter()",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "apiFunction",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "useConstraint",
      "tail_type": "useConstraint"
    },
    {
      "head": "apiFunction",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "useScenario",
      "tail_type": "useScenario"
    },
    {
      "head": "apiFunction",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "class",
      "tail_type": "class"
    },
    {
      "head": "class",
      "head_type": "class",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "class",
      "head_type": "class",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "class",
      "head_type": "class",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamHandler#charactersInternal(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "writeCharacters",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamHandler#charactersInternal(String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.StaxStreamHandler",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamHandler#charactersInternal(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils#getXMLStreamWriter(Result)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "get XMLStreamWriter from StAX Result",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils#getXMLStreamWriter(Result)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "IllegalArgumentException if result is not a JAXP 1.4 StAXResult or custom StAX Result",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils#getXMLStreamWriter(Result)",
      "head_type": "method",
      "relation": "have",
      "tail": "get XMLStreamWriter from StAX Result sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils#getXMLStreamWriter(Result)",
      "head_type": "method",
      "relation": "have",
      "tail": "StAXResult and StaxResult explanation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils#getXMLStreamWriter(Result)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle for handling different StAX Result types",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.StaxUtils#getXMLStreamWriter(Result)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamReader#standaloneSet()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "check if the current XML event is a start document and return standalone status",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamReader#standaloneSet()",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "method must be called when the event is a start document",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamReader#standaloneSet()",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "relatedConceptInterpretation",
      "head_type": "relatedConceptInterpretation",
      "relation": "associated_with",
      "tail": "StartDocument",
      "tail_type": "class"
    },
    {
      "head": "relatedConceptInterpretation",
      "head_type": "relatedConceptInterpretation",
      "relation": "associated_with",
      "tail": "IllegalStateException",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamReader#standaloneSet()",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "designPrincipleInterpretation",
      "head_type": "designPrincipleInterpretation",
      "relation": "associated_with",
      "tail": "error handling",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamReader#standaloneSet()",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamReader",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getNamespaceContext()",
      "tail_type": "apiFunction"
    },
    {
      "head": "getNamespaceContext()",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "NamespaceContext retrieval",
      "tail_type": "useScenario"
    },
    {
      "head": "getNamespaceContext()",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "XML event stream processing",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "getNamespaceContext()",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "Handling different XML event types",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "getNamespaceContext()",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "Complete example of using getNamespaceContext()",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter#writeStartDocument(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "writeStartDocument",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter#writeStartDocument(String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.XMLEventStreamWriter",
      "tail_type": "class"
    },
    {
      "head": "writeStartDocument",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "writeStartDocument",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "writeStartDocument",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "example.type.SomeNonCandidateClass",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "unknownFunctionality",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#isAccessibleWhenProtectedVisibilityInDifferentPackage()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "Access Control Test",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#isAccessibleWhenProtectedVisibilityInDifferentPackage()",
      "head_type": "method",
      "relation": "have",
      "tail": "Sample Code for Access Control Test",
      "tail_type": "useSampleCode"
    },
    {
      "head": "Sample Code for Access Control Test",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "Complete Example for Access Control Test",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#isAccessibleWhenPrivateVisibilityInDifferentPackage()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "Access Control",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#isAccessibleWhenPrivateVisibilityInDifferentPackage()",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.aot.generate.AccessControlTests",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.AccessControl",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#isAccessibleWhenPrivateVisibilityInDifferentPackage()",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#isAccessibleWhenPrivateVisibilityInDifferentPackage()",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#isAccessibleWhenPrivateVisibilityInDifferentPackage()",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#createMethodReference(String,TypeName[],ClassName)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "createMethodReference",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#createMethodReference(String,TypeName[],ClassName)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "DefaultMethodReferenceTests",
      "tail_type": "class"
    },
    {
      "head": "createMethodReference",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "createMethodReferenceSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "createMethodReferenceSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "createMethodReferenceSampleCodeContent",
      "tail_type": "useSampleCodeContent"
    },
    {
      "head": "org.springframework.aot.generate.FileSystemGeneratedFilesTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "addFilesCopiesToFileSystem",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.FileSystemGeneratedFilesTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "addFilesWithCustomRootsCopiesToFileSystem",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.FileSystemGeneratedFilesTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "createWhenRootIsNullThrowsException",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.FileSystemGeneratedFilesTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "createWhenRootsIsNullThrowsException",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.FileSystemGeneratedFilesTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "createWhenRootsResultsInNullThrowsException",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.FileSystemGeneratedFilesTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "addFileWhenPathIsOutsideOfRootThrowsException",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.FileSystemGeneratedFilesTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "addFileWhenFileAlreadyAddedThrowsException",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.FileSystemGeneratedFilesTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "handleFileWhenFileExistsProvidesFileHandler",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.FileSystemGeneratedFilesTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "handleFileWhenFileExistsFailsToCreate",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.FileSystemGeneratedFilesTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "handleFileWhenFileExistsCanOverrideContent",
      "tail_type": "apiFunction"
    },
    {
      "head": "addFilesCopiesToFileSystem",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "addSourceFile",
      "tail_type": "useScenario"
    },
    {
      "head": "addFilesCopiesToFileSystem",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "addResourceFile",
      "tail_type": "useScenario"
    },
    {
      "head": "addFilesCopiesToFileSystem",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "addClassFile",
      "tail_type": "useScenario"
    },
    {
      "head": "addFilesWithCustomRootsCopiesToFileSystem",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "addSourceFile",
      "tail_type": "useScenario"
    },
    {
      "head": "addFilesWithCustomRootsCopiesToFileSystem",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "addResourceFile",
      "tail_type": "useScenario"
    },
    {
      "head": "addFilesWithCustomRootsCopiesToFileSystem",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "addClassFile",
      "tail_type": "useScenario"
    },
    {
      "head": "createWhenRootIsNullThrowsException",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "rootMustNotBeNull",
      "tail_type": "useConstraint"
    },
    {
      "head": "createWhenRootsIsNullThrowsException",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "rootsMustNotBeNull",
      "tail_type": "useConstraint"
    },
    {
      "head": "createWhenRootsResultsInNullThrowsException",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "rootsMustReturnAValueForAllFileKinds",
      "tail_type": "useConstraint"
    },
    {
      "head": "addFileWhenPathIsOutsideOfRootThrowsException",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "pathMustBeRelative",
      "tail_type": "useConstraint"
    },
    {
      "head": "addFileWhenFileAlreadyAddedThrowsException",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "fileAlreadyExists",
      "tail_type": "useConstraint"
    },
    {
      "head": "handleFileWhenFileExistsProvidesFileHandler",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "handleFile",
      "tail_type": "useScenario"
    },
    {
      "head": "handleFileWhenFileExistsFailsToCreate",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "fileAlreadyExists",
      "tail_type": "useConstraint"
    },
    {
      "head": "handleFileWhenFileExistsCanOverrideContent",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "overrideContent",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.aot.generate.FileSystemGeneratedFilesTests",
      "head_type": "class",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.FileSystemGeneratedFilesTests",
      "head_type": "class",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.FileSystemGeneratedFilesTests",
      "head_type": "class",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassesTests#addForFeatureComponentUsesTarget()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "addForFeatureComponent",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassesTests#addForFeatureComponentUsesTarget()",
      "head_type": "method",
      "relation": "have",
      "tail": "GeneratedClass",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassesTests#addForFeatureComponentUsesTarget()",
      "head_type": "method",
      "relation": "have",
      "tail": "GeneratedClassesTests",
      "tail_type": "class"
    },
    {
      "head": "addForFeatureComponent",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "GeneratedClassesTests",
      "tail_type": "class"
    },
    {
      "head": "addForFeatureComponent",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "GeneratedClass",
      "tail_type": "class"
    },
    {
      "head": "addForFeatureComponent",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "TestComponent",
      "tail_type": "class"
    },
    {
      "head": "addForFeatureComponent",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "emptyTypeCustomizer",
      "tail_type": "class"
    },
    {
      "head": "addForFeatureComponent",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "assertThat(generatedClass.getName().toString()).endsWith(\"TestComponent__Test\")",
      "tail_type": "useSampleCode"
    },
    {
      "head": "addForFeatureComponent",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "GeneratedClass generatedClass = this.generatedClasses.addForFeatureComponent(\"Test\", TestComponent.class, emptyTypeCustomizer);",
      "tail_type": "useSampleCode"
    },
    {
      "head": "addForFeatureComponent",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "GeneratedClass generatedClass = this.generatedClasses.addForFeatureComponent(\"Test\", TestComponent.class, emptyTypeCustomizer); assertThat(generatedClass.getName().toString()).endsWith(\"TestComponent__Test\");",
      "tail_type": "useSampleCode"
    },
    {
      "head": "addForFeatureComponent",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "package com.example; import org.springframework.aot.generate.GeneratedClasses; import org.springframework.aot.generate.GeneratedClass; public class TestClass { public static void main(String[] args) { GeneratedClasses generatedClasses = new GeneratedClasses(); GeneratedClass generatedClass = generatedClasses.addForFeatureComponent(\"Test\", TestComponent.class, emptyTypeCustomizer); System.out.println(generatedClass.getName()); } }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "addForFeatureComponent",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "This method is used to add a feature component to the generated classes.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "addForFeatureComponent",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "The method follows the principle of modularity and reusability.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassesTests#getOrAddForFeatureComponentWhenHasFeatureNamePrefix()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getOrAddForFeatureComponent",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassesTests#getOrAddForFeatureComponentWhenHasFeatureNamePrefix()",
      "head_type": "method",
      "relation": "have",
      "tail": "prefix",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassesTests#getOrAddForFeatureComponentWhenHasFeatureNamePrefix()",
      "head_type": "method",
      "relation": "have",
      "tail": "GeneratedClasses",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassesTests#getOrAddForFeatureComponentWhenHasFeatureNamePrefix()",
      "head_type": "method",
      "relation": "have",
      "tail": "GeneratedClass",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassesTests#getOrAddForFeatureComponentWhenHasFeatureNamePrefix()",
      "head_type": "method",
      "relation": "have",
      "tail": "TestComponent",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassesTests#getOrAddForFeatureComponentWhenHasFeatureNamePrefix()",
      "head_type": "method",
      "relation": "have",
      "tail": "emptyTypeCustomizer",
      "tail_type": "useScenario"
    },
    {
      "head": "getOrAddForFeatureComponent",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "prefix",
      "tail_type": "useConstraint"
    },
    {
      "head": "getOrAddForFeatureComponent",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "prefix",
      "tail_type": "useScenario"
    },
    {
      "head": "getOrAddForFeatureComponent",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "GeneratedClasses",
      "tail_type": "class"
    },
    {
      "head": "getOrAddForFeatureComponent",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "GeneratedClass",
      "tail_type": "class"
    },
    {
      "head": "getOrAddForFeatureComponent",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "TestComponent",
      "tail_type": "class"
    },
    {
      "head": "getOrAddForFeatureComponent",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "emptyTypeCustomizer",
      "tail_type": "useScenario"
    },
    {
      "head": "getOrAddForFeatureComponent",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "getOrAddForFeatureComponent",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "getOrAddForFeatureComponent",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "prefix",
      "head_type": "useScenario",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "prefix",
      "head_type": "useScenario",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "prefix",
      "head_type": "useScenario",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "emptyTypeCustomizer",
      "head_type": "useScenario",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "emptyTypeCustomizer",
      "head_type": "useScenario",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "emptyTypeCustomizer",
      "head_type": "useScenario",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "GeneratedClasses",
      "head_type": "class",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "GeneratedClasses",
      "head_type": "class",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "GeneratedClass",
      "head_type": "class",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "GeneratedClass",
      "head_type": "class",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "TestComponent",
      "head_type": "class",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "TestComponent",
      "head_type": "class",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getOrAddWhenRepeatReturnsSameGeneratedClass",
      "tail_type": "apiFunction"
    },
    {
      "head": "getOrAddWhenRepeatReturnsSameGeneratedClass",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "getOrAddWhenRepeatReturnsSameGeneratedClass() Sample Code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "getOrAddWhenRepeatReturnsSameGeneratedClass() Sample Code",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "Complete Example Code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests#addSourceFileWithConsumedAppendableAddsFile()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "addSourceFileWithConsumedAppendableAddsFile",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests#addSourceFileWithConsumedAppendableAddsFile()",
      "head_type": "method",
      "relation": "have",
      "tail": "addSourceFileWithConsumedAppendableAddsFile useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "addSourceFileWithConsumedAppendableAddsFile useSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "package com.example;\n\nimport org.springframework.aot.generate.GeneratedFiles;\n\npublic class HelloWorld {\n    public static void main(String[] args) {\n        GeneratedFiles generatedFiles = new GeneratedFiles();\n        generatedFiles.addSourceFile(\"com.example.HelloWorld\", appendable -> appendable.append(\";\"));\n    }\n}",
      "tail_type": "String"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests#addResourceFileWithConsumedAppendableAddsFile()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "addResourceFile",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests#addResourceFileWithConsumedAppendableAddsFile()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "assertThatFileAdded",
      "tail_type": "apiFunction"
    },
    {
      "head": "addResourceFile",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "addResourceFileWithConsumedAppendableAddsFile-SampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "assertThatFileAdded",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "assertThatFileAdded-SampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "addResourceFileWithConsumedAppendableAddsFile-SampleCode",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.GeneratedFilesTests#addResourceFileWithConsumedAppendableAddsFile()",
      "tail_type": "method"
    },
    {
      "head": "assertThatFileAdded-SampleCode",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.GeneratedFilesTests#addResourceFileWithConsumedAppendableAddsFile()",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests#addResourceFileWithConsumedAppendableAddsFile()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.GeneratedFilesTests",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests",
      "head_type": "class",
      "relation": "have",
      "tail": "GeneratedFilesTests-RelatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests",
      "head_type": "class",
      "relation": "have",
      "tail": "GeneratedFilesTests-DesignPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.ValueCodeGeneratorTests#writeCode(CodeBlock)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "generateJavaCode",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.ValueCodeGeneratorTests#writeCode(CodeBlock)",
      "head_type": "method",
      "relation": "have",
      "tail": "generateJavaCodeSample",
      "tail_type": "useSampleCode"
    },
    {
      "head": "generateJavaCodeSample",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "private static String writeCode(CodeBlock valueCode) {\n    FieldSpec field = FieldSpec.builder(Object.class, \"value\").initializer(valueCode).build();\n    TypeSpec helloWorld = TypeSpec.classBuilder(\"Test\").addField(field).build();\n    JavaFile javaFile = JavaFile.builder(\"com.example\", helloWorld).build();\n    StringWriter out = new StringWriter();\n    try {\n        javaFile.writeTo(out);\n    } catch (IOException ex) {\n        throw new IllegalStateException(ex);\n    }\n    return out.toString();\n}",
      "tail_type": "code"
    },
    {
      "head": "org.springframework.aot.generate.ValueCodeGeneratorTests#writeCode(CodeBlock)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.ValueCodeGeneratorTests",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.ValueCodeGeneratorTests",
      "head_type": "class",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "relatedConceptInterpretation",
      "head_type": "relatedConceptInterpretation",
      "relation": "have",
      "tail": "The method `writeCode` is used to generate Java code dynamically using the `CodeBlock` provided. It constructs a `FieldSpec`, a `TypeSpec`, and a `JavaFile` to represent the structure of the Java code being generated. The generated code is then written to a `StringWriter` and returned as a string.",
      "tail_type": "description"
    },
    {
      "head": "org.springframework.aot.generate.ValueCodeGeneratorTests",
      "head_type": "class",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "designPrincipleInterpretation",
      "head_type": "designPrincipleInterpretation",
      "relation": "have",
      "tail": "The design principle behind the `ValueCodeGeneratorTests` class and the `writeCode` method is to facilitate the dynamic generation of Java code. This is achieved by using a fluent API provided by the JavaPoet library, which allows for programmatic creation and manipulation of Java source files. The method follows the principle of modularity and separation of concerns by encapsulating the code generation logic within a single method that can be easily tested and reused.",
      "tail_type": "description"
    },
    {
      "head": "org.springframework.aot.hint.annotation.SampleClassWithGetter",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getName",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.hint.annotation.SampleClassWithGetter",
      "head_type": "class",
      "relation": "have",
      "tail": "public String getName() { return \"test\"; }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.core.type.StandardAnnotationMetadata#isAnnotatedMethod(Method,String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "check if a method is annotated with a specific annotation",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.core.type.StandardAnnotationMetadata#isAnnotatedMethod(Method,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for checking method annotation",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.core.type.StandardAnnotationMetadata#isAnnotatedMethod(Method,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "interpretation of method annotation checking",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.core.type.StandardAnnotationMetadata#isAnnotatedMethod(Method,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle behind method annotation checking",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.core.type.StandardAnnotationMetadata#isAnnotatedMethod(Method,String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.core.type.StandardAnnotationMetadata",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.objenesis.SpringObjenesis#isWorthTrying()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "Objenesis instance evaluation",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.objenesis(SpringObjenesis",
      "head_type": "class",
      "relation": "have",
      "tail": "Objenesis instantiator strategy",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.objenesis(SpringObjenesis",
      "head_type": "class",
      "relation": "have",
      "tail": "Objenesis instance creation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.objenesis(SpringObjenesis",
      "head_type": "class",
      "relation": "have",
      "tail": "Objenesis instance worth trying",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#match(String,String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "pattern matching",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#match(String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is used to determine if a given path matches a specified pattern. It is commonly used in routing and URL mapping scenarios where you need to check if a path conforms to a certain pattern.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#match(String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "package com.example.demo;\n\nimport org.springframework.util.AntPathMatcher;\n\npublic class PatternMatchingExample {\n    public static void main(String[] args) {\n        AntPathMatcher matcher = new AntPathMatcher();\n        String pattern = \"/users/**\";\n        String path = \"/users/123\";\n        boolean isMatch = matcher.match(pattern, path);\n        System.out.println(\"Does the path match the pattern? \" + isMatch);\n    }\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#match(String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "The design principle behind this method is to provide a flexible and efficient way to match patterns against strings, particularly useful in web applications for URL routing and request mapping.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.AntPathStringMatcher#quote(String,int,int)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "quote a substring of a string for regex",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.AntPathStringMatcher#quote(String,int,int)",
      "head_type": "method",
      "relation": "have",
      "tail": "quote a substring of a string for regex",
      "tail_type": "useSampleCode"
    },
    {
      "head": "quote a substring of a string for regex",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "private String quote(String s, int start, int end) {\n    if (start == end) {\n        return \"\";\n    }\n    return Pattern.quote(s.substring(start, end));\n}",
      "tail_type": "code"
    },
    {
      "head": "org.springframework.util.Assert#state(boolean,String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "assert boolean expression",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.Assert#state(boolean,String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "expression evaluates to false",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.Assert#state(boolean,String)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "initialization check",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.Assert#state(boolean,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for assertion",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.Assert#state(boolean,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "related concept interpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.Assert#state(boolean,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle interpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.Assert#state(boolean,String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.Assert",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.Assert#doesNotContain(String,String,Supplier<String>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "assertDoesNotContain",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.Assert#doesNotContain(String,String,Supplier<String>)",
      "head_type": "method",
      "relation": "have",
      "tail": "assertDoesNotContainSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "assertDoesNotContainSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "assertDoesNotContainSampleCodeContent",
      "tail_type": "useSampleCodeContent"
    },
    {
      "head": "org.springframework.util.Assert#doesNotContain(String,String,Supplier<String>)",
      "head_type": "method",
      "relation": "have",
      "tail": "assertDoesNotContainRelatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "assertDoesNotContainRelatedConceptInterpretation",
      "head_type": "relatedConceptInterpretation",
      "relation": "have",
      "tail": "assertDoesNotContainRelatedConceptInterpretationContent",
      "tail_type": "relatedConceptInterpretationContent"
    },
    {
      "head": "org.springframework.util.Assert#doesNotContain(String,String,Supplier<String>)",
      "head_type": "method",
      "relation": "have",
      "tail": "assertDoesNotContainDesignPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "assertDoesNotContainDesignPrincipleInterpretation",
      "head_type": "designPrincipleInterpretation",
      "relation": "have",
      "tail": "assertDoesNotContainDesignPrincipleInterpretationContent",
      "tail_type": "designPrincipleInterpretationContent"
    },
    {
      "head": "org.springframework.util.backoff.ExponentialBackOff#setMaxAttempts(int)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "set maximum number of attempts",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.backoff.ExponentialBackOff#setMaxAttempts(int)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "maxAttempts must be greater than 0",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.backoff.ExponentialBackOff#setMaxAttempts(int)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "retry operations",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.backoff.ExponentialBackOff#setMaxAttempts(int)",
      "head_type": "method",
      "relation": "have",
      "tail": "public void setMaxAttempts(int maxAttempts) { this.maxAttempts = maxAttempts; }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.backoff.ExponentialBackOff#setMaxAttempts(int)",
      "head_type": "method",
      "relation": "have",
      "tail": "related to BackOffExecution",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.backoff.ExponentialBackOff#setMaxAttempts(int)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle of setting maximum attempts",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.backoff.ExponentialBackOff#setMaxAttempts(int)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.backoff.BackOffExecution",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.backoff.ExponentialBackOffExecution",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "exponential backoff",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.backoff.ExponentialBackOffExecution",
      "head_type": "class",
      "relation": "have",
      "tail": "calculate next backoff interval",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.backoff.ExponentialBackOffExecution",
      "head_type": "class",
      "relation": "have",
      "tail": "handle maximum attempts and elapsed time",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.backoff.ExponentialBackOffExecution",
      "head_type": "class",
      "relation": "have",
      "tail": "toString representation",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.backoff.ExponentialBackOffExecution",
      "head_type": "class",
      "relation": "have",
      "tail": "backoff interval calculation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.backoff.ExponentialBackOffExecution",
      "head_type": "class",
      "relation": "have",
      "tail": "design principles for exponential backoff",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.backoff.ExponentialBackOffExecution",
      "head_type": "class",
      "relation": "have",
      "tail": "sample code for exponential backoff",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.backoff.FixedBackOff#getMaxAttempts()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "get maximum number of attempts",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.backoff.FixedBackOff#getMaxAttempts()",
      "head_type": "method",
      "relation": "have",
      "tail": "Return the maximum number of attempts in milliseconds.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.backoff.FixedBackOff",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.backoff.FixedBackOff#getMaxAttempts()",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.ClassUtils#isCacheSafe(Class<?>,ClassLoader)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "cache-safe check",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ClassUtils#isCacheSafe(Class<?>,ClassLoader)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "class must not be null",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ClassUtils#isCacheSafe(Class<?>,ClassLoader)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "class loaded by given ClassLoader or its parent",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ClassUtils#isCacheSafe(Class<?>,ClassLoader)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for cache-safe check",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ClassUtils#isCacheSafe(Class<?>,ClassLoader)",
      "head_type": "method",
      "relation": "have",
      "tail": "interpretation of cache-safe concept",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#isCacheSafe(Class<?>,ClassLoader)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle of cache-safe check",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#isCacheSafe(Class<?>,ClassLoader)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.ClassUtils",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.ClassUtils#getAllInterfacesForClass(Class<?>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getAllInterfacesForClass",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ClassUtils#getAllInterfacesForClass(Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "Return all interfaces that the given class implements as an array, including ones implemented by superclasses.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#getAllInterfacesForClass(Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "If the class itself is an interface, it gets returned as sole interface.",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ClassUtils#getAllInterfacesForClass(Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "package com.example.util; import java.lang.Class; public class InterfaceExample { public static void main(String[] args) { Class<?> clazz = InterfaceExample.class; Class<?>[] interfaces = org.springframework.util.ClassUtils.getAllInterfacesForClass(clazz); for (Class<?> iface : interfaces) { System.out.println(iface.getName()); } } }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ClassUtils#getAllInterfacesForClass(Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is designed to retrieve all interfaces implemented by a given class, including those implemented by its superclasses. It is useful for analyzing class hierarchies and understanding the complete set of interfaces that a class conforms to.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#isCglibProxyClass(Class<?>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "Check whether the specified class is a CGLIB-generated class",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ClassUtils#isCglibProxyClass(Class<?>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "deprecated as of 5.2",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ClassUtils#isCglibProxyClass(Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "Check whether the specified class is a CGLIB-generated class",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#isCglibProxyClass(Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is used to determine if a given class is a CGLIB-generated class. It checks if the class name contains the CGLIB_CLASS_SEPARATOR. This is useful in scenarios where you need to identify dynamically generated classes, such as in AOP (Aspect-Oriented Programming) frameworks.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#isCglibProxyClass(Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "public static boolean isCglibProxyClass(@Nullable Class<?> clazz) {\n    return (clazz != null && isCglibProxyClassName(clazz.getName()));\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ClassUtils#isCglibProxyClass(Class<?>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.ClassUtils",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.CollectionUtils#compositeMap(Map<K,V>,Map<K,V>,BiFunction<K,V,V>,Consumer<Map<K,V>>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "compositeMap",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.CollectionUtils#compositeMap(Map<K,V>,Map<K,V>,BiFunction<K,V,V>,Consumer<Map<K,V>>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "putFunction must be provided for Map::put",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.CollectionUtils#compositeMap(Map<K,V>,Map<K,V>,BiFunction<K,V,V>,Consumer<Map<K,V>>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "putAllFunction must be provided for Map::putAll",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.CollectionUtils#compositeMap(Map<K,V>,Map<K,V>,BiFunction<K,V,V>,Consumer<Map<K,V>>)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "combining two maps with precedence to the first map",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.CollectionUtils#compositeMap(Map<K,V>,Map<K,V>,BiFunction<K,V,V>,Consumer<Map<K,V>>)",
      "head_type": "method",
      "relation": "have",
      "tail": "Return a map that combines the provided maps. Invoking\n\t * {@link Map#put(Object, Object)} on the returned map will apply\n\t * {@code putFunction}, or will throw an\n\t * {@link UnsupportedOperationException} {@code putFunction} is\n\t * {@code null}. The same applies to {@link Map#putAll(Map)} and\n\t * {@code putAllFunction}.\n\t * <p>In the case of a key collision, {@code first} takes precedence over\n\t * {@code second}. In other words, entries in {@code second} with a key\n\t * that is also mapped by {@code first} are effectively ignored.\n\t * @param first the first map to compose\n\t * @param second the second map to compose\n\t * @param putFunction applied when {@code Map::put} is invoked. If\n\t * {@code null}, {@code Map::put} throws an\n\t * {@link UnsupportedOperationException}.\n\t * @param putAllFunction applied when {@code Map::putAll} is invoked. If\n\t * {@code null}, {@code Map::putAll} throws an\n\t * {@link UnsupportedOperationException}.\n\t * @return a new map that composes the give maps\n\t * @since 6.2\n\t ",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.CollectionUtils#compositeMap(Map<K,V>,Map<K,V>,BiFunction<K,V,V>,Consumer<Map<K,V>>)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is used to combine two maps into one, where the first map takes precedence over the second in case of key collisions. The putFunction and putAllFunction parameters define the behavior when adding new elements to the combined map.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.CollectionUtils#compositeMap(Map<K,V>,Map<K,V>,BiFunction<K,V,V>,Consumer<Map<K,V>>)",
      "head_type": "method",
      "relation": "have",
      "tail": "The design principle behind this method is to provide a flexible way to merge maps, allowing the user to define custom behavior for handling key collisions and updates. This promotes code reuse and reduces the need for boilerplate code when dealing with map compositions.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.comparator.BooleanComparator#hashCode()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "hash code generation",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.comparator.BooleanComparator#hashCode()",
      "head_type": "method",
      "relation": "have",
      "tail": "Generates hash code for a boolean value",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.comparator.BooleanComparator#hashCode()",
      "head_type": "method",
      "relation": "have",
      "tail": "Utilizes Boolean.hashCode() method",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.comparator.BooleanComparator#hashCode()",
      "head_type": "method",
      "relation": "have",
      "tail": "Implements hashCode method from Object class",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.concurrent.FutureUtils#toSupplier(Callable<T>,CompletableFuture<T>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "converts a Callable to a Supplier",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.concurrent.FutureUtils#toSupplier(Callable<T>,CompletableFuture<T>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "Callable must not throw checked exceptions",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.concurrent.FutureUtils#toSupplier(Callable<T>,CompletableFuture<T>)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "asynchronous computations",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.concurrent.FutureUtils#toSupplier(Callable<T>,CompletableFuture<T>)",
      "head_type": "method",
      "relation": "have",
      "tail": "private static <T> Supplier<T> toSupplier(Callable<T> callable, CompletableFuture<T> result) {\n    return () -> {\n        try {\n            return callable.call();\n        } catch (Exception ex) {\n            // wrap the exception just like CompletableFuture::supplyAsync does\n            result.completeExceptionally((ex instanceof CompletionException) ? ex : new CompletionException(ex));\n            return null;\n        }\n    };\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.concurrent.FutureUtils#toSupplier(Callable<T>,CompletableFuture<T>)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is used to convert a Callable to a Supplier, which can then be used in asynchronous computations.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.concurrent.FutureUtils#toSupplier(Callable<T>,CompletableFuture<T>)",
      "head_type": "method",
      "relation": "have",
      "tail": "The design principle behind this method is to provide a bridge between synchronous and asynchronous code execution, allowing for more flexible and efficient programming models.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.concurrent.FutureUtils#toSupplier(Callable<T>,CompletableFuture<T>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.concurrent.FutureUtils",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.EvictionQueue",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "poll",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.EvictionQueue",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "add",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.EvictionQueue",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "contains",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.EvictionQueue",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "linkLast",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.EvictionQueue",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "unlink",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.EvictionQueue",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "moveToBack",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.EvictionQueue",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "remove",
      "tail_type": "apiFunction"
    },
    {
      "head": "poll",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "add",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "contains",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "linkLast",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "unlink",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "moveToBack",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "remove",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.EvictionQueue",
      "head_type": "class",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.EvictionQueue",
      "head_type": "class",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.EvictionQueue#moveToBack(Node<K,V>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "move element to back of queue",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.EvictionQueue#moveToBack(Node<K,V>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "element must be in queue and not be the last element",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.EvictionQueue#moveToBack(Node<K,V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "void moveToBack(Node<K, V> e) {\n    if (contains(e) && e != this.last) {\n        unlink(e);\n        linkLast(e);\n    }\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.EvictionQueue#moveToBack(Node<K,V>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.EvictionQueue",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.ConcurrentReferenceHashMap#replace(K,V)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "replace",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ConcurrentReferenceHashMap#replace(K,V)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.ConcurrentReferenceHashMap#replace(K,V)_useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ConcurrentReferenceHashMap#replace(K,V)_useSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "org.springframework.util.ConcurrentReferenceHashMap#replace(K,V)_useSampleCode_content",
      "tail_type": "content"
    },
    {
      "head": "org.springframework.util.Entry#getKey()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "retrieveKey",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.Entry#getKey()",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is used to retrieve the key from a map entry.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.Entry#getKey()",
      "head_type": "method",
      "relation": "have",
      "tail": "The design principle followed here is to provide a simple and direct method to access the key of the map entry.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.Entry#getKey()",
      "head_type": "method",
      "relation": "have",
      "tail": "public K getKey() {\n    return this.key;\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.Task",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "executeTask",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.Task",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "taskWithOption",
      "tail_type": "apiFunction"
    },
    {
      "head": "executeTask",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "taskExecution",
      "tail_type": "useScenario"
    },
    {
      "head": "taskWithOption",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "taskWithOptionScenario",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.Task",
      "head_type": "class",
      "relation": "have",
      "tail": "taskExecution",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.Task",
      "head_type": "class",
      "relation": "have",
      "tail": "taskWithOptionScenario",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.Task",
      "head_type": "class",
      "relation": "have",
      "tail": "taskWithOptionSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.Task",
      "head_type": "class",
      "relation": "have",
      "tail": "executeTaskSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.Task",
      "head_type": "class",
      "relation": "have",
      "tail": "taskDesignPrinciple",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.Task",
      "head_type": "class",
      "relation": "have",
      "tail": "taskRelatedConcept",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ReferenceManager",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "createReference",
      "tail_type": "apiFunction"
    },
    {
      "head": "createReference",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "createReferenceSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "createReference",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "referenceTypeConstraint",
      "tail_type": "useConstraint"
    },
    {
      "head": "createReference",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "garbageCollectionScenario",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ReferenceManager",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "pollForPurge",
      "tail_type": "apiFunction"
    },
    {
      "head": "pollForPurge",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "pollForPurgeSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "pollForPurge",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "threadSafetyConstraint",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ReferenceManager",
      "head_type": "class",
      "relation": "have",
      "tail": "referenceManagementStrategy",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ReferenceManager",
      "head_type": "class",
      "relation": "have",
      "tail": "designPrinciple",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.FastByteArrayOutputStream#write(int)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "write a single byte to the stream",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.FastByteArrayOutputStream#write(int)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "stream must not be closed",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.FastByteArrayOutputStream#write(int)",
      "head_type": "method",
      "relation": "have",
      "tail": "Stream closed",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.FastByteArrayOutputStream#write(int)",
      "head_type": "method",
      "relation": "have",
      "tail": "IOException is thrown when the stream is closed",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.FastByteArrayOutputStream#write(int)",
      "head_type": "method",
      "relation": "have",
      "tail": "Design principle: Ensure that the stream is open before writing data",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.FastByteArrayOutputStream#write(int)",
      "head_type": "method",
      "relation": "have",
      "tail": "public void write(int datum) throws IOException {\n    if (this.closed) {\n        throw new IOException(\"Stream closed\");\n    }\n    if (this.buffers.peekLast() == null || this.buffers.getLast().length == this.index) {\n        addBuffer(1);\n    }\n    // store the byte\n    this.buffers.getLast()[this.index++] = (byte) datum;\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.LinkedCaseInsensitiveMap#isEmpty()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "check emptiness",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.LinkedCaseInsensitiveMap#isEmpty()",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.LinkedCaseInsensitiveMap",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.LinkedCaseInsensitiveMap#isEmpty()",
      "head_type": "method",
      "relation": "have",
      "tail": "This method checks if the map is empty.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.LinkedCaseInsensitiveMap#isEmpty()",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is overridden to provide case-insensitive behavior.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.LinkedCaseInsensitiveMap#isEmpty()",
      "head_type": "method",
      "relation": "have",
      "tail": "java\nimport java.util.Map;\n\npublic class Main {\n    public static void main(String[] args) {\n        Map<String, String> map = new LinkedCaseInsensitiveMap<>();\n        map.put(\"Key\", \"Value\");\n        boolean isEmpty = map.isEmpty();\n        System.out.println(\"Is map empty? \" + isEmpty);\n    }\n}\n",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.EntrySet#clear()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "clearing delegate and caseInsensitiveKeys",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.EntrySet#clear()",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for clearing delegate and caseInsensitiveKeys",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.EntrySet#clear()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.EntrySet",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.MimeType#includes(MimeType)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "MIME Type Inclusion",
      "tail_type": "apiFunction"
    },
    {
      "head": "MIME Type Inclusion",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "Non-symmetric Comparison",
      "tail_type": "useConstraint"
    },
    {
      "head": "MIME Type Inclusion",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "MIME Type Hierarchy",
      "tail_type": "useScenario"
    },
    {
      "head": "MIME Type Inclusion",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "MIME Type Hierarchy Example",
      "tail_type": "useSampleCode"
    },
    {
      "head": "MIME Type Inclusion",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "MIME Type Hierarchy Explanation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "MIME Type Inclusion",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "Design Principles of MIME Type Inclusion",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.MimeType",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "MIME Type Hierarchy",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MimeTypeUtils",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "parseMimeType",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MimeTypeUtils",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "parseMimeTypes",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MimeTypeUtils",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "tokenize",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MimeTypeUtils",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "toString",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MimeTypeUtils",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "sortBySpecificity",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MimeTypeUtils",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "generateMultipartBoundary",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MimeTypeUtils",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "generateMultipartBoundaryString",
      "tail_type": "apiFunction"
    },
    {
      "head": "parseMimeType",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "InvalidMimeTypeException",
      "tail_type": "useConstraint"
    },
    {
      "head": "parseMimeTypes",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "InvalidMimeTypeException",
      "tail_type": "useConstraint"
    },
    {
      "head": "sortBySpecificity",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "InvalidMimeTypeException",
      "tail_type": "useConstraint"
    },
    {
      "head": "generateMultipartBoundary",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "BOUNDARY_CHARS",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.MimeTypeUtils",
      "head_type": "class",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.MimeTypeUtils",
      "head_type": "class",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.MimeTypeUtils",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "MimeType",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.MimeTypeUtils",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "StringUtils",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.MimeTypeUtils",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "InvalidMimeTypeException",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.MimeTypeUtils",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "ConcurrentLruCache",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.MimeTypeUtils",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "MimeType.WILDCARD_TYPE",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.MimeTypeUtils",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "Random",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.MimeTypeUtils",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "SecureRandom",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.MimeTypeUtils",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "StandardCharsets",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.MultiToSingleValueMapAdapter#putAll(Map<? extends K,? extends V>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "map entry iteration",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MultiToSingleValueMapAdapter#putAll(Map<? extends K,? extends V>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "key-value insertion",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MultiToSingleValueMapAdapter#putAll(Map<? extends K,? extends V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.MultiToSingleValueMapAdapter#put(Object, Object)",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.MultiToSingleValueMapAdapter#putAll(Map<? extends K,? extends V>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "java.util.Map.Entry",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.MultiToSingleValueMapAdapter#putAll(Map<? extends K,? extends V>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.MultiToSingleValueMapAdapter",
      "tail_type": "class"
    },
    {
      "head": "map entry iteration",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "Iterate over each entry in the provided map",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "key-value insertion",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "Insert each key-value pair into the map",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.MultiToSingleValueMapAdapter#put(Object, Object)",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "public void put(Object key, Object value) {\n    // Implementation details\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.MultiToSingleValueMapAdapter#clear()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "clearing a map",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MultiToSingleValueMapAdapter#clear()",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for clearing a map",
      "tail_type": "useSampleCode"
    },
    {
      "head": "sample code for clearing a map",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "complete example of clearing a map",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.PropertiesPersister#load(Properties,Reader)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "load properties",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.PropertiesPersister#load(Properties,Reader)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "IOException in case of I/O errors",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.PropertiesPersister#load(Properties,Reader)",
      "head_type": "method",
      "relation": "have",
      "tail": "Load properties from the given Reader into the given Properties object",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.PropertiesPersister#load(Properties,Reader)",
      "head_type": "method",
      "relation": "have",
      "tail": "void load(Properties props, Reader reader) throws IOException",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.PropertiesPersister#load(Properties,Reader)",
      "head_type": "method",
      "relation": "have",
      "tail": "The method is used to load properties from a given Reader into a Properties object. It throws an IOException if any I/O errors occur during the loading process.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.PropertiesPersister#load(Properties,Reader)",
      "head_type": "method",
      "relation": "have",
      "tail": "The design principle of this method is to provide a convenient way to load properties from a Reader into a Properties object, ensuring that any I/O errors are properly handled and reported.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#makeAccessible(Constructor<?>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "makeAccessible",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#makeAccessible(Constructor<?>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "Modifier.isPublic",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#makeAccessible(Constructor<?>)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "constructor accessibility",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#makeAccessible(Constructor<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "constructor accessibility sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#makeAccessible(Constructor<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "constructor accessibility concept",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#makeAccessible(Constructor<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle for accessibility",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "constructor accessibility sample code",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "tail": "org.springframework.util.ReflectionUtils#makeAccessible(Constructor<?>)",
      "tail_type": "method"
    },
    {
      "head": "constructor accessibility concept",
      "head_type": "relatedConceptInterpretation",
      "relation": "associated_with",
      "tail": "org.springframework.util.ReflectionUtils#makeAccessible(Constructor<?>)",
      "tail_type": "method"
    },
    {
      "head": "design principle for accessibility",
      "head_type": "designPrincipleInterpretation",
      "relation": "associated_with",
      "tail": "org.springframework.util.ReflectionUtils#makeAccessible(Constructor<?>)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.ResourceUtils#getFile(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "Resolving a resource location to a java.io.File",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ResourceUtils#getFile(String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "Resource location must not be null",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ResourceUtils#getFile(String)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "Resolving classpath, file URL, or plain file path",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ResourceUtils#getFile(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "Complete example of resolving a resource location to a File object",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ResourceUtils#getFile(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "Explanation of resource location resolution",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ResourceUtils#getFile(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "Design principles behind ResourceUtils#getField(String)",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ResourceUtils#getFile(String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "java.io.File",
      "tail_type": "class"
    },
    {
      "head": "Resolving a resource location to a java.io.File",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "Complete example of resolving a resource location to a File object",
      "tail_type": "useSampleCode"
    },
    {
      "head": "Resolving a resource location to a java.io.File",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "Explanation of resource location resolution",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "Resolving a resource location to a java.io.File",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "Design principles behind ResourceUtils#getField(String)",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.SingleToMultiValueMapAdapter#toSingleValueMap()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "convert multi-value map to single-value map",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.SingleToMultiValueMapAdapter#toSingleValueMap()",
      "head_type": "method",
      "relation": "have",
      "tail": "This method returns an unmodifiable view of the underlying map.",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.SingleToMultiValueMapAdapter#toSingleValueMap()",
      "head_type": "method",
      "relation": "have",
      "tail": "public Map<K, V> toSingleValueMap() {\n    return Collections.unmodifiableMap(this.targetMap);\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.SingleToMultiValueMapAdapter#toSingleValueMap()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.SingleToMultiValueMapAdapter",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.StreamUtils#copy(String,Charset,OutputStream)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "copy contents of a String to an OutputStream",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StreamUtils#copy(String,Charset,OutputStream)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "I/O errors",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.StreamUtils#copy(String,Charset,OutputStream)",
      "head_type": "method",
      "relation": "have",
      "tail": "Leaves the stream open when done",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.StreamUtils#copy(String,Charset,OutputStream)",
      "head_type": "method",
      "relation": "have",
      "tail": "public static void copy(String in, Charset charset, OutputStream out) throws IOException {\n    Assert.notNull(in, \"No input String specified\");\n    Assert.notNull(charset, \"No Charset specified\");\n    Assert.notNull(out, \"No OutputStream specified\");\n    out.write(in.getBytes(charset));\n    out.flush();\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.StreamUtils#copy(String,Charset,OutputStream)",
      "head_type": "method",
      "relation": "have",
      "tail": "The method is designed to copy data from a String to an OutputStream using a specified Charset. It ensures that the OutputStream is not closed after the operation, which allows for additional data to be written to the stream if needed.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.StreamUtils#copy(String,Charset,OutputStream)",
      "head_type": "method",
      "relation": "have",
      "tail": "The design principle behind this method is to provide a utility function that simplifies the process of writing string data to an output stream. It emphasizes robustness by checking for null inputs and uses the specified Charset to encode the string, ensuring compatibility with different character encodings.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "StreamUtils",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.StreamUtils#copy(String,Charset,OutputStream)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.NonClosingOutputStream#write(byte[],int,int)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "write method override",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.NonClosingOutputStream#write(byte[],int,int)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "performance critical",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.NonClosingOutputStream#write(byte[],int,int)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "java.io.IOException",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.NonClosingOutputStream#write(byte[],int,int)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "java.io.OutputStream",
      "tail_type": "class"
    },
    {
      "head": "write method override",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "org.springframework.util.NonClosingOutputStream#write(byte[],int,int)",
      "tail_type": "useSampleCode"
    },
    {
      "head": "write method override",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "Override annotation is used to indicate that the method is meant to override a method in a parent class.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "write method override",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "Design principle: Follow the Liskov Substitution Principle by ensuring that the overridden method can be used in place of the parent method without altering the correctness of the program.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.StringUtils#unqualify(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "unqualify a string",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils#unqualify(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "Unqualify a string qualified by a '.' dot character. For example, \"this.name.is.qualified\", returns \"qualified\".",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.StringUtils#unqualify(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "public static String unqualify(String qualifiedName) {\n    return unqualify(qualifiedName, DOT_CHAR);\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.StringUtils#capitalize(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "capitalize a String",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils#capitalize(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "Capitalize a String, changing the first letter to upper case as per Character#toUpperCase(char). No other letters are changed.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.StringUtils#capitalize(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "public static String capitalize(String str) { return changeFirstCharacterCase(str, true); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "capitalize a String",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "the String to capitalize cannot be null",
      "tail_type": "useConstraint"
    },
    {
      "head": "capitalize a String",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "any String that needs to start with an uppercase letter",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.StringUtils#getFilenameExtension(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "extract filename extension",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils#getFilenameExtension(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.StringUtils#getFilenameExtension(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.StringUtils#getFilenameExtension(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "extract filename extension",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "Java resource path",
      "tail_type": "useScenario"
    },
    {
      "head": "extract filename extension",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "path may be null",
      "tail_type": "useConstraint"
    },
    {
      "head": "useSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "complete sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "relatedConceptInterpretation",
      "head_type": "relatedConceptInterpretation",
      "relation": "have",
      "tail": "filename extension explanation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "designPrincipleInterpretation",
      "head_type": "designPrincipleInterpretation",
      "relation": "have",
      "tail": "null safety principle",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "relationships": [
        {
          "tail": "concatenateStringArrays",
          "head_type": "method",
          "relation": "haveFunction",
          "head": "org.springframework.util.StringUtils#concatenateStringArrays(String[],String[])",
          "tail_type": "apiFunction"
        },
        {
          "tail": "arrayConcatenation",
          "head_type": "apiFunction",
          "relation": "applied_to",
          "head": "concatenateStringArrays",
          "tail_type": "useScenario"
        },
        {
          "tail": "concatenateStringArraysSampleCode",
          "head_type": "useScenario",
          "relation": "have",
          "head": "arrayConcatenation",
          "tail_type": "useSampleCode"
        },
        {
          "tail": "arrayConcatenationDescription",
          "head_type": "apiFunction",
          "relation": "have",
          "head": "concatenateStringArrays",
          "tail_type": "relatedConceptInterpretation"
        },
        {
          "tail": "arrayConcatenationDesignPrinciple",
          "head_type": "apiFunction",
          "relation": "have",
          "head": "concatenateStringArrays",
          "tail_type": "designPrincipleInterpretation"
        }
      ]
    },
    {
      "apple": "banana"
    },
    [],
    {
      "banana": "cherry"
    },
    [],
    {
      "relationships": [
        {
          "tail": "concatenateStringArrays",
          "head_type": "method",
          "relation": "haveFunction",
          "head": "org.springframework.util.StringUtils#concatenateStringArrays(String[],String[])",
          "tail_type": "apiFunction"
        },
        {
          "tail": "arrayConcatenation",
          "head_type": "apiFunction",
          "relation": "applied_to",
          "head": "concatenateStringArrays",
          "tail_type": "useScenario"
        },
        {
          "tail": "concatenateStringArraysSampleCode",
          "head_type": "useScenario",
          "relation": "have",
          "head": "arrayConcatenation",
          "tail_type": "useSampleCode"
        },
        {
          "tail": "arrayConcatenationDescription",
          "head_type": "apiFunction",
          "relation": "have",
          "head": "concatenateStringArrays",
          "tail_type": "relatedConceptInterpretation"
        },
        {
          "tail": "arrayConcatenationDesignPrinciple",
          "head_type": "apiFunction",
          "relation": "have",
          "head": "concatenateStringArrays",
          "tail_type": "designPrincipleInterpretation"
        }
      ]
    },
    {
      "head": "org.springframework.util.StringUtils#splitArrayElementsIntoProperties(String[],String,String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "splitting array elements into properties",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils#splitArrayElementsIntoProperties(String[],String,String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "delimiter must be provided",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.StringUtils#splitArrayElementsIntoProperties(String[],String,String)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "array processing for key-value pairs",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.StringUtils#splitArrayElementsIntoProperties(String[],String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for splitting array elements into properties",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.StringUtils#splitArrayElementsIntoProperties(String[],String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "related concept interpretation for splitting array elements",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.StringUtils#splitArrayElementsIntoProperties(String[],String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle interpretation for splitting array elements",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.StringUtils#splitArrayElementsIntoProperties(String[],String,String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.StringUtils",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.TypeUtils#isAssignable(Type,Type)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "type assignability check",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.TypeUtils#isAssignable(Type,Type)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "Java generics rules",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.TypeUtils#isAssignable(Type,Type)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "assigning one type to another",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.TypeUtils#isAssignable(Type,Type)",
      "head_type": "method",
      "relation": "have",
      "tail": "related concept interpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.TypeUtils#isAssignable(Type,Type)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle interpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "type assignability check",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "use sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "related concept interpretation",
      "head_type": "relatedConceptInterpretation",
      "relation": "associated_with",
      "tail": "Java generics",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "design principle interpretation",
      "head_type": "designPrincipleInterpretation",
      "relation": "associated_with",
      "tail": "type safety",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#size()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "size determination",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#size()",
      "head_type": "method",
      "relation": "have",
      "tail": "delegation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#size()",
      "head_type": "method",
      "relation": "have",
      "tail": "This method determines the size by delegating the call to the underlying delegate object's size method.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#size()",
      "head_type": "method",
      "relation": "have",
      "tail": "public int size() {\n    return this.delegate.size();\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySet#removeIf(Predicate<? super Entry<K,List<V>>>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "removeIf",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySet#removeIf(Predicate<? super Entry<K,List<V>>>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "UnsupportedOperationException",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySet#removeIf(Predicate<? super Entry<K,List<V>>>)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is not supported and will always throw an UnsupportedOperationException.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySet#removeIf(Predicate<? super Entry<K,List<V>>>)",
      "head_type": "method",
      "relation": "have",
      "tail": "The method is designed to prevent modification of the set.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySet#removeIf(Predicate<? super Entry<K,List<V>>>)",
      "head_type": "method",
      "relation": "have",
      "tail": "package com.example.util; import java.util.*; public class UnmodifiableEntrySetExample { public static void main(String[] args) { Map<String, List<Integer>> map = new HashMap<>(); map.put(\"key\", Arrays.asList(1, 2, 3)); Set<Map.Entry<String, List<Integer>>> entrySet = map.entrySet(); Set<Map.Entry<String, List<Integer>>> unmodifiableEntrySet = Collections.unmodifiableSet(entrySet); try { unmodifiableEntrySet.removeIf(entry -> entry.getValue().contains(2)); } catch (UnsupportedOperationException e) { System.out.println(\"Cannot remove elements from an unmodifiable set.\"); } } }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueCollection#containsAll(Collection<?>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "check subset",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueCollection#containsAll(Collection<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is used to determine if the specified collection is a subset of this collection.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueCollection#containsAll(Collection<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "The design principle behind this method is to ensure that the collection remains unmodifiable while still providing the functionality to check for subsets.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueCollection#containsAll(Collection<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "package com.example.util;\n\nimport java.util.Collection;\n\npublic class UnmodifiableValueCollectionExample {\n    public static void main(String[] args) {\n        // Example usage of containsAll method\n        Collection<String> originalCollection = new UnmodifiableValueCollection<>(Arrays.asList(\"apple\", \"banana\", \"cherry\"));\n        Collection<String> subsetCollection = Arrays.asList(\"banana\", \"cherry\");\n        boolean isSubset = originalCollection.containsAll(subsetCollection);\n        System.out.println(\"Is subset: \" + isSubset);\n    }\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueCollection#toArray()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "convert collection to array",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueCollection#toArray()",
      "head_type": "method",
      "relation": "have",
      "tail": "The method converts the collection to an array, applying a filter to the result.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueCollection#toArray()",
      "head_type": "method",
      "relation": "have",
      "tail": "This method ensures that the resulting array is unmodifiable.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueCollection#toArray()",
      "head_type": "method",
      "relation": "have",
      "tail": "public Object[] toArray() {\n    Object[] result = this.delegate.toArray();\n    filterArray(result);\n    return result;\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#endEntity(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "endEntity",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#endEntity(String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.AbstractStaxHandler",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler",
      "head_type": "class",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler",
      "head_type": "class",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxXMLReader#startPrefixMapping(String,String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "startPrefixMapping",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxXMLReader#startPrefixMapping(String,String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "prefix cannot be null",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxXMLReader#startPrefixMapping(String,String)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "namespace handling in XML processing",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxXMLReader#startPrefixMapping(String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "namespace handling in XML processing",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxXMLReader#startPrefixMapping(String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxXMLReader#startPrefixMapping(String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxXMLReader#startPrefixMapping(String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxXMLReader#startPrefixMapping(String,String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.AbstractStaxXMLReader",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxXMLReader",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "startPrefixMapping",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxXMLReader",
      "head_type": "class",
      "relation": "constrained_by",
      "tail": "prefix cannot be null",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxXMLReader",
      "head_type": "class",
      "relation": "applied_to",
      "tail": "namespace handling in XML processing",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxXMLReader",
      "head_type": "class",
      "relation": "have",
      "tail": "namespace handling in XML processing",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxXMLReader",
      "head_type": "class",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxXMLReader",
      "head_type": "class",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxXMLReader",
      "head_type": "class",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLReader",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getLexicalHandler()",
      "tail_type": "apiFunction"
    },
    {
      "head": "getLexicalHandler()",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "LexicalHandler",
      "tail_type": "class"
    },
    {
      "head": "getLexicalHandler()",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "return this.lexicalHandler",
      "tail_type": "useSampleCode"
    },
    {
      "head": "getLexicalHandler()",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "The method returns the current lexical handler which is responsible for handling lexical events.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "getLexicalHandler()",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "This method is designed to provide access to the lexical handler that is currently set for this XML reader. It is part of the XML processing API and is used to handle lexical events such as comments and CDATA sections.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.ListBasedXMLEventReader#nextEvent()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "xmlEventReading",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.ListBasedXMLEventReader#nextEvent()",
      "head_type": "method",
      "relation": "have",
      "tail": "xmlEventReadingSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "xmlEventReadingSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "xmlEventReadingSampleCodeContent",
      "tail_type": "useSampleCodeContent"
    },
    {
      "head": "org.springframework.util.xml.ListBasedXMLEventReader#nextEvent()",
      "head_type": "method",
      "relation": "have",
      "tail": "xmlEventReadingRelatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "xmlEventReadingRelatedConceptInterpretation",
      "head_type": "relatedConceptInterpretation",
      "relation": "have",
      "tail": "xmlEventReadingRelatedConceptInterpretationContent",
      "tail_type": "relatedConceptInterpretationContent"
    },
    {
      "head": "org.springframework.util.xml.ListBasedXMLEventReader#nextEvent()",
      "head_type": "method",
      "relation": "have",
      "tail": "xmlEventReadingDesignPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "xmlEventReadingDesignPrincipleInterpretation",
      "head_type": "designPrincipleInterpretation",
      "relation": "have",
      "tail": "xmlEventReadingDesignPrincipleInterpretationContent",
      "tail_type": "designPrincipleInterpretationContent"
    },
    {
      "head": "org.springframework.util.xml.StaxSource#setInputSource(InputSource)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "throwing UnsupportedOperationException",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxSource#setInputSource(InputSource)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "always throwing UnsupportedOperationException",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.xml.StaxSource#setInputSource(InputSource)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for throwing UnsupportedOperationException",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.StaxSource#setInputSource(InputSource)",
      "head_type": "method",
      "relation": "have",
      "tail": "related concept interpretation for throwing UnsupportedOperationException",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxSource#setInputSource(InputSource)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle interpretation for throwing UnsupportedOperationException",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxSource#setXMLReader(XMLReader)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "throwing UnsupportedOperationException",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxSource#setXMLReader(XMLReader)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "always throwing UnsupportedOperationException",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.xml.StaxSource#setXMLReader(XMLReader)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for throwing UnsupportedOperationException",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.StaxSource#setXMLReader(XMLReader)",
      "head_type": "method",
      "relation": "have",
      "tail": "interpretation of related concepts",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxSource#setXMLReader(XMLReader)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle interpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxSource#setXMLReader(XMLReader)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.StaxSource",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamHandler#startEntity(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "startEntity",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamHandler#startEntity(String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.StaxStreamHandler",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamReader#countIterator(Iterator)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "counting elements in an iterator",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamReader#countIterator(Iterator)",
      "head_type": "method",
      "relation": "have",
      "tail": "private static int countIterator(Iterator iterator) { int count = 0; while (iterator.hasNext()) { iterator.next(); count++; } return count; }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamReader#countIterator(Iterator)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method iterates over an iterator and counts the number of elements.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamReader#countIterator(Iterator)",
      "head_type": "method",
      "relation": "have",
      "tail": "The method follows a simple iteration principle to count elements in an iterator, showcasing a straightforward design.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "example.type.SomeSubclassOfSomeComponent",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "lazy loading",
      "tail_type": "apiFunction"
    },
    {
      "head": "example.type.SomeSubclassOfSomeComponent",
      "head_type": "class",
      "relation": "constrained_by",
      "tail": "circular aliases are prohibited",
      "tail_type": "useConstraint"
    },
    {
      "head": "example.type.SomeSubclassOfSomeComponent",
      "head_type": "class",
      "relation": "applied_to",
      "tail": "multiple aliases for a single name",
      "tail_type": "useScenario"
    },
    {
      "head": "example.type.SomeSubclassOfSomeComponent",
      "head_type": "class",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "example.type.SomeSubclassOfSomeComponent",
      "head_type": "class",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "example.type.SomeSubclassOfSomeComponent",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.core.SimpleAliasRegistryTests",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#createWithStaticAndClassAndStringCreatesMethodReference()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "createStaticMethodReference",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#createWithStaticAndClassAndStringCreatesMethodReference()",
      "head_type": "method",
      "relation": "have",
      "tail": "void createWithStaticAndClassAndStringCreatesMethodReference() {\n    ClassName declaringClass = ClassName.get(DefaultMethodReferenceTests.class);\n    MethodReference reference = createStaticMethodReference(\"someMethod\", declaringClass);\n    assertThat(reference).hasToString(EXPECTED_STATIC);\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "createStaticMethodReference",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "ClassName.get",
      "tail_type": "apiFunction"
    },
    {
      "head": "createStaticMethodReference",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "assertThat",
      "tail_type": "apiFunction"
    },
    {
      "head": "createStaticMethodReference",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "hasToString",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "createWithStaticAndClassAndStringCreatesMethodReference()",
      "tail_type": "method"
    },
    {
      "head": "createWithStaticAndClassAndStringCreatesMethodReference()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.DefaultMethodReferenceTests",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#createStaticMethodReference(String,ClassName,TypeName)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "createStaticMethodReference",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#createStaticMethodReference(String,ClassName,TypeName)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.DefaultMethodReferenceTests",
      "tail_type": "class"
    },
    {
      "head": "createStaticMethodReference",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "createStaticMethodReferenceSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "createStaticMethodReferenceSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "createStaticMethodReferenceSampleCodeContent",
      "tail_type": "useSampleCodeContent"
    },
    {
      "head": "org.springframework.aot.generate.FileSystemGeneratedFilesTests#createWhenRootIsNullThrowsException()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "handle null value",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.FileSystemGeneratedFilesTests#createWhenRootIsNullThrowsException()",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "root must not be null",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.aot.generate.FileSystemGeneratedFilesTests#createWhenRootIsNullThrowsException()",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.FileSystemGeneratedFilesTests#createWhenRootIsNullThrowsException()",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.FileSystemGeneratedFilesTests#createWhenRootIsNullThrowsException()",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedMethodsTests#addWithStringNameWhenMethodIsNullThrowsException()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "addWithStringNameWhenMethodIsNullThrowsException",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedMethodsTests#addWithStringNameWhenMethodIsNullThrowsException()",
      "head_type": "method",
      "relation": "have",
      "tail": "addWithStringNameWhenMethodIsNullThrowsException useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "addWithStringNameWhenMethodIsNullThrowsException useSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "package com.healthMgr.common.email; import java.xxxx; public class OneClass { // specific code }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedMethodsTests#addAddsMethod()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "addMethod",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedMethodsTests#addAddsMethod()",
      "head_type": "method",
      "relation": "have",
      "tail": "addMethodSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "addMethodSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "org.springframework.aot.generate.GeneratedMethodsTests",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.MethodNameTests#hashCodeAndEquals()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "MethodName generation",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.MethodNameTests#hashCodeAndEquals()",
      "head_type": "method",
      "relation": "have",
      "tail": "MethodName generation sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "MethodName generation sample code",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "Complete MethodName generation example",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.NullTests#generateWhenNull()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "generateCode",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.NullTests#generateWhenNull()",
      "head_type": "method",
      "relation": "have",
      "tail": "generateWhenNull sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.PrimitiveTests#generateWhenSimpleEscapedCharReturnsEscaped()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "generateEscapedCharacters",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.PrimitiveTests#generateWhenSimpleEscapedCharReturnsEscaped()",
      "head_type": "method",
      "relation": "have",
      "tail": "generateEscapedCharactersSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "generateEscapedCharactersSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "org.springframework.aot.generate.PrimitiveTests",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.ClassTests#generateWhenCglibClass()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "generate code for Cglib class",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.ClassTests#generateWhenCglibClass()",
      "head_type": "method",
      "relation": "have",
      "tail": "generate code for Cglib class sample",
      "tail_type": "useSampleCode"
    },
    {
      "head": "generate code for Cglib class sample",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.ClassTests#generateWhenCglibClass()",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.aot.generate.ClassTests#generateWhenCglibClass()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.ClassTests",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.ClassTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "generate code for Cglib class",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.ResolvableTypeTests#generateWhenNoneResolvableType()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "generateWhenNoneResolvableType",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.ResolvableTypeTests#generateWhenNoneResolvableType()",
      "head_type": "method",
      "relation": "have",
      "tail": "generateWhenNoneResolvableTypeSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "generateWhenNoneResolvableTypeSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "generateWhenNoneResolvableTypeSampleCodeContent",
      "tail_type": "useSampleCodeContent"
    },
    {
      "head": "org.springframework.aot.hint.annotation.ClassLevelAnnotatedBean",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "bean registration",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.hint.annotation.ClassLevelAnnotatedBean",
      "head_type": "class",
      "relation": "constrained_by",
      "tail": "class-level annotations",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.aot.hint.annotation.ClassLevelAnnotatedBean",
      "head_type": "class",
      "relation": "applied_to",
      "tail": "Spring AOT processing",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.aot.hint.annotation.ClassLevelAnnotatedBean",
      "head_type": "class",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.hint.annotation.ClassLevelAnnotatedBean",
      "head_type": "class",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.hint.annotation.ClassLevelAnnotatedBean",
      "head_type": "class",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "bean registration",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "org.springframework.beans.factory.config.BeanDefinition",
      "tail_type": "class"
    },
    {
      "head": "class-level annotations",
      "head_type": "useConstraint",
      "relation": "associated_with",
      "tail": "org.springframework.stereotype.Component",
      "tail_type": "class"
    },
    {
      "head": "Spring AOT processing",
      "head_type": "useScenario",
      "relation": "associated_with",
      "tail": "org.springframework.aot.hint.RuntimeHints",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.objenesis.SpringObjenesis#newInstance(Class<T>,boolean)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "Create a new instance of the given class via Objenesis",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.objenesis(SpringObjenesis",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "Objenesis",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "newInstance",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "ObjenesisException if instance creation failed",
      "tail_type": "useConstraint"
    },
    {
      "head": "newInstance",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "reloadable classes",
      "tail_type": "useScenario"
    },
    {
      "head": "newInstance",
      "head_type": "method",
      "relation": "have",
      "tail": "useCache parameter to control instantiator cache",
      "tail_type": "useScenario"
    },
    {
      "head": "newInstance",
      "head_type": "method",
      "relation": "have",
      "tail": "Complete sample code for creating an instance using Objenesis",
      "tail_type": "useSampleCode"
    },
    {
      "head": "newInstance",
      "head_type": "method",
      "relation": "have",
      "tail": "Objenesis is a library for creating instances without using constructors",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "newInstance",
      "head_type": "method",
      "relation": "have",
      "tail": "Design principles behind the Objenesis library",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.AntPatternComparator",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "pattern comparison",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.AntPatternComparator",
      "head_type": "class",
      "relation": "constrained_by",
      "tail": "null pattern handling",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.AntPatternComparator",
      "head_type": "class",
      "relation": "applied_to",
      "tail": "ant pattern matching",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.AntPatternComparator",
      "head_type": "class",
      "relation": "have",
      "tail": "related concept interpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.AntPatternComparator",
      "head_type": "class",
      "relation": "have",
      "tail": "design principle interpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.AntPatternComparator",
      "head_type": "class",
      "relation": "have",
      "tail": "use sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "pattern comparison",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "org.springframework.util.AntPatternComparator",
      "tail_type": "class"
    },
    {
      "head": "null pattern handling",
      "head_type": "useConstraint",
      "relation": "associated_with",
      "tail": "org.springframework.util.AntPatternComparator",
      "tail_type": "class"
    },
    {
      "head": "ant pattern matching",
      "head_type": "useScenario",
      "relation": "associated_with",
      "tail": "org.springframework.util.AntPatternComparator",
      "tail_type": "class"
    },
    {
      "head": "related concept interpretation",
      "head_type": "relatedConceptInterpretation",
      "relation": "associated_with",
      "tail": "org.springframework.util.AntPatternComparator",
      "tail_type": "class"
    },
    {
      "head": "design principle interpretation",
      "head_type": "designPrincipleInterpretation",
      "relation": "associated_with",
      "tail": "org.springframework.util.AntPatternComparator",
      "tail_type": "class"
    },
    {
      "head": "use sample code",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "tail": "org.springframework.util.AntPatternComparator",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.PatternInfo",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "pattern analysis",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.PatternInfo",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "URI variable counting",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.PatternInfo",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "wildcard counting",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.PatternInfo",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "specificity determination",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.PatternInfo",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "prefix pattern checking",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.PatternInfo",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "total pattern element counting",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.PatternInfo",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "pattern length calculation",
      "tail_type": "apiFunction"
    },
    {
      "head": "pattern analysis",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "null pattern handling",
      "tail_type": "useConstraint"
    },
    {
      "head": "URI variable counting",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "pattern initialization",
      "tail_type": "useScenario"
    },
    {
      "head": "wildcard counting",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "pattern initialization",
      "tail_type": "useScenario"
    },
    {
      "head": "specificity determination",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "pattern comparison",
      "tail_type": "useScenario"
    },
    {
      "head": "prefix pattern checking",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "pattern analysis",
      "tail_type": "useScenario"
    },
    {
      "head": "total pattern element counting",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "pattern analysis",
      "tail_type": "useScenario"
    },
    {
      "head": "pattern length calculation",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "pattern analysis",
      "tail_type": "useScenario"
    },
    {
      "head": "pattern analysis",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "Related Concept Interpretation: Pattern analysis involves examining a given pattern to identify and count specific elements such as URI variables, single wildcards, and double wildcards. It is crucial for understanding the structure and complexity of the pattern, which can affect routing and matching efficiency in applications like web frameworks.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "URI variable counting",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "Related Concept Interpretation: URI variable counting refers to the process of identifying and tallying the number of unique placeholders (e.g., {var}) in a pattern. This is essential for applications that need to extract parameters from URLs, such as web services.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "wildcard counting",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "Related Concept Interpretation: Wildcard counting involves identifying and counting wildcard characters (e.g., * and **) in a pattern. This is important for applications that use pattern matching, such as file system search or URL routing, where wildcards represent variable parts of the pattern.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "specificity determination",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "Related Concept Interpretation: Specificity determination is the process of evaluating how specific or general a pattern is. In applications like routing, more specific patterns are matched before less specific ones to ensure precise handling of requests.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "prefix pattern checking",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "Related Concept Interpretation: Prefix pattern checking involves determining if a pattern is a prefix pattern, which typically ends with a double wildcard (**). This is used in applications to handle routes that can match any sub-paths of a given path.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "total pattern element counting",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "Related Concept Interpretation: Total pattern element counting refers to calculating the total number of significant elements in a pattern, including URI variables and wildcards. This metric can be used to assess the complexity of the pattern, which is important for performance optimization in pattern matching tasks.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "pattern length calculation",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "Related Concept Interpretation: Pattern length calculation involves determining the effective length of a pattern, considering that each variable or wildcard may represent a segment of the pattern. This is crucial for applications where pattern length affects matching priority or performance.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.PatternInfo",
      "head_type": "class",
      "relation": "have",
      "tail": "Design Principle Interpretation: The PatternInfo class is designed to encapsulate the analysis of a pattern, providing a structured way to store and retrieve information about the pattern's components. This design promotes modularity and reusability, allowing other parts of the application to efficiently work with pattern data without needing to reanalyze the pattern each time.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.PatternInfo",
      "head_type": "class",
      "relation": "have",
      "tail": "useSampleCode: \npackage com.example.pattern;\n\nimport org.springframework.util.PatternInfo;\n\npublic class PatternAnalysisExample {\n    public static void main(String[] args) {\n        PatternInfo patternInfo = new PatternInfo(\"/users/{userId}/profiles/**\", \"/\");\n        System.out.println(\"Number of URI variables: \" + patternInfo.getUriVars());\n        System.out.println(\"Number of single wildcards: \" + patternInfo.getSingleWildcards());\n        System.out.println(\"Number of double wildcards: \" + patternInfo.getDoubleWildcards());\n        System.out.println(\"Is least specific: \" + patternInfo.isLeastSpecific());\n        System.out.println(\"Is prefix pattern: \" + patternInfo.isPrefixPattern());\n        System.out.println(\"Total count: \" + patternInfo.getTotalCount());\n        System.out.println(\"Pattern length: \" + patternInfo.getLength());\n    }\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.PathSeparatorPatternCache",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "pattern caching",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.PathSeparatorPatternCache",
      "head_type": "class",
      "relation": "have",
      "tail": "A simple cache for patterns that depend on the configured path separator.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.PathSeparatorPatternCache",
      "head_type": "class",
      "relation": "have",
      "tail": "private final String endsOnWildCard; private final String endsOnDoubleWildCard; public PathSeparatorPatternCache(String pathSeparator) { this.endsOnWildCard = pathSeparator + \"*\"; this.endsOnDoubleWildCard = pathSeparator + \"**\"; } public String getEndsOnWildCard() { return this.endsOnWildCard; } public String getEndsOnDoubleWildCard() { return this.endsOnDoubleWildCard; }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.Assert#isNull(Object,Supplier<String>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "assertNull",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.Assert#isNull(Object,Supplier<String>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "objectMustBeNull",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.Assert#isNull(Object,Supplier<String>)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "checkForObjectNullity",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.Assert#isNull(Object,Supplier<String>)",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.Assert#isNull(Object,Supplier<String>)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.Assert#isNull(Object,Supplier<String>)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.Assert#isNull(Object,Supplier<String>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "IllegalArgumentException",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.Assert#assignableCheckFailed(Class<?>,Class<?>,String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "type checking",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.Assert#assignableCheckFailed(Class<?>,Class<?>,String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "null input handling",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.Assert#assignableCheckFailed(Class<?>,Class<?>,String)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "assignable check",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.Assert#assignableCheckFailed(Class<?>,Class<?>,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.Assert#assignableCheckFailed(Class<?>,Class<?>,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.Assert#assignableCheckFailed(Class<?>,Class<?>,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "relatedConceptInterpretation",
      "head_type": "relatedConceptInterpretation",
      "relation": "associated_with",
      "tail": "type compatibility",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "designPrincipleInterpretation",
      "head_type": "designPrincipleInterpretation",
      "relation": "associated_with",
      "tail": "robustness principle",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "useSampleCode",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "tail": "complete example",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.AutoPopulatingList#add(E)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "add elements to a list",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.AutoPopulatingList#add(E)",
      "head_type": "method",
      "relation": "have",
      "tail": "add elements to a list",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.AutoPopulatingList#add(E)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.AutoPopulatingList",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.AutoPopulatingList#add(E)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.AutoPopulatingList",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.backoff.ExponentialBackOff#setMaxInterval(long)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "set maximum back off time",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.backoff.ExponentialBackOff#setMaxInterval(long)",
      "head_type": "method",
      "relation": "have",
      "tail": "Set the maximum back off time in milliseconds.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.backoff.ExponentialBackOff#setMaxInterval(long)",
      "head_type": "method",
      "relation": "have",
      "tail": "public void setMaxInterval(long maxInterval) { this.maxInterval = maxInterval; }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ClassUtils#isPresent(String,ClassLoader)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "class presence check",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ClassUtils#isPresent(String,ClassLoader)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "class loader specification",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ClassUtils#isPresent(String,ClassLoader)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "class loading verification",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ClassUtils#isPresent(String,ClassLoader)",
      "head_type": "method",
      "relation": "have",
      "tail": "class loading verification sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ClassUtils#isPresent(String,ClassLoader)",
      "head_type": "method",
      "relation": "have",
      "tail": "class presence and dependency explanation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#isPresent(String,ClassLoader)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle for class loading",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#isPresent(String,ClassLoader)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.ClassUtils",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.ClassUtils#isStaticClass(Class<?>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "determine if the supplied class is a static class",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ClassUtils#isStaticClass(Class<?>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "none",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ClassUtils#isStaticClass(Class<?>)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "none",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ClassUtils#isStaticClass(Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "none",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ClassUtils#isStaticClass(Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "none",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#isStaticClass(Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "none",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#isStaticClass(Class<?>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "Modifier#isStatic(int)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.ClassUtils#isStaticClass(Class<?>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "#isInnerClass(Class)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.CollectionUtils#findValueOfType(Collection<?>,Class<T>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "find a single value of the given type in the given Collection",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.CollectionUtils#findValueOfType(Collection<?>,Class<T>)",
      "head_type": "method",
      "relation": "have",
      "tail": "Find a single value of the given type in the given Collection",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.CollectionUtils#findValueOfType(Collection<?>,Class<T>)",
      "head_type": "method",
      "relation": "have",
      "tail": "The method searches for a single instance of a specified type within a given collection, returning null if no clear single value is found or if multiple instances exist.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.CollectionUtils#findValueOfType(Collection<?>,Class<T>)",
      "head_type": "method",
      "relation": "have",
      "tail": "The design principle is to provide a utility method for easily finding a single value of a specified type in a collection, enhancing code readability and maintainability.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.CompositeMap#keySet()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "keySet",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.CompositeMap#keySet()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.CompositeMap",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.CompositeMap#keySet()",
      "head_type": "method",
      "relation": "have",
      "tail": "Return a set view of the keys contained in this map.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.CompositeMap#keySet()",
      "head_type": "method",
      "relation": "have",
      "tail": "The method returns a set that contains all the keys from both the first and the second map.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.CompositeMap#keySet()",
      "head_type": "method",
      "relation": "have",
      "tail": "java\nimport java.util.Set;\nimport org.springframework.util.CompositeSet;\n\npublic class KeySetExample {\n    public static void main(String[] args) {\n        // Assuming first and second are instances of Map\n        Set<K> keys = new CompositeSet<>(first.keySet(), second.keySet());\n        // Use the keys set as needed\n    }\n}\n",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ConcurrentLruCache#drainOperations()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "drainOperations",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ConcurrentLruCache#drainOperations()",
      "head_type": "method",
      "relation": "have",
      "tail": "private void drainOperations() { if (this.evictionLock.tryLock()) { try { this.drainStatus.lazySet(DrainStatus.PROCESSING); this.readOperations.drain(); this.writeOperations.drain(); } finally { this.drainStatus.compareAndSet(DrainStatus.PROCESSING, DrainStatus.IDLE); this.evictionLock.unlock(); } } }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "drainOperations",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "org.springframework.util.ConcurrentLruCache#drainOperations()",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.ConcurrentLruCache#drainOperations()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.ConcurrentLruCache",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.ConcurrentLruCache",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "ConcurrentLruCache",
      "tail_type": "apiFunction"
    },
    {
      "head": "ConcurrentLruCache",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "org.springframework.util.ConcurrentLruCache",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.ConcurrentReferenceHashMap#put(K,V,boolean)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "add or update entries",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ConcurrentReferenceHashMap#put(K,V,boolean)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "key and value must be nullable",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ConcurrentReferenceHashMap#put(K,V,boolean)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "overwrite existing entries",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ConcurrentReferenceHashMap#put(K,V,boolean)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for put method",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ConcurrentReferenceHashMap#put(K,V,boolean)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.ConcurrentReferenceHashMap",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.ConcurrentReferenceHashMap#put(K,V,boolean)",
      "head_type": "method",
      "relation": "have",
      "tail": "related concept interpretation for ConcurrentReferenceHashMap",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ConcurrentReferenceHashMap#put(K,V,boolean)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle interpretation for ConcurrentReferenceHashMap",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ConcurrentReferenceHashMap#getSegmentForHash(int)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "hash-based segment retrieval",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ConcurrentReferenceHashMap#getSegmentForHash(int)",
      "head_type": "method",
      "relation": "have",
      "tail": "hash-based segment retrieval sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "hash-based segment retrieval sample code",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "private Segment getSegmentForHash(int hash) {\n    return this.segments[(hash >>> (32 - this.shift)) & (this.segments.length - 1)];\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ConcurrentReferenceHashMap#getSegmentForHash(int)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.ConcurrentReferenceHashMap",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.Segment#getCount()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "reference counting",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.Segment#getCount()",
      "head_type": "method",
      "relation": "have",
      "tail": "Return the total number of references in this segment.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.Segment",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.Segment#getCount()",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.EntryIterator#moveToNextReference()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "move to next reference",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.EntryIterator#moveToNextReference()",
      "head_type": "method",
      "relation": "have",
      "tail": "private void moveToNextReference() { if (this.reference != null) { this.reference = this.reference.getNext(); } while (this.reference == null && this.references != null) { if (this.referenceIndex >= this.references.length) { moveToNextSegment(); this.referenceIndex = 0; } else { this.reference = this.references[this.referenceIndex]; this.referenceIndex++; } } }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.EntryIterator#moveToNextReference()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.EntryIterator",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.EntryIterator#moveToNextReference()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.core.EntryIterator",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.EntryIterator#moveToNextReference()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.EntryIterator#moveToNextReference()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "util",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.EntryIterator#moveToNextReference()",
      "head_type": "method",
      "relation": "designPrincipleInterpretation",
      "tail": "The method follows the principle of iteration to navigate through references, ensuring that each reference is properly handled until the end of the list or until a valid reference is found. This design allows for efficient traversal of references, maintaining a state of readiness for the next reference in the sequence.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.EntryIterator#moveToNextReference()",
      "head_type": "method",
      "relation": "relatedConceptInterpretation",
      "tail": "The concept of reference iteration is central to this method. It involves navigating through a series of references linked to each other, typically used in data structures like linked lists or trees. The method ensures that each reference is visited in turn, and the process continues until no more references are available or a specific condition is met.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.CustomizableThreadCreator#setThreadGroupName(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "specifyThreadGroupName",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.CustomizableThreadCreator#setThreadGroupName(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "threadsCreatedInSpecifiedGroup",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.CustomizableThreadCreator#setThreadGroupName(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "threadGroupCreation",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.CustomizableThreadCreator#setThreadGroupName(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "threadGroupManagement",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.CustomizableThreadCreator#setThreadGroupName(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "threadGroupDesignPrinciple",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.CustomizableThreadCreator#setThreadGroupName(String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.CustomizableThreadCreator",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.FastByteArrayOutputStream",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "lazy loading",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.FastByteArrayOutputStream",
      "head_type": "class",
      "relation": "constrained_by",
      "tail": "circular aliases are prohibited",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.FastByteArrayOutputStream",
      "head_type": "class",
      "relation": "applied_to",
      "tail": "multiple aliases for a single name",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.FastByteArrayOutputStream",
      "head_type": "class",
      "relation": "have",
      "tail": "package com.healthMgr.common.email; import java.xxxx; public class OneClass { // specific code }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.FastByteArrayOutputStream",
      "head_type": "class",
      "relation": "have",
      "tail": "org.springframework.core.SimpleAliasRegistryTests",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.FastByteArrayOutputStream",
      "head_type": "class",
      "relation": "have",
      "tail": "An explanation of related concepts",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.FastByteArrayOutputStream",
      "head_type": "class",
      "relation": "have",
      "tail": "An explanation of the design principles of the class or method",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.FastByteArrayOutputStream",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.FastByteArrayOutputStream",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.FastByteArrayInputStream#read()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "read data from byte array",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.FastByteArrayInputStream#read()",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "stream end condition",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.FastByteArrayInputStream#read()",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "sequential byte reading",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.FastByteArrayInputStream#read()",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.FastByteArrayInputStream",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.FastByteArrayInputStream#read()",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.FastByteArrayInputStream#read()",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.FastByteArrayInputStream#read()",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.FilteredMap#size()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "size determination",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.FilteredMap#size()",
      "head_type": "method",
      "relation": "have",
      "tail": "size determination sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "size determination sample code",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "package com.healthMgr.util;\nimport java.util.Map;\nimport java.util.Set;\nimport org.springframework.util.FilteredMap;\n\npublic class SizeDeterminationExample {\n    public static void main(String[] args) {\n        Map<String, Integer> originalMap = Map.of(\n            \"key1\", 1,\n            \"key2\", 2,\n            \"key3\", 3\n        );\n        \n        FilteredMap<String, Integer> filteredMap = new FilteredMap<>(originalMap, key -> key.contains(\"1\"));\n        \n        int size = filteredMap.size();\n        System.out.println(\"Filtered map size: \" + size);\n    }\n}",
      "tail_type": "String"
    },
    {
      "head": "org.springframework.util.FilteredMap#size()",
      "head_type": "method",
      "relation": "have",
      "tail": "related concept interpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "related concept interpretation",
      "head_type": "relatedConceptInterpretation",
      "relation": "have",
      "tail": "FilteredMap is a specialized map implementation that filters elements based on a given predicate. The size() method efficiently calculates the number of elements that satisfy the filter condition.",
      "tail_type": "String"
    },
    {
      "head": "org.springframework.util.FilteredMap#size()",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle interpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "design principle interpretation",
      "head_type": "designPrincipleInterpretation",
      "relation": "have",
      "tail": "The design principle behind FilteredMap#size() emphasizes efficiency and flexibility. By filtering elements on-the-fly, it avoids the need to create a separate, filtered collection, thus saving memory and processing time. This method adheres to the principle of least surprise, ensuring that the size calculation behaves as expected while accommodating custom filtering logic.",
      "tail_type": "String"
    },
    {
      "head": "org.springframework.util.function.ThrowingFunction#of(ThrowingFunction<T,R>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "create ThrowingFunction",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.function.ThrowingFunction#of(ThrowingFunction<T,R>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "lambda expression or method reference must throw checked exception",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.function.ThrowingFunction#of(ThrowingFunction<T,R>)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "convert method that throws checked exception to Function",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.function.ThrowingFunction#of(ThrowingFunction<T,R>)",
      "head_type": "method",
      "relation": "have",
      "tail": "stream.map(ThrowingFunction.of(Example::methodThatCanThrowCheckedException))",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.function.ThrowingFunction#of(ThrowingFunction<T,R>)",
      "head_type": "method",
      "relation": "have",
      "tail": "Lambda friendly convenience method to create ThrowingFunction",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.function.ThrowingFunction#of(ThrowingFunction<T,R>)",
      "head_type": "method",
      "relation": "have",
      "tail": "Design principle to handle checked exceptions in functional interfaces",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.function.ThrowingFunction#of(ThrowingFunction<T,R>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.function.ThrowingFunction",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.function.ThrowingSupplier#get()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "wrapping checked exceptions",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.function.ThrowingSupplier#get()",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "must wrap exceptions in RuntimeException",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.function.ThrowingSupplier#get()",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "handling checked exceptions in functional interfaces",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.function.ThrowingSupplier#get()",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for handling checked exceptions",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.function.ThrowingSupplier#get()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "java.util.function.Supplier",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.function.ThrowingSupplier#get()",
      "head_type": "method",
      "relation": "have",
      "tail": "functional interfaces and exception handling",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.function.ThrowingSupplier#get()",
      "head_type": "method",
      "relation": "have",
      "tail": "design principles for robust functional interfaces",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.function.ThrowingSupplier#get(BiFunction<String,Exception,RuntimeException>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "exception wrapping",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.function.ThrowingSupplier#get(BiFunction<String,Exception,RuntimeException>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "exceptionWrapper must not be null",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.function.ThrowingSupplier#get(BiFunction<String,Exception,RuntimeException>)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "handling checked exceptions",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.function.ThrowingSupplier#get(BiFunction<String,Exception,RuntimeException>)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.function.ThrowingSupplier#get(BiFunction<String,Exception,RuntimeException>) sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.function.ThrowingSupplier#get(BiFunction<String,Exception,RuntimeException>)",
      "head_type": "method",
      "relation": "have",
      "tail": "exception wrapping explanation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.function.ThrowingSupplier#get(BiFunction<String,Exception,RuntimeException>)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle for exception handling",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.function.ThrowingSupplier#get(BiFunction<String,Exception,RuntimeException>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.function.ThrowingSupplier",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.Values",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "size",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.Values",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "contains",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.Values",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "iterator",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.Values",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "clear",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.Values",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "spliterator",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.Values",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "forEach",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.Values",
      "head_type": "class",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.Values",
      "head_type": "class",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.Values",
      "head_type": "class",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.MethodInvoker#getTargetObject()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getTargetObject",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MethodInvoker#getTargetObject()",
      "head_type": "method",
      "relation": "have",
      "tail": "Return the target object on which to call the target method.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "getTargetObject",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "Return the target object on which to call the target method.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.MethodInvoker#isPrepared()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "checkPreparationStatus",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MethodInvoker#isPrepared()",
      "head_type": "method",
      "relation": "have",
      "tail": "Return whether this invoker has been prepared already, i.e. whether it allows access to getPreparedMethod() already.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.MethodInvoker#isPrepared()",
      "head_type": "method",
      "relation": "have",
      "tail": "public boolean isPrepared() { return (this.methodObject != null); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.MimeType",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "lazy loading",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MimeType",
      "head_type": "class",
      "relation": "constrained_by",
      "tail": "circular aliases are prohibited",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.MimeType",
      "head_type": "class",
      "relation": "applied_to",
      "tail": "multiple aliases for a single name",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.MimeType",
      "head_type": "class",
      "relation": "have",
      "tail": "package com.healthMgr.common.email; import java.xxxx; public class OneClass { // specific code }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.MimeType",
      "head_type": "class",
      "relation": "have",
      "tail": "org.springframework.core.SimpleAliasRegistryTests",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.MimeType",
      "head_type": "class",
      "relation": "have",
      "tail": "An explanation of related concepts",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.MimeType",
      "head_type": "class",
      "relation": "have",
      "tail": "An explanation of the design principles of the class or method",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.MimeType",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.MimeType",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.MimeType#compareTo(MimeType)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "MIME Type Comparison",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MimeType#compareTo(MimeType)",
      "head_type": "method",
      "relation": "have",
      "tail": "Compare MIME Types Alphabetically",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.MimeType#compareTo(MimeType)",
      "head_type": "method",
      "relation": "have",
      "tail": "Example Code for MIME Type Comparison",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.MimeType#compareTo(MimeType)",
      "head_type": "method",
      "relation": "have",
      "tail": "MIME Type Comparison Explanation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.MimeType#compareTo(MimeType)",
      "head_type": "method",
      "relation": "have",
      "tail": "Design Principles of MIME Type Comparison",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "MIME Type Comparison Explanation",
      "head_type": "relatedConceptInterpretation",
      "relation": "associated_with",
      "tail": "MIME Type",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "Design Principles of MIME Type Comparison",
      "head_type": "designPrincipleInterpretation",
      "relation": "associated_with",
      "tail": "Alphabetical Comparison",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.MimeType#isLessSpecific(MimeType)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "MimeType Comparison",
      "tail_type": "apiFunction"
    },
    {
      "head": "MimeType Comparison",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "Non-null MimeType Parameter",
      "tail_type": "useConstraint"
    },
    {
      "head": "MimeType Comparison",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "HTTP 1.1: Semantics and Content",
      "tail_type": "useScenario"
    },
    {
      "head": "MimeType Comparison",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "Sample Code for MimeType Comparison",
      "tail_type": "useSampleCode"
    },
    {
      "head": "MimeType Comparison",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "MimeType Hierarchy Interpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "MimeType Comparison",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "Design Principles of MimeType Comparison",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.MimeType#isLessSpecific(MimeType)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.MimeType",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.MimeTypeUtils#initRandom()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "lazyInitialization",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MimeTypeUtils#initRandom()",
      "head_type": "method",
      "relation": "have",
      "tail": "lazyInitializationOfSecureRandom",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.MimeTypeUtils#initRandom()",
      "head_type": "method",
      "relation": "have",
      "tail": "lazyInitializationOfSecureRandomForMultipartBoundary",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.MimeTypeUtils#initRandom()",
      "head_type": "method",
      "relation": "have",
      "tail": "SecureRandomInitialization",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.MimeTypeUtils#initRandom()",
      "head_type": "method",
      "relation": "have",
      "tail": "threadSafeLazyInitialization",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.MimeTypeUtils",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.MimeTypeUtils#initRandom()",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.NumberUtils",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "convertNumberToTargetClass",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.NumberUtils",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "parseNumber",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.NumberUtils",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "checkedLongValue",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.NumberUtils",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "raiseOverflowException",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.NumberUtils",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "isHexNumber",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.NumberUtils",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "decodeBigInteger",
      "tail_type": "apiFunction"
    },
    {
      "head": "convertNumberToTargetClass",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "Number conversion to target class",
      "tail_type": "useScenario"
    },
    {
      "head": "parseNumber",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "Parsing text into a Number instance",
      "tail_type": "useScenario"
    },
    {
      "head": "checkedLongValue",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "Checking for long overflow in BigInteger/BigDecimal",
      "tail_type": "useScenario"
    },
    {
      "head": "raiseOverflowException",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "Raising overflow exception for number conversion",
      "tail_type": "useScenario"
    },
    {
      "head": "isHexNumber",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "Determining if a value string indicates a hex number",
      "tail_type": "useScenario"
    },
    {
      "head": "decodeBigInteger",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "Decoding a BigInteger from a string value",
      "tail_type": "useScenario"
    },
    {
      "head": "convertNumberToTargetClass",
      "head_type": "apiFunction",
      "relation": "useSampleCode",
      "tail": "NumberUtils.convertNumberToTargetClassExample",
      "tail_type": "useSampleCode"
    },
    {
      "head": "parseNumber",
      "head_type": "apiFunction",
      "relation": "useSampleCode",
      "tail": "NumberUtils.parseNumberExample",
      "tail_type": "useSampleCode"
    },
    {
      "head": "checkedLongValue",
      "head_type": "apiFunction",
      "relation": "useSampleCode",
      "tail": "NumberUtils.checkedLongValueExample",
      "tail_type": "useSampleCode"
    },
    {
      "head": "raiseOverflowException",
      "head_type": "apiFunction",
      "relation": "useSampleCode",
      "tail": "NumberUtils.raiseOverflowExceptionExample",
      "tail_type": "useSampleCode"
    },
    {
      "head": "isHexNumber",
      "head_type": "apiFunction",
      "relation": "useSampleCode",
      "tail": "NumberUtils.isHexNumberExample",
      "tail_type": "useSampleCode"
    },
    {
      "head": "decodeBigInteger",
      "head_type": "apiFunction",
      "relation": "useSampleCode",
      "tail": "NumberUtils.decodeBigIntegerExample",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.NumberUtils",
      "head_type": "class",
      "relation": "relatedConceptInterpretation",
      "tail": "NumberUtilsRelatedConcepts",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.NumberUtils",
      "head_type": "class",
      "relation": "designPrincipleInterpretation",
      "tail": "NumberUtilsDesignPrinciples",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ObjectUtils#addObjectToArray(A[],O)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "appendObjectToArray",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ObjectUtils#addObjectToArray(A[],O)",
      "head_type": "method",
      "relation": "have",
      "tail": "appendObjectToArraySampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "appendObjectToArraySampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "appendObjectToArraySampleCodeContent",
      "tail_type": "codeContent"
    },
    {
      "head": "org.springframework.util.ObjectUtils#addObjectToArray(A[],O)",
      "head_type": "method",
      "relation": "have",
      "tail": "appendObjectToArrayRelatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "appendObjectToArrayRelatedConceptInterpretation",
      "head_type": "relatedConceptInterpretation",
      "relation": "have",
      "tail": "appendObjectToArrayRelatedConceptInterpretationContent",
      "tail_type": "interpretationContent"
    },
    {
      "head": "org.springframework.util.ObjectUtils#addObjectToArray(A[],O)",
      "head_type": "method",
      "relation": "have",
      "tail": "appendObjectToArrayDesignPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "appendObjectToArrayDesignPrincipleInterpretation",
      "head_type": "designPrincipleInterpretation",
      "relation": "have",
      "tail": "appendObjectToArrayDesignPrincipleInterpretationContent",
      "tail_type": "interpretationContent"
    },
    {
      "head": "org.springframework.util.PropertiesPersister#load(Properties,InputStream)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "load properties from InputStream",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.PropertiesPersister#load(Properties,InputStream)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "IOException in case of I/O errors",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.PropertiesPersister#load(Properties,InputStream)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "loading properties into Properties object",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.PropertiesPersister#load(Properties,InputStream)",
      "head_type": "method",
      "relation": "have",
      "tail": "java.util.Properties#load",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.PropertiesPersister#load(Properties,InputStream)",
      "head_type": "method",
      "relation": "have",
      "tail": "void load(Properties props, InputStream is) throws IOException",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.PropertiesPersister#load(Properties,InputStream)",
      "head_type": "method",
      "relation": "have",
      "tail": "efficiently handle properties loading",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.PropertiesPersister#storeToXml(Properties,OutputStream,String,String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "write contents of Properties object to XML OutputStream",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.PropertiesPersister#storeToXml(Properties,OutputStream,String,String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "IOException in case of I/O errors",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.PropertiesPersister#storeToXml(Properties,OutputStream,String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "java.util.Properties#storeToXML(java.io.OutputStream, String, String)",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.PropertiesPersister#storeToXml(Properties,OutputStream,String,String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "java.util.Properties",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.PropertiesPersister#storeToXml(Properties,OutputStream,String,String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "java.io.OutputStream",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.PropertiesPersister#storeToXml(Properties,OutputStream,String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.PropertiesPersister#storeToXml(Properties,OutputStream,String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.PropertyPlaceholderHelper#replacePlaceholders(String,PlaceholderResolver)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "replace placeholders",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.PropertyPlaceholderHelper#replacePlaceholders(String,PlaceholderResolver)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "value must not be null",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.PropertyPlaceholderHelper#replacePlaceholders(String,PlaceholderResolver)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "replace placeholders in a string",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.PropertyPlaceholderHelper#replacePlaceholders(String,PlaceholderResolver)",
      "head_type": "method",
      "relation": "have",
      "tail": "public String replacePlaceholders(String value, PlaceholderResolver placeholderResolver) {\n    Assert.notNull(value, \"'value' must not be null\");\n    return parseStringValue(value, placeholderResolver);\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.PropertyPlaceholderHelper#replacePlaceholders(String,PlaceholderResolver)",
      "head_type": "method",
      "relation": "have",
      "tail": "Replaces placeholders in a string with values obtained from a PlaceholderResolver.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.PropertyPlaceholderHelper#replacePlaceholders(String,PlaceholderResolver)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is designed to replace placeholders in a string with their corresponding values using a PlaceholderResolver. It ensures that placeholders are replaced inline within the given string.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.PropertyPlaceholderHelper",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.PropertyPlaceholderHelper#replacePlaceholders(String,PlaceholderResolver)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.ResourceUtils#toURL(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "URL conversion",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ResourceUtils#toURL(String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "location must be a valid URL",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ResourceUtils#toURL(String)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "convert location String to URL instance",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ResourceUtils#toURL(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "java.net.URL instance",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ResourceUtils#toURL(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "related to URI construction and URL conversion",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ResourceUtils#toURL(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle of robustness and flexibility",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ResourceUtils#toURL(String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "java.net.URI#toURL()",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.ResourceUtils#toURL(String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "toURI(String)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.SimpleRouteMatcher#isPattern(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "pattern matching",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.SimpleRouteMatcher#isPattern(String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.PathMatcher",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.SimpleRouteMatcher#isPattern(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "Delegates pattern checking to the internal PathMatcher instance.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.SimpleRouteMatcher#isPattern(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "public boolean isPattern(String route) { return this.pathMatcher.isPattern(route); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.StopWatch#getTaskCount()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "获取任务计时数量",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StopWatch#getTaskCount()",
      "head_type": "method",
      "relation": "have",
      "tail": "获取任务计时数量的示例代码",
      "tail_type": "useSampleCode"
    },
    {
      "head": "获取任务计时数量的示例代码",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "package com.example; import org.springframework.util.StopWatch; public class StopWatchExample { public static void main(String[] args) { StopWatch stopWatch = new StopWatch(); stopWatch.start(\"task1\"); // 模拟任务执行 stopWatch.stop(); System.out.println(\"Task count: \" + stopWatch.getTaskCount()); } }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.StopWatch#getTaskCount()",
      "head_type": "method",
      "relation": "have",
      "tail": "获取任务计时数量的相关概念解释",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "获取任务计时数量的相关概念解释",
      "head_type": "relatedConceptInterpretation",
      "relation": "have",
      "tail": "StopWatch 类用于统计执行时间，getTaskCount() 方法返回已计时的任务数量。",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.StopWatch#getTaskCount()",
      "head_type": "method",
      "relation": "have",
      "tail": "获取任务计时数量的设计原则解释",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "获取任务计时数量的设计原则解释",
      "head_type": "designPrincipleInterpretation",
      "relation": "have",
      "tail": "该方法提供了一种简单的方式来获取已执行任务的数量，有助于性能分析和监控。",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.StreamUtils#nonClosing(InputStream)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "decorating InputStream",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StreamUtils#nonClosing(InputStream)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "InputStream must not be null",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.StreamUtils#nonClosing(InputStream)",
      "head_type": "method",
      "relation": "have",
      "tail": "decorating InputStream sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.StreamUtils#nonClosing(InputStream)",
      "head_type": "method",
      "relation": "have",
      "tail": "decorating InputStream concept interpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.StreamUtils#nonClosing(InputStream)",
      "head_type": "method",
      "relation": "have",
      "tail": "decorating InputStream design principle interpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "decorating InputStream sample code",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "complete sample code for decorating InputStream",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.StringUtils#uncapitalizeAsProperty(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "uncapitalize a String in JavaBeans property format",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils#uncapitalizeAsProperty(String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "initial two letters are upper case in direct succession",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.StringUtils#uncapitalizeAsProperty(String)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "uncapitalize a String",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.StringUtils#uncapitalizeAsProperty(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "change the first letter to lower case",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.StringUtils#uncapitalizeAsProperty(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "related to JavaBeans property format",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.StringUtils#uncapitalizeAsProperty(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle of uncapitalizing strings",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.StringUtils#uncapitalizeAsProperty(String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "java.beans.Introspector#decapitalize(String)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.StringUtils#applyRelativePath(String,String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "applyRelativePath",
      "tail_type": "apiFunction"
    },
    {
      "head": "applyRelativePath",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "applyRelativePathSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "applyRelativePath",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "applyRelativePathRelatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "applyRelativePath",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "applyRelativePathDesignPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "applyRelativePathSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "applyRelativePathSampleCodeContent",
      "tail_type": "codeContent"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#addIfAbsent(K,V)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "addIfAbsent",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#addIfAbsent(K,V)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "UnsupportedOperationException",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#addIfAbsent(K,V)",
      "head_type": "method",
      "relation": "have",
      "tail": "addIfAbsent(K,V) sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#addIfAbsent(K,V)",
      "head_type": "method",
      "relation": "have",
      "tail": "related concept interpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#addIfAbsent(K,V)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle interpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#addIfAbsent(K,V)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.UnmodifiableMultiValueMap",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySet#retainAll(Collection<?>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "retainAll",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySet#retainAll(Collection<?>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "UnsupportedOperationException",
      "tail_type": "useConstraint"
    },
    {
      "head": "retainAll",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "org.springframework.util.UnmodifiableEntrySet#retainAll(Collection<?>)",
      "tail_type": "useSampleCode"
    },
    {
      "head": "retainAll",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "This method is used to retain only the elements in this set that are contained in the specified collection.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "retainAll",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "Design principle: This method follows the principle of immutability, ensuring that the set remains unmodifiable.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySpliterator",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getExactSizeIfKnown()",
      "tail_type": "apiFunction"
    },
    {
      "head": "getExactSizeIfKnown()",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "getExactSizeIfKnown() returns the exact size if known",
      "tail_type": "useSampleCode"
    },
    {
      "head": "getExactSizeIfKnown()",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "Delegate pattern used for method execution",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySpliterator",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.UnmodifiableEntrySpliterator#getExactSizeIfKnown()",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueCollection#isEmpty()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "checkEmptiness",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueCollection#isEmpty()",
      "head_type": "method",
      "relation": "have",
      "tail": "This method checks if the collection is empty.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueCollection#isEmpty()",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is part of the UnmodifiableValueCollection class, which provides a read-only view of a collection.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueCollection#isEmpty()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.UnmodifiableValueCollection",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueCollection",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "provideReadOnlyView",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueCollection",
      "head_type": "class",
      "relation": "have",
      "tail": "This class provides a read-only view of a collection, ensuring that the underlying collection cannot be modified through this view.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueCollection",
      "head_type": "class",
      "relation": "have",
      "tail": "The design principle of this class is to provide a safe way to share collections without the risk of accidental modification.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueCollection#removeIf(Predicate<? super List<V>>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "org.springframework.util.UnmodifiableValueCollection#removeIf(Predicate<? super List<V>>)",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueCollection#removeIf(Predicate<? super List<V>>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "UnsupportedOperationException",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueCollection#removeIf(Predicate<? super List<V>>)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.UnmodifiableValueCollection#removeIf(Predicate<? super List<V>>)",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueCollection#removeIf(Predicate<? super List<V>>)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.UnmodifiableValueCollection#removeIf(Predicate<? super List<V>>)",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueCollection#removeIf(Predicate<? super List<V>>)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.UnmodifiableValueCollection#removeIf(Predicate<? super List<V>>)",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueCollection#removeIf(Predicate<? super List<V>>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.UnmodifiableValueCollection",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#startDocument()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "startDocument",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#startDocument()",
      "head_type": "method",
      "relation": "have",
      "tail": "startDocumentInternal()",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#startDocument()",
      "head_type": "method",
      "relation": "have",
      "tail": "removeAllNamespaceMappings()",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#startDocument()",
      "head_type": "method",
      "relation": "have",
      "tail": "newNamespaceMapping()",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#startDocument()",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "XMLStreamException",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#startDocument()",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "SAXException",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#startDocument()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.AbstractStaxHandler",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#startDocument()",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#startDocument()",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#endDTD()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "end Document Type Definition (DTD) processing",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#endDTD()",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is called to signal the end of DTD declarations.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#endDTD()",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is part of the SAX (Simple API for XML) ContentHandler interface.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#endDTD()",
      "head_type": "method",
      "relation": "have",
      "tail": "public final void endDTD() throws SAXException",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#isNamespaceDeclaration(QName)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "namespace declaration checking",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#isNamespaceDeclaration(QName)",
      "head_type": "method",
      "relation": "have",
      "tail": "Checks if a given QName is a namespace declaration",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#isNamespaceDeclaration(QName)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method checks whether a given QName is a namespace declaration by examining its prefix and local part. If the local part is 'xmlns' and the prefix is empty, or if the prefix is 'xmlns' and the local part is not empty, it returns true, indicating that the QName is a namespace declaration.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#isNamespaceDeclaration(QName)",
      "head_type": "method",
      "relation": "have",
      "tail": "protected boolean isNamespaceDeclaration(QName qName) {\n    String prefix = qName.getPrefix();\n    String localPart = qName.getLocalPart();\n    return (XMLConstants.XMLNS_ATTRIBUTE.equals(localPart) && prefix.isEmpty()) || (XMLConstants.XMLNS_ATTRIBUTE.equals(prefix) && !localPart.isEmpty());\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#charactersInternal(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "handle characters internal",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#charactersInternal(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "protected abstract void charactersInternal(String data) throws XMLStreamException;",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "skipping an entity",
      "head_type": "method",
      "relation": "haveFunction",
      "head": "org.springframework.util.xml.AbstractStaxHandler#skippedEntityInternal(String)",
      "tail_type": "apiFunction"
    },
    {
      "tail": "used to skip an XML entity",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.xml.AbstractStaxHandler#skippedEntityInternal(String)",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "tail": "part of XML processing",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.xml.AbstractStaxHandler#skippedEntityInternal(String)",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "tail": "protected abstract void skippedEntityInternal(String name) throws XMLStreamException;",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.xml.AbstractStaxHandler#skippedEntityInternal(String)",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.StaxLocator#getPublicId()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getPublicId",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxLocator#getPublicId()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.StaxLocator",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.StaxLocator",
      "head_type": "class",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxLocator",
      "head_type": "class",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "getPublicId",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLStreamReader#getTextCharacters()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "convert text to character array",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLStreamReader#getTextCharacters()",
      "head_type": "method",
      "relation": "have",
      "tail": "convert text to character array",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLStreamReader#getTextCharacters()",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is used to retrieve the text content of an XML element and convert it into a character array. It internally calls the getText() method to get the text as a string and then converts this string into a character array using the toCharArray() method.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLStreamReader#getTextCharacters()",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is designed to efficiently handle the conversion of text data into a character array format, which can be useful for processing XML content in a more manageable way. The design principle behind this method is to provide a straightforward and performance-efficient way to access and manipulate XML text data.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLStreamReader#getTextCharacters()",
      "head_type": "method",
      "relation": "have",
      "tail": "@Override\npublic char[] getTextCharacters() {\n    return getText().toCharArray();\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.DomContentHandler#getParent()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "retrieving parent node",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.DomContentHandler#getParent()",
      "head_type": "method",
      "relation": "have",
      "tail": "This method retrieves the parent node in an XML document.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.DomContentHandler#getParent()",
      "head_type": "method",
      "relation": "have",
      "tail": "The method ensures that the structure of the XML document is maintained by correctly identifying parent-child relationships between nodes.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.DomContentHandler#getParent()",
      "head_type": "method",
      "relation": "have",
      "tail": "package com.healthMgr.common.email;\nimport org.springframework.util.xml.DomContentHandler;\npublic class OneClass {\n    public static void main(String[] args) {\n        DomContentHandler handler = new DomContentHandler();\n        Node parentNode = handler.getParent();\n        System.out.println(parentNode);\n    }\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.DomUtils#nodeNameMatch(Node,String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "node name matching",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.DomUtils#nodeNameMatch(Node,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "Matches the given node's name and local name against the given desired name.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.DomUtils#nodeNameMatch(Node,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method checks if the node's name or local name matches the desired name.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.DomUtils#nodeNameMatch(Node,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "java\nprivate static boolean nodeNameMatch(Node node, String desiredName) {\n    return (desiredName.equals(node.getNodeName()) || desiredName.equals(node.getLocalName()));\n}\n",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamHandler#dtdInternal(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "write DTD",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamHandler#dtdInternal(String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.StaxStreamHandler",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamHandler#dtdInternal(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamXMLReader#handleEndDocument()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "handleEndDocument",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamXMLReader#handleEndDocument()",
      "head_type": "method",
      "relation": "have",
      "tail": "handleEndDocument sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "handleEndDocument sample code",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "private void handleEndDocument() throws SAXException {\n    if (getContentHandler() != null) {\n        getContentHandler().endDocument();\n    }\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils#createCustomStaxSource(XMLEventReader)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "createCustomStaxSource",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils#createCustomStaxSource(XMLEventReader)",
      "head_type": "method",
      "relation": "have",
      "tail": "Create a custom, non-JAXP 1.4 StAX Source for the given XMLEventReader.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils#createCustomStaxSource(XMLEventReader)",
      "head_type": "method",
      "relation": "have",
      "tail": "public static Source createCustomStaxSource(XMLEventReader eventReader) { return new StaxSource(eventReader); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.StaxUtils#createCustomStaxSource(XMLEventReader)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter#setNamespaceContext(NamespaceContext)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "setNamespaceContext",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter#setNamespaceContext(NamespaceContext)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.XMLEventStreamWriter",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter#setNamespaceContext(NamespaceContext)",
      "head_type": "method",
      "relation": "have",
      "tail": "setNamespaceContext(NamespaceContext) Sample Code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter#writeAttribute(String,String,String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "writeAttribute",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter#writeAttribute(String,String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "writeAttributeSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "example.type.TestInterface",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "unknownFunction",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#forMemberWhenPublicClassWithPackagePrivateField()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "Access Control",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#forMemberWhenPublicClassWithPackagePrivateField()",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.aot.generate.AccessControlTests#forMemberWhenPublicClassWithPackagePrivateField() Sample Code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#forMemberWhenPublicClassWithPackagePrivateField() Sample Code",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "org.springframework.aot.generate.AccessControlTests#forMemberWhenPublicClassWithPackagePrivateField() Code Content",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#forMemberWhenPublicClassWithPackagePrivateField()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.AccessControlTests",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#forMemberWhenPublicClassWithPackagePrivateField()",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.aot.generate.AccessControlTests#forMemberWhenPublicClassWithPackagePrivateField() Related Concept Interpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#forMemberWhenPublicClassWithPackagePrivateField()",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.aot.generate.AccessControlTests#forMemberWhenPublicClassWithPackagePrivateField() Design Principle Interpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.DefaultGenerationContextTests#createWhenGeneratedFilesIsNullThrowsException()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "handle null parameters",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.DefaultGenerationContextTests#createWhenGeneratedFilesIsNullThrowsException()",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "null parameters are not allowed",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.aot.generate.DefaultGenerationContextTests#createWhenGeneratedFilesIsNullThrowsException()",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.aot.generate.DefaultGenerationContext requires non-null generatedFiles",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.DefaultGenerationContextTests#createWhenGeneratedFilesIsNullThrowsException()",
      "head_type": "method",
      "relation": "have",
      "tail": "ensuring non-null parameters is crucial for robustness",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.DefaultGenerationContextTests#createWhenGeneratedFilesIsNullThrowsException()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.DefaultGenerationContext",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.DefaultGenerationContextTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "handle null parameters",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.DefaultGenerationContextTests",
      "head_type": "class",
      "relation": "constrained_by",
      "tail": "null parameters are not allowed",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.aot.generate.DefaultGenerationContextTests",
      "head_type": "class",
      "relation": "have",
      "tail": "org.springframework.aot.generate.DefaultGenerationContext requires non-null generatedFiles",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.DefaultGenerationContextTests",
      "head_type": "class",
      "relation": "have",
      "tail": "ensuring non-null parameters is crucial for robustness",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.DefaultGenerationContextTests",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.DefaultGenerationContext",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#createWithStringCreatesMethodReference()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "create method reference with string",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#createWithStringCreatesMethodReference()",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for creating method reference with string",
      "tail_type": "useSampleCode"
    },
    {
      "head": "sample code for creating method reference with string",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "org.springframework.aot.generate.DefaultMethodReferenceTests#createWithStringCreatesMethodReference()",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.DefaultMethodReferenceTests#createWithStringCreatesMethodReference()",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#createWithStringCreatesMethodReference()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.DefaultMethodReferenceTests",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.TestComponent",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "generate test components",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.TestComponent",
      "head_type": "class",
      "relation": "have",
      "tail": "used in automated testing frameworks",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.aot.generate.TestComponent",
      "head_type": "class",
      "relation": "have",
      "tail": "related to unit testing and integration testing",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.TestComponent",
      "head_type": "class",
      "relation": "have",
      "tail": "design principle is to facilitate the creation of test components for automated testing",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.TestComponent",
      "head_type": "class",
      "relation": "have",
      "tail": "public class TestComponent { // example code }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.MethodNameTests#andNameReturnsMethodName()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "MethodName construction and concatenation",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.MethodNameTests#andNameReturnsMethodName()",
      "head_type": "method",
      "relation": "have",
      "tail": "Sample code for MethodName construction and concatenation",
      "tail_type": "useSampleCode"
    },
    {
      "head": "MethodName construction and concatenation",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "Sample code for MethodName construction and concatenation",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.PrimitiveTests#generateWhenByte()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "generateWhenByte",
      "tail_type": "apiFunction"
    },
    {
      "head": "generateWhenByte",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "generateWhenByte sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.PrimitiveTests#generateWhenByte()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.PrimitiveTests",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.CharsetTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "generateWhenCharset",
      "tail_type": "apiFunction"
    },
    {
      "head": "generateWhenCharset",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "generateWhenCharsetSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "generateWhenCharsetSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "generateWhenCharsetCodeContent",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.ArrayTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "generateWhenPrimitiveArray",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.ArrayTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "generateWhenWrapperArray",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.ArrayTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "generateWhenClassArray",
      "tail_type": "apiFunction"
    },
    {
      "head": "generateWhenPrimitiveArray",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "generateWhenPrimitiveArraySampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "generateWhenWrapperArray",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "generateWhenWrapperArraySampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "generateWhenClassArray",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "generateWhenClassArraySampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.core.type.StandardAnnotationMetadata#getAllAnnotationAttributes(String,boolean)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getAllAnnotationAttributes",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.core.type.StandardAnnotationMetadata#getAllAnnotationAttributes(String,boolean)",
      "head_type": "method",
      "relation": "have",
      "tail": "getAllAnnotationAttributes(String,boolean) Sample Code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "getAllAnnotationAttributes(String,boolean) Sample Code",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "Complete Example Code",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.AntPathStringMatcher",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "patternMatching",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.AntPathStringMatcher",
      "head_type": "class",
      "relation": "constrained_by",
      "tail": "specialCharacterSupport",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.AntPathStringMatcher",
      "head_type": "class",
      "relation": "applied_to",
      "tail": "uriTemplatePattern",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.AntPathStringMatcher",
      "head_type": "class",
      "relation": "have",
      "tail": "uriTemplatePattern",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.AntPathStringMatcher",
      "head_type": "class",
      "relation": "have",
      "tail": "patternMatchingExample",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.AntPathStringMatcher",
      "head_type": "class",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.AntPathStringMatcher",
      "head_type": "class",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "patternMatching",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "org.springframework.util.AntPathStringMatcher",
      "tail_type": "class"
    },
    {
      "head": "specialCharacterSupport",
      "head_type": "useConstraint",
      "relation": "associated_with",
      "tail": "org.springframework.util.AntPathStringMatcher",
      "tail_type": "class"
    },
    {
      "head": "uriTemplatePattern",
      "head_type": "useScenario",
      "relation": "associated_with",
      "tail": "org.springframework.util.AntPathStringMatcher",
      "tail_type": "class"
    },
    {
      "head": "relatedConceptInterpretation",
      "head_type": "relatedConceptInterpretation",
      "relation": "associated_with",
      "tail": "org.springframework.util.AntPathStringMatcher",
      "tail_type": "class"
    },
    {
      "head": "designPrincipleInterpretation",
      "head_type": "designPrincipleInterpretation",
      "relation": "associated_with",
      "tail": "org.springframework.util.AntPathStringMatcher",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.Assert#hasText(String,String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "assert valid text content",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.Assert#hasText(String,String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "text must not be null and must contain at least one non-whitespace character",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.Assert#hasText(String,String)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "checking if a string contains valid text content",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.Assert#hasText(String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "Assert.hasText(name, \"'name' must not be empty\");",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.Assert#hasText(String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "IllegalArgumentException if the text does not contain valid text content",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.Assert#hasText(String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is used to assert that a given string contains valid text content, which means it must not be null and must contain at least one non-whitespace character. If the string does not meet these criteria, an IllegalArgumentException is thrown.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.Assert#hasText(String,String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "StringUtils#hasText",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.backoff.ExponentialBackOffExecution#nextBackOff()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "exponential backoff",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.backoff.ExponentialBackOffExecution#nextBackOff()",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "max elapsed time",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.backoff.ExponentialBackOffExecution#nextBackOff()",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "max attempts",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.backoff.ExponentialBackOffExecution#nextBackOff()",
      "head_type": "method",
      "relation": "have",
      "tail": "calculate next backoff interval",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.backoff.ExponentialBackOffExecution#nextBackOff()",
      "head_type": "method",
      "relation": "have",
      "tail": "update current elapsed time",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.backoff.ExponentialBackOffExecution#nextBackOff()",
      "head_type": "method",
      "relation": "have",
      "tail": "increment attempts",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.backoff.ExponentialBackOffExecution#nextBackOff()",
      "head_type": "method",
      "relation": "have",
      "tail": "return next interval or stop",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.backoff.ExponentialBackOffExecution#nextBackOff()",
      "head_type": "method",
      "relation": "have",
      "tail": "related to retry mechanism",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.backoff.ExponentialBackOffExecution#nextBackOff()",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle: exponential backoff strategy",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.backoff.ExponentialBackOffExecution#nextBackOff()",
      "head_type": "method",
      "relation": "have",
      "tail": "public long nextBackOff() {\n    if (this.currentElapsedTime >= getMaxElapsedTime() || this.attempts >= getMaxAttempts()) {\n        return STOP;\n    }\n    long nextInterval = computeNextInterval();\n    this.currentElapsedTime += nextInterval;\n    this.attempts++;\n    return nextInterval;\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ClassUtils#isPrimitiveWrapper(Class<?>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "check if a class represents a primitive wrapper",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ClassUtils#isPrimitiveWrapper(Class<?>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "class must not be null",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ClassUtils#isPrimitiveWrapper(Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for checking if a class is a primitive wrapper",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ClassUtils#isPrimitiveWrapper(Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "related concept interpretation for primitive wrapper classes",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#isPrimitiveWrapper(Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle interpretation for checking primitive wrapper classes",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#isPrimitiveWrapper(Class<?>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.ClassUtils",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.ClassUtils#isAssignableValue(Class<?>,Object)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "determine type assignability",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ClassUtils#isAssignableValue(Class<?>,Object)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "type must not be null",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ClassUtils#isAssignableValue(Class<?>,Object)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "reflection-based type assignment",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ClassUtils#isAssignableValue(Class<?>,Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.ClassUtils#isAssignableValue(Class<?>,Object) sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ClassUtils#isAssignableValue(Class<?>,Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "related concept interpretation for org.springframework.util.ClassUtils#isAssignableValue(Class<?>,Object)",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#isAssignableValue(Class<?>,Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle interpretation for org.springframework.util.ClassUtils#isAssignableValue(Class<?>,Object)",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#isAssignableValue(Class<?>,Object)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.ClassUtils",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.ClassUtils#createCompositeInterface(Class<?>[],ClassLoader)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "createCompositeInterface",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ClassUtils#createCompositeInterface(Class<?>[],ClassLoader)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "IllegalArgumentException if the specified interfaces expose conflicting method signatures",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ClassUtils#createCompositeInterface(Class<?>[],ClassLoader)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "merging multiple interfaces into a single composite interface",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ClassUtils#createCompositeInterface(Class<?>[],ClassLoader)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for creating a composite interface",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ClassUtils#createCompositeInterface(Class<?>[],ClassLoader)",
      "head_type": "method",
      "relation": "have",
      "tail": "related concept interpretation for creating a composite interface",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#createCompositeInterface(Class<?>[],ClassLoader)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle interpretation for creating a composite interface",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.ClassUtils#createCompositeInterface(Class<?>[],ClassLoader)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.ClassUtils#isJavaLanguageInterface(Class<?>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "determining Java language interface",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ClassUtils#isJavaLanguageInterface(Class<?>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "interface must be common Java language interface",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ClassUtils#isJavaLanguageInterface(Class<?>)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "ignoring common interfaces for primary user-level interfaces",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ClassUtils#isJavaLanguageInterface(Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for determining Java language interface",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ClassUtils#isJavaLanguageInterface(Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "related concept interpretation for Java language interfaces",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#isJavaLanguageInterface(Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle interpretation for determining Java language interface",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.ClassUtils#isJavaLanguageInterface(Class<?>)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.CollectionUtils#mergePropertiesIntoMap(Properties,Map<K,V>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "mergePropertiesIntoMap",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.CollectionUtils#mergePropertiesIntoMap(Properties,Map<K,V>)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "mergePropertiesIntoMap",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.CollectionUtils#mergePropertiesIntoMap(Properties,Map<K,V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "mergePropertiesIntoMap",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.CollectionUtils#mergePropertiesIntoMap(Properties,Map<K,V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "mergePropertiesIntoMap",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.CollectionUtils#mergePropertiesIntoMap(Properties,Map<K,V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "mergePropertiesIntoMap",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "mergePropertiesIntoMap",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "Properties instance may be null",
      "tail_type": "useConstraint"
    },
    {
      "head": "mergePropertiesIntoMap",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "Map must be non-null",
      "tail_type": "useConstraint"
    },
    {
      "head": "mergePropertiesIntoMap",
      "head_type": "useScenario",
      "relation": "associated_with",
      "tail": "Properties.propertyNames()",
      "tail_type": "apiFunction"
    },
    {
      "head": "mergePropertiesIntoMap",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "tail": "org.springframework.util.CollectionUtils",
      "tail_type": "class"
    },
    {
      "head": "mergePropertiesIntoMap",
      "head_type": "relatedConceptInterpretation",
      "relation": "associated_with",
      "tail": "Properties",
      "tail_type": "class"
    },
    {
      "head": "mergePropertiesIntoMap",
      "head_type": "relatedConceptInterpretation",
      "relation": "associated_with",
      "tail": "Map",
      "tail_type": "class"
    },
    {
      "head": "mergePropertiesIntoMap",
      "head_type": "designPrincipleInterpretation",
      "relation": "associated_with",
      "tail": "Properties.propertyNames()",
      "tail_type": "apiFunction"
    },
    {
      "head": "mergePropertiesIntoMap",
      "head_type": "designPrincipleInterpretation",
      "relation": "associated_with",
      "tail": "default properties linked into the original Properties instance",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.CommonsLogWriter",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "java.io.Writer adapter",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.CommonsLogWriter",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "Commons Logging Log",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.CommonsLogWriter",
      "head_type": "class",
      "relation": "have",
      "tail": "writes characters to a buffer and logs when a newline is encountered",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.CommonsLogWriter",
      "head_type": "class",
      "relation": "have",
      "tail": "used for adapting java.io.Writer to Commons Logging Log",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.CommonsLogWriter",
      "head_type": "class",
      "relation": "have",
      "tail": "design to simplify logging by integrating Writer interface with Log",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.CommonsLogWriter",
      "head_type": "class",
      "relation": "have",
      "tail": "public class CommonsLogWriterTest {\n    @Test\n    public void testWrite() {\n        Log mockLog = mock(Log.class);\n        CommonsLogWriter writer = new CommonsLogWriter(mockLog);\n        writer.write('a');\n        writer.write('b');\n        writer.write('\\n');\n        verify(mockLog).debug(\"ab\");\n    }\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.comparator.InstanceComparator#getOrder(T)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getOrder",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.comparator.InstanceComparator#getOrder(T)",
      "head_type": "method",
      "relation": "have",
      "tail": "getOrder(T) useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "getOrder(T) useSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "private int getOrder(@Nullable T object) {\n    if (object != null) {\n        for (int i = 0; i < this.instanceOrder.length; i++) {\n            if (this.instanceOrder[i].isInstance(object)) {\n                return i;\n            }\n        }\n    }\n    return this.instanceOrder.length;\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.CompositeIterator#remove()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "remove elements",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.CompositeIterator#remove()",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "UnsupportedOperationException",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.CompositeIterator#remove()",
      "head_type": "method",
      "relation": "have",
      "tail": "CompositeIterator does not support remove()",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.CompositeIterator#remove()",
      "head_type": "method",
      "relation": "have",
      "tail": "CompositeIterator does not support remove()",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.CompositeIterator#remove()",
      "head_type": "method",
      "relation": "have",
      "tail": "CompositeIterator does not support remove()",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.CompositeSet",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "combining two sets",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.CompositeSet",
      "head_type": "class",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.CompositeSet",
      "head_type": "class",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "combining two sets",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "org.springframework.util.CompositeSet",
      "tail_type": "class"
    },
    {
      "head": "combining two sets",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "combining two sets",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "input sets must be non-null",
      "tail_type": "useConstraint"
    },
    {
      "head": "useSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "combining two sets",
      "tail_type": "apiFunction"
    },
    {
      "head": "relatedConceptInterpretation",
      "head_type": "relatedConceptInterpretation",
      "relation": "have",
      "tail": "org.springframework.util.CompositeSet",
      "tail_type": "class"
    },
    {
      "head": "designPrincipleInterpretation",
      "head_type": "designPrincipleInterpretation",
      "relation": "have",
      "tail": "org.springframework.util.CompositeSet",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.concurrent.DelegatingCompletableFuture",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "cancel a delegate along with the CompletableFuture itself",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.concurrent.DelegatingCompletableFuture",
      "head_type": "class",
      "relation": "constrained_by",
      "tail": "Delegate must not be null",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.concurrent.DelegatingCompletableFuture",
      "head_type": "class",
      "relation": "have",
      "tail": "Extension of CompletableFuture which allows for cancelling a delegate along with the CompletableFuture itself",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.concurrent.DelegatingCompletableFuture",
      "head_type": "class",
      "relation": "have",
      "tail": "The class is designed to extend CompletableFuture and provide additional functionality for managing and cancelling asynchronous tasks.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.concurrent.DelegatingCompletableFuture",
      "head_type": "class",
      "relation": "have",
      "tail": "package org.springframework.util.concurrent;\n\nimport java.util.concurrent.Future;\nimport java.util.concurrent.CompletableFuture;\nimport org.springframework.util.Assert;\n\npublic class DelegatingCompletableFuture<T> extends CompletableFuture<T> {\n    private final Future<T> delegate;\n\n    public DelegatingCompletableFuture(Future<T> delegate) {\n        Assert.notNull(delegate, \"Delegate must not be null\");\n        this.delegate = delegate;\n    }\n\n    @Override\n    public boolean cancel(boolean mayInterruptIfRunning) {\n        boolean result = this.delegate.cancel(mayInterruptIfRunning);\n        super.cancel(mayInterruptIfRunning);\n        return result;\n    }\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.EntryIterator",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "entryIteration",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.EntryIterator",
      "head_type": "class",
      "relation": "have",
      "tail": "Internal entry iterator implementation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "entryIteration",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "Internal entry iterator implementation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.EntryIterator",
      "head_type": "class",
      "relation": "have",
      "tail": "private int segmentIndex;\nprivate int referenceIndex;\n@Nullable\nprivate Reference<K, V> @Nullable [] references;\n@Nullable\nprivate Reference<K, V> reference;\n@Nullable\nprivate Entry<K, V> next;\n@Nullable\nprivate Entry<K, V> last;\npublic EntryIterator() {\n    moveToNextSegment();\n}\n@Override\npublic boolean hasNext() {\n    getNextIfNecessary();\n    return (this.next != null);\n}\n@Override\npublic Entry<K, V> next() {\n    getNextIfNecessary();\n    if (this.next == null) {\n        throw new NoSuchElementException();\n    }\n    this.last = this.next;\n    this.next = null;\n    return this.last;\n}\nprivate void getNextIfNecessary() {\n    while (this.next == null) {\n        moveToNextReference();\n        if (this.reference == null) {\n            return;\n        }\n        this.next = this.reference.get();\n    }\n}\nprivate void moveToNextReference() {\n    if (this.reference != null) {\n        this.reference = this.reference.getNext();\n    }\n    while (this.reference == null && this.references != null) {\n        if (this.referenceIndex >= this.references.length) {\n            moveToNextSegment();\n            this.referenceIndex = 0;\n        } else {\n            this.reference = this.references[this.referenceIndex];\n            this.referenceIndex++;\n        }\n    }\n}\nprivate void moveToNextSegment() {\n    this.reference = null;\n    this.references = null;\n    if (this.segmentIndex < ConcurrentReferenceHashMap.this.segments.length) {\n        this.references = ConcurrentReferenceHashMap.this.segments[this.segmentIndex].references;\n        this.segmentIndex++;\n    }\n}\n@Override\npublic void remove() {\n    Assert.state(this.last != null, \"No element to remove\");\n    ConcurrentReferenceHashMap.this.remove(this.last.getKey());\n    this.last = null;\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.WeakEntryReference#getHash()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getHash",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.WeakEntryReference#getHash()",
      "head_type": "method",
      "relation": "have",
      "tail": "getHash returns the hash code of the referenced entry",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.WeakEntryReference#getHash()",
      "head_type": "method",
      "relation": "have",
      "tail": "getHash is overridden to provide a custom hash code calculation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.WeakEntryReference#getHash()",
      "head_type": "method",
      "relation": "have",
      "tail": "public int getHash() { return this.hash; }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.FastByteArrayOutputStream#toString()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "convertStreamContentsToString",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.FastByteArrayOutputStream#toString()",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "defaultCharsetDecoding",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.FastByteArrayOutputStream#toString()",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "streamContentDecoding",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.FastByteArrayOutputStream#toString()",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.FastByteArrayOutputStream#toString()",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.FastByteArrayOutputStream#toString()",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "convertStreamContentsToString",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "java.nio.charset.CharsetDecoder",
      "tail_type": "class"
    },
    {
      "head": "defaultCharsetDecoding",
      "head_type": "useConstraint",
      "relation": "associated_with",
      "tail": "java.nio.charset.Charset",
      "tail_type": "class"
    },
    {
      "head": "streamContentDecoding",
      "head_type": "useScenario",
      "relation": "associated_with",
      "tail": "org.springframework.util.FastByteArrayOutputStream",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.FastByteArrayInputStream#read(byte[])",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "read data into byte array",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.FastByteArrayInputStream#read(byte[])",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.FastByteArrayInputStream#read(byte[], int, int)",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.FastByteArrayInputStream#read(byte[])",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "java.io.InputStream",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.FastByteArrayInputStream#read(byte[])",
      "head_type": "method",
      "relation": "designPrincipleInterpretation",
      "tail": "Efficiency and simplicity in reading data into a byte array.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.FileSystemUtils#copyRecursively(File,File)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "recursive file/directory copying",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.FileSystemUtils#copyRecursively(File,File)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "source and destination must not be null",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.FileSystemUtils#copyRecursively(File,File)",
      "head_type": "method",
      "relation": "have",
      "tail": "copying files/directories",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.FileSystemUtils#copyRecursively(File,File)",
      "head_type": "method",
      "relation": "have",
      "tail": "IOException handling",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.FileSystemUtils#copyRecursively(File,File)",
      "head_type": "method",
      "relation": "have",
      "tail": "efficient file handling",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.FileSystemUtils#copyRecursively(File,File)",
      "head_type": "method",
      "relation": "have",
      "tail": "public static void copyRecursively(File src, File dest) throws IOException {\n    Assert.notNull(src, \"Source File must not be null\");\n    Assert.notNull(dest, \"Destination File must not be null\");\n    copyRecursively(src.toPath(), dest.toPath());\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.LinkedCaseInsensitiveMap#convertKey(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "convertKey",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.LinkedCaseInsensitiveMap#convertKey(String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "key must be a string",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.LinkedCaseInsensitiveMap#convertKey(String)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "case-insensitive key conversion",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.LinkedCaseInsensitiveMap#convertKey(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "Convert the given key to a case-insensitive key.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.LinkedCaseInsensitiveMap#convertKey(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "The default implementation converts the key to lower-case according to this Map's Locale.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.LinkedCaseInsensitiveMap#convertKey(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "package com.healthMgr.common.email; import java.util.Locale; public class LinkedCaseInsensitiveMapExample { public static void main(String[] args) { LinkedCaseInsensitiveMap map = new LinkedCaseInsensitiveMap(); map.put(\"Key\", \"Value\"); String key = map.convertKey(\"KEY\"); System.out.println(map.get(key)); } }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.KeySet",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "size",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.KeySet",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "contains",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.KeySet",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "iterator",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.KeySet",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "remove",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.KeySet",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "clear",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.KeySet",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "spliterator",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.KeySet",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "forEach",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.KeySet",
      "head_type": "class",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.KeySet",
      "head_type": "class",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.KeySet",
      "head_type": "class",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.Values#contains(Object)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "contains",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.Values#contains(Object)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.Values",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.Values",
      "head_type": "class",
      "relation": "have",
      "tail": "org.springframework.util.Values#contains(Object)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.MethodInvoker#setTargetObject(Object)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "setTargetObject",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MethodInvoker#setTargetObject(Object)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "targetMethodNotStatic",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.MethodInvoker#setTargetObject(Object)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "nonStaticMethodInvocation",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.MethodInvoker#setTargetObject(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "setTargetObjectSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.MethodInvoker#setTargetObject(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.MethodInvoker#setTargetObject(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.MethodInvoker#setTargetObject(Object)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.MethodInvoker",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.MimeType#getParameter(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "return a generic parameter value",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MimeType#getParameter(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "Return a generic parameter value, given a parameter name.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.MimeType#getParameter(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "The method retrieves a parameter value based on the provided parameter name. If the parameter is not present, it returns null.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.MimeType#getParameter(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "public String getParameter(String name) {\n    return this.parameters.get(name);\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.MultiToSingleValueMapAdapter#isEmpty()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "checkEmptiness",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MultiToSingleValueMapAdapter#isEmpty()",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.MultiToSingleValueMapAdapter#isEmpty()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.MultiToSingleValueMapAdapter",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.MultiValueMap#addAll(K,List<? extends V>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "Add values to list",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MultiValueMap#addAll(K,List<? extends V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "Add all the values of the given list to the current list of values for the given key.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.MultiValueMap#addAll(K,List<? extends V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "public void addAll(K key, List<? extends V> values) { ... }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.MultiValueMap#addAll(K,List<? extends V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "Add all values from a list to the current list of values for a specific key.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.MultiValueMapAdapter#setAll(Map<K,V>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "set values",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MultiValueMapAdapter#setAll(Map<K,V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "setAll method implementation",
      "tail_type": "useSampleCode"
    },
    {
      "head": "setAll method implementation",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "public void setAll(Map<K, V> values) { values.forEach(this::set); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.MultiValueMapAdapter#put(K,List<V>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "add a list of values to a specific key",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MultiValueMapAdapter#put(K,List<V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for adding a list of values to a specific key",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.MultiValueMapAdapter#put(K,List<V>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.MultiValueMapAdapter",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.MultiValueMapAdapter#keySet()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "keySetRetrieval",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MultiValueMapAdapter#keySet()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.MultiValueMapAdapter",
      "tail_type": "class"
    },
    {
      "head": "keySetRetrieval",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "keySetRetrieval",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "keySetRetrieval",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.MultiValueMapAdapter#values()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "retrieve values from MultiValueMap",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MultiValueMapAdapter#values()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "MultiValueMap",
      "tail_type": "class"
    },
    {
      "head": "retrieve values from MultiValueMap",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "useSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "Complete Java Example for Retrieving Values",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.NumberUtils#parseNumber(String,Class<T>,NumberFormat)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "parseNumber",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.NumberUtils#parseNumber(String,Class<T>,NumberFormat)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "IllegalArgumentException if the target class is not supported",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.NumberUtils#parseNumber(String,Class<T>,NumberFormat)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "parse the given text into a Number instance of the given target class",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.NumberUtils#parseNumber(String,Class<T>,NumberFormat)",
      "head_type": "method",
      "relation": "have",
      "tail": "complete sample code for using parseNumber",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.NumberUtils#parseNumber(String,Class<T>,NumberFormat)",
      "head_type": "method",
      "relation": "have",
      "tail": "related concept interpretation for parseNumber",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.NumberUtils#parseNumber(String,Class<T>,NumberFormat)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle interpretation for parseNumber",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.NumberUtils#parseNumber(String,Class<T>,NumberFormat)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "java.text.NumberFormat",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.NumberUtils#parseNumber(String,Class<T>,NumberFormat)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.NumberUtils",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.NumberUtils#decodeBigInteger(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "decode a BigInteger from a String",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.NumberUtils#decodeBigInteger(String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "Supports decimal, hex, and octal notation",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.NumberUtils#decodeBigInteger(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "Decode a BigInteger from a String",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.NumberUtils#decodeBigInteger(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "Handles minus sign, radix specifier, and different notations",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.NumberUtils#decodeBigInteger(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "private static BigInteger decodeBigInteger(String value) {\n    int radix = 10;\n    int index = 0;\n    boolean negative = false;\n    // Handle minus sign, if present.\n    if (value.startsWith(\"-\")) {\n        negative = true;\n        index++;\n    }\n    // Handle radix specifier, if present.\n    if (value.startsWith(\"0x\", index) || value.startsWith(\"0X\", index)) {\n        index += 2;\n        radix = 16;\n    } else if (value.startsWith(\"#\", index)) {\n        index++;\n        radix = 16;\n    } else if (value.startsWith(\"0\", index) && value.length() > 1 + index) {\n        index++;\n        radix = 8;\n    }\n    BigInteger result = new BigInteger(value.substring(index), radix);\n    return (negative ? result.negate() : result);\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ObjectUtils",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "nullSafeHashCode(long[])",
      "tail_type": "apiFunction"
    },
    {
      "head": "nullSafeHashCode(long[])",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "deprecated as of 6.1",
      "tail_type": "useConstraint"
    },
    {
      "head": "nullSafeHashCode(long[])",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "return a hash code based on the contents of the specified array",
      "tail_type": "useScenario"
    },
    {
      "head": "nullSafeHashCode(long[])",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "public static int nullSafeHashCode(long @Nullable [] array) { return Arrays.hashCode(array); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "nullSafeHashCode(long[])",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "nullSafeHashCode(long[])",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ObjectUtils",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "java.util.Arrays",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.PathMatcher#matchStart(String,String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "pathMatching",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.PathMatcher#matchStart(String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "pathMatchingDescription",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "pathMatchingDescription",
      "head_type": "relatedConceptInterpretation",
      "relation": "associated_with",
      "tail": "org.springframework.util.PathMatcher",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.PathMatcher#matchStart(String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "pathMatchingSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "pathMatchingSampleCode",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "tail": "org.springframework.util.PathMatcher",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.PlaceholderParser",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "lazy loading",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.PlaceholderParser",
      "head_type": "class",
      "relation": "constrained_by",
      "tail": "circular aliases are prohibited",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.PlaceholderParser",
      "head_type": "class",
      "relation": "applied_to",
      "tail": "multiple aliases for a single name",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.PlaceholderParser",
      "head_type": "class",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.PlaceholderParser",
      "head_type": "class",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.PlaceholderParser",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.core.SimpleAliasRegistryTests",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.PartResolutionContext#parse(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "parseStringToParts",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.PartResolutionContext#parse(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.PartResolutionContext#parse(String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.PartResolutionContext",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.Part#text()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "textual representation",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.Part#text()",
      "head_type": "method",
      "relation": "have",
      "tail": "Provide a textual representation of this part.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.Part#text()",
      "head_type": "method",
      "relation": "have",
      "tail": "Returns the raw text that this part defines.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.Part#text()",
      "head_type": "method",
      "relation": "have",
      "tail": "String text();",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.AbstractPart",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "resolveRecursively",
      "tail_type": "apiFunction"
    },
    {
      "head": "resolveRecursively",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "null resolution if placeholder has no value",
      "tail_type": "useConstraint"
    },
    {
      "head": "resolveRecursively",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "nested placeholder resolution",
      "tail_type": "useScenario"
    },
    {
      "head": "resolveRecursively",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "sample code for resolveRecursively",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.AbstractPart",
      "head_type": "class",
      "relation": "have",
      "tail": "base Part implementation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.AbstractPart",
      "head_type": "class",
      "relation": "have",
      "tail": "design principle of AbstractPart",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.PlaceholderResolutionException#getValues()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "return contextualized list",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.PlaceholderResolutionException#getValues()",
      "head_type": "method",
      "relation": "have",
      "tail": "Return a contextualized list of the resolution attempts that led to this exception, where the first element is the value that generated this exception.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.PlaceholderResolutionException#getValues()",
      "head_type": "method",
      "relation": "have",
      "tail": "public List<String> getValues() {\n    return this.values;\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#handleReflectionException(Exception)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "handle reflection exception",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#handleReflectionException(Exception)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "no checked exception expected",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#handleReflectionException(Exception)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "accessing method or field",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#handleReflectionException(Exception)",
      "head_type": "method",
      "relation": "have",
      "tail": "handle reflection exception sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#handleReflectionException(Exception)",
      "head_type": "method",
      "relation": "have",
      "tail": "reflection exception handling explanation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#handleReflectionException(Exception)",
      "head_type": "method",
      "relation": "have",
      "tail": "reflection exception handling design principle",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#getField(Field,Object)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getField",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#getField(Field,Object)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "fieldAccessibility",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#getField(Field,Object)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "fieldRetrieval",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#getField(Field,Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "handleReflectionException",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#getField(Field,Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "reflectionExceptionHandling",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#getField(Field,Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "accessingFieldsThroughReflection",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#getField(Field,Object)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "Field",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#getField(Field,Object)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "Object",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.FieldFilter#and(FieldFilter)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "composite filter creation",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.FieldFilter#and(FieldFilter)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "FieldFilter argument must not be null",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.FieldFilter#and(FieldFilter)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "applying multiple filters sequentially",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.FieldFilter#and(FieldFilter)",
      "head_type": "method",
      "relation": "have",
      "tail": "Create a composite filter based on this filter <em>and</em> the provided filter. <p>If this filter does not match, the next filter will not be applied.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.FieldFilter#and(FieldFilter)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method facilitates the creation of a composite FieldFilter by combining the current filter with another provided filter. It ensures that both filters must match for a field to be accepted. If the current filter does not match, the next filter is not evaluated, optimizing the filtering process.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.FieldFilter#and(FieldFilter)",
      "head_type": "method",
      "relation": "have",
      "tail": "package com.healthMgr.common.email; import java.xxxx; public class OneClass { // specific code }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.FieldFilter#and(FieldFilter)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.FieldFilter",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.SimpleRouteMatcher#combine(String,String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "combining patterns",
      "tail_type": "apiFunction"
    },
    {
      "head": "combining patterns",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "combining two patterns into one",
      "tail_type": "useScenario"
    },
    {
      "head": "combining patterns",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "sample code for combining patterns",
      "tail_type": "useSampleCode"
    },
    {
      "head": "combining patterns",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "related concept interpretation for combining patterns",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "combining patterns",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "design principle interpretation for combining patterns",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.SimpleRouteMatcher#match(String,Route)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "pattern matching",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.SimpleRouteMatcher#match(String,Route)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is used to determine if a given pattern matches a route.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.SimpleRouteMatcher#match(String,Route)",
      "head_type": "method",
      "relation": "have",
      "tail": "The design principle behind this method is to provide a flexible and efficient way to match patterns against routes, which is essential for routing mechanisms in web applications.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.SimpleRouteMatcher#match(String,Route)",
      "head_type": "method",
      "relation": "have",
      "tail": "java\npackage org.springframework.util;\n\nimport org.springframework.web.util.pattern.PathPatternRouteMatcher;\n\npublic class SimpleRouteMatcher {\n    private PathMatcher pathMatcher;\n\n    public SimpleRouteMatcher(PathMatcher pathMatcher) {\n        this.pathMatcher = pathMatcher;\n    }\n\n    public boolean match(String pattern, Route route) {\n        return this.pathMatcher.match(pattern, route.value());\n    }\n}\n",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.SingleToMultiValueMapAdapter#values()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "convert single value map to multi value map",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.SingleToMultiValueMapAdapter#values()",
      "head_type": "method",
      "relation": "have",
      "tail": "convert single value map to multi value map sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "convert single value map to multi value map sample code",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "package com.healthMgr.common.map;\nimport org.springframework.util.SingleToMultiValueMapAdapter;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\n\nclass SingleToMultiValueMapAdapterExample {\n    public static void main(String[] args) {\n        SingleToMultiValueMapAdapter<String, String> adapter = new SingleToMultiValueMapAdapter<>();\n        adapter.putSingleValue(\"key\", \"value1\");\n        adapter.putSingleValue(\"key\", \"value2\");\n        Collection<List<String>> values = adapter.values();\n        for (List<String> valueList : values) {\n            for (String value : valueList) {\n                System.out.println(value);\n            }\n        }\n    }\n}",
      "tail_type": "String"
    },
    {
      "head": "org.springframework.util.SingleToMultiValueMapAdapter#values()",
      "head_type": "method",
      "relation": "have",
      "tail": "related concept interpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "related concept interpretation",
      "head_type": "relatedConceptInterpretation",
      "relation": "have",
      "tail": "This method is used to convert a single value map to a multi value map. It is useful when you need to handle multiple values for a single key in a map.",
      "tail_type": "String"
    },
    {
      "head": "org.springframework.util.SingleToMultiValueMapAdapter#values()",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle interpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "design principle interpretation",
      "head_type": "designPrincipleInterpretation",
      "relation": "have",
      "tail": "This method follows the principle of encapsulation and lazy initialization. It encapsulates the logic to convert a single value map to a multi value map and initializes the values only when needed.",
      "tail_type": "String"
    },
    {
      "head": "org.springframework.util.StreamUtils#copyToByteArray(InputStream)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "copy contents of InputStream to byte array",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StreamUtils#copyToByteArray(InputStream)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "stream may be null or empty",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.StreamUtils#copyToByteArray(InputStream)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "copying data from an InputStream",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.StreamUtils#copyToByteArray(InputStream)",
      "head_type": "method",
      "relation": "have",
      "tail": "public static byte[] copyToByteArray(@Nullable InputStream in) throws IOException { if (in == null) { return EMPTY_CONTENT; } return in.readAllBytes(); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.StreamUtils#copyToByteArray(InputStream)",
      "head_type": "method",
      "relation": "have",
      "tail": "related to handling InputStreams and byte arrays",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.StreamUtils#copyToByteArray(InputStream)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle of handling streams efficiently",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.StreamUtils#copyToByteArray(InputStream)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "java.io.InputStream",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.StreamUtils#copyToByteArray(InputStream)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "java.io.IOException",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.StringUtils#addStringToArray(String[],String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "Appending String to Array",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils#addStringToArray(String[],String)",
      "head_type": "method",
      "relation": "have",
      "tail": "Appending String to Array Sample Code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "Appending String to Array Sample Code",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "package com.healthMgr.common.util; import org.springframework.util.StringUtils; public class AppendStringToArrayExample { public static void main(String[] args) { String[] originalArray = {\"Hello\", \"World\"}; String newString = \"!\"; String[] newArray = StringUtils.addStringToArray(originalArray, newString); for (String s : newArray) { System.out.println(s); } } }",
      "tail_type": "code"
    },
    {
      "head": "org.springframework.util.StringUtils#addStringToArray(String[],String)",
      "head_type": "method",
      "relation": "have",
      "tail": "Appending String to Array Related Concept Interpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "Appending String to Array Related Concept Interpretation",
      "head_type": "relatedConceptInterpretation",
      "relation": "have",
      "tail": "Appending a string to an array involves creating a new array with an increased size to accommodate the new element. This operation is common in dynamic programming and data manipulation, where the size of the data structure needs to be adjusted dynamically.",
      "tail_type": "description"
    },
    {
      "head": "org.springframework.util.StringUtils#addStringToArray(String[],String)",
      "head_type": "method",
      "relation": "have",
      "tail": "Appending String to Array Design Principle Interpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "Appending String to Array Design Principle Interpretation",
      "head_type": "designPrincipleInterpretation",
      "relation": "have",
      "tail": "The design principle behind this method is to provide a utility function that abstracts the common task of appending an element to an array. This method ensures immutability by returning a new array rather than modifying the original one, which is a best practice in Java to avoid side effects.",
      "tail_type": "description"
    },
    {
      "head": "org.springframework.util.StringValueResolver#resolveStringValue(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "parsing placeholders",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringValueResolver#resolveStringValue(String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "IllegalArgumentException in case of an unresolvable String value",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.StringValueResolver#resolveStringValue(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "resolve the given String value, for example parsing placeholders",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "parsing placeholders",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "resolve the given String value, for example parsing placeholders",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "IllegalArgumentException in case of an unresolvable String value",
      "head_type": "useConstraint",
      "relation": "have",
      "tail": "resolve the given String value, for example parsing placeholders",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.unit.DataSize#ofMegabytes(long)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "representing the specified number of megabytes",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.unit.DataSize#ofMegabytes(long)",
      "head_type": "method",
      "relation": "have",
      "tail": "Obtain a DataSize representing the specified number of megabytes",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.unit.DataSize#ofMegabytes(long)",
      "head_type": "method",
      "relation": "have",
      "tail": "The method returns a DataSize object which represents the specified number of megabytes",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.unit.DataSize#ofMegabytes(long)",
      "head_type": "method",
      "relation": "have",
      "tail": "The method uses Math.multiplyExact to calculate the number of bytes",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.unit.DataSize#ofMegabytes(long)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "DataSize",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#set(K,V)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "org.springframework.util.UnmodifiableMultiValueMap#set(K,V)",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#set(K,V)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "UnsupportedOperationException",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#set(K,V)",
      "head_type": "method",
      "relation": "have",
      "tail": "public void set(K key, @Nullable V value) { throw new UnsupportedOperationException(); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#set(K,V)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#set(K,V)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#computeIfPresent(K,BiFunction<? super K,? super List<V>,? extends List<V>>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "computeIfPresent",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#computeIfPresent(K,BiFunction<? super K,? super List<V>,? extends List<V>>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "UnsupportedOperationException",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#computeIfPresent(K,BiFunction<? super K,? super List<V>,? extends List<V>>)",
      "head_type": "method",
      "relation": "have",
      "tail": "computeIfPresent throws UnsupportedOperationException",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#computeIfPresent(K,BiFunction<? super K,? super List<V>,? extends List<V>>)",
      "head_type": "method",
      "relation": "have",
      "tail": "UnmodifiableMultiValueMap does not support computeIfPresent operation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#computeIfPresent(K,BiFunction<? super K,? super List<V>,? extends List<V>>)",
      "head_type": "method",
      "relation": "have",
      "tail": "Design principle of UnmodifiableMultiValueMap",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySet#parallelStream()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "parallelStream",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySet#parallelStream()",
      "head_type": "method",
      "relation": "have",
      "tail": "StreamSupport.stream(spliterator(), true)",
      "tail_type": "useSampleCode"
    },
    {
      "head": "StreamSupport.stream(spliterator(), true)",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "tail": "Stream",
      "tail_type": "class"
    },
    {
      "head": "StreamSupport.stream(spliterator(), true)",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "tail": "Spliterator",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySet#parallelStream()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.UnmodifiableEntrySet",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySpliterator#characteristics()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "characteristics",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySpliterator#characteristics()",
      "head_type": "method",
      "relation": "have",
      "tail": "characteristics() method delegate call",
      "tail_type": "useSampleCode"
    },
    {
      "head": "characteristics() method delegate call",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "tail": "org.springframework.util.UnmodifiableEntrySpliterator",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySpliterator#characteristics()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.UnmodifiableEntrySpliterator",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueCollection#parallelStream()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "parallelStream",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueCollection#parallelStream()",
      "head_type": "method",
      "relation": "have",
      "tail": "Stream<List<V>>",
      "tail_type": "useSampleCode"
    },
    {
      "head": "Stream<List<V>>",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "tail": "StreamSupport.stream(spliterator(), true)",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueCollection#parallelStream()",
      "head_type": "method",
      "relation": "have",
      "tail": "StreamSupport.stream(spliterator(), true)",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueCollection#clear()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "clearing a collection",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueCollection#clear()",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "operation not supported",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueCollection#clear()",
      "head_type": "method",
      "relation": "have",
      "tail": "throwing an UnsupportedOperationException",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueCollection#clear()",
      "head_type": "method",
      "relation": "have",
      "tail": "related to unmodifiable collections",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueCollection#clear()",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle of immutability",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#endCDATA()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "endCDATA",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#endCDATA()",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is used to handle the end of a CDATA section.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#endCDATA()",
      "head_type": "method",
      "relation": "have",
      "tail": "public final void endCDATA() throws SAXException { this.inCData = false; }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#commentInternal(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "comment processing",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#commentInternal(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.xml.AbstractStaxHandler#commentInternal(String) useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#commentInternal(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.xml.AbstractStaxHandler#commentInternal(String) relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#commentInternal(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.xml.AbstractStaxHandler#commentInternal(String) designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#commentInternal(String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.AbstractStaxHandler",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLEventReader",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "nextEvent",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLEventReader",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "remove",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLEventReader",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getProperty",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLEventReader",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "close",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLEventReader",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "checkIfClosed",
      "tail_type": "apiFunction"
    },
    {
      "head": "next",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "XMLStreamException",
      "tail_type": "useConstraint"
    },
    {
      "head": "getProperty",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "IllegalArgumentException",
      "tail_type": "useConstraint"
    },
    {
      "head": "checkIfClosed",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "XMLStreamException",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLEventReader",
      "head_type": "class",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLEventReader",
      "head_type": "class",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLEventReader",
      "head_type": "class",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLEventReader",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "XMLEventReader",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLEventReader",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "Arjen Poutsma",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLEventReader",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "Juergen Hoeller",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.DomContentHandler#ignorableWhitespace(char[],int,int)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "handleIgnorableWhitespace",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.DomContentHandler#ignorableWhitespace(char[],int,int)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.xml.DomContentHandler",
      "tail_type": "class"
    },
    {
      "head": "handleIgnorableWhitespace",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.DomContentHandler",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.SimpleNamespaceContext#setBindings(Map<String,String>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "set namespace bindings",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.SimpleNamespaceContext#setBindings(Map<String,String>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "map must consist of string key value pairs",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.xml.SimpleNamespaceContext#setBindings(Map<String,String>)",
      "head_type": "method",
      "relation": "have",
      "tail": "Set the bindings for this namespace context. The supplied map must consist of string key value pairs.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.SimpleNamespaceContext#setBindings(Map<String,String>)",
      "head_type": "method",
      "relation": "have",
      "tail": "public void setBindings(Map<String, String> bindings) { bindings.forEach(this::bindNamespaceUri); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.StaxEventHandler#commentInternal(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "xml comment processing",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxEventHandler#commentInternal(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "xml comment processing sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "xml comment processing sample code",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "xml comment processing sample code content",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.StaxEventHandler#commentInternal(String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.StaxEventHandler",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.LocatorLocationAdapter#getColumnNumber()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getColumnNumber",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.LocatorLocationAdapter#getColumnNumber()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.LocatorLocationAdapter",
      "tail_type": "class"
    },
    {
      "head": "getColumnNumber",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "This method returns the column number where the current document event ends.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "getColumnNumber",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "The method is part of the DOM Location interface and is used to obtain the column number of the current node in the parsed XML document.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "getColumnNumber",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "package com.example.xmlparsing;\n\nimport org.springframework.util.xml.LocatorLocationAdapter;\nimport org.xml.sax.Locator;\n\npublic class XMLParser {\n    public static void main(String[] args) {\n        Locator locator = new LocatorLocationAdapter();\n        // Assuming the locator is set up with a column number\n        int columnNumber = locator.getColumnNumber();\n        System.out.println(\"Column Number: \" + columnNumber);\n    }\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamHandler#endDocumentInternal()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "end XML document processing",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamHandler#endDocumentInternal()",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is used to signal the end of an XML document processing.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamHandler#endDocumentInternal()",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is part of the StAX API which is used for pull-parsing XML documents.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamHandler#endDocumentInternal()",
      "head_type": "method",
      "relation": "have",
      "tail": "protected void endDocumentInternal() throws XMLStreamException {\n    this.streamWriter.writeEndDocument();\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamHandler#processingInstructionInternal(String,String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "writeProcessingInstruction",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamHandler#processingInstructionInternal(String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "Write a processing instruction to the output stream.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamHandler#processingInstructionInternal(String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "Ensure that the processing instruction is properly formatted and written to the output stream.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamHandler#processingInstructionInternal(String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "package com.healthMgr.common.email; import java.io.StringWriter; import javax.xml.stream.XMLOutputFactory; import javax.xml.stream.XMLStreamWriter; import org.springframework.util.xml.StaxStreamHandler; import org.springframework.util.xml.XMLEventStreamHandler; import java.io.IOException; import javax.xml.stream.XMLStreamException; import javax.xml.stream.events.ProcessingInstruction; public class OneClass { public static void main(String[] args) throws XMLStreamException, IOException { StringWriter writer = new StringWriter(); XMLOutputFactory factory = XMLOutputFactory.newInstance(); XMLStreamWriter streamWriter = factory.createXMLStreamWriter(writer); StaxStreamHandler handler = new StaxStreamHandler(streamWriter); String target = \"target\"; String data = \"data\"; handler.processingInstruction(target, data); ProcessingInstruction pi = factory.createProcessingInstruction(target, data); System.out.println(writer.toString()); } }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils#createContentHandler(XMLStreamWriter)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "createContentHandler",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils#createContentHandler(XMLStreamWriter)",
      "head_type": "method",
      "relation": "have",
      "tail": "Create a SAX ContentHandler that writes to the given StAX XMLStreamWriter.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils#createContentHandler(XMLStreamWriter)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method facilitates the integration between SAX and StAX XML processing by creating a ContentHandler that outputs to a given XMLStreamWriter.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils#createContentHandler(XMLStreamWriter)",
      "head_type": "method",
      "relation": "have",
      "tail": "public static ContentHandler createContentHandler(XMLStreamWriter streamWriter) {\n    return new StaxStreamHandler(streamWriter);\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "createContentHandler",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "ContentHandler",
      "tail_type": "class"
    },
    {
      "head": "createContentHandler",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "XMLStreamWriter",
      "tail_type": "class"
    },
    {
      "head": "createContentHandler",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "StaxStreamHandler",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.TransformerUtils#disableIndenting(Transformer)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "Disable indenting",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.TransformerUtils#disableIndenting(Transformer)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "Transformer must not be null",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.xml.TransformerUtils#disableIndenting(Transformer)",
      "head_type": "method",
      "relation": "have",
      "tail": "Disable indenting for the supplied Transformer",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.TransformerUtils#disableIndenting(Transformer)",
      "head_type": "method",
      "relation": "have",
      "tail": "Sample code to disable indenting",
      "tail_type": "useSampleCode"
    },
    {
      "head": "Disable indenting",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "Transformer",
      "tail_type": "class"
    },
    {
      "head": "Disable indenting for the supplied Transformer",
      "head_type": "relatedConceptInterpretation",
      "relation": "associated_with",
      "tail": "javax.xml.transform.Transformer",
      "tail_type": "class"
    },
    {
      "head": "Sample code to disable indenting",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "tail": "javax.xml.transform.Transformer",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamReader#getProperty(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getProperty",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamReader#getProperty(String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.XMLEventStreamReader",
      "tail_type": "class"
    },
    {
      "head": "getProperty",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamReader#getAttributeValue(int)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getAttributeValue",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamReader#getAttributeValue(int)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.XMLEventStreamReader",
      "tail_type": "class"
    },
    {
      "head": "getAttributeValue",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "This method is used to get the value of an attribute at a specified index in an XML element.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "getAttributeValue",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "public String getAttributeValue(int index) { return getAttribute(index).getValue(); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamReader#getAttribute(int)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getAttribute",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamReader#getAttribute(int)",
      "head_type": "method",
      "relation": "have",
      "tail": "getAttributeUseSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "getAttributeUseSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "package com.healthMgr.common.xml;\nimport org.springframework.util.xml.XMLEventStreamReader;\nimport javax.xml.stream.events.Attribute;\nimport javax.xml.stream.events.XMLEvent;\n\npublic class XMLAttributeExample {\n    public static void main(String[] args) {\n        XMLEventStreamReader reader = new XMLEventStreamReader();\n        // Assuming reader is properly initialized and points to a start element\n        try {\n            Attribute attribute = reader.getAttribute(0);\n            System.out.println(\"Attribute value: \" + attribute.getValue());\n        } catch (IllegalArgumentException | IllegalStateException e) {\n            e.printStackTrace();\n        }\n    }\n}",
      "tail_type": "String"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter#getNamespaceContext()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getNamespaceContext",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter#getNamespaceContext()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.XMLEventStreamWriter",
      "tail_type": "class"
    },
    {
      "head": "getNamespaceContext",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "Retrieves the namespace context",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "getNamespaceContext",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "public NamespaceContext getNamespaceContext() { return this.eventWriter.getNamespaceContext(); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter#writeEmptyElement(String,String,String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "write an empty XML element",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter#writeEmptyElement(String,String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is used to write an empty XML element with the specified prefix, local name, and namespace URI.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter#writeEmptyElement(String,String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "The design principle behind this method is to provide a way to write an empty XML element, which is a common requirement in XML processing.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter#writeEmptyElement(String,String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "java\nimport org.springframework.util.xml.XMLEventStreamWriter;\nimport javax.xml.stream.XMLStreamException;\n\npublic class Example {\n    public static void main(String[] args) throws XMLStreamException {\n        XMLEventStreamWriter writer = new XMLEventStreamWriter();\n        writer.writeEmptyElement(\"prefix\", \"localName\", \"namespaceURI\");\n    }\n}\n",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter#writeEndDocument()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "write end document",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter#writeEndDocument()",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for writeEndDocument",
      "tail_type": "useSampleCode"
    },
    {
      "head": "sample code for writeEndDocument",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "complete sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "a.NestedClass",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "nestedClassFunctionality",
      "tail_type": "apiFunction"
    },
    {
      "head": "a.NestedClass",
      "head_type": "class",
      "relation": "constrained_by",
      "tail": "nestedClassConstraints",
      "tail_type": "useConstraint"
    },
    {
      "head": "a.NestedClass",
      "head_type": "class",
      "relation": "applied_to",
      "tail": "nestedClassScenarios",
      "tail_type": "useScenario"
    },
    {
      "head": "a.NestedClass",
      "head_type": "class",
      "relation": "have",
      "tail": "nestedClassSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "a.NestedClass",
      "head_type": "class",
      "relation": "have",
      "tail": "nestedClassRelatedConcepts",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "a.NestedClass",
      "head_type": "class",
      "relation": "have",
      "tail": "nestedClassDesignPrinciples",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "a.NestedClass",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "relatedClassOrMethod",
      "tail_type": "class"
    },
    {
      "head": "example.type.AnnotatedComponent",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "componentAnnotation",
      "tail_type": "apiFunction"
    },
    {
      "head": "example.type.AnnotatedComponent",
      "head_type": "class",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "example.type.AnnotatedComponent",
      "head_type": "class",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "example.type.AnnotatedComponent",
      "head_type": "class",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "example.type.SomeInterface",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "unknownFunctionality",
      "tail_type": "apiFunction"
    },
    {
      "head": "example.type.SomeClassExtendingSomeClassExtendingSomeClassAndImplementingSomeInterface",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "exampleFunctionality",
      "tail_type": "apiFunction"
    },
    {
      "head": "example.type.SomeClassExtendingSomeClassExtendingSomeClassAndImplementingSomeInterface",
      "head_type": "class",
      "relation": "constrained_by",
      "tail": "exampleConstraint",
      "tail_type": "useConstraint"
    },
    {
      "head": "example.type.SomeClassExtendingSomeClassExtendingSomeClassAndImplementingSomeInterface",
      "head_type": "class",
      "relation": "applied_to",
      "tail": "exampleScenario",
      "tail_type": "useScenario"
    },
    {
      "head": "example.type.SomeClassExtendingSomeClassExtendingSomeClassAndImplementingSomeInterface",
      "head_type": "class",
      "relation": "have",
      "tail": "exampleSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "example.type.SomeClassExtendingSomeClassExtendingSomeClassAndImplementingSomeInterface",
      "head_type": "class",
      "relation": "have",
      "tail": "exampleRelatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "example.type.SomeClassExtendingSomeClassExtendingSomeClassAndImplementingSomeInterface",
      "head_type": "class",
      "relation": "have",
      "tail": "exampleDesignPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "example.type.SomeClassExtendingSomeClassExtendingSomeClassAndImplementingSomeInterface",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "example.type.AnotherClass",
      "tail_type": "class"
    },
    {
      "head": "example.type.SomeDaoLikeInterface",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "dataPersistence",
      "tail_type": "apiFunction"
    },
    {
      "head": "example.type.SomeDaoLikeInterface",
      "head_type": "class",
      "relation": "constrained_by",
      "tail": "threadSafety",
      "tail_type": "useConstraint"
    },
    {
      "head": "example.type.SomeDaoLikeInterface",
      "head_type": "class",
      "relation": "applied_to",
      "tail": "databaseInteraction",
      "tail_type": "useScenario"
    },
    {
      "head": "example.type.SomeDaoLikeInterface",
      "head_type": "class",
      "relation": "have",
      "tail": "sampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "example.type.SomeDaoLikeInterface",
      "head_type": "class",
      "relation": "have",
      "tail": " persistenceLayerExplanation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "example.type.SomeDaoLikeInterface",
      "head_type": "class",
      "relation": "have",
      "tail": "designPrinciples",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#forMemberWhenPackagePrivateConstructor()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "Access Control",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#forMemberWhenPackagePrivateConstructor()",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.aot.generate.AccessControlTests#forMemberWhenPackagePrivateConstructor() Sample Code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#forMemberWhenPackagePrivateConstructor() Sample Code",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "org.springframework.aot.generate.AccessControlTests#forMemberWhenPackagePrivateConstructor() Code Content",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithMatchingArgs()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "generate method reference",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithMatchingArgs()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "generate code block",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithMatchingArgs()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "generate argument code",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithMatchingArgs()",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "useSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithMatchingArgs() sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithMatchingArgs()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.DefaultMethodReferenceTests",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithMatchingArgs()",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "relatedConceptInterpretation",
      "head_type": "relatedConceptInterpretation",
      "relation": "have",
      "tail": "MethodReference is used to generate code blocks for method invocations.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithMatchingArgs()",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "designPrincipleInterpretation",
      "head_type": "designPrincipleInterpretation",
      "relation": "have",
      "tail": "This method follows the principle of code generation, aiming to automate the process of generating method invocation code blocks based on method references and argument types.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassesTests#getOrAddForFeatureComponentWhenNewReturnsGeneratedClass()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "generate and manage classes for feature components",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassesTests#getOrAddForFeatureComponentWhenNewReturnsGeneratedClass()",
      "head_type": "method",
      "relation": "have",
      "tail": "getOrAddForFeatureComponentWhenNewReturnsGeneratedClass() sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "getOrAddForFeatureComponentWhenNewReturnsGeneratedClass() sample code",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "package org.springframework.aot.generate;\n\nimport org.junit.jupiter.api.Test;\nimport static org.assertj.core.api.Assertions.assertThat;\n\npublic class GeneratedClassesTests {\n\n    @Test\n    void getOrAddForFeatureComponentWhenNewReturnsGeneratedClass() {\n        GeneratedClass generatedClass1 = this.generatedClasses.getOrAddForFeatureComponent(\"one\", TestComponent.class, emptyTypeCustomizer);\n        GeneratedClass generatedClass2 = this.generatedClasses.getOrAddForFeatureComponent(\"two\", TestComponent.class, emptyTypeCustomizer);\n        assertThat(generatedClass1).isNotNull().isNotEqualTo(generatedClass2);\n        assertThat(generatedClass2).isNotNull();\n    }\n}",
      "tail_type": "code"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassesTests",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.GeneratedClassesTests#getOrAddForFeatureComponentWhenNewReturnsGeneratedClass()",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassesTests",
      "head_type": "class",
      "relation": "have",
      "tail": "related concept interpretation for GeneratedClassesTests",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "related concept interpretation for GeneratedClassesTests",
      "head_type": "relatedConceptInterpretation",
      "relation": "have",
      "tail": "GeneratedClassesTests is a test class designed to verify the functionality of generating and managing classes for feature components in the Spring framework. It ensures that new classes are generated and managed correctly when new feature components are added.",
      "tail_type": "description"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassesTests",
      "head_type": "class",
      "relation": "have",
      "tail": "design principle interpretation for GeneratedClassesTests",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "design principle interpretation for GeneratedClassesTests",
      "head_type": "designPrincipleInterpretation",
      "relation": "have",
      "tail": "GeneratedClassesTests follows the principle of ensuring that each feature component is associated with a unique generated class. This design ensures that the generated classes are correctly managed and that the functionality of the feature components is preserved during the code generation process.",
      "tail_type": "description"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getEnclosingNameOnTopLevelClassReturnsNull",
      "tail_type": "apiFunction"
    },
    {
      "head": "getEnclosingNameOnTopLevelClassReturnsNull",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "GeneratedClass generatedClass = createGeneratedClass(TEST_CLASS_NAME); assertThat(generatedClass.getEnclosingClass()).isNull();",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassTests",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.GeneratedClass",
      "tail_type": "class"
    },
    {
      "head": "getEnclosingNameOnTopLevelClassReturnsNull",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "Verify that the getEnclosingClass method returns null for a top-level class.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "getEnclosingNameOnTopLevelClassReturnsNull",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "This test ensures that the GeneratedClass correctly identifies top-level classes by returning null for their enclosing class.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests#addSourceFileWithInputStreamSourceAddsFile()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "addSourceFileWithInputStream",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests#addSourceFileWithInputStreamSourceAddsFile()",
      "head_type": "method",
      "relation": "have",
      "tail": "addSourceFileWithInputStreamSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "addSourceFileWithInputStreamSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "org.springframework.aot.generate.GeneratedFilesTests#addSourceFileWithInputStreamSourceAddsFile()",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.GeneratedFilesTests#addSourceFileWithInputStreamSourceAddsFile()",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests#addSourceFileWithInputStreamSourceAddsFile()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.GeneratedFilesTests",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.InMemoryGeneratedFilesTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getGeneratedFileWhenFileIsMissingReturnsNull",
      "tail_type": "apiFunction"
    },
    {
      "head": "getGeneratedFileWhenFileIsMissingReturnsNull",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "getGeneratedFileWhenFileIsMissingReturnsNull() { this.generatedFiles.addResourceFile(\"META-INF/test\", \"test\"); assertThat(this.generatedFiles.getGeneratedFile(Kind.RESOURCE, \"META-INF/missing\")).isNull(); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "getGeneratedFileWhenFileIsMissingReturnsNull",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "This method tests the behavior of getGeneratedFile when the requested file is missing. It adds a resource file, then checks if getGeneratedFile returns null for a missing file.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "getGeneratedFileWhenFileIsMissingReturnsNull",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "The design principle here is to ensure that the method behaves correctly when a file is not found, returning null as expected.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.MethodNameTests#andPartsWhenPartsIsNullThrowsException()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "handle null input",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.MethodNameTests#andPartsWhenPartsIsNullThrowsException()",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "null input not allowed",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.aot.generate.MethodNameTests#andPartsWhenPartsIsNullThrowsException()",
      "head_type": "method",
      "relation": "have",
      "tail": "use sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.MethodNameTests#andPartsWhenPartsIsNullThrowsException()",
      "head_type": "method",
      "relation": "have",
      "tail": "related concept interpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.MethodNameTests#andPartsWhenPartsIsNullThrowsException()",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle interpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.MethodNameTests#andPartsWhenPartsIsNullThrowsException()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.MethodNameTests",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.ProtectedAccessor",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "methodWithProtectedParameter",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.ProtectedAccessor",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "methodWithProtectedReturnType",
      "tail_type": "apiFunction"
    },
    {
      "head": "methodWithProtectedParameter",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "methodWithProtectedReturnType",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.hint.annotation.RegisterReflectionReflectiveProcessorTests#hasOnlyMemberCategories(MemberCategory)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "validateTypeHintMemberCategories",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.hint.annotation.RegisterReflectionReflectiveProcessorTests#hasOnlyMemberCategories(MemberCategory)",
      "head_type": "method",
      "relation": "have",
      "tail": "validateTypeHintMemberCategoriesSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "validateTypeHintMemberCategoriesSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "private Consumer<TypeHint> hasOnlyMemberCategories(MemberCategory... categories) {\n    return typeHint -> {\n        assertThat(typeHint.fields()).isEmpty();\n        assertThat(typeHint.methods()).isEmpty();\n        assertThat(typeHint.constructors()).isEmpty();\n        assertThat(typeHint.getMemberCategories()).containsOnly(categories);\n    };\n}",
      "tail_type": "code"
    },
    {
      "head": "org.springframework.core.type.MethodMetadata#isStatic()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "determine if method is static",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.core.type.MethodMetadata#isStatic()",
      "head_type": "method",
      "relation": "have",
      "tail": "Check if the method is declared as 'static'.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.core.type.MethodMetadata#isStatic()",
      "head_type": "method",
      "relation": "have",
      "tail": "boolean isStatic();",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.core.type.StandardMethodMetadata#isOverridable()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "checkMethodOverrideEligibility",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.core.type.StandardMethodMetadata#isOverridable()",
      "head_type": "method",
      "relation": "have",
      "tail": "sampleCodeForIsOverridable",
      "tail_type": "useSampleCode"
    },
    {
      "head": "sampleCodeForIsOverridable",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "completeExampleForIsOverridable",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.AntPathStringMatcher#matchStrings(String,Map<String,String>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "string matching",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.AntPathStringMatcher#matchStrings(String,Map<String,String>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "number of capturing groups must match URI template variables",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.AntPathStringMatcher#matchStrings(String,Map<String,String>)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "matching strings against a pattern",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.AntPathStringMatcher#matchStrings(String,Map<String,String>)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for matching strings",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.AntPathStringMatcher#matchStrings(String,Map<String,String>)",
      "head_type": "method",
      "relation": "have",
      "tail": "related concept interpretation for string matching",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.AntPathStringMatcher#matchStrings(String,Map<String,String>)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle interpretation for string matching",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.AntPathStringMatcher#matchStrings(String,Map<String,String>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.AntPathStringMatcher",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.PatternInfo",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getSingleWildcards()",
      "tail_type": "apiFunction"
    },
    {
      "head": "getSingleWildcards()",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "org.springframework.util.PatternInfo",
      "tail_type": "class"
    },
    {
      "head": "getSingleWildcards()",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.PatternInfo#isPrefixPattern()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "prefix pattern checking",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.PatternInfo#isPrefixPattern()",
      "head_type": "method",
      "relation": "have",
      "tail": "Checks if the pattern is a prefix pattern.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.PatternInfo#isPrefixPattern()",
      "head_type": "method",
      "relation": "have",
      "tail": "public boolean isPrefixPattern() {\n    return this.prefixPattern;\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.AutoPopulatingList#clear()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "clearing elements",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.AutoPopulatingList#clear()",
      "head_type": "method",
      "relation": "have",
      "tail": "Clears all elements from the backing list.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.AutoPopulatingList#clear()",
      "head_type": "method",
      "relation": "have",
      "tail": "public void clear() { this.backingList.clear(); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.AutoPopulatingList#clear()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.AutoPopulatingList",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.AutoPopulatingList",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "managing a dynamic list",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.AutoPopulatingList",
      "head_type": "class",
      "relation": "have",
      "tail": "This class extends the functionality of a regular list by automatically populating elements as needed.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.AutoPopulatingList",
      "head_type": "class",
      "relation": "have",
      "tail": "public void clear() { this.backingList.clear(); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.comparator.BooleanComparator#toString()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "convert boolean comparison result to string",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.comparator.BooleanComparator#toString()",
      "head_type": "method",
      "relation": "have",
      "tail": "public String toString() { return \"BooleanComparator: \" + (this.trueLow ? \"true low\" : \"true high\"); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.comparator.BooleanComparator#toString()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.comparator.BooleanComparator",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.comparator.NullSafeComparator#toString()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "toString",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.comparator.NullSafeComparator#toString()",
      "head_type": "method",
      "relation": "have",
      "tail": "NullSafeComparator: non-null comparator [comparator]; nulls low",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.comparator.NullSafeComparator#toString()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.comparator.NullSafeComparator",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.CompositeCollection#toArray(T[])",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "convert collection to array",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.CompositeCollection#toArray(T[])",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "type of array must match the type of collection elements",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.CompositeCollection#toArray(T[])",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "convert a collection to an array when the array type is known",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.CompositeCollection#toArray(T[])",
      "head_type": "method",
      "relation": "have",
      "tail": "public <T> T[] toArray(@Nullable T[] a) { ... }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.CompositeCollection#toArray(T[])",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is used to convert a collection into an array. It takes an array as a parameter and returns an array of the same type. If the provided array is large enough to hold all the elements of the collection, it is used directly. Otherwise, a new array of the appropriate size is created. The method iterates over the collection and fills the array with the elements of the collection. If the array is larger than the collection, the remaining elements of the array are set to null.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.CompositeCollection#toArray(T[])",
      "head_type": "method",
      "relation": "have",
      "tail": "The design principle behind this method is to provide a convenient way to convert a collection into an array. It ensures that the type of the array matches the type of elements in the collection, which helps to avoid runtime type errors. The method is designed to be efficient by reusing the provided array if it is large enough, thereby reducing the need for additional memory allocation.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.CompositeCollection#toArray(T[])",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.CompositeCollection",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.CompositeMap#size()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "sizeCalculation",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.CompositeMap#size()",
      "head_type": "method",
      "relation": "have",
      "tail": "sizeCalculationSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "sizeCalculationSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "Complete sizeCalculation Example",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ConcurrentReferenceHashMap#clear()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "clearing contents",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ConcurrentReferenceHashMap#clear()",
      "head_type": "method",
      "relation": "have",
      "tail": "Clears all mappings from this map",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ConcurrentReferenceHashMap#clear()",
      "head_type": "method",
      "relation": "have",
      "tail": "This method iterates over all segments and calls the clear method on each segment",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ConcurrentReferenceHashMap#clear()",
      "head_type": "method",
      "relation": "have",
      "tail": "Design principle: Ensure thread-safe clearing of all segments",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.Segment#createReferenceArray(int)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "createReferenceArray",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.Segment#createReferenceArray(int)",
      "head_type": "method",
      "relation": "have",
      "tail": "createReferenceArray(int) sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "createReferenceArray(int) sample code",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "private Reference<K, V>[] createReferenceArray(int size) { return new Reference[size]; }",
      "tail_type": "code"
    },
    {
      "head": "org.springframework.util.Reference#getNext()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "reference chaining",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.Reference#getNext()",
      "head_type": "method",
      "relation": "have",
      "tail": "Return the next reference in the chain, or null if none.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.Reference#getNext()",
      "head_type": "method",
      "relation": "have",
      "tail": "public Reference<K, V> getNext() { return next; }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.Reference",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.Reference#getNext()",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.SoftEntryReference#getHash()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getHash",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.SoftEntryReference#getHash()",
      "head_type": "method",
      "relation": "have",
      "tail": "Calculate hash value",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.SoftEntryReference#getHash()",
      "head_type": "method",
      "relation": "have",
      "tail": "Efficient hash retrieval",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.SoftEntryReference#getHash()",
      "head_type": "method",
      "relation": "have",
      "tail": "public int getHash() { return this.hash; }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.SoftEntryReference#release()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "release",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.SoftEntryReference#release()",
      "head_type": "method",
      "relation": "have",
      "tail": "release method implementation",
      "tail_type": "useSampleCode"
    },
    {
      "head": "release method implementation",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "tail": "SoftEntryReference",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.ErrorHandler",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "handleError",
      "tail_type": "apiFunction"
    },
    {
      "head": "handleError",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "Throwable parameter",
      "tail_type": "useConstraint"
    },
    {
      "head": "handleError",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "asynchronous task execution",
      "tail_type": "useScenario"
    },
    {
      "head": "handleError",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "void handleError(Throwable t);",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ErrorHandler",
      "head_type": "class",
      "relation": "have",
      "tail": "A strategy for handling errors. This is especially useful for handling errors that occur during asynchronous execution of tasks that have been submitted to a TaskScheduler. In such cases, it may not be possible to throw the error to the original caller.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ErrorHandler",
      "head_type": "class",
      "relation": "have",
      "tail": "Author: Mark Fisher, Since: 3.0",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.FileSystemUtils#deleteRecursively(File)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "deleteRecursively",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.FileSystemUtils#deleteRecursively(File)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "I/O errors handled silently",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.FileSystemUtils#deleteRecursively(File)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "deleting directories and files recursively",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.FileSystemUtils#deleteRecursively(File)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for deleting files recursively",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.FileSystemUtils#deleteRecursively(File)",
      "head_type": "method",
      "relation": "have",
      "tail": "related concept interpretation for deleting files recursively",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.FileSystemUtils#deleteRecursively(File)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle interpretation for deleting files recursively",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.FileSystemUtils#deleteRecursively(File)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.FileSystemUtils",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.function.SingletonSupplier#ofNullable(Supplier<? extends T>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "build SingletonSupplier",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.function.SingletonSupplier#ofNullable(Supplier<? extends T>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "supplier can be null",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.function.SingletonSupplier#ofNullable(Supplier<? extends T>)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "instance supplier potentially null",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.function.SingletonSupplier#ofNullable(Supplier<? extends T>)",
      "head_type": "method",
      "relation": "have",
      "tail": "public static SingletonSupplier ofNullable(Supplier supplier) { return (supplier != null ? new SingletonSupplier(supplier) : null); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.function.SingletonSupplier#ofNullable(Supplier<? extends T>)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.function.SingletonSupplier#ofNullable(Supplier<? extends T>)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.function.SingletonSupplier#ofNullable(Supplier<? extends T>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "SingletonSupplier",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.function.ThrowingBiFunction#applyWithException(T,U)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "applying a function with exception handling",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.function.ThrowingBiFunction#applyWithException(T,U)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "must throw checked exceptions",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.function.ThrowingBiFunction#applyWithException(T,U)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "scenarios requiring exception handling in functional interfaces",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.function.ThrowingBiFunction#applyWithException(T,U)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code demonstrating function application with exception handling",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.function.ThrowingBiFunction#applyWithException(T,U)",
      "head_type": "method",
      "relation": "have",
      "tail": "detailed explanation of checked exceptions in Java",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.function.ThrowingBiFunction#applyWithException(T,U)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principles behind exception handling in functional interfaces",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.function.ThrowingBiFunction#applyWithException(T,U)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.function.ThrowingBiFunction",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.LinkedCaseInsensitiveMap#clear()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "clearing a map",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.LinkedCaseInsensitiveMap#clear()",
      "head_type": "method",
      "relation": "have",
      "tail": "removes all mappings from the map",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.LinkedCaseInsensitiveMap#clear()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.LinkedCaseInsensitiveMap",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.LinkedCaseInsensitiveMap",
      "head_type": "class",
      "relation": "have",
      "tail": "caseInsensitiveKeys",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.LinkedCaseInsensitiveMap",
      "head_type": "class",
      "relation": "have",
      "tail": "targetMap",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.LinkedCaseInsensitiveMap#clear()",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle of clearing maps efficiently",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.LinkedCaseInsensitiveMap#entrySet()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "entrySet",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.LinkedCaseInsensitiveMap#entrySet()",
      "head_type": "method",
      "relation": "have",
      "tail": "Lazy Initialization",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.LinkedCaseInsensitiveMap#entrySet()",
      "head_type": "method",
      "relation": "have",
      "tail": "Efficiency",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.LinkedCaseInsensitiveMap#entrySet()",
      "head_type": "method",
      "relation": "have",
      "tail": "Thread Safety",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.LinkedCaseInsensitiveMap#entrySet()",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.LinkedCaseInsensitiveMap",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.LinkedCaseInsensitiveMap#entrySet()",
      "head_type": "method",
      "relation": "have",
      "tail": "Caching",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.LinkedCaseInsensitiveMap#entrySet()",
      "head_type": "method",
      "relation": "have",
      "tail": "Complete Example",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.EntrySet",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "delegateInitialization",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.EntrySet",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "sizeRetrieval",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.EntrySet",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "objectContainmentCheck",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.EntrySet",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "entryIteration",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.EntrySet",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "entryRemoval",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.EntrySet",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "clearingEntries",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.EntrySet",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "entrySpliteration",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.EntrySet",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "forEachAction",
      "tail_type": "apiFunction"
    },
    {
      "head": "delegateInitialization",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "sizeRetrieval",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "objectContainmentCheck",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "entryIteration",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "entryRemoval",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "clearingEntries",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "entrySpliteration",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "forEachAction",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "useSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "completeSampleCode",
      "tail_type": "completeSampleCode"
    },
    {
      "head": "org.springframework.util.EntryIterator#nextEntry()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "Entry retrieval",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.EntryIterator#nextEntry()",
      "head_type": "method",
      "relation": "have",
      "tail": "Retrieves the next entry from the delegate iterator",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.EntryIterator#nextEntry()",
      "head_type": "method",
      "relation": "have",
      "tail": "Updates the last entry to the current one",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.EntryIterator#nextEntry()",
      "head_type": "method",
      "relation": "have",
      "tail": "package com.example.util; import java.util.Iterator; import java.util.Map; public class EntryIteratorExample { public static void main(String[] args) { Map<String, String> map = Map.of(\"key1\", \"value1\", \"key2\", \"value2\"); Iterator<Map.Entry<String, String>> iterator = map.entrySet().iterator(); while (iterator.hasNext()) { Map.Entry<String, String> entry = iterator.next(); System.out.println(\"Key: \" + entry.getKey() + \", Value: \" + entry.getValue()); } } }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.EntrySetIterator",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "Entry retrieval",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.EntrySetIterator",
      "head_type": "class",
      "relation": "have",
      "tail": "next() method implementation",
      "tail_type": "useSampleCode"
    },
    {
      "head": "next() method implementation",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "Entry retrieval",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MethodInvoker#resolveClassName(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "resolve the given class name into a Class",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MethodInvoker#resolveClassName(String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "className must be valid",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.MethodInvoker#resolveClassName(String)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "resolving class names",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.MethodInvoker#resolveClassName(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for resolving class names",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.MethodInvoker#resolveClassName(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "ClassUtils.forName is used for resolving",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.MethodInvoker#resolveClassName(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle of using thread context class loader",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.MethodInvoker#resolveClassName(String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "ClassUtils",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.MimeTypeUtils#parseMimeType(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "parseMimeType",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MimeTypeUtils#parseMimeType(String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "InvalidMimeTypeException",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.MimeTypeUtils#parseMimeType(String)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "parsing a single MimeType from a string",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.MimeTypeUtils#parseMimeType(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for parsing MimeType",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.MimeTypeUtils#parseMimeType(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "MimeType parsing explanation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.MimeTypeUtils#parseMimeType(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle behind MimeType parsing",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.MimeTypeUtils#parseMimeType(String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "MimeType",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.MultiToSingleValueMapAdapter#containsKey(Object)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "check key existence",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MultiToSingleValueMapAdapter#containsKey(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.MultiToSingleValueMapAdapter#containsKey(Object) sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.MultiToSingleValueMapAdapter#containsKey(Object) sample code",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "package com.example.demo; import org.springframework.util.MultiToSingleValueMapAdapter; import java.util.HashMap; import java.util.Map; public class SampleCode { public static void main(String[] args) { MultiToSingleValueMapAdapter<String, String> adapter = new MultiToSingleValueMapAdapter<>(new HashMap<>()); adapter.add(\"key\", \"value\"); boolean containsKey = adapter.containsKey(\"key\"); System.out.println(\"Contains key: \" + containsKey); } }",
      "tail_type": "code"
    },
    {
      "head": "org.springframework.util.MultiValueMap#getFirst(K)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "retrieveFirstValue",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MultiValueMap#getFirst(K)",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.MultiValueMap#getFirst(K)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.MultiValueMap#getFirst(K)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "retrieveFirstValue",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "org.springframework.util.MultiValueMap#getFirst(K)",
      "tail_type": "method"
    },
    {
      "head": "useSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "org.springframework.util.MultiValueMap#getFirst(K)",
      "tail_type": "method"
    },
    {
      "head": "relatedConceptInterpretation",
      "head_type": "relatedConceptInterpretation",
      "relation": "have",
      "tail": "org.springframework.util.MultiValueMap#getFirst(K)",
      "tail_type": "method"
    },
    {
      "head": "designPrincipleInterpretation",
      "head_type": "designPrincipleInterpretation",
      "relation": "have",
      "tail": "org.springframework.util.MultiValueMap#getFirst(K)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeToString(short[])",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "String representation of array",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeToString(short[])",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "array must not be null",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeToString(short[])",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "convert array to String",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeToString(short[])",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for array to String conversion",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeToString(short[])",
      "head_type": "method",
      "relation": "have",
      "tail": "explanation of StringJoiner usage",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeToString(short[])",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle of null safety",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ObjectUtils",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.ObjectUtils#nullSafeToString(short[])",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.AbstractPart#toText(List<Part>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "concatenation of part texts",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.AbstractPart#toText(List<Part>)",
      "head_type": "method",
      "relation": "have",
      "tail": "StringBuilder used for concatenation",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.AbstractPart#toText(List<Part>)",
      "head_type": "method",
      "relation": "have",
      "tail": "forEach loop to append part text",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.AbstractPart#toText(List<Part>)",
      "head_type": "method",
      "relation": "have",
      "tail": "StringBuilder",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.AbstractPart#toText(List<Part>)",
      "head_type": "method",
      "relation": "have",
      "tail": "Efficiency in string concatenation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#rethrowRuntimeException(Throwable)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "rethrowing runtime exceptions",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#rethrowRuntimeException(Throwable)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "should only be called if no checked exception is expected",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#rethrowRuntimeException(Throwable)",
      "head_type": "method",
      "relation": "have",
      "tail": "rethrowing underlying exception as RuntimeException or Error",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#rethrowRuntimeException(Throwable)",
      "head_type": "method",
      "relation": "have",
      "tail": "public static void rethrowRuntimeException(@Nullable Throwable ex) { if (ex instanceof RuntimeException runtimeException) { throw runtimeException; } if (ex instanceof Error error) { throw error; } throw new UndeclaredThrowableException(ex); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#rethrowRuntimeException(Throwable)",
      "head_type": "method",
      "relation": "have",
      "tail": "used to handle exceptions thrown by reflection methods",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#rethrowRuntimeException(Throwable)",
      "head_type": "method",
      "relation": "have",
      "tail": "simplifies exception handling by rethrowing runtime exceptions and errors",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#rethrowRuntimeException(Throwable)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.ReflectionUtils",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.ResourceUtils#getFile(URL)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "Resolving a resource URL to a file",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ResourceUtils#getFile(URL)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "FileNotFoundException if URL cannot be resolved",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ResourceUtils#getFile(URL)",
      "head_type": "method",
      "relation": "have",
      "tail": "Resolving a resource URL to a file in the file system",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ResourceUtils#getFile(URL)",
      "head_type": "method",
      "relation": "have",
      "tail": "public static File getFile(URL resourceUrl) throws FileNotFoundException { return getFile(resourceUrl, \"URL\"); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ResourceUtils#getFile(URL)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "java.io.File",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.ResourceUtils#getFile(URL)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is used to resolve a resource URL to a java.io.File object, which represents a file in the file system. It throws a FileNotFoundException if the URL cannot be resolved to a file.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ResourceUtils#getFile(URL)",
      "head_type": "method",
      "relation": "have",
      "tail": "The design principle behind this method is to provide a straightforward way to convert a resource URL into a File object, simplifying file operations within an application. It ensures that resources can be easily accessed and manipulated, adhering to the principle of ease of use and practicality.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ResourceUtils#getFile(URI,String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "Resolving a resource URI to a file",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ResourceUtils#getFile(URI,String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "Resource URI must not be null",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ResourceUtils#getFile(URI,String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "URI must reside in the file system",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ResourceUtils#getFile(URI,String)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "Resolving a file path from a resource URI",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ResourceUtils#getFile(URI,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "public static File getFile(URI resourceUri, String description) throws FileNotFoundException {\n    Assert.notNull(resourceUri, \"Resource URI must not be null\");\n    if (!URL_PROTOCOL_FILE.equals(resourceUri.getScheme())) {\n        throw new FileNotFoundException(description + \" cannot be resolved to absolute file path \" + \"because it does not reside in the file system: \" + resourceUri);\n    }\n    return new File(resourceUri.getSchemeSpecificPart());\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ResourceUtils#getFile(URI,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is used to resolve a resource URI to a java.io.File object. It ensures that the given URI points to a file in the file system and returns a corresponding File object. If the URI does not reside in the file system, it throws a FileNotFoundException.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ResourceUtils#getFile(URI,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "The design principle behind this method is to provide a straightforward way to convert a resource URI to a File object, ensuring that the URI is valid and points to a file within the file system. It emphasizes robust error handling by throwing a FileNotFoundException when the URI cannot be resolved to a file path.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ResourceUtils#getFile(URI,String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "java.io.File",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.ResourceUtils#getFile(URI,String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "URI",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.ResourceUtils#getFile(URI,String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "FileNotFoundException",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.StopWatch#currentTaskName()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "current task name retrieval",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StopWatch#currentTaskName()",
      "head_type": "method",
      "relation": "have",
      "tail": "Get the name of the currently running task, if any.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.StopWatch#currentTaskName()",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is used to retrieve the name of the task that is currently running. It returns the name of the task if there is one running, otherwise it returns null.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.StopWatch#currentTaskName()",
      "head_type": "method",
      "relation": "have",
      "tail": "public String currentTaskName() {\n    return this.currentTaskName;\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.SystemPropertyUtils#resolvePlaceholders(String,boolean)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "resolvePlaceholders",
      "tail_type": "apiFunction"
    },
    {
      "head": "resolvePlaceholders",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "IllegalArgumentException if there is an unresolvable placeholder",
      "tail_type": "useConstraint"
    },
    {
      "head": "resolvePlaceholders",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "replace placeholders in the given text with corresponding system property values",
      "tail_type": "useScenario"
    },
    {
      "head": "resolvePlaceholders",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "resolvePlaceholders(String text, boolean ignoreUnresolvablePlaceholders)",
      "tail_type": "useSampleCode"
    },
    {
      "head": "resolvePlaceholders",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "related to system property values and placeholder resolution",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "resolvePlaceholders",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "design principle of resolving placeholders in text",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.SystemPropertyUtils",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "resolvePlaceholders",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#addAll(K,List<? extends V>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "add values to a map",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#addAll(K,List<? extends V>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "unsupported operation",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#addAll(K,List<? extends V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "add values to a map",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#addAll(K,List<? extends V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#addAll(K,List<? extends V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#addAll(K,List<? extends V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#addAll(K,List<? extends V>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.UnmodifiableMultiValueMap",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySet#isEmpty()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "checkEmptiness",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySet#isEmpty()",
      "head_type": "method",
      "relation": "have",
      "tail": "This method checks if the underlying delegate set is empty.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySet#isEmpty()",
      "head_type": "method",
      "relation": "have",
      "tail": "This method follows the principle of delegation, where it relies on the underlying delegate to determine emptiness.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySet#isEmpty()",
      "head_type": "method",
      "relation": "have",
      "tail": "package com.example.util;\n\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.Set;\n\npublic class UnmodifiableEntrySetExample {\n    public static void main(String[] args) {\n        Set<String> originalSet = new HashSet<>();\n        originalSet.add(\"Element1\");\n        originalSet.add(\"Element2\");\n\n        Set<String> unmodifiableSet = Collections.unmodifiableSet(originalSet);\n\n        System.out.println(\"Is the set empty? \" + unmodifiableSet.isEmpty());\n    }\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySpliterator#forEachRemaining(Consumer<? super Entry<K,List<V>>>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "forEachRemaining",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySpliterator#forEachRemaining(Consumer<? super Entry<K,List<V>>>)",
      "head_type": "method",
      "relation": "have",
      "tail": "UnmodifiableEntrySpliterator",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySpliterator#forEachRemaining(Consumer<? super Entry<K,List<V>>>)",
      "head_type": "method",
      "relation": "have",
      "tail": "Consumer<? super Entry<K,List<V>>> action",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySpliterator#forEachRemaining(Consumer<? super Entry<K,List<V>>>)",
      "head_type": "method",
      "relation": "have",
      "tail": "this.delegate.forEachRemaining(entry -> action.accept(new UnmodifiableEntry<>(entry)))",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySpliterator#forEachRemaining(Consumer<? super Entry<K,List<V>>>)",
      "head_type": "method",
      "relation": "have",
      "tail": "new UnmodifiableEntry<>(entry)",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySpliterator#forEachRemaining(Consumer<? super Entry<K,List<V>>>)",
      "head_type": "method",
      "relation": "have",
      "tail": "Delegate the forEachRemaining operation to the underlying delegate, ensuring that each entry is wrapped in an UnmodifiableEntry.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySpliterator#forEachRemaining(Consumer<? super Entry<K,List<V>>>)",
      "head_type": "method",
      "relation": "have",
      "tail": "The design principle followed here is to ensure immutability by wrapping each entry with an UnmodifiableEntry, thereby preventing any modifications to the underlying data structure.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueCollection#stream()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "streaming",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueCollection#stream()",
      "head_type": "method",
      "relation": "have",
      "tail": "StreamSupport.stream(spliterator(), false)",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueCollection#stream()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "Stream",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueCollection#stream()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "StreamSupport",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueCollection#stream()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "spliterator()",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#endPrefixMapping(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "endPrefixMapping",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#endPrefixMapping(String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.AbstractStaxHandler",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLReader#setProperty(String,Object)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "setProperty",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLReader#setProperty(String,Object)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "SAXNotRecognizedException",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLReader#setProperty(String,Object)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "SAXNotSupportedException",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLReader#setProperty(String,Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "http://xml.org/sax/properties/lexical-handler",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLReader#setProperty(String,Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "relatedConceptInterpretation",
      "head_type": "relatedConceptInterpretation",
      "relation": "have",
      "tail": "SAXNotRecognizedException is thrown when the given property does not signify a lexical handler.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLReader#setProperty(String,Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "useSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "package com.healthMgr.common.email;\nimport org.springframework.util.xml.AbstractXMLReader;\nimport org.xml.sax.LexicalHandler;\nimport org.xml.sax.SAXNotRecognizedException;\nimport org.xml.sax.SAXNotSupportedException;\n\npublic class SampleCode {\n    public static void main(String[] args) {\n        AbstractXMLReader reader = new AbstractXMLReader() {\n            @Override\n            public void setProperty(String name, Object value) throws SAXNotRecognizedException, SAXNotSupportedException {\n                if (\"http://xml.org/sax/properties/lexical-handler\".equals(name)) {\n                    this.lexicalHandler = (LexicalHandler) value;\n                } else {\n                    throw new SAXNotRecognizedException(name);\n                }\n            }\n        };\n    }\n}",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLStreamReader#getElementText()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getElementText",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLStreamReader#getElementText()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.AbstractXMLStreamReader",
      "tail_type": "class"
    },
    {
      "head": "getElementText",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "useSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "sampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLStreamReader#nextTag()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "xml tag navigation",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLStreamReader#nextTag()",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "xml structure constraints",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLStreamReader#nextTag()",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "xml parsing",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLStreamReader#nextTag()",
      "head_type": "method",
      "relation": "have",
      "tail": "xml parsing sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLStreamReader#nextTag()",
      "head_type": "method",
      "relation": "have",
      "tail": "xml parsing concept",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLStreamReader#nextTag()",
      "head_type": "method",
      "relation": "have",
      "tail": "xml parsing design principle",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLStreamReader#nextTag()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.AbstractXMLStreamReader",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.SimpleNamespaceContext#bindNamespaceUri(String,String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "bindNamespaceUri",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.SimpleNamespaceContext#bindNamespaceUri(String,String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "prefixNotNull",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.xml.SimpleNamespaceContext#bindNamespaceUri(String,String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "namespaceUriNotNull",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.xml.SimpleNamespaceContext#bindNamespaceUri(String,String)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "defaultNamespaceUriBinding",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.xml.SimpleNamespaceContext#bindNamespaceUri(String,String)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "prefixToNamespaceUriMapping",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.xml.SimpleNamespaceContext#bindNamespaceUri(String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "namespaceUriToPrefixesManagement",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.xml.SimpleNamespaceContext#bindNamespaceUri(String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "SimpleNamespaceContext",
      "tail_type": "class"
    },
    {
      "head": "SimpleNamespaceContext",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.SimpleNamespaceContext#bindNamespaceUri(String,String)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.xml.SimpleNamespaceContext#bindNamespaceUri(String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.SimpleNamespaceContext#bindNamespaceUri(String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.SimpleNamespaceContext#bindNamespaceUri(String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamHandler#cDataInternal(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "writeCData",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamHandler#cDataInternal(String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.StaxStreamHandler",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamHandler#cDataInternal(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamReader#getAttributeName(int)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getAttributeName",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamReader#getAttributeName(int)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.XMLEventStreamReader",
      "tail_type": "class"
    },
    {
      "head": "getAttributeName",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter#writeStartDocument()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "writeStartDocument",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter#writeStartDocument()",
      "head_type": "method",
      "relation": "have",
      "tail": "writeStartDocumentSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter#closeEmptyElementIfNecessary()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "close empty XML element if necessary",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter#closeEmptyElementIfNecessary()",
      "head_type": "method",
      "relation": "have",
      "tail": "private void closeEmptyElementIfNecessary() throws XMLStreamException {\n    if (this.emptyElement) {\n        this.emptyElement = false;\n        writeEndElement();\n    }\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter#closeEmptyElementIfNecessary()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.XMLEventStreamWriter",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter#doWriteNamespace(Namespace)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "writeNamespace",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter#doWriteNamespace(Namespace)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "XMLStreamExceptionHandling",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter#doWriteNamespace(Namespace)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "XMLNamespaceManagement",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter#doWriteNamespace(Namespace)",
      "head_type": "method",
      "relation": "have",
      "tail": "XMLNamespaceManagementSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter#doWriteNamespace(Namespace)",
      "head_type": "method",
      "relation": "have",
      "tail": "XMLNamespaceManagementConcept",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter#doWriteNamespace(Namespace)",
      "head_type": "method",
      "relation": "have",
      "tail": "EfficientXMLProcessingPrinciple",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter#doWriteNamespace(Namespace)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.XMLEventStreamWriter",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#forMemberWhenPackagePrivateClassWithPublicConstructor()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "Access Control",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#forMemberWhenPackagePrivateClassWithPublicConstructor()",
      "head_type": "method",
      "relation": "have",
      "tail": "Access Control for Package Private Class with Public Constructor",
      "tail_type": "useSampleCode"
    },
    {
      "head": "Access Control for Package Private Class with Public Constructor",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "package org.springframework.aot.generate; import org.junit.jupiter.api.Test; import static org.assertj.core.api.Assertions.assertThat; import java.lang.reflect.Member; import java.lang.reflect.Modifier; public class AccessControlTests { @Test void forMemberWhenPackagePrivateClassWithPublicConstructor() { Member member = PackagePrivateClass.class.getDeclaredConstructors()[0]; AccessControl accessControl = AccessControl.forMember(member); assertThat(accessControl.getVisibility()).isEqualTo(Visibility.PACKAGE_PRIVATE); } }",
      "tail_type": "code"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#forMemberWhenPackagePrivateClassWithPublicConstructor()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.AccessControl",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#forMemberWhenPackagePrivateClassWithPublicConstructor()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.PackagePrivateClass",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#forMemberWhenPackagePrivateClassWithPublicConstructor()",
      "head_type": "method",
      "relation": "have",
      "tail": "Testing Access Control for Package Private Class with Public Constructor",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "Testing Access Control for Package Private Class with Public Constructor",
      "head_type": "relatedConceptInterpretation",
      "relation": "have",
      "tail": "This test method verifies the behavior of the AccessControl class when dealing with a package-private class that has a public constructor. It ensures that the visibility is correctly identified as PACKAGE_PRIVATE.",
      "tail_type": "description"
    },
    {
      "head": "org.springframework.aot.generate.ClassNameGeneratorTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "generateClassName",
      "tail_type": "apiFunction"
    },
    {
      "head": "generateClassName",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "featureName must not be empty",
      "tail_type": "useConstraint"
    },
    {
      "head": "generateClassName",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "featureName must be all letters",
      "tail_type": "useConstraint"
    },
    {
      "head": "generateClassName",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "generate class name with null target class",
      "tail_type": "useScenario"
    },
    {
      "head": "generateClassName",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "generate class name with feature name prefix",
      "tail_type": "useScenario"
    },
    {
      "head": "generateClassName",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "generate class name with no text feature name prefix",
      "tail_type": "useScenario"
    },
    {
      "head": "generateClassName",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "generate class name when feature is empty",
      "tail_type": "useScenario"
    },
    {
      "head": "generateClassName",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "generate class name when feature is not all letters",
      "tail_type": "useScenario"
    },
    {
      "head": "generateClassName",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "generate class name with class when lowercase feature name",
      "tail_type": "useScenario"
    },
    {
      "head": "generateClassName",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "generate class name with class when inner class",
      "tail_type": "useScenario"
    },
    {
      "head": "generateClassName",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "generate class name with class when multiple calls",
      "tail_type": "useScenario"
    },
    {
      "head": "generateClassName",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "generate class name sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.ClassNameGeneratorTests",
      "head_type": "class",
      "relation": "have",
      "tail": "related concept interpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.ClassNameGeneratorTests",
      "head_type": "class",
      "relation": "have",
      "tail": "design principle interpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.ClassNameGeneratorTests",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "ClassNameGenerator",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.DefaultGenerationContextTests#createCreatesContext()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "createContext",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.DefaultGenerationContextTests#createCreatesContext()",
      "head_type": "method",
      "relation": "have",
      "tail": "createContextSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "createContextSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "createContextSampleCodeContent",
      "tail_type": "useSampleCodeContent"
    },
    {
      "head": "org.springframework.aot.generate.FileSystemGeneratedFilesTests#handleFileWhenFileExistsCanOverrideContent()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "override file content",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.FileSystemGeneratedFilesTests#handleFileWhenFileExistsCanOverrideContent()",
      "head_type": "method",
      "relation": "have",
      "tail": "FileSystemGeneratedFiles is used to handle file operations",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.FileSystemGeneratedFilesTests#handleFileWhenFileExistsCanOverrideContent()",
      "head_type": "method",
      "relation": "have",
      "tail": "Design principle: Ensure file operations are handled efficiently",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.FileSystemGeneratedFilesTests#handleFileWhenFileExistsCanOverrideContent()",
      "head_type": "method",
      "relation": "have",
      "tail": "package org.springframework.aot.generate;\n\nimport org.springframework.core.io.ByteArrayResource;\nimport org.springframework.core.io.Resource;\nimport org.springframework.aot.generate.Kind;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Path;\nimport org.springframework.aot.generate.FileSystemGeneratedFiles;\nimport static org.assertj.core.api.Assertions.assertThat;\n\npublic class FileSystemGeneratedFilesTests {\n    // Test method\n    @Test\n    public void handleFileWhenFileExistsCanOverrideContent() {\n        FileSystemGeneratedFiles generatedFiles = new FileSystemGeneratedFiles(root);\n        generatedFiles.addResourceFile(\"META-INF/mydir\", \"test\");\n        generatedFiles.handleFile(Kind.RESOURCE, \"META-INF/mydir\", handler -> handler.override(new ByteArrayResource(\"overridden\".getBytes(StandardCharsets.UTF_8))));\n        assertThat(root.resolve(\"resources/META-INF/mydir\")).content().isEqualTo(\"overridden\");\n    }\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.FileSystemGeneratedFilesTests#assertPathMustBeRelative(FileSystemGeneratedFiles,String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "assertPathMustBeRelative",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.FileSystemGeneratedFilesTests#assertPathMustBeRelative(FileSystemGeneratedFiles,String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "pathMustBeRelative",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.aot.generate.FileSystemGeneratedFilesTests#assertPathMustBeRelative(FileSystemGeneratedFiles,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.FileSystemGeneratedFilesTests#assertPathMustBeRelative(FileSystemGeneratedFiles,String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "FileSystemGeneratedFiles",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests#addFileWithConsumedAppendableAddsFile()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "addFileWithConsumedAppendableAddsFile",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests#addFileWithConsumedAppendableAddsFile()",
      "head_type": "method",
      "relation": "have",
      "tail": "addFileWithConsumedAppendableAddsFile useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "addFileWithConsumedAppendableAddsFile useSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "package com.example;\n\nimport org.springframework.aot.generate.GeneratedFiles;\n\npublic class HelloWorld {\n    public static void main(String[] args) {\n        GeneratedFiles generatedFiles = new GeneratedFiles();\n        generatedFiles.addFile(GeneratedFiles.Kind.SOURCE, \"com/example/HelloWorld.java\", appendable -> appendable.append(\";\"));\n    }\n}",
      "tail_type": "String"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests#createSource(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "createSource",
      "tail_type": "apiFunction"
    },
    {
      "head": "createSource",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "createSource(String content) { return new ByteArrayResource(content.getBytes(StandardCharsets.UTF_8)); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "createSource(String content) { return new ByteArrayResource(content.getBytes(StandardCharsets.UTF_8)); }",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "tail": "ByteArrayResource",
      "tail_type": "class"
    },
    {
      "head": "createSource(String content) { return new ByteArrayResource(content.getBytes(StandardCharsets.UTF_8)); }",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "tail": "StandardCharsets",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.ValueCodeGeneratorTests#generateCode(Object)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "generateCode",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.ValueCodeGeneratorTests#generateCode(Object)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "ValueCodeGenerator",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.ValueCodeGeneratorTests#generateCode(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "generateCode Sample Code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.ResolvableTypeTests#generateWhenNestedGenericResolvableType()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "generate nested generic resolvable type",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.ResolvableTypeTests#generateWhenNestedGenericResolvableType()",
      "head_type": "method",
      "relation": "have",
      "tail": "generate nested generic resolvable type sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "generate nested generic resolvable type sample code",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "generate nested generic resolvable type sample code content",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.ResolvableTypeTests#generateWhenNestedGenericResolvableType()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.ResolvableTypeTests",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.ResolvableTypeTests",
      "head_type": "class",
      "relation": "have",
      "tail": "org.springframework.aot.generate.ResolvableTypeTests class interpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.ResolvableTypeTests",
      "head_type": "class",
      "relation": "have",
      "tail": "org.springframework.aot.generate.ResolvableTypeTests design principle interpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.ArrayTests#generateWhenWrapperArray()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "generate code for array",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.ArrayTests#generateWhenWrapperArray()",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for generating code for array",
      "tail_type": "useSampleCode"
    },
    {
      "head": "generate code for array",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "sample code for generating code for array",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.ArrayTests#generateWhenWrapperArray()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.ArrayTests",
      "tail_type": "class"
    },
    {
      "tail": "retry invocation",
      "head_type": "class",
      "relation": "haveFunction",
      "head": "org.springframework.aot.hint.annotation.SampleMethodMetaAnnotatedBeanWithAlias",
      "tail_type": "apiFunction"
    },
    {
      "tail": "not managed operation",
      "head_type": "class",
      "relation": "haveFunction",
      "head": "org.springframework.aot.hint.annotation.SampleMethodMetaAnnotatedBeanWithAlias",
      "tail_type": "apiFunction"
    },
    {
      "tail": "void invoke() ;\nvoid notManaged() ;",
      "head_type": "class",
      "relation": "have",
      "head": "org.springframework.aot.hint.annotation.SampleMethodMetaAnnotatedBeanWithAlias",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.core.type.StandardAnnotationMetadata#getAnnotationAttributes(String,boolean)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getAnnotationAttributes",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.core.type.StandardAnnotationMetadata#getAnnotationAttributes(String,boolean)",
      "head_type": "method",
      "relation": "have",
      "tail": "getAnnotationAttributes(String,boolean) sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "getAnnotationAttributes(String,boolean) sample code",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "org.springframework.core.type.StandardAnnotationMetadata",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.core.type.StandardAnnotationMetadata#getAnnotatedMethods(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getAnnotatedMethods",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.core.type.StandardAnnotationMetadata#getAnnotatedMethods(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "getAnnotatedMethodsSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "getAnnotatedMethodsSampleCode",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "tail": "org.springframework.core.type.StandardAnnotationMetadata",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.core.type.StandardAnnotationMetadata#getAnnotatedMethods(String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.core.type.StandardAnnotationMetadata",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.core.type.StandardAnnotationMetadata#from(Class<?>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "create AnnotationMetadata",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.core.type.StandardAnnotationMetadata#from(Class<?>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "introspectedClass",
      "tail_type": "class"
    },
    {
      "head": "introspectedClass",
      "head_type": "class",
      "relation": "have",
      "tail": "StandardAnnotationMetadata",
      "tail_type": "class"
    },
    {
      "head": "introspectedClass",
      "head_type": "class",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "introspectedClass",
      "head_type": "class",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "introspectedClass",
      "head_type": "class",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.core.type.StandardClassMetadata#getIntrospectedClass()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "returnUnderlyingClass",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.core.type.StandardClassMetadata#getIntrospectedClass()",
      "head_type": "method",
      "relation": "have",
      "tail": "Return the underlying Class.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.core.type.StandardClassMetadata",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.core.type.StandardClassMetadata#getIntrospectedClass()",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.Assert#notEmpty(Collection<?>,String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "assertion",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.Assert#notEmpty(Collection<?>,String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "collection must not be null and must contain at least one element",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.Assert#notEmpty(Collection<?>,String)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "validating collections",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.Assert#notEmpty(Collection<?>,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.Assert#notEmpty(Collection<?>,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.Assert#notEmpty(Collection<?>,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.Assert#notEmpty(Collection<?>,String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "IllegalArgumentException",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.ReflectiveElementFactory#createElement(int)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "element instantiation",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ReflectiveElementFactory#createElement(int)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "element class must have a default constructor",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ReflectiveElementFactory#createElement(int)",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "useSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "complete example of createElement(int) usage",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ReflectiveElementFactory#createElement(int)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.ReflectionUtils",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.ReflectiveElementFactory#createElement(int)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "relatedConceptInterpretation",
      "head_type": "relatedConceptInterpretation",
      "relation": "have",
      "tail": "ReflectionUtils is used to access and instantiate the element class",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ReflectiveElementFactory#createElement(int)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "designPrincipleInterpretation",
      "head_type": "designPrincipleInterpretation",
      "relation": "have",
      "tail": "The method follows the principle of reflection to dynamically create an instance of the element class",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#getClassFileName(Class<?>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getClassFileName",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ClassUtils#getClassFileName(Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "Determine the name of the class file, relative to the containing package: for example, \"String.class\".",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#getClassFileName(Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "The method returns the file name of the \".class\" file.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#getClassFileName(Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "public static String getClassFileName(Class<?> clazz) {\n    Assert.notNull(clazz, \"Class must not be null\");\n    String className = clazz.getName();\n    int lastDotIndex = className.lastIndexOf(PACKAGE_SEPARATOR);\n    return className.substring(lastDotIndex + 1) + CLASS_FILE_SUFFIX;\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ClassUtils#hasAtLeastOneMethodWithName(Class<?>,String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "check existence of method with given name",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ClassUtils#hasAtLeastOneMethodWithName(Class<?>,String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "class and method name must not be null",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ClassUtils#hasAtLeastOneMethodWithName(Class<?>,String)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "determine if a class or its superclass has a method with a specific name",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ClassUtils#hasAtLeastOneMethodWithName(Class<?>,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for checking method existence",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ClassUtils#hasAtLeastOneMethodWithName(Class<?>,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "interpretation of method existence check",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#hasAtLeastOneMethodWithName(Class<?>,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle behind method existence check",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#hasAtLeastOneMethodWithName(Class<?>,String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.ClassUtils",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.CollectionUtils#firstElement(Set<T>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "retrieve first element of a set",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.CollectionUtils#firstElement(Set<T>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "set may be null or empty",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.CollectionUtils#firstElement(Set<T>)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "using SortedSet#first() or iterator",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.CollectionUtils#firstElement(Set<T>)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for retrieving first element",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.CollectionUtils#firstElement(Set<T>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "SortedSet",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.CollectionUtils#firstElement(Set<T>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "LinkedHashMap#keySet()",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.CollectionUtils#firstElement(Set<T>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "java.util.LinkedHashSet",
      "tail_type": "class"
    },
    {
      "head": "retrieve first element of a set",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "related concept interpretation for retrieving first element",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "retrieve first element of a set",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "design principle interpretation for retrieving first element",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.CompositeCollection",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "combine two collections",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.CompositeCollection",
      "head_type": "class",
      "relation": "have",
      "tail": "used in CompositeMap#values()",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.CompositeCollection",
      "head_type": "class",
      "relation": "have",
      "tail": "author Arjen Poutsma",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.CompositeCollection",
      "head_type": "class",
      "relation": "have",
      "tail": "since 6.2",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.CompositeCollection",
      "head_type": "class",
      "relation": "have",
      "tail": "param <E> the type of elements maintained by this collection",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.CompositeCollection",
      "head_type": "class",
      "relation": "have",
      "tail": "Combines two other collections",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.CompositeCollection",
      "head_type": "class",
      "relation": "have",
      "tail": "Exposes functionality through CompositeMap#values()",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.CompositeCollection",
      "head_type": "class",
      "relation": "have",
      "tail": "Complete sample code for using the combine two collections functionality",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.CompositeCollection#retainAll(Collection<?>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "retain elements from another collection",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.CompositeCollection#retainAll(Collection<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "public boolean retainAll(Collection<?> c) { boolean firstResult = this.first.retainAll(c); boolean secondResult = this.second.retainAll(c); return firstResult || secondResult; }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "retain elements from another collection",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "input collection must be non-null",
      "tail_type": "useConstraint"
    },
    {
      "head": "retain elements from another collection",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "managing collections that need to synchronize their contents",
      "tail_type": "useScenario"
    },
    {
      "head": "retain elements from another collection",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "This method iterates over the specified collection and retains only the elements that are also contained in the specified collection.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "retain elements from another collection",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "The design principle behind this method is to provide a way to modify the contents of a collection based on the contents of another collection, ensuring that only shared elements are retained.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ConcurrentLruCache#markAsRemoved(Node<K,V>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "transition node to removed state",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ConcurrentLruCache#markAsRemoved(Node<K,V>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "decrement current size of the cache",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ConcurrentLruCache#markAsRemoved(Node<K,V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "private void markAsRemoved(Node<K, V> node) { ... }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ConcurrentLruCache#markAsRemoved(Node<K,V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "related to concurrent cache management",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ConcurrentLruCache#markAsRemoved(Node<K,V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle of thread-safe operations",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.EvictionQueue#unlink(Node<K,V>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "unlinking a node from a doubly linked list",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.EvictionQueue#unlink(Node<K,V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for unlinking a node",
      "tail_type": "useSampleCode"
    },
    {
      "head": "unlinking a node from a doubly linked list",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "sample code for unlinking a node",
      "tail_type": "useSampleCode"
    },
    {
      "head": "sample code for unlinking a node",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "complete example of unlinking a node from a doubly linked list",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ConcurrentReferenceHashMap",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "lazy loading",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ConcurrentReferenceHashMap",
      "head_type": "class",
      "relation": "constrained_by",
      "tail": "circular aliases are prohibited",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ConcurrentReferenceHashMap",
      "head_type": "class",
      "relation": "applied_to",
      "tail": "multiple aliases for a single name",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ConcurrentReferenceHashMap",
      "head_type": "class",
      "relation": "have",
      "tail": "ConcurrentReferenceHashMap",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ConcurrentReferenceHashMap",
      "head_type": "class",
      "relation": "have",
      "tail": "org.springframework.core.SimpleAliasRegistryTests",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.ConcurrentReferenceHashMap",
      "head_type": "class",
      "relation": "have",
      "tail": "lazy loading",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ConcurrentReferenceHashMap",
      "head_type": "class",
      "relation": "have",
      "tail": "lazy initialization",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ConcurrentReferenceHashMap",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "java.util.concurrent.ConcurrentHashMap",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.ConcurrentReferenceHashMap",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getSegmentsSize()",
      "tail_type": "apiFunction"
    },
    {
      "head": "getSegmentsSize()",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "useSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "org.springframework.util.ConcurrentReferenceHashMap",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.Segment",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "Reference Management",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.Segment",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "Concurrent Data Structure",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.Segment",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "Segmented Hashing",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.Segment",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "Dynamic Resizing",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.Segment",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "Garbage Collection Management",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.Segment",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "Thread-Safe Operations",
      "tail_type": "apiFunction"
    },
    {
      "head": "Reference Management",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "Reference Array Initialization",
      "tail_type": "useConstraint"
    },
    {
      "head": "Concurrent Data Structure",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "Thread Safety",
      "tail_type": "useConstraint"
    },
    {
      "head": "Segmented Hashing",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "Hash Collision Handling",
      "tail_type": "useConstraint"
    },
    {
      "head": "Dynamic Resizing",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "Maximum Segment Size",
      "tail_type": "useConstraint"
    },
    {
      "head": "Garbage Collection Management",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "Reference Purging",
      "tail_type": "useConstraint"
    },
    {
      "head": "Thread-Safe Operations",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "Locking Mechanism",
      "tail_type": "useConstraint"
    },
    {
      "head": "Reference Management",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "Multiple Reference Arrays",
      "tail_type": "useScenario"
    },
    {
      "head": "Concurrent Data Structure",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "High Concurrency Environment",
      "tail_type": "useScenario"
    },
    {
      "head": "Segmented Hashing",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "Distributed Data Storage",
      "tail_type": "useScenario"
    },
    {
      "head": "Dynamic Resizing",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "Variable Workload",
      "tail_type": "useScenario"
    },
    {
      "head": "Garbage Collection Management",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "Memory Optimization",
      "tail_type": "useScenario"
    },
    {
      "head": "Thread-Safe Operations",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "Simultaneous Access",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.Segment",
      "head_type": "class",
      "relation": "have",
      "tail": "Reference Management",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.Segment",
      "head_type": "class",
      "relation": "have",
      "tail": "Concurrent Data Structure",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.Segment",
      "head_type": "class",
      "relation": "have",
      "tail": "Segmented Hashing",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.Segment",
      "head_type": "class",
      "relation": "have",
      "tail": "Dynamic Resizing",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.Segment",
      "head_type": "class",
      "relation": "have",
      "tail": "Garbage Collection Management",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.Segment",
      "head_type": "class",
      "relation": "have",
      "tail": "Thread-Safe Operations",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.Segment",
      "head_type": "class",
      "relation": "have",
      "tail": "Reference Array Initialization",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.Segment",
      "head_type": "class",
      "relation": "have",
      "tail": "Thread Safety",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.Segment",
      "head_type": "class",
      "relation": "have",
      "tail": "Hash Collision Handling",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.Segment",
      "head_type": "class",
      "relation": "have",
      "tail": "Maximum Segment Size",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.Segment",
      "head_type": "class",
      "relation": "have",
      "tail": "Reference Purging",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.Segment",
      "head_type": "class",
      "relation": "have",
      "tail": "Locking Mechanism",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.Segment",
      "head_type": "class",
      "relation": "have",
      "tail": "Multiple Reference Arrays",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.Segment",
      "head_type": "class",
      "relation": "have",
      "tail": "High Concurrency Environment",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.Segment",
      "head_type": "class",
      "relation": "have",
      "tail": "Distributed Data Storage",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.Segment",
      "head_type": "class",
      "relation": "have",
      "tail": "Variable Workload",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.Segment",
      "head_type": "class",
      "relation": "have",
      "tail": "Memory Optimization",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.Segment",
      "head_type": "class",
      "relation": "have",
      "tail": "Simultaneous Access",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.Segment",
      "head_type": "class",
      "relation": "have",
      "tail": "Detailed Explanation of Reference Management",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.Segment",
      "head_type": "class",
      "relation": "have",
      "tail": "In-Depth Analysis of Concurrent Data Structures",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.Segment",
      "head_type": "class",
      "relation": "have",
      "tail": "Segmented Hashing Overview",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.Segment",
      "head_type": "class",
      "relation": "have",
      "tail": "Dynamic Resizing Strategy",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.Segment",
      "head_type": "class",
      "relation": "have",
      "tail": "Garbage Collection Impact on Performance",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.Segment",
      "head_type": "class",
      "relation": "have",
      "tail": "Thread Safety Considerations",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.Segment",
      "head_type": "class",
      "relation": "have",
      "tail": "Principles of Efficient Reference Management",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.Segment",
      "head_type": "class",
      "relation": "have",
      "tail": "Concurrency Control Design",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.Segment",
      "head_type": "class",
      "relation": "have",
      "tail": "Scalable Hashing Design",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.Segment",
      "head_type": "class",
      "relation": "have",
      "tail": "Adaptive Resizing Policy",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.Segment",
      "head_type": "class",
      "relation": "have",
      "tail": "Efficient Memory Management",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.Segment",
      "head_type": "class",
      "relation": "have",
      "tail": "Thread Safety Design",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.Segment",
      "head_type": "class",
      "relation": "have",
      "tail": "Complete Example of Segment Usage",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.DefaultPropertiesPersister",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "load",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.DefaultPropertiesPersister",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "store",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.DefaultPropertiesPersister",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "loadFromXml",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.DefaultPropertiesPersister",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "storeToXml",
      "tail_type": "apiFunction"
    },
    {
      "head": "load",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "Properties",
      "tail_type": "class"
    },
    {
      "head": "store",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "Properties",
      "tail_type": "class"
    },
    {
      "head": "loadFromXml",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "Properties",
      "tail_type": "class"
    },
    {
      "head": "storeToXml",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "Properties",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.DefaultPropertiesPersister",
      "head_type": "class",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.DefaultPropertiesPersister",
      "head_type": "class",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.DefaultPropertiesPersister",
      "head_type": "class",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.DefaultPropertiesPersister#load(Properties,Reader)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "load properties from reader",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.DefaultPropertiesPersister#load(Properties,Reader)",
      "head_type": "method",
      "relation": "have",
      "tail": "load properties from reader sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "load properties from reader sample code",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "complete sample code for loading properties from reader",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.DigestUtils#digestAsHexChars(String,InputStream)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "encoding hexadecimal characters",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.DigestUtils#digestAsHexChars(String,InputStream)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "computing message digest",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.DigestUtils#digestAsHexChars(String,InputStream)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "input stream must be non-null",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.DigestUtils#digestAsHexChars(String,InputStream)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "algorithm string must be valid",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.DigestUtils#digestAsHexChars(String,InputStream)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "data integrity verification",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.DigestUtils#digestAsHexChars(String,InputStream)",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.DigestUtils#digestAsHexChars(String,InputStream)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.DigestUtils#digestAsHexChars(String,InputStream)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.DigestUtils#digestAsHexChars(String,InputStream)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.DigestUtils",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.function.ThrowingSupplier#getWithException()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getting a result with exception handling",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.function.ThrowingSupplier#getWithException()",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "must throw checked exceptions",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.function.ThrowingSupplier#getWithException()",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "scenarios requiring exception handling",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.function.ThrowingSupplier#getWithException()",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for exception handling",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.function.ThrowingSupplier#getWithException()",
      "head_type": "method",
      "relation": "have",
      "tail": "interpretation of checked exceptions",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.function.ThrowingSupplier#getWithException()",
      "head_type": "method",
      "relation": "have",
      "tail": "design principles of exception handling",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.function.ThrowingSupplier",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.function.ThrowingSupplier#getWithException()",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.EntrySet#remove(Object)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "caseInsensitiveRemoval",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.EntrySet#remove(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "caseInsensitiveRemovalSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.EntrySet#remove(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "caseInsensitiveRemovalConcept",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.EntrySet#remove(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "caseInsensitiveRemovalPrinciple",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.EntryIterator#remove()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "removeElement",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.EntryIterator#remove()",
      "head_type": "method",
      "relation": "have",
      "tail": "removeElementSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "removeElementSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "removeElementCompleteExample",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.EntryIterator#remove()",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "removeElementConstraints",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.EntryIterator#remove()",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "removeElementScenario",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.EntryIterator#remove()",
      "head_type": "method",
      "relation": "have",
      "tail": "removeElementRelatedConcepts",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.EntryIterator#remove()",
      "head_type": "method",
      "relation": "have",
      "tail": "removeElementDesignPrinciples",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.EntryIterator#remove()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.EntryIterator",
      "tail_type": "class"
    },
    {
      "relationships": [
        {
          "tail": "adapt a given Map to the MultiValueMap contract",
          "head_type": "class",
          "relation": "haveFunction",
          "head": "org.springframework.util.MultiValueMapAdapter",
          "tail_type": "apiFunction"
        },
        {
          "tail": "Adapts a given Map to the MultiValueMap contract",
          "head_type": "class",
          "relation": "have",
          "head": "org.springframework.util.MultiValueMapAdapter",
          "tail_type": "relatedConceptInterpretation"
        },
        {
          "tail": "CollectionUtils",
          "head_type": "class",
          "relation": "associated_with",
          "head": "org.springframework.util.MultiValueMapAdapter",
          "tail_type": "class"
        },
        {
          "tail": "LinkedMultiValueMap",
          "head_type": "class",
          "relation": "associated_with",
          "head": "org.springframework.util.MultiValueMapAdapter",
          "tail_type": "class"
        },
        {
          "tail": "Sample Code for MultiValueMapAdapter",
          "head_type": "class",
          "relation": "have",
          "head": "org.springframework.util.MultiValueMapAdapter",
          "tail_type": "useSampleCode"
        }
      ]
    },
    {
      "value6": "System.out.println(",
      "all": " + multiValueMap.get(\"key2\"));\n        multiValueMap.set(\"key1",
      "key1": "Map<String",
      "key2": "new ArrayList<>(List.of(",
      "value5": "System.out.println(",
      "value2": "targetMap.put(",
      "System.out.println(": "ingle value map:",
      "value3": "value4\")));\n\n        MultiValueMap<String, String> multiValueMap = new MultiValueMapAdapter<>(targetMap);\n\n        System.out.println(\"First value for key1: \" + multiValueMap.getFirst(\"key1\"));\n        multiValueMap.add(\"key1",
      "targetMap.put(": "ey1",
      "setting": " + multiValueMap.get(",
      "relationships": [
        {
          "tail": "adapt a given Map to the MultiValueMap contract",
          "head_type": "class",
          "relation": "haveFunction",
          "head": "org.springframework.util.MultiValueMapAdapter",
          "tail_type": "apiFunction"
        },
        {
          "tail": "Adapts a given Map to the MultiValueMap contract",
          "head_type": "class",
          "relation": "have",
          "head": "org.springframework.util.MultiValueMapAdapter",
          "tail_type": "relatedConceptInterpretation"
        },
        {
          "tail": "CollectionUtils",
          "head_type": "class",
          "relation": "associated_with",
          "head": "org.springframework.util.MultiValueMapAdapter",
          "tail_type": "class"
        },
        {
          "tail": "LinkedMultiValueMap",
          "head_type": "class",
          "relation": "associated_with",
          "head": "org.springframework.util.MultiValueMapAdapter",
          "tail_type": "class"
        },
        {
          "tail": "Sample Code for MultiValueMapAdapter",
          "head_type": "class",
          "relation": "have",
          "head": "org.springframework.util.MultiValueMapAdapter",
          "tail_type": "useSampleCode"
        }
      ],
      "ArrayList<>(List.of(": "alue1",
      "adding": " + multiValueMap.get(\"key1\"));\n        multiValueMap.addAll(\"key2",
      "List.of(": "alue5"
    },
    {
      "head": "org.springframework.util.ObjectUtils#isCheckedException(Throwable)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "checked exception determination",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ObjectUtils#isCheckedException(Throwable)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": " throwable must not be null",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ObjectUtils#isCheckedException(Throwable)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "exception handling",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ObjectUtils#isCheckedException(Throwable)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for checking exceptions",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ObjectUtils#isCheckedException(Throwable)",
      "head_type": "method",
      "relation": "have",
      "tail": "explanation of checked exceptions",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ObjectUtils#isCheckedException(Throwable)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principles for exception checking",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ObjectUtils#isCheckedException(Throwable)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "java.lang.Exception",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.ObjectUtils#isCheckedException(Throwable)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "java.lang.RuntimeException",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.ObjectUtils#isCheckedException(Throwable)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "java.lang.Error",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.ObjectUtils#addObjectToArray(A[],O,int)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "addObjectToArray",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ObjectUtils#addObjectToArray(A[],O,int)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "nullArrayAllowed",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ObjectUtils#addObjectToArray(A[],O,int)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "arrayElementAddition",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ObjectUtils#addObjectToArray(A[],O,int)",
      "head_type": "method",
      "relation": "have",
      "tail": "addObjectToArraySampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ObjectUtils#addObjectToArray(A[],O,int)",
      "head_type": "method",
      "relation": "have",
      "tail": "arrayManipulationConcept",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ObjectUtils#addObjectToArray(A[],O,int)",
      "head_type": "method",
      "relation": "have",
      "tail": "arrayElementAdditionDesignPrinciple",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "addObjectToArraySampleCode",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "tail": "org.springframework.util.ObjectUtils#addObjectToArray(A[],O,int)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeHashCode(char[])",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "hash code generation",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeHashCode(char[])",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "null input returns zero",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeHashCode(char[])",
      "head_type": "method",
      "relation": "have",
      "tail": "Return a hash code based on the contents of the specified array. If array is null, this method returns 0.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeHashCode(char[])",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is deprecated as of version 6.1, in favor of using Arrays.hashCode(char[]).",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeHashCode(char[])",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "Arrays",
      "tail_type": "class"
    },
    {
      "head": "hash code generation",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "org.springframework.util.ObjectUtils#nullSafeHashCode(char[])",
      "tail_type": "method"
    },
    {
      "head": "null input returns zero",
      "head_type": "useConstraint",
      "relation": "applied_to",
      "tail": "org.springframework.util.ObjectUtils#nullSafeHashCode(char[])",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeToString(Object)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "String representation of Object",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeToString(Object)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "null input returns 'null' string",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeToString(Object)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "array contents conversion",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeToString(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for nullSafeToString",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeToString(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "related concept interpretation for nullSafeToString",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeToString(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle interpretation for nullSafeToString",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ObjectUtils",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.ObjectUtils#nullSafeToString(Object)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#isPublicStaticFinal(Field)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "determining if a field is a public static final constant",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#isPublicStaticFinal(Field)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for using isPublicStaticFinal method",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#isPublicStaticFinal(Field)",
      "head_type": "method",
      "relation": "have",
      "tail": "interpretation of related concepts for isPublicStaticFinal method",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#isPublicStaticFinal(Field)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle interpretation for isPublicStaticFinal method",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#isPublicStaticFinal(Field)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "java.lang.reflect.Field",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#clearCache()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "cache handling",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#clearCache()",
      "head_type": "method",
      "relation": "have",
      "tail": "Clear the internal method/field cache.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#clearCache()",
      "head_type": "method",
      "relation": "have",
      "tail": "public static void clearCache() {\n    declaredMethodsCache.clear();\n    declaredFieldsCache.clear();\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.SingleToMultiValueMapAdapter#get(Object)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "retrieve single value from map",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.SingleToMultiValueMapAdapter#get(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "SingleToMultiValueMapAdapter",
      "tail_type": "class"
    },
    {
      "head": "retrieve single value from map",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "SingleToMultiValueMapAdapter",
      "tail_type": "class"
    },
    {
      "head": "SingleToMultiValueMapAdapter",
      "head_type": "class",
      "relation": "have",
      "tail": "org.springframework.util.SingleToMultiValueMapAdapter",
      "tail_type": "class"
    },
    {
      "head": "SingleToMultiValueMapAdapter",
      "head_type": "class",
      "relation": "have",
      "tail": "retrieve single value from map",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StreamUtils#copyRange(InputStream,OutputStream,long,long)",
      "head_type": "method",
      "relation": "haveFuntion",
      "tail": "copy a range of content from InputStream to OutputStream",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StreamUtils#copyRange(InputStream,OutputStream,long,long)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "specified range exceeds the length of the InputStream",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.StreamUtils#copyRange(InputStream,OutputStream,long,long)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "copying data within a specified range",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.StreamUtils#copyRange(InputStream,OutputStream,long,long)",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "useSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "complete sample code for using copyRange method",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.StreamUtils#copyRange(InputStream,OutputStream,long,long)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "relatedConceptInterpretation",
      "head_type": "relatedConceptInterpretation",
      "relation": "have",
      "tail": "InputStream and OutputStream are used for reading and writing data",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.StreamUtils#copyRange(InputStream,OutputStream,long,long)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "designPrincipleInterpretation",
      "head_type": "designPrincipleInterpretation",
      "relation": "have",
      "tail": "method should handle cases where the specified range exceeds the stream length",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.SystemPropertyUtils#resolvePlaceholders(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "resolvePlaceholders",
      "tail_type": "apiFunction"
    },
    {
      "head": "resolvePlaceholders",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "IllegalArgumentException if there is an unresolvable placeholder",
      "tail_type": "useConstraint"
    },
    {
      "head": "resolvePlaceholders",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "resolve ${...} placeholders in the given text",
      "tail_type": "useScenario"
    },
    {
      "head": "resolvePlaceholders",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "resolve ${...} placeholders in the given text, replacing them with corresponding system property values",
      "tail_type": "useScenario"
    },
    {
      "head": "resolvePlaceholders",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "public static String resolvePlaceholders(String text) { return resolvePlaceholders(text, false); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "resolvePlaceholders",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "This method is used to resolve placeholders in a string by replacing them with corresponding system property values.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "resolvePlaceholders",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "The design principle behind this method is to provide a flexible way to handle placeholders in strings, allowing for dynamic resolution based on system properties.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.SystemPropertyUtils#resolvePlaceholders(String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.SystemPropertyUtils",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.unit.DataSizeUtils#determineDataUnit(String,DataUnit)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "determineDataUnit",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.unit.DataSizeUtils#determineDataUnit(String,DataUnit)",
      "head_type": "method",
      "relation": "have",
      "tail": "DataSizeUtils",
      "tail_type": "class"
    },
    {
      "head": "determineDataUnit",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "useSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "sampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxXMLReader#hasNamespacePrefixesFeature()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "hasNamespacePrefixesFeature",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxXMLReader#hasNamespacePrefixesFeature()",
      "head_type": "method",
      "relation": "have",
      "tail": "Indicates whether the SAX feature http://xml.org/sax/features/namespaces-prefixes is turned on.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxXMLReader",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.AbstractStaxXMLReader#hasNamespacePrefixesFeature()",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLReader#setEntityResolver(EntityResolver)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "setEntityResolver",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLReader#setEntityResolver(EntityResolver)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "EntityResolver",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLReader#setEntityResolver(EntityResolver)",
      "head_type": "method",
      "relation": "have",
      "tail": "setEntityResolverSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "setEntityResolverSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "org.springframework.util.xml.AbstractXMLReader",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.DomUtils#getChildElementsByTagName(Element,String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "retrieveChildElementsByTagName",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.DomUtils#getChildElementsByTagName(Element,String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "directChildLevelOnly",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.xml.DomUtils#getChildElementsByTagName(Element,String)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "xmlElementAnalysis",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.xml.DomUtils#getChildElementsByTagName(Element,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "xmlElementAnalysisSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.DomUtils#getChildElementsByTagName(Element,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "xmlElementAnalysisConcept",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.DomUtils#getChildElementsByTagName(Element,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleOfDomUtils",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.DomUtils#getChildElementsByTagName(Element,String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.w3c.dom.Element",
      "tail_type": "class"
    },
    {
      "head": "retrieveChildElementsByTagName",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.DomUtils",
      "tail_type": "class"
    },
    {
      "head": "directChildLevelOnly",
      "head_type": "useConstraint",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.DomUtils",
      "tail_type": "class"
    },
    {
      "head": "xmlElementAnalysis",
      "head_type": "useScenario",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.DomUtils",
      "tail_type": "class"
    },
    {
      "head": "xmlElementAnalysisSampleCode",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.DomUtils",
      "tail_type": "class"
    },
    {
      "head": "xmlElementAnalysisConcept",
      "head_type": "relatedConceptInterpretation",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.DomUtils",
      "tail_type": "class"
    },
    {
      "head": "designPrincipleOfDomUtils",
      "head_type": "designPrincipleInterpretation",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.DomUtils",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.SimpleNamespaceContext",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getNamespaceURI",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.SimpleNamespaceContext",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getPrefix",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.SimpleNamespaceContext",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getPrefixes",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.SimpleNamespaceContext",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "setBindings",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.SimpleNamespaceContext",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "bindDefaultNamespaceUri",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.SimpleNamespaceContext",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "bindNamespaceUri",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.SimpleNamespaceContext",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "removeBinding",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.SimpleNamespaceContext",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "clear",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.SimpleNamespaceContext",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getBoundPrefixes",
      "tail_type": "apiFunction"
    },
    {
      "head": "getNamespaceURI",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "XML namespace handling",
      "tail_type": "useScenario"
    },
    {
      "head": "getPrefix",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "XML namespace handling",
      "tail_type": "useScenario"
    },
    {
      "head": "getPrefixes",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "XML namespace handling",
      "tail_type": "useScenario"
    },
    {
      "head": "setBindings",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "Setting namespace bindings",
      "tail_type": "useScenario"
    },
    {
      "head": "bindDefaultNamespaceUri",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "Binding default namespace",
      "tail_type": "useScenario"
    },
    {
      "head": "bindNamespaceUri",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "Binding specific namespace",
      "tail_type": "useScenario"
    },
    {
      "head": "removeBinding",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "Removing namespace binding",
      "tail_type": "useScenario"
    },
    {
      "head": "clear",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "Clearing all namespace bindings",
      "tail_type": "useScenario"
    },
    {
      "head": "getBoundPrefixes",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "Retrieving all bound prefixes",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.xml.SimpleNamespaceContext",
      "head_type": "class",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.SimpleNamespaceContext",
      "head_type": "class",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.SimpleNamespaceContext",
      "head_type": "class",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamHandler#endEntity(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "endEntity",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamHandler#endEntity(String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.StaxStreamHandler",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamHandler",
      "head_type": "class",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamHandler",
      "head_type": "class",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamHandler#endEntity(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamXMLReader",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "parse XML using StAX",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamXMLReader",
      "head_type": "class",
      "relation": "constrained_by",
      "tail": "reader must be at the start of a document or element",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamXMLReader",
      "head_type": "class",
      "relation": "applied_to",
      "tail": "reading XML documents",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamXMLReader",
      "head_type": "class",
      "relation": "have",
      "tail": "sample code for parsing XML with StAX",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamXMLReader",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.core.io.ResourceLoader",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamXMLReader",
      "head_type": "class",
      "relation": "have",
      "tail": "interpretation of related concepts like SAX and StAX",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamXMLReader",
      "head_type": "class",
      "relation": "have",
      "tail": "design principles of StaxStreamXMLReader",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils#isStaxSource(Source)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "Indicate whether the given Source is a JAXP 1.4 StAX Source or custom StAX Source",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils#isStaxSource(Source)",
      "head_type": "method",
      "relation": "have",
      "tail": "public static boolean isStaxSource(Source source) { return (source instanceof StAXSource || source instanceof StaxSource); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils#isStaxSource(Source)",
      "head_type": "method",
      "relation": "have",
      "tail": "The method checks if the provided Source object is an instance of StAXSource or StaxSource, returning true if it is, and false otherwise.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils#isStaxSource(Source)",
      "head_type": "method",
      "relation": "have",
      "tail": "The design principle followed here is to provide a utility method that can be used to easily determine if a given Source object is a StAX Source or not, which can be useful in XML processing scenarios.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "XML stream writing",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter",
      "head_type": "class",
      "relation": "constrained_by",
      "tail": "XMLStreamException handling",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter",
      "head_type": "class",
      "relation": "applied_to",
      "tail": "XML document manipulation",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter",
      "head_type": "class",
      "relation": "have",
      "tail": "XML event handling",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter",
      "head_type": "class",
      "relation": "have",
      "tail": "Stream-based XML processing",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter",
      "head_type": "class",
      "relation": "have",
      "tail": "Sample code for XML stream writing",
      "tail_type": "useSampleCode"
    },
    {
      "head": "Sample code for XML stream writing",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.XMLEventStreamWriter",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter#writeStartElement(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "writeStartElement",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter#writeStartElement(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "writeStartElement(String) Sample Code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "writeStartElement(String) Sample Code",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "org.springframework.util.xml.XMLEventStreamWriter",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.core.task.VirtualThreadDelegate#virtualThreadFactory(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "virtualThreadFactory",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.core.task.VirtualThreadDelegate#virtualThreadFactory(String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.core.task.VirtualThreadDelegate",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.core.task.VirtualThreadDelegate",
      "head_type": "class",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.core.task.VirtualThreadDelegate",
      "head_type": "class",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.core.task.VirtualThreadDelegate#virtualThreadFactory(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#isAccessibleWhenPrivateVisibilityInSamePackage()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "Access Control Test",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#isAccessibleWhenPrivateVisibilityInSamePackage()",
      "head_type": "method",
      "relation": "have",
      "tail": "Access Control Sample Code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "Access Control Sample Code",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "Complete Access Control Test Example",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.ClassNameGeneratorTests#generatedClassNameWhenFeatureIsNotAllLettersThrowsException()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "generateClassName",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.ClassNameGeneratorTests#generatedClassNameWhenFeatureIsNotAllLettersThrowsException()",
      "head_type": "method",
      "relation": "have",
      "tail": "generateClassName sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "generateClassName sample code",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "generateClassName sample code content",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.ClassNameGeneratorTests#generatedClassNameWhenFeatureIsNotAllLettersThrowsException()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "ClassName.get(InputStream.class)",
      "tail_type": "class"
    },
    {
      "head": "ClassName.get(InputStream.class)",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "java.io.InputStream",
      "tail_type": "class"
    },
    {
      "tail": "generate code block for method invocation",
      "head_type": "method",
      "relation": "haveFunction",
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithDeclaringClassAndNullTargetClass()",
      "tail_type": "apiFunction"
    },
    {
      "tail": "generate code block for method invocation",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithDeclaringClassAndNullTargetClass()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithDeclaringClassAndNullTargetClass()",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "head": "generate code block for method invocation",
      "tail_type": "method"
    },
    {
      "tail": "new com.example.Test().methodName()",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithDeclaringClassAndNullTargetClass()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithDeclaringClassAndNullTargetClass()",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "head": "new com.example.Test().methodName()",
      "tail_type": "method"
    },
    {
      "tail": "MethodSpec method = createTestMethod(\"methodName\", new TypeName[0]);\nMethodReference methodReference = new DefaultMethodReference(method, TEST_CLASS_NAME);\nassertThat(methodReference.toInvokeCodeBlock(ArgumentCodeGenerator.none())).isEqualTo(CodeBlock.of(\"new com.example.Test().methodName()\"));",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithDeclaringClassAndNullTargetClass()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithDeclaringClassAndNullTargetClass()",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "head": "MethodSpec method = createTestMethod(\"methodName\", new TypeName[0]);\nMethodReference methodReference = new DefaultMethodReference(method, TEST_CLASS_NAME);\nassertThat(methodReference.toInvokeCodeBlock(ArgumentCodeGenerator.none())).isEqualTo(CodeBlock.of(\"new com.example.Test().methodName()\"));",
      "tail_type": "method"
    },
    {
      "tail": "generate code block for method invocation",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithDeclaringClassAndNullTargetClass()",
      "tail_type": "apiFunction"
    },
    {
      "tail": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithDeclaringClassAndNullTargetClass()",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "head": "generate code block for method invocation",
      "tail_type": "method"
    },
    {
      "tail": "generate code block for method invocation",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithDeclaringClassAndNullTargetClass()",
      "tail_type": "apiFunction"
    },
    {
      "tail": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithDeclaringClassAndNullTargetClass()",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "head": "generate code block for method invocation",
      "tail_type": "method"
    },
    {
      "tail": "generate code block for method invocation",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithDeclaringClassAndNullTargetClass()",
      "tail_type": "apiFunction"
    },
    {
      "tail": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithDeclaringClassAndNullTargetClass()",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "head": "generate code block for method invocation",
      "tail_type": "method"
    },
    {
      "tail": "generate code block for method invocation",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithDeclaringClassAndNullTargetClass()",
      "tail_type": "apiFunction"
    },
    {
      "tail": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithDeclaringClassAndNullTargetClass()",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "head": "generate code block for method invocation",
      "tail_type": "method"
    },
    {
      "tail": "generate code block for method invocation",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithDeclaringClassAndNullTargetClass()",
      "tail_type": "apiFunction"
    },
    {
      "tail": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithDeclaringClassAndNullTargetClass()",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "head": "generate code block for method invocation",
      "tail_type": "method"
    },
    {
      "tail": "generate code block for method invocation",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithDeclaringClassAndNullTargetClass()",
      "tail_type": "apiFunction"
    },
    {
      "tail": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithDeclaringClassAndNullTargetClass()",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "head": "generate code block for method invocation",
      "tail_type": "method"
    },
    {
      "tail": "generate code block for method invocation",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithDeclaringClassAndNullTargetClass()",
      "tail_type": "apiFunction"
    },
    {
      "tail": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithDeclaringClassAndNullTargetClass()",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "head": "generate code block for method invocation",
      "tail_type": "method"
    },
    {
      "tail": "generate code block for method invocation",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithDeclaringClassAndNullTargetClass()",
      "tail_type": "apiFunction"
    },
    {
      "tail": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithDeclaringClassAndNullTargetClass()",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "head": "generate code block for method invocation",
      "tail_type": "method"
    },
    {
      "tail": "generate code block for method invocation",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithDeclaringClassAndNullTargetClass()",
      "tail_type": "apiFunction"
    },
    {
      "tail": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithDeclaringClassAndNullTargetClass()",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "head": "generate code block for method invocation",
      "tail_type": "method"
    },
    {
      "tail": "generate code block for method invocation",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithDeclaringClassAndNullTargetClass()",
      "tail_type": "apiFunction"
    },
    {
      "tail": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithDeclaringClassAndNullTargetClass()",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "head": "generate code block for method invocation",
      "tail_type": "method"
    },
    {
      "tail": "generate code block for method invocation",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithDeclaringClassAndNullTargetClass()",
      "tail_type": "apiFunction"
    },
    {
      "tail": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithDeclaringClassAndNullTargetClass()",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "head": "generate code block for method invocation",
      "tail_type": "method"
    },
    {
      "tail": "generate code block for method invocation",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithDeclaringClassAndNullTargetClass()",
      "tail_type": "apiFunction"
    },
    {
      "tail": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithDeclaringClassAndNullTargetClass()",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "head": "generate code block for method invocation",
      "tail_type": "method"
    },
    {
      "tail": "generate code block for method invocation",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithDeclaringClassAndNullTargetClass()",
      "tail_type": "apiFunction"
    },
    {
      "tail": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithDeclaringClassAndNullTargetClass()",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "head": "generate code block for method invocation",
      "tail_type": "method"
    },
    {
      "tail": "generate code block for method invocation",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithDeclaringClassAndNullTargetClass()",
      "tail_type": "apiFunction"
    },
    {
      "tail": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithDeclaringClassAndNullTargetClass()",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "head": "generate code block for method invocation",
      "tail_type": "method"
    },
    {
      "tail": "generate code block for method invocation",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithDeclaringClassAndNullTargetClass()",
      "tail_type": "apiFunction"
    },
    {
      "tail": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithDeclaringClassAndNullTargetClass()",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "head": "generate code block for method invocation",
      "tail_type": "method"
    },
    {
      "tail": "generate code block for method invocation",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithDeclaringClassAndNullTargetClass()",
      "tail_type": "apiFunction"
    },
    {
      "tail": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithDeclaringClassAndNullTargetClass()",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "head": "generate code block for method invocation",
      "tail_type": "method"
    },
    {
      "tail": "generate code block for method invocation",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithDeclaringClassAndNullTargetClass()",
      "tail_type": "apiFunction"
    },
    {
      "tail": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithDeclaringClassAndNullTargetClass()",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "head": "generate code block for method invocation",
      "tail_type": "method"
    },
    {
      "tail": "generate code block for method invocation",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithDeclaringClassAndNullTargetClass()",
      "tail_type": "apiFunction"
    },
    {
      "tail": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithDeclaringClassAndNullTargetClass()",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "head": "generate code block for method invocation",
      "tail_type": "method"
    },
    {
      "tail": "generate code block for method invocation",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithDeclaringClassAndNullTargetClass()",
      "tail_type": "apiFunction"
    },
    {
      "tail": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithDeclaringClassAndNullTargetClass()",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "head": "generate code block for method invocation",
      "tail_type": "method"
    },
    {
      "tail": "generate code block for method invocation",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithDeclaringClassAndNullTargetClass()",
      "tail_type": "apiFunction"
    },
    {
      "tail": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithDeclaringClassAndNullTargetClass()",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "head": "generate code block for method invocation",
      "tail_type": "method"
    },
    {
      "tail": "generate code block for method invocation",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithDeclaringClassAndNullTargetClass()",
      "tail_type": "apiFunction"
    },
    {
      "tail": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithDeclaringClassAndNullTargetClass()",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "head": "generate code block for method invocation",
      "tail_type": "method"
    },
    {
      "tail": "generate code block for method invocation",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithDeclaringClassAndNullTargetClass()",
      "tail_type": "apiFunction"
    },
    {
      "tail": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithDeclaringClassAndNullTargetClass()",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "head": "generate code block for method invocation",
      "tail_type": "method"
    },
    {
      "tail": "generate code block for method invocation",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithDeclaringClassAndNullTargetClass()",
      "tail_type": "apiFunction"
    },
    {
      "tail": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithDeclaringClassAndNullTargetClass()",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "head": "generate code block for method invocation",
      "tail_type": "method"
    },
    {
      "tail": "generate code block for method invocation",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithDeclaringClassAndNullTargetClass()",
      "tail_type": "apiFunction"
    },
    {
      "tail": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithDeclaringClassAndNullTargetClass()",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "head": "generate code block for method invocation",
      "tail_type": "method"
    },
    {
      "tail": "generate code block for method invocation",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithDeclaringClassAndNullTargetClass()",
      "tail_type": "apiFunction"
    },
    {
      "tail": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithDeclaringClassAndNullTargetClass()",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "head": "generate code block for method invocation",
      "tail_type": "method"
    },
    {
      "head": ""
    },
    {
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithMatchingTargetClass()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "code generation",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithMatchingTargetClass()",
      "head_type": "method",
      "relation": "have",
      "tail": "MethodSpec method = createTestMethod(\"methodName\", new TypeName[0]);\nMethodReference methodReference = new DefaultMethodReference(method, TEST_CLASS_NAME);\nCodeBlock invocation = methodReference.toInvokeCodeBlock(ArgumentCodeGenerator.none(), TEST_CLASS_NAME);\n// Assume com.example.Test is in a `test` variable.\nassertThat(CodeBlock.of(\"$L.$L\", \"test\", invocation)).isEqualTo(CodeBlock.of(\"test.methodName()\"));",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithMatchingTargetClass()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.DefaultMethodReferenceTests",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithMatchingTargetClass()",
      "head_type": "method",
      "relation": "have",
      "tail": "This method tests the generation of an invocation code block for a method reference when the target class matches. It creates a test method using `createTestMethod`, generates a method reference with `DefaultMethodReference`, and then produces the invocation code block. Finally, it asserts that the generated code block matches the expected output.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithMatchingTargetClass()",
      "head_type": "method",
      "relation": "have",
      "tail": "The design principle demonstrated in this method is the importance of ensuring that generated code blocks accurately reflect the intended method invocations. This is crucial for maintaining the integrity and functionality of the generated code, especially in scenarios involving method references and dynamic code generation.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#createTestMethod(String,TypeName[],Modifier)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "createTestMethod",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#createTestMethod(String,TypeName[],Modifier)",
      "head_type": "method",
      "relation": "have",
      "tail": "createTestMethodSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "createTestMethodSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "createTestMethodSampleCodeContent",
      "tail_type": "useSampleCodeContent"
    },
    {
      "tail": "generateJavaFileIsAnnotatedWithGenerated",
      "head_type": "method",
      "relation": "haveFunction",
      "head": "org.springframework.aot.generate.GeneratedClassTests#generateJavaFileIsAnnotatedWithGenerated()",
      "tail_type": "apiFunction"
    },
    {
      "tail": "GeneratedClass",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.aot.generate.GeneratedClassTests#generateJavaFileIsAnnotatedWithGenerated()",
      "tail_type": "class"
    },
    {
      "tail": "Generated",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.aot.generate.GeneratedClassTests#generateJavaFileIsAnnotatedWithGenerated()",
      "tail_type": "class"
    },
    {
      "tail": "import \" + Generated.class.getName() + \";",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.aot.generate.GeneratedClassTests#generateJavaFileIsAnnotatedWithGenerated()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "relatedConceptInterpretation",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.aot.generate.GeneratedClassTests#generateJavaFileIsAnnotatedWithGenerated()",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "tail": "designPrincipleInterpretation",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.aot.generate.GeneratedClassTests#generateJavaFileIsAnnotatedWithGenerated()",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedTypeReferenceTests#equalsWithIdenticalCanonicalNameIsTrue()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "GeneratedTypeReference comparison",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedTypeReferenceTests#equalsWithIdenticalCanonicalNameIsTrue()",
      "head_type": "method",
      "relation": "have",
      "tail": "GeneratedTypeReference comparison sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "GeneratedTypeReference comparison sample code",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "package org.springframework.aot.generate;\n\nimport java.lang.reflect.Type;\nimport org.springframework.aot.generate.GeneratedTypeReference;\nimport org.junit.jupiter.api.Test;\nimport static org.assertj.core.api.Assertions.assertThat;\n\npublic class GeneratedTypeReferenceTest {\n\n    @Test\n    void equalsWithIdenticalCanonicalNameIsTrue() {\n        assertThat(GeneratedTypeReference.of(ClassName.get(\"java.lang\", \"String\")))\n            .isEqualTo(TypeReference.of(String.class));\n    }\n}",
      "tail_type": "code"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedTypeReferenceTests#equalsWithIdenticalCanonicalNameIsTrue()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.GeneratedTypeReference",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedTypeReference",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "TypeReference generation",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedTypeReference",
      "head_type": "class",
      "relation": "have",
      "tail": "TypeReference generation design principle",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "TypeReference generation design principle",
      "head_type": "designPrincipleInterpretation",
      "relation": "have",
      "tail": "The design principle behind TypeReference generation is to provide a flexible and type-safe way to represent and manipulate types at runtime. This is crucial for frameworks that rely on dynamic type information, such as Spring's Ahead-of-Time (AOT) processing. By generating TypeReferences, the framework can ensure that type information is accurately captured and utilized during the code generation phase, facilitating more efficient and error-free code execution.",
      "tail_type": "description"
    },
    {
      "head": "org.springframework.aot.generate.MethodNameTests#andPartsReturnsMethodName()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "MethodName manipulation",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.MethodNameTests#andPartsReturnsMethodName()",
      "head_type": "method",
      "relation": "have",
      "tail": "Sample code for MethodName manipulation",
      "tail_type": "useSampleCode"
    },
    {
      "head": "MethodName manipulation",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "Sample code for MethodName manipulation",
      "tail_type": "useSampleCode"
    },
    {
      "head": "Sample code for MethodName manipulation",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.MethodNameTests#andPartsReturnsMethodName()",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.aot.generate.MethodNameTests#andPartsReturnsMethodName()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.MethodName",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.ProtectedAccessor#methodWithProtectedParameter(PackagePrivateClass)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "accessing protected members",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.ProtectedAccessor#methodWithProtectedParameter(PackagePrivateClass)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.aot.generate.ProtectedAccessor#methodWithProtectedParameter(PackagePrivateClass) allows accessing protected members of a class.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.ProtectedAccessor#methodWithProtectedParameter(PackagePrivateClass)",
      "head_type": "method",
      "relation": "have",
      "tail": "public String methodWithProtectedParameter(PackagePrivateClass type) {\n    return \"test\";\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.ClassTests#generateWhenClass()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "generate code for class",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.ClassTests#generateWhenClass()",
      "head_type": "method",
      "relation": "have",
      "tail": "InputStream.class usage",
      "tail_type": "useSampleCode"
    },
    {
      "head": "generate code for class",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "InputStream.class usage",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.ClassTests#generateWhenClass()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "InputStream.class",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldProcessAnnotationOnMethod()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "processAnnotation",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldProcessAnnotationOnMethod()",
      "head_type": "method",
      "relation": "have",
      "tail": "SampleMethodAnnotatedBean.class",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldProcessAnnotationOnMethod()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "SampleMethodAnnotatedBean",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldProcessAnnotationOnMethod()",
      "head_type": "method",
      "relation": "have",
      "tail": "This method processes an annotation on a method.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldProcessAnnotationOnMethod()",
      "head_type": "method",
      "relation": "have",
      "tail": "Ensure that annotations on methods are correctly processed for runtime hints.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.hint.annotation.SampleMultipleCustomProcessors#managed()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "managed",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.hint.annotation.SampleMultipleCustomProcessors#managed()",
      "head_type": "method",
      "relation": "have",
      "tail": "public String managed() {\n    return \"test\";\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.hint.annotation.RegisterReflectionForBindingProcessorTests#registerReflectionForBindingOnClass()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "registerReflectionHints",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.hint.annotation.RegisterReflectionForBindingProcessorTests#registerReflectionForBindingOnClass()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "RuntimeHintsPredicates.reflection().onType()",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.hint.annotation.RegisterReflectionForBindingProcessorTests#registerReflectionForBindingOnClass()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "RuntimeHintsPredicates.reflection().onMethodInvocation()",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.hint.annotation.RegisterReflectionForBindingProcessorTests#registerReflectionForBindingOnClass()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.hint.RuntimeHints",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.hint.annotation.RegisterReflectionForBindingProcessorTests#registerReflectionForBindingOnClass()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.hint.annotation.RegisterReflectionForBinding",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.hint.annotation.RegisterReflectionForBindingProcessorTests#registerReflectionForBindingOnClass()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "SampleClassWithGetter",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.hint.annotation.RegisterReflectionForBindingProcessorTests#registerReflectionForBindingOnClass()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "String",
      "tail_type": "class"
    },
    {
      "head": "registerReflectionHints",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "RuntimeHintsPredicates.reflection().onType()",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "RuntimeHintsPredicates.reflection().onMethodInvocation()",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "useSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "complete sample code for using the apiFunction",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.hint.annotation.RegisterReflectionReflectiveProcessorTests#getTypeHint(Class<?>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getTypeHint",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.hint.annotation.RegisterReflectionReflectiveProcessorTests#getTypeHint(Class<?>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.hint.annotation.RegisterReflectionReflectiveProcessorTests",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.hint.annotation.RegisterReflectionReflectiveProcessorTests#getTypeHint(Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "private TypeHint getTypeHint(Class<?> target) {\n    TypeHint typeHint = hints.reflection().getTypeHint(target);\n    assertThat(typeHint).isNotNull();\n    return typeHint;\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.core.type.MethodMetadata#getReturnTypeName()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "get the fully-qualified name of the underlying method's declared return type",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.core.type.MethodMetadata#getReturnTypeName()",
      "head_type": "method",
      "relation": "have",
      "tail": "Get the fully-qualified name of the underlying method's declared return type",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.core.type.MethodMetadata",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.core.type.MethodMetadata#getReturnTypeName()",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.core.type.StandardMethodMetadata#isFinal()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "check if method is final",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.core.type.StandardMethodMetadata#isFinal()",
      "head_type": "method",
      "relation": "have",
      "tail": "Modifier.isFinal(this.introspectedMethod.getModifiers())",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.core.type.StandardMethodMetadata#isFinal()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.core.type.StandardMethodMetadata",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.core.type.StandardMethodMetadata#isFinal()",
      "head_type": "method",
      "relation": "have",
      "tail": "This method checks if the method represented by this metadata is declared as final.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.core.type.StandardMethodMetadata#isFinal()",
      "head_type": "method",
      "relation": "have",
      "tail": "This method utilizes java.lang.reflect.Modifier to determine if the method is final.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.Assert#noNullElements(Object[],String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "assertNoNullElements",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.Assert#noNullElements(Object[],String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "arrayNotNull",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.Assert#noNullElements(Object[],String)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "arrayWithNonNullElements",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.Assert#noNullElements(Object[],String)",
      "head_type": "method",
      "relation": "have",
      "tail": "sampleCodeForNoNullElements",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.Assert#noNullElements(Object[],String)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.Assert#noNullElements(Object[],String)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "assertNoNullElements",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "org.springframework.util.Assert",
      "tail_type": "class"
    },
    {
      "head": "arrayNotNull",
      "head_type": "useConstraint",
      "relation": "associated_with",
      "tail": "org.springframework.util.Assert",
      "tail_type": "class"
    },
    {
      "head": "arrayWithNonNullElements",
      "head_type": "useScenario",
      "relation": "associated_with",
      "tail": "org.springframework.util.Assert",
      "tail_type": "class"
    },
    {
      "head": "sampleCodeForNoNullElements",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "tail": "org.springframework.util.Assert",
      "tail_type": "class"
    },
    {
      "head": "relatedConceptInterpretation",
      "head_type": "relatedConceptInterpretation",
      "relation": "associated_with",
      "tail": "org.springframework.util.Assert",
      "tail_type": "class"
    },
    {
      "head": "designPrincipleInterpretation",
      "head_type": "designPrincipleInterpretation",
      "relation": "associated_with",
      "tail": "org.springframework.util.Assert",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.Assert#isAssignable(Class<?>,Class<?>,String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "type checking",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.Assert#isAssignable(Class<?>,Class<?>,String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "superType must be non-null",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.Assert#isAssignable(Class<?>,Class<?>,String)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "ensuring subtype is assignable to supertype",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.Assert#isAssignable(Class<?>,Class<?>,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "Assert.isAssignable(Number.class, myClass, \"Number expected\")",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.Assert#isAssignable(Class<?>,Class<?>,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is used to assert that one class (subtype) is assignable to another class (supertype). It checks if the subtype can be cast to the supertype without causing a ClassCastException.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.Assert#isAssignable(Class<?>,Class<?>,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "The method follows the principle of fail-fast, which means it throws an exception as soon as a problem is detected, thus preventing further processing and potential errors.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.Assert",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.Assert#isAssignable(Class<?>,Class<?>,String)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.CollectionUtils#firstElement(List<T>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "retrieveFirstElement",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.CollectionUtils#firstElement(List<T>)",
      "head_type": "method",
      "relation": "have",
      "tail": "The method retrieves the first element of a given List by accessing the zero index.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.CollectionUtils#firstElement(List<T>)",
      "head_type": "method",
      "relation": "have",
      "tail": "The design principle is to provide a utility method for easily accessing the first element of a list, enhancing code readability and maintainability.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.CollectionUtils#firstElement(List<T>)",
      "head_type": "method",
      "relation": "have",
      "tail": "package com.example.util; import java.util.List; public class Example { public static void main(String[] args) { List<String> myList = List.of(\"apple\", \"banana\", \"cherry\"); String first = org.springframework.util.CollectionUtils.firstElement(myList); System.out.println(\"First element: \" + first); } }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.CompositeSet#hashCode()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "calculateHashCode",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.CompositeSet#hashCode()",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.CompositeSet",
      "tail_type": "class"
    },
    {
      "head": "calculateHashCode",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "Iterate through elements to compute hash code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "calculateHashCode",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "Each non-null object's hash code is added to the total hash code",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "calculateHashCode",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "Override the hashCode method to ensure correct behavior when using objects in hash-based collections",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.Entry#getValue()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "retrieveValue",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.Entry#getValue()",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is used to retrieve the value from an entry.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.Entry#getValue()",
      "head_type": "method",
      "relation": "have",
      "tail": "The design principle followed here is simplicity and direct access to the value stored within an entry.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.Entry#getValue()",
      "head_type": "method",
      "relation": "have",
      "tail": "java\npackage org.springframework.util;\n\npublic class Entry<K, V> {\n    private K key;\n    private V value;\n\n    public Entry(K key, V value) {\n        this.key = key;\n        this.value = value;\n    }\n\n    @Nullable\n    public V getValue() {\n        return this.value;\n    }\n}\n",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.EntrySet#size()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "size determination",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.EntrySet#size()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "ConcurrentReferenceHashMap",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.EntrySet#size()",
      "head_type": "method",
      "relation": "have",
      "tail": "size determination sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "size determination sample code",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "org.springframework.util.EntrySet#size() sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.CustomizableThreadCreator#setThreadNamePrefix(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "thread naming",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.CustomizableThreadCreator#setThreadNamePrefix(String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "threadNamePrefix must be non-null",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.CustomizableThreadCreator#setThreadNamePrefix(String)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "custom thread naming",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.CustomizableThreadCreator#setThreadNamePrefix(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "setThreadNamePrefix sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.CustomizableThreadCreator#setThreadNamePrefix(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "thread naming explanation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.CustomizableThreadCreator#setThreadNamePrefix(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "thread naming design principle",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.CustomizableThreadCreator#setThreadNamePrefix(String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.CustomizableThreadCreator",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.DigestUtils#digest(String,InputStream)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "calculateDigest",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.DigestUtils#digest(String,InputStream)",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.DigestUtils#digest(String,InputStream)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.DigestUtils#digest(String,InputStream)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "calculateDigest",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "inputStreamNotNull",
      "tail_type": "useConstraint"
    },
    {
      "head": "calculateDigest",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "streamDataDigestion",
      "tail_type": "useScenario"
    },
    {
      "head": "useSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "completeDigestExample",
      "tail_type": "useSampleCode"
    },
    {
      "head": "relatedConceptInterpretation",
      "head_type": "relatedConceptInterpretation",
      "relation": "have",
      "tail": "messageDigestExplanation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "designPrincipleInterpretation",
      "head_type": "designPrincipleInterpretation",
      "relation": "have",
      "tail": "efficientStreamProcessing",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.FileCopyUtils",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "copyFileToFile",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.FileCopyUtils",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "copyByteArrayToFile",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.FileCopyUtils",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "copyFileToByteArray",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.FileCopyUtils",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "copyInputStreamToOutputStream",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.FileCopyUtils",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "copyByteArrayToOutputStream",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.FileCopyUtils",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "copyInputStreamToByteArray",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.FileCopyUtils",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "copyReaderToWriter",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.FileCopyUtils",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "copyStringToWriter",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.FileCopyUtils",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "copyReaderToString",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.FileCopyUtils",
      "head_type": "class",
      "relation": "have",
      "tail": "BUFFER_SIZE",
      "tail_type": "useSampleCode"
    },
    {
      "head": "copyFileToFile",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "copying contents of one File to another File",
      "tail_type": "useScenario"
    },
    {
      "head": "copyByteArrayToFile",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "copying contents of a byte array to a File",
      "tail_type": "useScenario"
    },
    {
      "head": "copyFileToByteArray",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "copying contents of a File to a byte array",
      "tail_type": "useScenario"
    },
    {
      "head": "copyInputStreamToOutputStream",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "copying contents of an InputStream to an OutputStream",
      "tail_type": "useScenario"
    },
    {
      "head": "copyByteArrayToOutputStream",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "copying contents of a byte array to an OutputStream",
      "tail_type": "useScenario"
    },
    {
      "head": "copyInputStreamToByteArray",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "copying contents of an InputStream to a byte array",
      "tail_type": "useScenario"
    },
    {
      "head": "copyReaderToWriter",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "copying contents of a Reader to a Writer",
      "tail_type": "useScenario"
    },
    {
      "head": "copyStringToWriter",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "copying contents of a String to a Writer",
      "tail_type": "useScenario"
    },
    {
      "head": "copyReaderToString",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "copying contents of a Reader to a String",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.FileCopyUtils",
      "head_type": "class",
      "relation": "have",
      "tail": "StreamUtils",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.FileCopyUtils",
      "head_type": "class",
      "relation": "have",
      "tail": "close(Closeable)",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.FileCopyUtils",
      "head_type": "class",
      "relation": "have",
      "tail": "IOException handling",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.FileCopyUtils",
      "head_type": "class",
      "relation": "have",
      "tail": " BUFFER_SIZE constant",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.FileCopyUtils",
      "head_type": "class",
      "relation": "have",
      "tail": "Juergen Hoeller",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.FileCopyUtils",
      "head_type": "class",
      "relation": "have",
      "tail": "Hyunjin Choi",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.FileCopyUtils",
      "head_type": "class",
      "relation": "have",
      "tail": "06.10.2003",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.FileCopyUtils",
      "head_type": "class",
      "relation": "have",
      "tail": "StreamUtils",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.FileCopyUtils",
      "head_type": "class",
      "relation": "have",
      "tail": "FileSystemUtils",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.FileCopyUtils#copyToByteArray(InputStream)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "copy contents of InputStream into a new byte array",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.FileCopyUtils#copyToByteArray(InputStream)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "InputStream may be null or empty",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.FileCopyUtils#copyToByteArray(InputStream)",
      "head_type": "method",
      "relation": "have",
      "tail": "Closes the stream when done",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.FileCopyUtils#copyToByteArray(InputStream)",
      "head_type": "method",
      "relation": "have",
      "tail": "Returns a new byte array that has been copied to (possibly empty)",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.FileCopyUtils#copyToByteArray(InputStream)",
      "head_type": "method",
      "relation": "have",
      "tail": "Throws IOException in case of I/O errors",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.FileCopyUtils#copyToByteArray(InputStream)",
      "head_type": "method",
      "relation": "have",
      "tail": "public static byte[] copyToByteArray(@Nullable InputStream in) throws IOException { if (in == null) { return new byte[0]; } try (in) { return in.readAllBytes(); } }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.FileCopyUtils#copyToByteArray(InputStream)",
      "head_type": "method",
      "relation": "have",
      "tail": "Related to stream handling and array manipulation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.FileCopyUtils#copyToByteArray(InputStream)",
      "head_type": "method",
      "relation": "have",
      "tail": "Design principle focuses on efficiency and simplicity in handling I/O operations",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.FilteredCollection#remove(Object)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "remove an element from the collection",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.FilteredCollection#remove(Object)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "element must satisfy the filter condition",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.FilteredCollection#remove(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "public boolean remove(Object o) {\n    boolean removed = this.delegate.remove(o);\n    return removed && this.filter.test((E) o);\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.FilteredCollection#remove(Object)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.FilteredCollection",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.FilteredCollection#contains(Object)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "filtered element containment check",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.FilteredCollection#contains(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "Checks if the collection contains an element that satisfies the filter condition.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.FilteredCollection#contains(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "The method first checks if the delegate collection contains the object. If it does, it then applies the filter to the object. If the filter condition is satisfied, it returns true; otherwise, it returns false.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.FilteredCollection#contains(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "@Override\n@SuppressWarnings(\"unchecked\")\npublic boolean contains(Object o) {\n    if (this.delegate.contains(o)) {\n        return this.filter.test((E) o);\n    } else {\n        return false;\n    }\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.function.ThrowingBiFunction#apply(T,U)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "apply",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.function.ThrowingBiFunction#apply(T,U)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "checked exceptions",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.function.ThrowingBiFunction#apply(T,U)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "BiFunction#apply(Object, Object)",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.function.ThrowingBiFunction#apply(T,U)",
      "head_type": "method",
      "relation": "have",
      "tail": "Default BiFunction#apply(Object, Object) that wraps any thrown checked exceptions (by default in a RuntimeException)",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.function.ThrowingBiFunction#apply(T,U)",
      "head_type": "method",
      "relation": "have",
      "tail": "Design principle of handling checked exceptions by wrapping them in a RuntimeException",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.function.ThrowingBiFunction#apply(T,U)",
      "head_type": "method",
      "relation": "have",
      "tail": "public R apply(T t, U u) { return apply(t, u, RuntimeException::new); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.function.ThrowingBiFunction#apply(T,U)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "java.util.function.BiFunction",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.KeySet#forEach(Consumer<? super String>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "forEach",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.KeySet#forEach(Consumer<? super String>)",
      "head_type": "method",
      "relation": "have",
      "tail": "Iterates over each element in the KeySet",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.KeySet#forEach(Consumer<? super String>)",
      "head_type": "method",
      "relation": "have",
      "tail": "Delegates the iteration to the underlying set",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.KeySet#forEach(Consumer<? super String>)",
      "head_type": "method",
      "relation": "have",
      "tail": "public void forEach(Consumer<? super String> action) {\n    this.delegate.forEach(action);\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.MimeType#getSubtype()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getSubtype",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MimeType",
      "head_type": "class",
      "relation": "have",
      "tail": "getSubtype()",
      "tail_type": "method"
    },
    {
      "head": "getSubtype",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "Return the subtype.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.MimeType",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.MimeType#getSubtype()",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.MultiToSingleValueMapAdapter#adaptValue(List<V>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "adapt the first value from a list",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MultiToSingleValueMapAdapter#adaptValue(List<V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "if the list is not empty, return the first element; otherwise, return null",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.MultiToSingleValueMapAdapter#adaptValue(List<V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is designed to adapt a list of values to a single value by selecting the first element of the list. It checks if the list is not empty using CollectionUtils.isEmpty(). If the list contains elements, it returns the first element. If the list is empty, it returns null. This behavior is useful in scenarios where only the first value of a list is needed, and the list can potentially be empty.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.MultiToSingleValueMapAdapter#adaptValue(List<V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "The design principle behind this method is simplicity and efficiency. It aims to provide a straightforward way to extract the first element from a list, which is a common requirement in various applications. By returning null for empty lists, it also handles the edge case where the list might not contain any elements. This method is a part of the MultiToSingleValueMapAdapter class, which suggests that it is used in the context of adapting multi-value maps to single-value maps, possibly for simplifying data structures or for compatibility with APIs that expect single values.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeToString(double[])",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "String representation of array",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeToString(double[])",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "array must not be null",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeToString(double[])",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "convert array to String",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeToString(double[])",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for array to String conversion",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeToString(double[])",
      "head_type": "method",
      "relation": "have",
      "tail": "explanation of StringJoiner usage",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeToString(double[])",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle of null safety",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ObjectUtils",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.ObjectUtils#nullSafeToString(double[])",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#getDeclaredMethods(Class<?>,boolean)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getDeclaredMethods",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#getDeclaredMethods(Class<?>,boolean)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "class must not be null",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#getDeclaredMethods(Class<?>,boolean)",
      "head_type": "method",
      "relation": "have",
      "tail": "getDeclaredMethods sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "getDeclaredMethods sample code",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "org.springframework.util.ReflectionUtils#getDeclaredMethods(Class<?>,boolean) sample code content",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#getDeclaredMethods(Class<?>,boolean)",
      "head_type": "method",
      "relation": "have",
      "tail": "related concept interpretation for getDeclaredMethods",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "related concept interpretation for getDeclaredMethods",
      "head_type": "relatedConceptInterpretation",
      "relation": "have",
      "tail": "related concept interpretation content",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#getDeclaredMethods(Class<?>,boolean)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle interpretation for getDeclaredMethods",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "design principle interpretation for getDeclaredMethods",
      "head_type": "designPrincipleInterpretation",
      "relation": "have",
      "tail": "design principle interpretation content",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#isHashCodeMethod(Method)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "Determine whether the given method is a \"hashCode\" method",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#isHashCodeMethod(Method)",
      "head_type": "method",
      "relation": "have",
      "tail": "Determine whether the given method is a \"hashCode\" method",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#isHashCodeMethod(Method)",
      "head_type": "method",
      "relation": "have",
      "tail": "public static boolean isHashCodeMethod(@Nullable Method method) { return (method != null && method.getParameterCount() == 0 && method.getName().equals(\"hashCode\")); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#isHashCodeMethod(Method)",
      "head_type": "method",
      "relation": "have",
      "tail": "The method checks if the provided method object represents a hashCode method from java.lang.Object, which is used to get the hash code of an object. It ensures that the method has no parameters and its name is 'hashCode'.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#isHashCodeMethod(Method)",
      "head_type": "method",
      "relation": "have",
      "tail": "The design principle followed here is to provide a utility method that simplifies the reflection-based method checks, abstracting the complexity of checking method names and parameter counts. This promotes code readability and reusability.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.SingleToMultiValueMapAdapter#containsValue(Object)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "check for value existence",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.SingleToMultiValueMapAdapter#containsValue(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.SingleToMultiValueMapAdapter#containsValue(Object) useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.SingleToMultiValueMapAdapter#containsValue(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.SingleToMultiValueMapAdapter#containsValue(Object) relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.SingleToMultiValueMapAdapter#containsValue(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.SingleToMultiValueMapAdapter#containsValue(Object) designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.SingleToMultiValueMapAdapter#containsValue(Object)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.SingleToMultiValueMapAdapter",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.SingleToMultiValueMapAdapter",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "check for value existence",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.SingleToMultiValueMapAdapter",
      "head_type": "class",
      "relation": "have",
      "tail": "org.springframework.util.SingleToMultiValueMapAdapter#containsValue(Object) useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.SingleToMultiValueMapAdapter",
      "head_type": "class",
      "relation": "have",
      "tail": "org.springframework.util.SingleToMultiValueMapAdapter#containsValue(Object) relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.SingleToMultiValueMapAdapter",
      "head_type": "class",
      "relation": "have",
      "tail": "org.springframework.util.SingleToMultiValueMapAdapter#containsValue(Object) designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.StopWatch#getTotalTime(TimeUnit)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getTotalTime",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StopWatch#getTotalTime(TimeUnit)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "timeUnitPrecision",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.StopWatch#getTotalTime(TimeUnit)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "timeMeasurement",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.StopWatch#getTotalTime(TimeUnit)",
      "head_type": "method",
      "relation": "have",
      "tail": "timeUnitParameter",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.StopWatch#getTotalTime(TimeUnit)",
      "head_type": "method",
      "relation": "have",
      "tail": "totalTimeCalculation",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.StopWatch#getTotalTime(TimeUnit)",
      "head_type": "method",
      "relation": "have",
      "tail": "timeUnitConversion",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.StopWatch#getTotalTime(TimeUnit)",
      "head_type": "method",
      "relation": "have",
      "tail": "StopWatchDesignPrinciple",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.StopWatch#getTotalTime(TimeUnit)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.StopWatch",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.TaskInfo",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getTaskName",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.TaskInfo",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getTimeNanos",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.TaskInfo",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getTimeMillis",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.TaskInfo",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getTimeSeconds",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.TaskInfo",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getTime",
      "tail_type": "apiFunction"
    },
    {
      "head": "getTime",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "timeUnit",
      "tail_type": "useConstraint"
    },
    {
      "head": "getTime",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "timeUnit",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.TaskInfo",
      "head_type": "class",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.TaskInfo",
      "head_type": "class",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.TaskInfo",
      "head_type": "class",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.TaskInfo",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "StopWatch",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.StreamUtils#copyToString(InputStream,Charset)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "copy contents of InputStream into String",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StreamUtils#copyToString(InputStream,Charset)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "InputStream may be null or empty",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.StreamUtils#copyToString(InputStream,Charset)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "copying data from InputStream",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.StreamUtils#copyToString(InputStream,Charset)",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "useSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "complete sample code for using copyToString method",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.StreamUtils#copyToString(InputStream,Charset)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "relatedConceptInterpretation",
      "head_type": "relatedConceptInterpretation",
      "relation": "have",
      "tail": "InputStream and Charset are used to decode bytes into a String",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.StreamUtils#copyToString(InputStream,Charset)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "designPrincipleInterpretation",
      "head_type": "designPrincipleInterpretation",
      "relation": "have",
      "tail": "method leaves the stream open when done to allow further processing",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.StreamUtils#copyToString(InputStream,Charset)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "java.io.InputStream",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.StreamUtils#copyToString(InputStream,Charset)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "java.nio.charset.Charset",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.StringUtils#hasText(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "check if a string contains actual text",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils#hasText(String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "string must not be null and must contain at least one non-whitespace character",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.StringUtils#hasText(String)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "validating user input",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.StringUtils#hasText(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for checking string text presence",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.StringUtils#hasText(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "interpretation of related concepts for string text presence checking",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.StringUtils#hasText(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principles behind string text presence checking",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.StringUtils#hasText(String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.StringUtils",
      "tail_type": "class"
    },
    {
      "head": "check if a string contains actual text",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "sample code for checking string text presence",
      "tail_type": "useSampleCode"
    },
    {
      "head": "check if a string contains actual text",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "interpretation of related concepts for string text presence checking",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "check if a string contains actual text",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "design principles behind string text presence checking",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.StringUtils#deleteAny(String,String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "delete characters from string",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils#deleteAny(String,String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "input strings must have length",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.StringUtils#deleteAny(String,String)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "removing specified characters from a string",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.StringUtils#deleteAny(String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for deleting characters from a string",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.StringUtils#deleteAny(String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "explanation of character deletion in strings",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.StringUtils#deleteAny(String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle behind character deletion efficiency",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.StringUtils#deleteAny(String,String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.StringUtils",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.StringUtils#splitArrayElementsIntoProperties(String[],String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "splitArrayElementsIntoProperties",
      "tail_type": "apiFunction"
    },
    {
      "head": "splitArrayElementsIntoProperties",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "splitArrayElementsIntoProperties(String[] array, String delimiter)",
      "tail_type": "useSampleCode"
    },
    {
      "head": "splitArrayElementsIntoProperties(String[] array, String delimiter)",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "tail": "org.springframework.util.StringUtils",
      "tail_type": "class"
    },
    {
      "head": "splitArrayElementsIntoProperties",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "Take an array of strings and split each element based on the given delimiter.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "splitArrayElementsIntoProperties",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "A Properties instance is then generated, with the left of the delimiter providing the key, and the right of the delimiter providing the value.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.StringUtils#arrayToDelimitedString(Object[],String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "convert array to delimited string",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils#arrayToDelimitedString(Object[],String)",
      "head_type": "method",
      "relation": "have",
      "tail": "useful for toString() implementations",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.StringUtils#arrayToDelimitedString(Object[],String)",
      "head_type": "method",
      "relation": "have",
      "tail": "Convert a String array into a delimited String (for example, CSV)",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.StringUtils#arrayToDelimitedString(Object[],String)",
      "head_type": "method",
      "relation": "have",
      "tail": "The method takes an array and a delimiter as input and returns a string where the array elements are joined by the delimiter.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.StringUtils#arrayToDelimitedString(Object[],String)",
      "head_type": "method",
      "relation": "have",
      "tail": "public static String arrayToDelimitedString(@Nullable Object @Nullable [] arr, String delim) {\n    if (ObjectUtils.isEmpty(arr)) {\n        return \"\";\n    }\n    if (arr.length == 1) {\n        return ObjectUtils.nullSafeToString(arr[0]);\n    }\n    StringJoiner sj = new StringJoiner(delim);\n    for (Object elem : arr) {\n        sj.add(String.valueOf(elem));\n    }\n    return sj.toString();\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySet#size()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "delegation",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySet#size()",
      "head_type": "method",
      "relation": "have",
      "tail": "This method delegates the size operation to the underlying delegate set.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySet#size()",
      "head_type": "method",
      "relation": "have",
      "tail": "The design principle followed here is the delegation pattern, which is a common practice in Java to achieve flexibility and maintainability.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySet#size()",
      "head_type": "method",
      "relation": "have",
      "tail": "public int size() {\n    return this.delegate.size();\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.UpdateMessageDigestInputStream#updateMessageDigest(MessageDigest)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "updateMessageDigest",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.UpdateMessageDigestInputStream#updateMessageDigest(MessageDigest)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "IOException",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.UpdateMessageDigestInputStream#updateMessageDigest(MessageDigest)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "stream optimization",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.UpdateMessageDigestInputStream#updateMessageDigest(MessageDigest)",
      "head_type": "method",
      "relation": "have",
      "tail": "updateMessageDigest sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.UpdateMessageDigestInputStream#updateMessageDigest(MessageDigest)",
      "head_type": "method",
      "relation": "have",
      "tail": "updateMessageDigest related concept interpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.UpdateMessageDigestInputStream#updateMessageDigest(MessageDigest)",
      "head_type": "method",
      "relation": "have",
      "tail": "updateMessageDigest design principle interpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.UpdateMessageDigestInputStream#updateMessageDigest(MessageDigest)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "MessageDigest",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxXMLReader",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "parse XML using StAX",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxXMLReader",
      "head_type": "class",
      "relation": "constrained_by",
      "tail": "InputSource and system identifier are ignored in parse methods",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxXMLReader",
      "head_type": "class",
      "relation": "applied_to",
      "tail": "SAX XMLReader implementations using StAX",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxXMLReader",
      "head_type": "class",
      "relation": "have",
      "tail": "Sample code for parsing XML with StAX",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxXMLReader",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxXMLReader",
      "head_type": "class",
      "relation": "have",
      "tail": "Explanation of StAX and SAX in XML parsing",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxXMLReader",
      "head_type": "class",
      "relation": "have",
      "tail": "Design principles of AbstractStaxXMLReader",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLEventReader#next()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "xml event reading",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLEventReader#next()",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "xml stream exception handling",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLEventReader#next()",
      "head_type": "method",
      "relation": "have",
      "tail": "xml event reading sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLEventReader#next()",
      "head_type": "method",
      "relation": "have",
      "tail": "xml event reading concept interpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLEventReader#next()",
      "head_type": "method",
      "relation": "have",
      "tail": "xml event reading design principle interpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "xml event reading sample code",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "tail": "xml event reading",
      "tail_type": "apiFunction"
    },
    {
      "head": "xml event reading concept interpretation",
      "head_type": "relatedConceptInterpretation",
      "relation": "associated_with",
      "tail": "xml event reading",
      "tail_type": "apiFunction"
    },
    {
      "head": "xml event reading design principle interpretation",
      "head_type": "designPrincipleInterpretation",
      "relation": "associated_with",
      "tail": "xml event reading",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLStreamReader#getAttributeValue(String,String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getAttributeValue",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLStreamReader#getAttributeValue(String,String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.AbstractXMLStreamReader",
      "tail_type": "class"
    },
    {
      "head": "getAttributeValue",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "useSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "sampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.DomContentHandler#endPrefixMapping(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "endPrefixMapping",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.DomContentHandler#endPrefixMapping(String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.DomContentHandler",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.SimpleSaxErrorHandler#warning(SAXParseException)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "handle XML validation warning",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.SimpleSaxErrorHandler#warning(SAXParseException)",
      "head_type": "method",
      "relation": "have",
      "tail": "logger.warn(\"Ignored XML validation warning\", ex);",
      "tail_type": "useSampleCode"
    },
    {
      "head": "handle XML validation warning",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "XML parsing",
      "tail_type": "useScenario"
    },
    {
      "head": "handle XML validation warning",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "SAXException handling",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.xml.SimpleSaxErrorHandler#warning(SAXParseException)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.SimpleSaxErrorHandler",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.SimpleSaxErrorHandler",
      "head_type": "class",
      "relation": "have",
      "tail": "related to XML parsing and error handling",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.SimpleSaxErrorHandler",
      "head_type": "class",
      "relation": "have",
      "tail": "design principle of robust error handling",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.SimpleSaxErrorHandler#error(SAXParseException)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "handleSAXParseException",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.SimpleSaxErrorHandler#error(SAXParseException)",
      "head_type": "method",
      "relation": "have",
      "tail": "handleSAXParseExceptionSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "handleSAXParseExceptionSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "org.springframework.util.xml.SimpleSaxErrorHandler",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamHandler#setDocumentLocator(Locator)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "setDocumentLocator",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamHandler#setDocumentLocator(Locator)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.StaxStreamHandler",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils#createStaxResult(XMLStreamWriter)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "create a JAXP 1.4 StAXResult for the given XMLStreamWriter",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils#createStaxResult(XMLStreamWriter)",
      "head_type": "method",
      "relation": "have",
      "tail": "public static Result createStaxResult(XMLStreamWriter streamWriter) { return new StAXResult(streamWriter); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils#createStaxResult(XMLStreamWriter)",
      "head_type": "method",
      "relation": "have",
      "tail": "Create a JAXP 1.4 StAXResult for the given XMLStreamWriter",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils#createStaxResult(XMLStreamWriter)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is used to create a JAXP 1.4 StAXResult for the given XMLStreamWriter. It takes an XMLStreamWriter as input and returns a result wrapping the streamWriter.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "create a JAXP 1.4 StAXResult for the given XMLStreamWriter",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils",
      "head_type": "class",
      "relation": "have",
      "tail": "public static Result createStaxResult(XMLStreamWriter streamWriter) { return new StAXResult(streamWriter); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils",
      "head_type": "class",
      "relation": "have",
      "tail": "Create a JAXP 1.4 StAXResult for the given XMLStreamWriter",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils",
      "head_type": "class",
      "relation": "have",
      "tail": "This method is used to create a JAXP 1.4 StAXResult for the given XMLStreamWriter. It takes an XMLStreamWriter as input and returns a result wrapping the streamWriter.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter#writeCharacters(char[],int,int)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "writeCharacters",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter#writeCharacters(char[],int,int)",
      "head_type": "method",
      "relation": "have",
      "tail": "writeCharactersSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "writeCharactersSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "writeCharactersCodeContent",
      "tail_type": "codeContent"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#forMemberWhenPublicClassWithPackagePrivateConstructorParameter()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "Access Control",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#forMemberWhenPublicClassWithPackagePrivateConstructorParameter()",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.aot.generate.AccessControlTests#forMemberWhenPublicClassWithPackagePrivateConstructorParameter() Sample Code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#forMemberWhenPublicClassWithPackagePrivateConstructorParameter() Sample Code",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "package com.example;\n\nimport org.springframework.aot.generate.AccessControl;\nimport org.springframework.aot.generate.Visibility;\n\npublic class AccessControlExample {\n    public static void main(String[] args) throws NoSuchMethodException {\n        Member member = ProtectedParameter.class.getConstructors()[0];\n        AccessControl accessControl = AccessControl.forMember(member);\n        System.out.println(accessControl.getVisibility());\n    }\n}",
      "tail_type": "String"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#forMemberWhenPublicClassWithPackagePrivateConstructorParameter()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.AccessControl",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#forMemberWhenPublicClassWithPackagePrivateConstructorParameter()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.AccessControlTests",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#forMemberWhenPublicClassWithPackagePrivateConstructorParameter()",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.aot.generate.AccessControlTests#forMemberWhenPublicClassWithPackagePrivateConstructorParameter() Related Concept Interpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#forMemberWhenPublicClassWithPackagePrivateConstructorParameter() Related Concept Interpretation",
      "head_type": "relatedConceptInterpretation",
      "relation": "have",
      "tail": "This method tests the access control for a member when the class is public and the constructor parameter is package-private. It ensures that the visibility is correctly identified as PACKAGE_PRIVATE.",
      "tail_type": "String"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#forMemberWhenPublicClassWithPackagePrivateConstructorParameter()",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.aot.generate.AccessControlTests#forMemberWhenPublicClassWithPackagePrivateConstructorParameter() Design Principle Interpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#forMemberWhenPublicClassWithPackagePrivateConstructorParameter() Design Principle Interpretation",
      "head_type": "designPrincipleInterpretation",
      "relation": "have",
      "tail": "The design principle behind this method is to ensure that the access control mechanism correctly identifies the visibility of members, especially when dealing with different access levels for classes and their constructors. This is crucial for maintaining encapsulation and proper access control in object-oriented programming.",
      "tail_type": "String"
    },
    {
      "head": "org.springframework.aot.generate.DefaultGenerationContextTests#withNameUpdateNamingConvention()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "nameUpdateNamingConvention",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.DefaultGenerationContextTests#withNameUpdateNamingConvention()",
      "head_type": "method",
      "relation": "have",
      "tail": "DefaultGenerationContext",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.DefaultGenerationContextTests#withNameUpdateNamingConvention()",
      "head_type": "method",
      "relation": "have",
      "tail": "GeneratedClass",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.DefaultGenerationContextTests#withNameUpdateNamingConvention()",
      "head_type": "method",
      "relation": "have",
      "tail": "AnotherContext",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.DefaultGenerationContextTests#withNameUpdateNamingConvention()",
      "head_type": "method",
      "relation": "have",
      "tail": "ClassNameGenerator",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.DefaultGenerationContextTests#withNameUpdateNamingConvention()",
      "head_type": "method",
      "relation": "have",
      "tail": "GeneratedFiles",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.DefaultGenerationContextTests#withNameUpdateNamingConvention()",
      "head_type": "method",
      "relation": "have",
      "tail": "nameUpdateNamingConvention",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.DefaultGenerationContextTests#withNameUpdateNamingConvention()",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.DefaultGenerationContextTests#withNameUpdateNamingConvention()",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.MethodNameTests#ofWhenPartsIsNullThrowsException()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "IllegalArgumentException checking",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.MethodNameTests#ofWhenPartsIsNullThrowsException()",
      "head_type": "method",
      "relation": "have",
      "tail": "Sample code for IllegalArgumentException checking",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.MethodNameTests#ofWhenPartsIsNullThrowsException()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.MethodName",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.ConfigurationTests#scopedReturnsImmutableCopy()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "scopedReturnsImmutableCopy",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.ConfigurationTests#scopedReturnsImmutableCopy()",
      "head_type": "method",
      "relation": "have",
      "tail": "ValueCodeGenerator.withDefaults()",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.ConfigurationTests#scopedReturnsImmutableCopy()",
      "head_type": "method",
      "relation": "have",
      "tail": "GeneratedMethods(ClassName.get(\"com.example\", \"Test\"), MethodName::toString)",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.ConfigurationTests#scopedReturnsImmutableCopy()",
      "head_type": "method",
      "relation": "have",
      "tail": "valueCodeGenerator.scoped(generatedMethods)",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.ConfigurationTests#scopedReturnsImmutableCopy()",
      "head_type": "method",
      "relation": "have",
      "tail": "assertThat(scopedValueCodeGenerator).isNotSameAs(valueCodeGenerator)",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.ConfigurationTests#scopedReturnsImmutableCopy()",
      "head_type": "method",
      "relation": "have",
      "tail": "assertThat(scopedValueCodeGenerator.getGeneratedMethods()).isSameAs(generatedMethods)",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.ConfigurationTests#scopedReturnsImmutableCopy()",
      "head_type": "method",
      "relation": "have",
      "tail": "assertThat(valueCodeGenerator.getGeneratedMethods()).isNull()",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.ConfigurationTests#scopedReturnsImmutableCopy()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.ValueCodeGenerator",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.ConfigurationTests#scopedReturnsImmutableCopy()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.GeneratedMethods",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.ConfigurationTests#scopedReturnsImmutableCopy()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "com.example.Test",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.ConfigurationTests#scopedReturnsImmutableCopy()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.MethodName",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.ExceptionTests#generateWhenUnsupportedValue()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "generateCode",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.ExceptionTests#generateWhenUnsupportedValue()",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "UnsupportedTypeValueCodeGenerationException",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.aot.generate.ExceptionTests#generateWhenUnsupportedValue()",
      "head_type": "method",
      "relation": "have",
      "tail": "generateWhenUnsupportedValue() sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.ExceptionTests#generateWhenUnsupportedValue()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.ValueCodeGenerationException",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.ExceptionTests#generateWhenUnsupportedValue()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.UnsupportedTypeValueCodeGenerationException",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldProcessAnnotationOnField()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "processAnnotationOnField",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldProcessAnnotationOnField()",
      "head_type": "method",
      "relation": "have",
      "tail": "SampleFieldAnnotatedBean.class",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldProcessAnnotationOnField()",
      "head_type": "method",
      "relation": "have",
      "tail": "runtimeHints",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldProcessAnnotationOnField()",
      "head_type": "method",
      "relation": "have",
      "tail": "reflection().getTypeHint(SampleFieldAnnotatedBean.class)",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldProcessAnnotationOnField()",
      "head_type": "method",
      "relation": "have",
      "tail": "typeHint.fields()",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldProcessAnnotationOnField()",
      "head_type": "method",
      "relation": "have",
      "tail": "singleElement().satisfies(fieldHint -> assertThat(fieldHint.getName()).isEqualTo(\"managed\"))",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldProcessAnnotationOnField()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.hint.annotation.SampleFieldAnnotatedBean",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "reflectiveAnnotationUsage",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.hint.annotation.SampleFieldAnnotatedBean",
      "head_type": "class",
      "relation": "have",
      "tail": "reflectiveAnnotationUsageSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "reflectiveAnnotationUsageSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "org.springframework.aot.hint.annotation.SampleFieldAnnotatedBean",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.hint.annotation.SampleMethodAnnotatedBean#managed()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "reflectiveOperation",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.hint.annotation.SampleMethodAnnotatedBean#managed()",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#extractUriTemplateVariables(String,String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "extractUriTemplateVariables",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#extractUriTemplateVariables(String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method extracts URI template variables from a given pattern and path.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#extractUriTemplateVariables(String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "The method returns a map of variable names to values.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#extractUriTemplateVariables(String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "If the pattern does not match the path, an IllegalStateException is thrown.",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#extractUriTemplateVariables(String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "package com.example.demo;\n\nimport org.springframework.util.AntPathMatcher;\n\npublic class ExtractVariablesExample {\n    public static void main(String[] args) {\n        AntPathMatcher matcher = new AntPathMatcher();\n        String pattern = \"/users/{userId}/details/{detailId}\";\n        String path = \"/users/123/details/456\";\n\n        Map<String, String> variables = matcher.extractUriTemplateVariables(pattern, path);\n\n        variables.forEach((k, v) -> System.out.println(k + \" = \" + v));\n    }\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#extractUriTemplateVariables(String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is typically used in web applications to extract variables from URLs.",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#extractUriTemplateVariables(String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "The method follows the principle of matching the most specific pattern to ensure accurate variable extraction.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.PatternInfo#getUriVars()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "retrieve URI variables count",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.PatternInfo#getUriVars()",
      "head_type": "method",
      "relation": "have",
      "tail": "This method returns the number of URI variables in the pattern.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.PatternInfo#getUriVars()",
      "head_type": "method",
      "relation": "have",
      "tail": "public int getUriVars() {\n    return this.uriVars;\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.Assert#isTrue(boolean,String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "assert boolean expression",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.Assert#isTrue(boolean,String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "expression evaluates to false",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.Assert#isTrue(boolean,String)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "validate conditions",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.Assert#isTrue(boolean,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "IllegalArgumentException thrown if condition fails",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.Assert#isTrue(boolean,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "related to exception handling",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.Assert#isTrue(boolean,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle of fail-fast",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.Assert",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.Assert#isTrue(boolean,String)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.Assert#notEmpty(Map<?,?>,Supplier<String>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "Map assertion",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.Assert#notEmpty(Map<?,?>,Supplier<String>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "map must not be null or empty",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.Assert#notEmpty(Map<?,?>,Supplier<String>)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "Map validation",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.Assert#notEmpty(Map<?,?>,Supplier<String>)",
      "head_type": "method",
      "relation": "have",
      "tail": "Map assertion sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "Map assertion sample code",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "java\nimport org.springframework.util.Assert;\nimport java.util.Map;\nimport java.util.function.Supplier;\n\nclass MapAssertionExample {\n    public static void main(String[] args) {\n        Map<String, String> myMap = Map.of(\"key\", \"value\");\n        Assert.notEmpty(myMap, () -> \"The map must contain entries\");\n    }\n}\n",
      "tail_type": "String"
    },
    {
      "head": "org.springframework.util.Assert#notEmpty(Map<?,?>,Supplier<String>)",
      "head_type": "method",
      "relation": "have",
      "tail": "Map assertion explanation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "Map assertion explanation",
      "head_type": "relatedConceptInterpretation",
      "relation": "have",
      "tail": "The `notEmpty` method is used to assert that a given Map is not null and contains at least one entry. This is a common assertion used to validate input parameters in methods that require non-empty Maps to function correctly.",
      "tail_type": "String"
    },
    {
      "head": "org.springframework.util.Assert#notEmpty(Map<?,?>,Supplier<String>)",
      "head_type": "method",
      "relation": "have",
      "tail": "Design principle for Map assertion",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "Design principle for Map assertion",
      "head_type": "designPrincipleInterpretation",
      "relation": "have",
      "tail": "The design principle behind the `notEmpty` method is to enforce a contract for method parameters, ensuring that they meet certain criteria before the method proceeds with its logic. This helps in preventing runtime errors and makes the code more robust and easier to maintain.",
      "tail_type": "String"
    },
    {
      "head": "org.springframework.util.AutoPopulatingList#subList(int,int)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": " sublist extraction",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.AutoPopulatingList#subList(int,int)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.List",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.AutoPopulatingList#subList(int,int)",
      "head_type": "method",
      "relation": "have",
      "tail": " sublist extraction sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.AutoPopulatingList#subList(int,int)",
      "head_type": "method",
      "relation": "have",
      "tail": " sublist extraction concept interpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.AutoPopulatingList#subList(int,int)",
      "head_type": "method",
      "relation": "have",
      "tail": " sublist extraction design principle interpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.AutoPopulatingList#hashCode()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "calculateHashCode",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.AutoPopulatingList#hashCode()",
      "head_type": "method",
      "relation": "have",
      "tail": "overrideAnnotation",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.AutoPopulatingList#hashCode()",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.AutoPopulatingList#hashCode()",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.AutoPopulatingList#hashCode()",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.AutoPopulatingList#hashCode()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.AutoPopulatingList",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.ReflectiveElementFactory",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "createElement",
      "tail_type": "apiFunction"
    },
    {
      "head": "createElement",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "element class must not be null",
      "tail_type": "useConstraint"
    },
    {
      "head": "createElement",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "element class must not be an interface type",
      "tail_type": "useConstraint"
    },
    {
      "head": "createElement",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "element class cannot be an abstract class",
      "tail_type": "useConstraint"
    },
    {
      "head": "createElement",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "sample code for createElement",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ReflectiveElementFactory",
      "head_type": "class",
      "relation": "have",
      "tail": "Reflective implementation of the ElementFactory interface",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ReflectiveElementFactory",
      "head_type": "class",
      "relation": "have",
      "tail": "design principle of ReflectiveElementFactory",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#isPrimitiveArray(Class<?>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "check if class represents an array of primitives",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ClassUtils#isPrimitiveArray(Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "boolean, byte, char, short, int, long, float, or double",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#isPrimitiveArray(Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "The given class is a primitive array class",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#isPrimitiveArray(Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "java\npackage com.example;\n\nimport org.springframework.util.ClassUtils;\n\npublic class PrimitiveArrayCheck {\n    public static void main(String[] args) {\n        Class<?> clazz = int[].class;\n        boolean isPrimitiveArray = ClassUtils.isPrimitiveArray(clazz);\n        System.out.println(\"Is primitive array: \" + isPrimitiveArray);\n    }\n}\n",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ClassUtils#classNamesToString(Class<?>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "building a string from class names",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ClassUtils#classNamesToString(Class<?>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "input must be an array of Class objects",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ClassUtils#classNamesToString(Class<?>)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "creating a string representation of multiple classes",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ClassUtils#classNamesToString(Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for building a string from class names",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ClassUtils#classNamesToString(Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "related concept interpretation for building strings from class names",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#classNamesToString(Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle interpretation for building strings from class names",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#classNamesToString(Class<?>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "java.util.AbstractCollection#toString()",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.ClassUtils#isUserLevelMethod(Method)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "determine user-declared method",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ClassUtils#isUserLevelMethod(Method)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "method must not be null",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ClassUtils#isUserLevelMethod(Method)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "check if method is user-declared",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ClassUtils#isUserLevelMethod(Method)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for isUserLevelMethod",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ClassUtils#isUserLevelMethod(Method)",
      "head_type": "method",
      "relation": "have",
      "tail": "interpretation of synthetic and bridge methods",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#isUserLevelMethod(Method)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle of determining user-level methods",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#isUserLevelMethod(Method)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "Method",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.ClassUtils#isUserLevelMethod(Method)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "GroovyObject",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.comparator.Comparators#nullsHigh(Comparator<T>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "nullsHigh",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.comparator.Comparators#nullsHigh(Comparator<T>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "Comparator#nullsLast(Comparator)",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.comparator.Comparators#nullsHigh(Comparator<T>)",
      "head_type": "method",
      "relation": "have",
      "tail": "Return a decorator for the given comparator which accepts null values and sorts them higher than non-null values.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.comparator.Comparators#nullsHigh(Comparator<T>)",
      "head_type": "method",
      "relation": "have",
      "tail": "The method creates a comparator decorator that places null values higher than non-null values, utilizing Comparator.nullsLast(Comparator) internally.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.comparator.Comparators#nullsHigh(Comparator<T>)",
      "head_type": "method",
      "relation": "have",
      "tail": "package com.example;\n\nimport java.util.Comparator;\n\npublic class NullsHighExample {\n    public static void main(String[] args) {\n        Comparator<String> comparator = Comparator.nullsLast(String::compareTo);\n        System.out.println(\"Comparison result: \" + comparator.compare(null, \"apple\"));\n    }\n}\n",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.concurrent.FutureAdapter#getAdaptee()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getAdaptee",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.concurrent.FutureAdapter#getAdaptee()",
      "head_type": "method",
      "relation": "have",
      "tail": "getAdaptee() method returns the adaptee.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.concurrent.FutureAdapter",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.concurrent.FutureAdapter#getAdaptee()",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.concurrent.FutureAdapter#getAdaptee()",
      "head_type": "method",
      "relation": "have",
      "tail": "protected Future<S> getAdaptee() {\n    return this.adaptee;\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.EvictionQueue#linkLast(Node<K,V>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "linkLast",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.EvictionQueue#linkLast(Node<K,V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.EvictionQueue",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.EvictionQueue",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.EvictionQueue#linkLast(Node<K,V>)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.EvictionQueue#linkLast(Node<K,V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "Add a new node to the end of the eviction queue.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.EvictionQueue#linkLast(Node<K,V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "Ensure the integrity of the queue by properly setting the next and previous nodes.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.EvictionQueue#linkLast(Node<K,V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "package com.example;\n\nimport org.springframework.util.EvictionQueue;\n\npublic class Main {\n    public static void main(String[] args) {\n        EvictionQueue<String, String> queue = new EvictionQueue<>();\n        Node<String, String> node = queue.createNode(\"key\", \"value\");\n        queue.linkLast(node);\n    }\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.Segment#doTask(int,Object,Task<T>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "applyUpdateOperation",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.Segment#doTask(int,Object,Task<T>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "segmentLockedDuringUpdate",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.Segment#doTask(int,Object,Task<T>)",
      "head_type": "method",
      "relation": "have",
      "tail": "segmentLockedDuringUpdate",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.Segment#doTask(int,Object,Task<T>)",
      "head_type": "method",
      "relation": "have",
      "tail": "applyUpdateOperationSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "applyUpdateOperationSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "applyUpdateOperationSampleCodeContent",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.Segment#doTask(int,Object,Task<T>)",
      "head_type": "method",
      "relation": "have",
      "tail": "applyUpdateOperationRelatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "applyUpdateOperationRelatedConceptInterpretation",
      "head_type": "relatedConceptInterpretation",
      "relation": "have",
      "tail": "applyUpdateOperationRelatedConceptInterpretationContent",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.Segment#doTask(int/Object/Task<T>)",
      "head_type": "method",
      "relation": "have",
      "tail": "applyUpdateOperationDesignPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "applyUpdateOperationDesignPrincipleInterpretation",
      "head_type": "designPrincipleInterpretation",
      "relation": "have",
      "tail": "applyUpdateOperationDesignPrincipleInterpretationContent",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.Segment#doTask(int/Object/Task<T>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.Segment",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.Entry#setValue(V)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "Setting a value",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.Entry#setValue(V)",
      "head_type": "method",
      "relation": "have",
      "tail": "Set a new value to the entry and return the previous value.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.Entry#setValue(V)",
      "head_type": "method",
      "relation": "have",
      "tail": "public V setValue(@Nullable V value) {\n    V previous = this.value;\n    this.value = value;\n    return previous;\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.Entry#hashCode()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "generating hash code",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.Entry#hashCode()",
      "head_type": "method",
      "relation": "have",
      "tail": "The method computes the hash code of an entry by XORing the hash codes of its key and value, ensuring null safety.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.Entry#hashCode()",
      "head_type": "method",
      "relation": "have",
      "tail": "This approach ensures that the hash code is computed in a null-safe manner, where null keys or values do not cause a NullPointerException.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.Entry#hashCode()",
      "head_type": "method",
      "relation": "have",
      "tail": "java\npackage org.springframework.util;\n\nimport java.util.Objects;\n\npublic class Entry<K, V> {\n    private K key;\n    private V value;\n\n    public Entry(K key, V value) {\n        this.key = key;\n        this.value = value;\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(key, value);\n    }\n}\n",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.SoftEntryReference#getNext()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "reference retrieval",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.SoftEntryReference#getNext()",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is used to retrieve the next reference in a series of soft references.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.SoftEntryReference#getNext()",
      "head_type": "method",
      "relation": "have",
      "tail": "The design principle behind this method is to provide a way to navigate through a linked structure of soft references, ensuring efficient memory usage by allowing garbage collection of unreferenced entries.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.SoftEntryReference#getNext()",
      "head_type": "method",
      "relation": "have",
      "tail": "package com.example.util;\n\nimport org.springframework.util.SoftReference;\n\npublic class SoftEntryReferenceExample {\n    public static void main(String[] args) {\n        SoftReference<String> softReference = new SoftReference<>(\"Sample Data\");\n        SoftEntryReference<String, String> entryReference = new SoftEntryReference<>(\"key\", softReference);\n        SoftEntryReference<String, String> nextEntryReference = new SoftEntryReference<>(\"nextKey\", new SoftReference<>(\"Next Data\"));\n        entryReference.setNext(nextEntryReference);\n        SoftEntryReference<String, String> retrievedNext = entryReference.getNext();\n        System.out.println(\"Retrieved Next Key: \" + retrievedNext.getKey());\n        System.out.println(\"Retrieved Next Value: \" + retrievedNext.get());\n    }\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.CustomizableThreadCreator#getDefaultThreadNamePrefix()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "building default thread name prefix",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.CustomizableThreadCreator#getDefaultThreadNamePrefix()",
      "head_type": "method",
      "relation": "have",
      "tail": "the default thread name prefix (never null)",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.CustomizableThreadCreator#getDefaultThreadNamePrefix()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "ClassUtils",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.CustomizableThreadCreator#getDefaultThreadNamePrefix()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "getClass()",
      "tail_type": "method"
    },
    {
      "head": "building default thread name prefix",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "thread name prefix customization",
      "tail_type": "useScenario"
    },
    {
      "head": "thread name prefix customization",
      "head_type": "useScenario",
      "relation": "have",
      "tail": "CustomizableThreadCreator",
      "tail_type": "class"
    },
    {
      "head": "CustomizableThreadCreator",
      "head_type": "class",
      "relation": "designPrincipleInterpretation",
      "tail": "This class is designed to provide a flexible way to create threads with customizable names, improving the readability of stack traces and thread management.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "ClassUtils",
      "head_type": "class",
      "relation": "relatedConceptInterpretation",
      "tail": "ClassUtils is a utility class in Spring Framework that provides various methods for manipulating classes and resources.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.FastByteArrayInputStream#updateMessageDigest(MessageDigest,int)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "updateMessageDigest",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.FastByteArrayInputStream#updateMessageDigest(MessageDigest,int)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "len must be 0 or greater",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.FastByteArrayInputStream#updateMessageDigest(MessageDigest,int)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "update the message digest with the next len bytes in this stream",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.FastByteArrayInputStream#updateMessageDigest(MessageDigest,int)",
      "head_type": "method",
      "relation": "have",
      "tail": "update the message digest with the next len bytes in this stream",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.FastByteArrayInputStream#updateMessageDigest(MessageDigest,int)",
      "head_type": "method",
      "relation": "have",
      "tail": "void updateMessageDigest(MessageDigest messageDigest, int len) { ... }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.FastByteArrayInputStream#updateMessageDigest(MessageDigest,int)",
      "head_type": "method",
      "relation": "have",
      "tail": "Avoids creating new byte arrays and use internal buffers for performance.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.FastByteArrayInputStream#updateMessageDigest(MessageDigest,int)",
      "head_type": "method",
      "relation": "have",
      "tail": "Design principle: Optimize performance by reusing internal buffers.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.FastByteArrayInputStream#updateMessageDigest(MessageDigest,int)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.FastByteArrayInputStream",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.FilteredIterator#next()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "nextElementRetrieval",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.FilteredIterator#next()",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "elementAvailability",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.FilteredIterator#next()",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "iteratorTraversal",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.FilteredIterator#next()",
      "head_type": "method",
      "relation": "have",
      "tail": "iteratorStateManagement",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.FilteredIterator#next()",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrinciple",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.FilteredIterator#next()",
      "head_type": "method",
      "relation": "have",
      "tail": "sampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "nextElementRetrieval",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "org.springframework.util.FilteredIterator",
      "tail_type": "class"
    },
    {
      "head": "elementAvailability",
      "head_type": "useConstraint",
      "relation": "associated_with",
      "tail": "org.springframework.util.FilteredIterator",
      "tail_type": "class"
    },
    {
      "head": "iteratorTraversal",
      "head_type": "useScenario",
      "relation": "associated_with",
      "tail": "org.springframework.util.FilteredIterator",
      "tail_type": "class"
    },
    {
      "head": "iteratorStateManagement",
      "head_type": "relatedConceptInterpretation",
      "relation": "associated_with",
      "tail": "org.springframework.util.FilteredIterator",
      "tail_type": "class"
    },
    {
      "head": "designPrinciple",
      "head_type": "designPrincipleInterpretation",
      "relation": "associated_with",
      "tail": "org.springframework.util.FilteredIterator",
      "tail_type": "class"
    },
    {
      "head": "sampleCode",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "tail": "org.springframework.util.FilteredIterator",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.function.ThrowingBiFunction#of(ThrowingBiFunction<T,U,R>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "create ThrowingBiFunction",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.function.ThrowingBiFunction#of(ThrowingBiFunction<T,U,R>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "lambda expression or method reference must throw checked exception",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.function.ThrowingBiFunction#of(ThrowingBiFunction<T,U,R>)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "convert method that throws checked exception to BiFunction",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.function.ThrowingBiFunction#of(ThrowingBiFunction<T,U,R>)",
      "head_type": "method",
      "relation": "have",
      "tail": "map.replaceAll(ThrowingBiFunction.of(Example::methodThatCanThrowCheckedException));",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.function.ThrowingBiFunction#of(ThrowingBiFunction<T,U,R>)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method can be especially useful when working with method references. It allows you to easily convert a method that throws a checked exception into an instance compatible with a regular BiFunction.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.function.ThrowingBiFunction#of(ThrowingBiFunction<T,U,R>)",
      "head_type": "method",
      "relation": "have",
      "tail": "Lambda friendly convenience method that can be used to create a ThrowingBiFunction where the apply method wraps any checked exception thrown by the supplied lambda expression or method reference.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.function.ThrowingBiFunction#of(ThrowingBiFunction<T,U,R>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.function.ThrowingBiFunction",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.KeySet#size()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "sizeCalculation",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.KeySet#size()",
      "head_type": "method",
      "relation": "have",
      "tail": "sizeCalculationSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "sizeCalculationSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "org.springframework.util.KeySet#size()",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.KeySet#size()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.KeySet",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.KeySet#contains(Object)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "checkInclusion",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.KeySet#contains(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.KeySet#contains(Object) useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.KeySet#contains(Object)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.KeySet",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.MimeTypeUtils#generateMultipartBoundaryString()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "generate random MIME boundary",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MimeTypeUtils#generateMultipartBoundaryString()",
      "head_type": "method",
      "relation": "have",
      "tail": "used in multipart mime types",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.MimeTypeUtils#generateMultipartBoundaryString()",
      "head_type": "method",
      "relation": "have",
      "tail": "public static String generateMultipartBoundaryString() { return new String(generateMultipartBoundary(), StandardCharsets.US_ASCII); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.MimeTypeUtils#generateMultipartBoundaryString()",
      "head_type": "method",
      "relation": "have",
      "tail": "A random MIME boundary is a unique string used to separate different parts of data in a multipart message, ensuring that each part can be processed independently.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.MimeTypeUtils#generateMultipartBoundaryString()",
      "head_type": "method",
      "relation": "have",
      "tail": "The design principle behind generating a random MIME boundary is to ensure uniqueness and randomness, which helps in securely and accurately parsing multipart messages. This method leverages the use of standard character sets to ensure compatibility across different systems.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ObjectUtils#toObjectArray(Object)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "Convert the given array (which may be a primitive array) to an object array",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ObjectUtils#toObjectArray(Object)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "IllegalArgumentException if the parameter is not an array",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ObjectUtils#toObjectArray(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "A null source value or empty primitive array will be converted to an empty Object array",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ObjectUtils#toObjectArray(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "Convert the given array (which may be a primitive array) to an object array (if necessary, to an array of primitive wrapper objects)",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ObjectUtils#toObjectArray(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "The method should handle null and non-array inputs gracefully, converting them to an empty array or throwing an exception respectively",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ObjectUtils#toObjectArray(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "public static Object[] toObjectArray(@Nullable Object source) {\n    if (source instanceof Object[] objects) {\n        return objects;\n    }\n    if (source == null) {\n        return EMPTY_OBJECT_ARRAY;\n    }\n    if (!source.getClass().isArray()) {\n        throw new IllegalArgumentException(\"Source is not an array: \" + source);\n    }\n    int length = Array.getLength(source);\n    if (length == 0) {\n        return EMPTY_OBJECT_ARRAY;\n    }\n    Class<?> wrapperType = Array.get(source, 0).getClass();\n    Object[] newArray = (Object[]) Array.newInstance(wrapperType, length);\n    for (int i = 0; i < length; i++) {\n        newArray[i] = Array.get(source, i);\n    }\n    return newArray;\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.PathMatcher#combine(String,String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "combining two patterns",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.PathMatcher#combine(String,String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": " combinability of the two patterns",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.PathMatcher#combine(String,String)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "pattern combination in path matching",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.PathMatcher#combine(String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for combining patterns",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.PathMatcher#combine(String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "interpretation of pattern combination",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.PathMatcher#combine(String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principles behind pattern combination",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.PathMatcher#combine(String,String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.PathMatcher",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.TextPart",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "TextPart(String text)",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.TextPart",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "resolve(PartResolutionContext resolutionContext)",
      "tail_type": "apiFunction"
    },
    {
      "head": "resolve(PartResolutionContext resolutionContext)",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "return text();",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.TextPart",
      "head_type": "class",
      "relation": "have",
      "tail": "A Part implementation that does not contain a valid placeholder.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.StopWatch#lastTaskInfo()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "retrieve last task information",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StopWatch#lastTaskInfo()",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "must have tasks run before retrieval",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.StopWatch#lastTaskInfo()",
      "head_type": "method",
      "relation": "have",
      "tail": "used to get the last task information",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.StopWatch#lastTaskInfo()",
      "head_type": "method",
      "relation": "have",
      "tail": "package org.springframework.util; import org.springframework.util.Assert; public class StopWatch { // method implementation }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.StopWatch#lastTaskInfo()",
      "head_type": "method",
      "relation": "have",
      "tail": "related to task management and performance measurement",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.StopWatch#lastTaskInfo()",
      "head_type": "method",
      "relation": "have",
      "tail": "designed to provide detailed information about the last executed task",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.StringUtils#uncapitalize(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "uncapitalize a String",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils#uncapitalize(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "change the first letter to lower case",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.StringUtils#uncapitalize(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "No other letters are changed",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.StringUtils#uncapitalize(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "related to Character#toLowerCase(char)",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.StringUtils#uncapitalize(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle of uncapitalizing strings",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.StringUtils#uncapitalize(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "public static String uncapitalize(String str) { return changeFirstCharacterCase(str, false); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.SystemPropertyUtils",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "resolvePlaceholders",
      "tail_type": "apiFunction"
    },
    {
      "head": "resolvePlaceholders",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "IllegalArgumentException if there is an unresolvable placeholder",
      "tail_type": "useConstraint"
    },
    {
      "head": "resolvePlaceholders",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "replacing placeholders in texts with system property values",
      "tail_type": "useScenario"
    },
    {
      "head": "resolvePlaceholders",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "sample code for resolving placeholders",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.SystemPropertyUtils",
      "head_type": "class",
      "relation": "have",
      "tail": "related concept interpretation for resolving placeholders",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.SystemPropertyUtils",
      "head_type": "class",
      "relation": "have",
      "tail": "design principle interpretation for resolving placeholders",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.SystemPropertyUtils",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "Juergen Hoeller, Rob Harrop, Dave Syer",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.unit.DataSize#parse(CharSequence)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "parseDataSize",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.unit.DataSize#parse(CharSequence)",
      "head_type": "method",
      "relation": "have",
      "tail": "parseDataSizeSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "parseDataSizeSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "DataSizeSampleCodeContent",
      "tail_type": "useSampleCodeContent"
    },
    {
      "head": "org.springframework.util.unit.DataSize#parse(CharSequence)",
      "head_type": "method",
      "relation": "have",
      "tail": "parseDataSizeRelatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "parseDataSizeRelatedConceptInterpretation",
      "head_type": "relatedConceptInterpretation",
      "relation": "have",
      "tail": "DataSizeAndDataUnitExplanation",
      "tail_type": "relatedConceptExplanation"
    },
    {
      "head": "org.springframework.util.unit.DataSize#parse(CharSequence)",
      "head_type": "method",
      "relation": "have",
      "tail": "parseDataSizeDesignPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "parseDataSizeDesignPrincipleInterpretation",
      "head_type": "designPrincipleInterpretation",
      "relation": "have",
      "tail": "SimplicityAndFlexibilityPrinciple",
      "tail_type": "designPrincipleExplanation"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#containsKey(Object)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "check key existence",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#containsKey(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.UnmodifiableMultiValueMap#containsKey(Object) sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#containsKey(Object) sample code",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "package com.example.demo; import org.springframework.util.UnmodifiableMultiValueMap; import java.util.Arrays; import java.util.List; public class SampleCode { public static void main(String[] args) { UnmodifiableMultiValueMap<String, String> map = new UnmodifiableMultiValueMap<>(new MultiValueMap<String, String>() {{ put(\"key\", Arrays.asList(\"value1\", \"value2\")); }}); System.out.println(map.containsKey(\"key\")); } }",
      "tail_type": "code"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#values()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "return a collection of values",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#values()",
      "head_type": "method",
      "relation": "have",
      "tail": "if the values are null, initialize them with an unmodifiable view of the delegate's values",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#values()",
      "head_type": "method",
      "relation": "have",
      "tail": "always return the same collection instance if called multiple times",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#values()",
      "head_type": "method",
      "relation": "have",
      "tail": "the method ensures that the returned collection is unmodifiable",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#values()",
      "head_type": "method",
      "relation": "have",
      "tail": "the method provides a thread-safe view of the values if the underlying map is thread-safe",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#values()",
      "head_type": "method",
      "relation": "have",
      "tail": "the design principle is to provide a read-only view of the underlying map's values without allowing modification",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#values()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.UnmodifiableMultiValueMap",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySet#contains(Object)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "checkInclusion",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySet#contains(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.UnmodifiableEntrySet#contains(Object) useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySet#contains(Object) useSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "org.springframework.util.UnmodifiableEntrySet#contains(Object) sampleCodeContent",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySpliterator#estimateSize()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "estimation of size",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySpliterator#estimateSize()",
      "head_type": "method",
      "relation": "have",
      "tail": "Delegate the estimation to the internal delegate object",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySpliterator#estimateSize()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.UnmodifiableEntrySpliterator",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySpliterator#estimateSize()",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is used to estimate the size of the spliterator by delegating the call to the internal delegate object. It overrides the estimateSize method from the Spliterator interface.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySpliterator#estimateSize()",
      "head_type": "method",
      "relation": "have",
      "tail": "The design principle followed here is the delegation pattern, where the object forwards the request to another object. This promotes flexibility and loose coupling.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntry#setValue(List<V>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "org.springframework.util.UnmodifiableEntry#setValue(List<V>)",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntry#setValue(List<V>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "UnsupportedOperationException",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntry#setValue(List<V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "throw new UnsupportedOperationException();",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntry#setValue(List<V>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.UnmodifiableEntry",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueCollection#addAll(Collection<? extends List<V>>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "add elements to collection",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueCollection#addAll(Collection<? extends List<V>>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "unsupported operation",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueCollection#addAll(Collection<? extends List<V>>)",
      "head_type": "method",
      "relation": "have",
      "tail": "add elements to collection sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueCollection#addAll(Collection<? extends List<V>>)",
      "head_type": "method",
      "relation": "have",
      "tail": "related concept interpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueCollection#addAll(Collection<? extends List<V>>)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle interpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueCollection#addAll(Collection<? extends List<V>>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.UnmodifiableValueCollection",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#ignorableWhitespaceInternal(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "handleIgnorableWhitespace",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#ignorableWhitespaceInternal(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.xml.AbstractStaxHandler",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#ignorableWhitespaceInternal(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#ignorableWhitespaceInternal(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#ignorableWhitespaceInternal(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLStreamReader",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getNamespaceURI",
      "tail_type": "apiFunction"
    },
    {
      "head": "getNamespaceURI",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "getNamespaceURI(String)",
      "tail_type": "useSampleCode"
    },
    {
      "head": "getNamespaceURI(String)",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "tail": "getNamespaceContext().getNamespaceURI(prefix)",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLStreamReader",
      "head_type": "class",
      "relation": "have",
      "tail": "getNamespaceURI(String)",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.DomContentHandler#processingInstruction(String,String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "processing XML instructions",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.DomContentHandler#processingInstruction(String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is used to handle processing instructions within an XML document.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.DomContentHandler#processingInstruction(String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "public void processingInstruction(String target, String data) {\n    Node parent = getParent();\n    ProcessingInstruction pi = this.document.createProcessingInstruction(target, data);\n    parent.appendChild(pi);\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.SimpleTransformErrorListener#fatalError(TransformerException)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "handle fatal TransformerException",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.SimpleTransformErrorListener#fatalError(TransformerException)",
      "head_type": "method",
      "relation": "have",
      "tail": "handle fatal TransformerException sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "handle fatal TransformerException sample code",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "org.springframework.util.xml.SimpleTransformErrorListener",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.StaxEventHandler#startElementInternal(QName,Attributes,Map<String,String>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "xml event handling",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxEventHandler#startElementInternal(QName,Attributes,Map<String,String>)",
      "head_type": "method",
      "relation": "have",
      "tail": "xml event handling sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "xml event handling sample code",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "xml event handling sample code content",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.StaxEventHandler#startElementInternal(QName,Attributes,Map<String,String>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.StaxEventHandler",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamHandler",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "writeStartDocument",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamHandler",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "writeEndDocument",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamHandler",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "writeStartElement",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamHandler",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "writeNamespace",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamHandler",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "setDefaultNamespace",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamHandler",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "setPrefix",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamHandler",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "writeAttribute",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamHandler",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "writeEndElement",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamHandler",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "writeCharacters",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamHandler",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "writeCData",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamHandler",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "writeProcessingInstruction",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamHandler",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "writeDTD",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamHandler",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "writeComment",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamHandler",
      "head_type": "class",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamHandler",
      "head_type": "class",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamHandler",
      "head_type": "class",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamHandler",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.core.io.Resource",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamHandler",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.core.io.ResourceLoader",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamHandler",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.beans.factory.xml.DefaultDocumentLoader",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamHandler",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.beans.factory.xml.PluggableSchemaResolver",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamHandler",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.beans.factory.xml.XmlBeanDefinitionReader",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamHandler",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.beans.factory.support.DefaultBeanDefinitionRegistry",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamHandler",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.beans.factory.config.ConfigurableListableBeanFactory",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamHandler",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.beans.factory.config.ConfigurableBeanFactory",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamHandler",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.context.support.AbstractApplicationContext",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamHandler",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.context.ApplicationContext",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamHandler",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.context.ApplicationContextAware",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamHandler",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.beans.factory.BeanFactoryAware",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamHandler",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.beans.factory.BeanFactory",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamHandler",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.beans.factory.config.AutowireCapableBeanFactory",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamHandler",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.beans.factory.config.ConfigurableListableBeanFactory",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamHandler",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.beans.factory.config.ConfigurableBeanFactory",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamHandler",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.context.support.AbstractApplicationContext",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamHandler",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.context.ApplicationContext",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamHandler",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.context.ApplicationContextAware",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamHandler",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.beans.factory.BeanFactoryAware",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamHandler",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.beans.factory.BeanFactory",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamHandler",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.beans.factory.config.AutowireCapableBeanFactory",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamHandler",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.core.io.Resource",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamHandler",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.core.io.ResourceLoader",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamHandler",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.beans.factory.xml.DefaultDocumentLoader",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamHandler",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.beans.factory.xml.PluggableSchemaResolver",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamHandler",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.beans.factory.xml.XmlBeanDefinitionReader",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamHandler",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.beans.factory.support.DefaultBeanDefinitionRegistry",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamHandler",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.beans.factory.config.ConfigurableListableBeanFactory",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamHandler",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.beans.factory.config.ConfigurableBeanFactory",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamHandler",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.context.support.AbstractApplicationContext",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamHandler",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.context.ApplicationContext",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamHandler",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.context.ApplicationContextAware",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamHandler",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.beans.factory.BeanFactoryAware",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamHandler",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.beans.factory.BeanFactory",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamHandler",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.beans.factory.config.AutowireCapableBeanFactory",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.TransformerUtils",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "indenting",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.TransformerUtils",
      "head_type": "class",
      "relation": "constrained_by",
      "tail": "indent amount must not be less than zero",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.xml.TransformerUtils",
      "head_type": "class",
      "relation": "applied_to",
      "tail": "transformer indenting",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.xml.TransformerUtils",
      "head_type": "class",
      "relation": "have",
      "tail": "sample code for indenting",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.TransformerUtils",
      "head_type": "class",
      "relation": "have",
      "tail": "related concept interpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.TransformerUtils",
      "head_type": "class",
      "relation": "have",
      "tail": "design principle interpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "indenting",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "indent amount must not be less than zero",
      "tail_type": "useConstraint"
    },
    {
      "head": "indenting",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "transformer indenting",
      "tail_type": "useScenario"
    },
    {
      "head": "indenting",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "sample code for indenting",
      "tail_type": "useSampleCode"
    },
    {
      "head": "indenting",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "related concept interpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "indenting",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "design principle interpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamReader",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getCharacterEncodingScheme()",
      "tail_type": "apiFunction"
    },
    {
      "head": "getCharacterEncodingScheme()",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "getCharacterEncodingScheme() returns null",
      "tail_type": "useSampleCode"
    },
    {
      "head": "getCharacterEncodingScheme() returns null",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "This method always returns null",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamReader",
      "head_type": "class",
      "relation": "have",
      "tail": "This method always returns null",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter#writeEmptyElement(String,String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "writeEmptyElement",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter#writeEmptyElement(String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "writeEmptyElementSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "writeEmptyElementSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "writeEmptyElementSampleCodeContent",
      "tail_type": "useSampleCodeContent"
    },
    {
      "head": "org.springframework.util.xml.XmlValidationModeDetector#endComment(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "consuming the END_COMMENT token",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.XmlValidationModeDetector#endComment(String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "the END_COMMENT token must be present",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.xml.XmlValidationModeDetector#endComment(String)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "xml parsing",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.xml.XmlValidationModeDetector#endComment(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "xml parsing",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.xml.XmlValidationModeDetector#endComment(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.XmlValidationModeDetector#endComment(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.XmlValidationModeDetector#endComment(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.XmlValidationModeDetector#endComment(String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.XmlValidationModeDetector",
      "tail_type": "class"
    },
    {
      "head": "consuming the END_COMMENT token",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "xml parsing",
      "tail_type": "useScenario"
    },
    {
      "head": "consuming the END_COMMENT token",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "consuming the END_COMMENT token",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "consuming the END_COMMENT token",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "xml parsing",
      "head_type": "useScenario",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "xml parsing",
      "head_type": "useScenario",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "xml parsing",
      "head_type": "useScenario",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.SelfReference",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getThis()",
      "tail_type": "apiFunction"
    },
    {
      "head": "getThis()",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "getThis() returns the current instance",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "getThis()",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "Sample code for getThis()",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests#addResourceFileWithCharSequenceAddsFile()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "addResourceFile",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests#addResourceFileWithCharSequenceAddsFile()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "assertThatFileAdded",
      "tail_type": "apiFunction"
    },
    {
      "head": "addResourceFile",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "assertThatFileAdded",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests#addResourceFileWithCharSequenceAddsFile()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.GeneratedFilesTests",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests",
      "head_type": "class",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests",
      "head_type": "class",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests#addResourceFileWithInputStreamSourceAddsFile()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "addResourceFileWithInputStreamSourceAddsFile",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests#addResourceFileWithInputStreamSourceAddsFile()",
      "head_type": "method",
      "relation": "have",
      "tail": "Resource resource = new ByteArrayResource(\"test\".getBytes(StandardCharsets.UTF_8));\n    this.generatedFiles.addResourceFile(\"META-INF/file\", resource);\n    assertThatFileAdded(Kind.RESOURCE, \"META-INF/file\").isEqualTo(\"test\");",
      "tail_type": "useSampleCode"
    },
    {
      "head": "addResourceFileWithInputStreamSourceAddsFile",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "Resource resource = new ByteArrayResource(\"test\".getBytes(StandardCharsets.UTF_8));\n    this.generatedFiles.addResourceFile(\"META-INF/file\", resource);\n    assertThatFileAdded(Kind.RESOURCE, \"META-INF/file\").isEqualTo(\"test\");",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.ValueCodeAssert#valueCode()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "generate value code assertion",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.ValueCodeAssert#valueCode()",
      "head_type": "method",
      "relation": "have",
      "tail": "StringAssert valueCode() { return new StringAssert(this.actual.code); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.ValueCodeAssert#valueCode()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.ValueCodeAssert",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.ValueCodeAssert",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "generate value code assertion",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.ValueCodeAssert",
      "head_type": "class",
      "relation": "have",
      "tail": "StringAssert valueCode() { return new StringAssert(this.actual.code); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.hint.annotation.SampleTypeAnnotatedBean",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "notManaged",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.hint.annotation.SampleTypeAnnotatedBean",
      "head_type": "class",
      "relation": "have",
      "tail": "private String notManaged; public void notManaged();",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.core.type.StandardMethodMetadata#getDeclaringClassName()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getDeclaringClassName",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.core.type.StandardMethodMetadata#getDeclaringClassName()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.core.type.StandardMethodMetadata",
      "tail_type": "class"
    },
    {
      "head": "getDeclaringClassName",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "getDeclaringClassNameSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "getDeclaringClassNameSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "getDeclaringClassNameSampleCodeContent",
      "tail_type": "useSampleCodeContent"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#setCachePatterns(boolean)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "cache parsed pattern metadata",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#setCachePatterns(boolean)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "cachePatterns must be a boolean value",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#setCachePatterns(boolean)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "activating or deactivating the pattern cache",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#setCachePatterns(boolean)",
      "head_type": "method",
      "relation": "have",
      "tail": "public void setCachePatterns(boolean cachePatterns) {    this.cachePatterns = cachePatterns;}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#setCachePatterns(boolean)",
      "head_type": "method",
      "relation": "have",
      "tail": "The method allows for the activation or deactivation of the pattern cache, which stores parsed pattern metadata to enhance performance during pattern matching.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#setCachePatterns(boolean)",
      "head_type": "method",
      "relation": "have",
      "tail": "The design principle behind this method is to provide a way to control the caching behavior of pattern metadata, allowing for optimization of memory usage and performance based on the application's needs.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.AntPathMatcher",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.AntPathMatcher#setCachePatterns(boolean)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#extractPathWithinPattern(String,String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "extractPathWithinPattern",
      "tail_type": "apiFunction"
    },
    {
      "head": "extractPathWithinPattern",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "patternMatching",
      "tail_type": "useScenario"
    },
    {
      "head": "patternMatching",
      "head_type": "useScenario",
      "relation": "have",
      "tail": "extractPathWithinPatternSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "extractPathWithinPattern",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "extractPathWithinPattern",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.AutoPopulatingList#isEmpty()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "checkEmptiness",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.AutoPopulatingList#isEmpty()",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.AutoPopulatingList",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.AutoPopulatingList#isEmpty()",
      "head_type": "method",
      "relation": "have",
      "tail": "This method checks if the backing list is empty.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.AutoPopulatingList#isEmpty()",
      "head_type": "method",
      "relation": "have",
      "tail": "This method follows the principle of delegation, where it delegates the emptiness check to the backing list.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.AutoPopulatingList#isEmpty()",
      "head_type": "method",
      "relation": "have",
      "tail": "package com.example;\n\nimport org.springframework.util.AutoPopulatingList;\n\npublic class Main {\n    public static void main(String[] args) {\n        AutoPopulatingList<String> list = new AutoPopulatingList<>();\n        System.out.println(\"Is list empty? \" + list.isEmpty());\n    }\n}",
      "tail_type": "useSampleCode"
    },
    {
      "relationships": [
        {
          "tail": "listIterator",
          "head_type": "method",
          "relation": "haveFunction",
          "head": "org.springframework.util.AutoPopulatingList#listIterator(int)",
          "tail_type": "apiFunction"
        },
        {
          "tail": "org.springframework.util.AutoPopulatingList",
          "head_type": "method",
          "relation": "associated_with",
          "head": "org.springframework.util.AutoPopulatingList#listIterator(int)",
          "tail_type": "class"
        },
        {
          "tail": "org.springframework.util.AutoPopulatingList#listIterator(int) useSampleCode",
          "head_type": "method",
          "relation": "have",
          "head": "org.springframework.util.AutoPopulatingList#listIterator(int)",
          "tail_type": "useSampleCode"
        }
      ]
    },
    {
      "org.springframework.util.AutoPopulatingList#listIterator(int) useSampleCode": "package org.springframework.util;\n\nimport java.util.ListIterator;\n\npublic class AutoPopulatingListExample {\n    public static void main(String[] args) {\n        AutoPopulatingList<String> list = new AutoPopulatingList<>(Arrays.asList(\"apple\", \"banana\", \"cherry\"));\n        ListIterator<String> iterator = list.listIterator(1);\n        while (iterator.hasNext()) {\n            System.out.println(iterator.next());\n        }\n    }\n}"
    },
    {
      "head": "org.springframework.util.ClassUtils#convertClassNameToResourcePath(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "convert fully qualified class name to resource path",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ClassUtils#convertClassNameToResourcePath(String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "class name must not be null",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ClassUtils#convertClassNameToResourcePath(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "Convert a '.'-based fully qualified class name to a '/'-based resource path.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#convertClassNameToResourcePath(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is used to transform a class name into a resource path format that is typically used in resource loading or classpath scanning operations.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#convertClassNameToResourcePath(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "public static String convertClassNameToResourcePath(String className) {\n    Assert.notNull(className, \"Class name must not be null\");\n    return className.replace(PACKAGE_SEPARATOR, PATH_SEPARATOR);\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ClassUtils#getQualifiedMethodName(Method,Class<?>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "get qualified method name",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ClassUtils#getQualifiedMethodName(Method,Class<?>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "method must not be null",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ClassUtils#getQualifiedMethodName(Method,Class<?>)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "invoking method on a class",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ClassUtils#getQualifiedMethodName(Method,Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "Return the qualified name of the given method, consisting of fully qualified interface/class name + \".\" + method name.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#getQualifiedMethodName(Method,Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is designed to provide a way to get the fully qualified name of a method, which includes the package name, class name, and method name. It is useful for logging, debugging, and generating documentation.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#getQualifiedMethodName(Method,Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "public static String getQualifiedMethodName(Method method, @Nullable Class<?> clazz) {\n    Assert.notNull(method, \"Method must not be null\");\n    return (clazz != null ? clazz : method.getDeclaringClass()).getName() + '.' + method.getName();\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.CollectionUtils#findFirstMatch(Collection<?>,Collection<E>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "findFirstMatch",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.CollectionUtils#findFirstMatch(Collection<?>,Collection<E>)",
      "head_type": "method",
      "relation": "have",
      "tail": "Return the first element in 'candidates' that is contained in 'source'. If no element in 'candidates' is present in 'source' returns null. Iteration order is Collection implementation specific.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.CollectionUtils#findFirstMatch(Collection<?>,Collection<E>)",
      "head_type": "method",
      "relation": "have",
      "tail": "public static <E> E findFirstMatch(Collection<?> source, Collection<E> candidates) { if (isEmpty(source) || isEmpty(candidates)) { return null; } for (E candidate : candidates) { if (source.contains(candidate)) { return candidate; } } return null; }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "findFirstMatch",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "Return the first element in 'candidates' that is contained in 'source'. If no element in 'candidates' is present in 'source' returns null. Iteration order is Collection implementation specific.",
      "tail_type": "useScenario"
    },
    {
      "head": "findFirstMatch",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "Return the first element in 'candidates' that is contained in 'source'. If no element in 'candidates' is present in 'source' returns null. Iteration order is Collection implementation specific.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "findFirstMatch",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "public static <E> E findFirstMatch(Collection<?> source, Collection<E> candidates) { if (isEmpty(source) || isEmpty(candidates)) { return null; } for (E candidate : candidates) { if (source.contains(candidate)) { return candidate; } } return null; }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.CollectionUtils#toArray(Enumeration<E>,A[])",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "marshal elements into array",
      "tail_type": "apiFunction"
    },
    {
      "head": "marshal elements into array",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "elements must be assignable to array type",
      "tail_type": "useConstraint"
    },
    {
      "head": "marshal elements into array",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "convert enumeration to array",
      "tail_type": "useScenario"
    },
    {
      "head": "marshal elements into array",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "convert enumeration to array sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "marshal elements into array",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "enumeration to array conversion explanation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "marshal elements into array",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "design principle for enumeration to array conversion",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.CollectionUtils",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "marshal elements into array",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.CompositeMap#values()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "return a collection of values",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.CompositeMap#values()",
      "head_type": "method",
      "relation": "have",
      "tail": "new CompositeCollection<>(this.first.values(), this.second.values())",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.CompositeMap#values()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.CompositeCollection",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.CompositeMap#values()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "this.first",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.CompositeMap#values()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "this.second",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.ConcurrentLruCache#processWrite(Runnable)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "processWrite",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ConcurrentLruCache#processWrite(Runnable)",
      "head_type": "method",
      "relation": "have",
      "tail": "processWriteSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "processWriteSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "processWriteCompleteExample",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ReadOperations#detectNumberOfBuffers()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "detect number of buffers",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ReadOperations#detectNumberOfBuffers()",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is used to determine the optimal number of buffers for read operations based on the available processors.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ReadOperations#detectNumberOfBuffers()",
      "head_type": "method",
      "relation": "have",
      "tail": "The method follows the principle of performance optimization by adjusting the number of buffers according to system resources.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ReadOperations#detectNumberOfBuffers()",
      "head_type": "method",
      "relation": "have",
      "tail": "package org.springframework.util; import java.lang.Runtime; public class ReadOperations { private static int detectNumberOfBuffers() { int availableProcessors = Runtime.getRuntime().availableProcessors(); int nextPowerOfTwo = 1 << (Integer.SIZE - Integer.numberOfLeadingZeros(availableProcessors - 1)); return Math.min(4, nextPowerOfTwo); } }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.Node#getValue()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "value retrieval",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.Node#getValue()",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.Node",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.Node#getValue()",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is used to retrieve the value from a node.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.Node#getValue()",
      "head_type": "method",
      "relation": "have",
      "tail": "The design principle behind this method is to provide a simple and direct way to access the value stored in a node.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.Node#getValue()",
      "head_type": "method",
      "relation": "have",
      "tail": "package com.example;\nimport org.springframework.util.Node;\n\npublic class Main {\n    public static void main(String[] args) {\n        Node node = new Node();\n        node.setValue(\"example\");\n        String value = node.getValue();\n        System.out.println(value);\n    }\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ConcurrentReferenceHashMap#calculateShift(int,int)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "calculateShift",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ConcurrentReferenceHashMap#calculateShift(int,int)",
      "head_type": "method",
      "relation": "have",
      "tail": "Calculate a shift value that can be used to create a power-of-two value between the specified maximum and minimum values.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ConcurrentReferenceHashMap#calculateShift(int,int)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is used to calculate a shift value which helps in determining the appropriate power-of-two size within a specified range. It iteratively shifts the value to the left until it reaches or exceeds the minimum or maximum value, ensuring that the resulting size is a power of two.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ConcurrentReferenceHashMap#calculateShift(int,int)",
      "head_type": "method",
      "relation": "have",
      "tail": "java\npackage org.springframework.util;\n\npublic class ConcurrentReferenceHashMap {\n    protected static int calculateShift(int minimumValue, int maximumValue) {\n        int shift = 0;\n        int value = 1;\n        while (value < minimumValue && value < maximumValue) {\n            value <<= 1;\n            shift++;\n        }\n        return shift;\n    }\n}\n",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.Reference",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getReferencedEntry",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.Reference",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getHash",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.Reference",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getNextReference",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.Reference",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "releaseEntry",
      "tail_type": "apiFunction"
    },
    {
      "head": "getReferencedEntry",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "getReferencedEntrySampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "getHash",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "getHashSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "getNextReference",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "getNextReferenceSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "releaseEntry",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "releaseEntrySampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.Reference",
      "head_type": "class",
      "relation": "have",
      "tail": "referenceToEntryConcept",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.Reference",
      "head_type": "class",
      "relation": "have",
      "tail": "referenceDesignPrinciple",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.Entry#equals(Object)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "equality check",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.Entry#equals(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.Entry#equals(Object) sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "equality check",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "null safety",
      "tail_type": "useConstraint"
    },
    {
      "head": "equality check",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "Map.Entry comparison",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.Entry#equals(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "Map.Entry comparison",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.Entry#equals(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.Entry#equals(Object) related concept interpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.Entry#equals(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.Entry#equals(Object) design principle interpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.EntrySet#contains(Object)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "check if an entry is contained",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.EntrySet#contains(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.EntrySet#contains(Object) checks if a given object is an entry and if it exists within the map.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.EntrySet#contains(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "public boolean contains(@Nullable Object o) {\n    if (o instanceof Map.Entry<?, ?> entry) {\n        Reference<K, V> ref = ConcurrentReferenceHashMap.this.getReference(entry.getKey(), Restructure.NEVER);\n        Entry<K, V> otherEntry = (ref != null ? ref.get() : null);\n        if (otherEntry != null) {\n            return ObjectUtils.nullSafeEquals(entry.getValue(), otherEntry.getValue());\n        }\n    }\n    return false;\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ReferenceManager#createReference(Entry<K,V>,int,Reference<K,V>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "createReference",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ReferenceManager#createReference(Entry<K,V>,int,Reference<K,V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "create a new Reference",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ReferenceManager#createReference(Entry<K,V>,int,Reference<K,V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "Factory method used to create a new Reference",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ReferenceManager#createReference(Entry<K,V>,int,Reference<K,V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "Design Principle: Factory Pattern",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ReferenceManager#createReference(Entry<K,V>,int,Reference<K,V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "public Reference<K, V> createReference(Entry<K, V> entry, int hash, @Nullable Reference<K, V> next) {\n    if (ConcurrentReferenceHashMap.this.referenceType == ReferenceType.WEAK) {\n        return new WeakEntryReference<>(entry, hash, next, this.queue);\n    }\n    return new SoftEntryReference<>(entry, hash, next, this.queue);\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "createReference",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "create a new Reference",
      "tail_type": "useScenario"
    },
    {
      "head": "createReference",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "entry, hash, next must be valid",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.FileSystemUtils",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "deleteRecursively",
      "tail_type": "apiFunction"
    },
    {
      "head": "deleteRecursively",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "root parameter must not be null",
      "tail_type": "useConstraint"
    },
    {
      "head": "deleteRecursively",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "deleting files or directories",
      "tail_type": "useScenario"
    },
    {
      "head": "deleteRecursively",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "sample code for deleting files or directories",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.FileSystemUtils",
      "head_type": "class",
      "relation": "have",
      "tail": "related concept interpretation for file system utilities",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.FileSystemUtils",
      "head_type": "class",
      "relation": "have",
      "tail": "design principle interpretation for file system utilities",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.function.SingletonSupplier#of(T)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "SingletonSupplier creation",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.function.SingletonSupplier#of(T)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "instance must not be null",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.function.SingletonSupplier#of(T)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "relatedConceptInterpretation",
      "head_type": "relatedConceptInterpretation",
      "relation": "associated_with",
      "tail": "SingletonSupplier",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.function.SingletonSupplier#of(T)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "designPrincipleInterpretation",
      "head_type": "designPrincipleInterpretation",
      "relation": "associated_with",
      "tail": "SingletonSupplier",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.function.SingletonSupplier#of(T)",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "useSampleCode",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "tail": "SingletonSupplier",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.function.ThrowingBiFunction#apply(T,U,BiFunction<String,Exception,RuntimeException>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "exception wrapping",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.function.ThrowingBiFunction#apply(T,U,BiFunction<String,Exception,RuntimeException>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "exception handling",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.function.ThrowingBiFunction#apply(T,U,BiFunction<String,Exception,RuntimeException>)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "functional interfaces",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.function.ThrowingBiFunction#apply(T,U,BiFunction<String,Exception,RuntimeException>)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.function.ThrowingBiFunction#apply(T,U,BiFunction<String,Exception,RuntimeException>)",
      "head_type": "method",
      "relation": "have",
      "tail": "related concept interpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.function.ThrowingBiFunction#apply(T,U,BiFunction<String,Exception,RuntimeException>)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle interpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.function.ThrowingBiFunction#apply(T,U,BiFunction<String,Exception,RuntimeException>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "BiFunction",
      "tail_type": "class"
    },
    {
      "head": "BiFunction",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "exception wrapping",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.EntrySet#spliterator()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "spliterator",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.EntrySet#spliterator()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.EntrySet",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.EntrySet#spliterator()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "java.util.Spliterator",
      "tail_type": "class"
    },
    {
      "head": "spliterator",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "useSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "complete sample code for using spliterator",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.MultiToSingleValueMapAdapter",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "adapt a MultiValueMap to the Map contract",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MultiToSingleValueMapAdapter",
      "head_type": "class",
      "relation": "constrained_by",
      "tail": "The adapted Map will only return the first value for any given key",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.MultiToSingleValueMapAdapter",
      "head_type": "class",
      "relation": "applied_to",
      "tail": "scenarios where a MultiValueMap needs to be used as a regular Map",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.MultiToSingleValueMapAdapter",
      "head_type": "class",
      "relation": "have",
      "tail": "sample code for adapting MultiToSingleValueMapAdapter",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.MultiToSingleValueMapAdapter",
      "head_type": "class",
      "relation": "have",
      "tail": "related concept interpretation for MultiToSingleValueMapAdapter",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.MultiToSingleValueMapAdapter",
      "head_type": "class",
      "relation": "have",
      "tail": "design principle interpretation for MultiToSingleValueMapAdapter",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.MultiToSingleValueMapAdapter",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "SingleToMultiValueMapAdapter",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.MultiToSingleValueMapAdapter",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "MultiValueMapAdapter",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.MultiValueMap#asSingleValueMap()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "convert to single value map",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MultiValueMap#asSingleValueMap()",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "returns a view, not a copy",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.MultiValueMap#asSingleValueMap()",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "map with multiple values",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.MultiValueMap#asSingleValueMap()",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for converting to single value map",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.MultiValueMap#asSingleValueMap()",
      "head_type": "method",
      "relation": "have",
      "tail": "explanation of map views vs copies",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.MultiValueMap#asSingleValueMap()",
      "head_type": "method",
      "relation": "have",
      "tail": "design principles of map conversion methods",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.MultiValueMap#asSingleValueMap()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "MultiToSingleValueMapAdapter",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.ObjectUtils#containsConstant(Enum<?>[],String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "check enum constant",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ObjectUtils#containsConstant(Enum<?>[],String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "constant name must not be null or empty",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ObjectUtils#containsConstant(Enum<?>[],String)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "find enum constant by name",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ObjectUtils#containsConstant(Enum<?>[],String)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for checking enum constant",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ObjectUtils#containsConstant(Enum<?>[],String)",
      "head_type": "method",
      "relation": "have",
      "tail": "enum constant lookup explanation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ObjectUtils#containsConstant(Enum<?>[],String)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle for enum constant checking",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ObjectUtils#containsConstant(Enum<?>[],String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "Enum<?>[]",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.ObjectUtils#containsConstant(Enum<?>[],String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "String",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.PlaceholderResolutionException#withValue(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "add parent value to PlaceholderResolutionException",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.PlaceholderResolutionException#withValue(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "Return a PlaceholderResolutionException that provides an additional parent value",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.PlaceholderResolutionException#withValue(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "The method creates a new exception with the parent value added",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.PlaceholderResolutionException#withValue(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "package com.example.demo;\n\nimport org.springframework.util.PlaceholderResolutionException;\n\npublic class Main {\n    public static void main(String[] args) {\n        PlaceholderResolutionException exception = new PlaceholderResolutionException(\"reason\", \"placeholder\", java.util.Collections.singletonList(\"value1\"));\n        PlaceholderResolutionException newException = exception.withValue(\"value2\");\n        System.out.println(newException.getValues());\n    }\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ResizableByteArrayOutputStream#capacity()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "Return the current size of this stream's internal buffer",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ResizableByteArrayOutputStream#capacity()",
      "head_type": "method",
      "relation": "have",
      "tail": "Return the current size of this stream's internal buffer",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ResizableByteArrayOutputStream#capacity()",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is used to get the current capacity of the internal buffer of the ResizableByteArrayOutputStream.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ResizableByteArrayOutputStream#capacity()",
      "head_type": "method",
      "relation": "have",
      "tail": "The design principle of this method is to provide a way to check the current buffer size, ensuring efficient memory management.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.SerializationUtils#serialize(Object)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "Serialization",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.SerializationUtils#serialize(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "Serialization is the process of converting an object into a format that can be easily stored or transmitted, and then reconstructing it later.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.SerializationUtils#serialize(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "The design principle of this method is to provide a simple and efficient way to serialize objects, ensuring portability and ease of use.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.SerializationUtils#serialize(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "java\npackage com.example;\nimport java.io.*;\npublic class SerializationExample {\n    public static void main(String[] args) {\n        Object object = new Object();\n        byte[] serializedObject = SerializationUtils.serialize(object);\n        Object deserializedObject = SerializationUtils.deserialize(serializedObject);\n    }\n}\n",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.SerializationUtils#deserialize(byte[])",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "deserialize",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.SerializationUtils#deserialize(byte[])",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "Java Object Serialization RCE vulnerability",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.SerializationUtils#deserialize(byte[])",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "byte array deserialization",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.SerializationUtils#deserialize(byte[])",
      "head_type": "method",
      "relation": "have",
      "tail": "Prefer the use of an external tool (that serializes to JSON, XML, or any other format) which is regularly checked and updated for not allowing RCE.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.SerializationUtils#deserialize(byte[])",
      "head_type": "method",
      "relation": "have",
      "tail": "This utility uses Java Object Serialization, which allows arbitrary code to be run and is known for being the source of many Remote Code Execution (RCE) vulnerabilities.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.SerializationUtils#deserialize(byte[])",
      "head_type": "method",
      "relation": "have",
      "tail": "public static Object deserialize(byte[] bytes) {\n    if (bytes == null) {\n        return null;\n    }\n    try (ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(bytes))) {\n        return ois.readObject();\n    } catch (IOException ex) {\n        throw new IllegalArgumentException(\"Failed to deserialize object\", ex);\n    } catch (ClassNotFoundException ex) {\n        throw new IllegalStateException(\"Failed to deserialize object type\", ex);\n    }\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.SingleToMultiValueMapAdapter#put(K,List<V>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "add values to map",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.SingleToMultiValueMapAdapter#put(K,List<V>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "values cannot be empty",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.SingleToMultiValueMapAdapter#put(K,List<V>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "values size cannot be greater than 1",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.SingleToMultiValueMapAdapter#put(K,List<V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "SingleToMultiValueMapAdapter",
      "tail_type": "class"
    },
    {
      "head": "SingleToMultiValueMapAdapter",
      "head_type": "class",
      "relation": "have",
      "tail": "used for adapting single value map to multi value map",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "SingleToMultiValueMapAdapter",
      "head_type": "class",
      "relation": "have",
      "tail": "design principle is to provide a convenient way to handle collections",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.SingleToMultiValueMapAdapter#put(K,List<V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "public List<V> put(K key, List<V> values) {\n    if (values.isEmpty()) {\n        V result = this.targetMap.put(key, null);\n        return (result != null) ? Collections.singletonList(result) : null;\n    } else if (values.size() == 1) {\n        V result = this.targetMap.put(key, values.get(0));\n        return (result != null) ? Collections.singletonList(result) : null;\n    } else {\n        throw new UnsupportedOperationException(\"Duplicate key: \" + key);\n    }\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.SingleToMultiValueMapAdapter#equals(Object)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "equality check",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.SingleToMultiValueMapAdapter#equals(Object)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "null values handling",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.SingleToMultiValueMapAdapter#equals(Object)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "map comparison",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.SingleToMultiValueMapAdapter#equals(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.SingleToMultiValueMapAdapter",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.SingleToMultiValueMapAdapter#equals(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "related concept interpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.SingleToMultiValueMapAdapter#equals(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle interpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.SingleToMultiValueMapAdapter#equals(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "use sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "equality check",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "org.springframework.util.SingleToMultiValueMapAdapter#equals(Object)",
      "tail_type": "method"
    },
    {
      "head": "null values handling",
      "head_type": "useConstraint",
      "relation": "associated_with",
      "tail": "org.springframework.util.SingleToMultiValueMapAdapter#equals(Object)",
      "tail_type": "method"
    },
    {
      "head": "map comparison",
      "head_type": "useScenario",
      "relation": "associated_with",
      "tail": "org.springframework.util.SingleToMultiValueMapAdapter#equals(Object)",
      "tail_type": "method"
    },
    {
      "head": "related concept interpretation",
      "head_type": "relatedConceptInterpretation",
      "relation": "associated_with",
      "tail": "org.springframework.util.SingleToMultiValueMapAdapter#equals(Object)",
      "tail_type": "method"
    },
    {
      "head": "design principle interpretation",
      "head_type": "designPrincipleInterpretation",
      "relation": "associated_with",
      "tail": "org.springframework.util.SingleToMultiValueMapAdapter#equals(Object)",
      "tail_type": "method"
    },
    {
      "head": "use sample code",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "tail": "org.springframework.util.SingleToMultiValueMapAdapter#equals(Object)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.StopWatch#setKeepTaskList(boolean)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "ConfigureTaskInfoArray",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StopWatch#setKeepTaskList(boolean)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "MemoryUsageConstraint",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.StopWatch#setKeepTaskList(boolean)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "LargeNumberOfTasksScenario",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.StopWatch#setKeepTaskList(boolean)",
      "head_type": "method",
      "relation": "have",
      "tail": "SampleCodeForSetKeepTaskList",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.StopWatch#setKeepTaskList(boolean)",
      "head_type": "method",
      "relation": "have",
      "tail": "TaskInfoStructureExplanation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.StopWatch#setKeepTaskList(boolean)",
      "head_type": "method",
      "relation": "have",
      "tail": "MemoryManagementPrinciple",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "ConfigureTaskInfoArray",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "org.springframework.util.StopWatch",
      "tail_type": "class"
    },
    {
      "head": "MemoryUsageConstraint",
      "head_type": "useConstraint",
      "relation": "associated_with",
      "tail": "org.springframework.util.StopWatch",
      "tail_type": "class"
    },
    {
      "head": "LargeNumberOfTasksScenario",
      "head_type": "useScenario",
      "relation": "associated_with",
      "tail": "org.springframework.util.StopWatch",
      "tail_type": "class"
    },
    {
      "head": "SampleCodeForSetKeepTaskList",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "tail": "org.springframework.util.StopWatch",
      "tail_type": "class"
    },
    {
      "head": "TaskInfoStructureExplanation",
      "head_type": "relatedConceptInterpretation",
      "relation": "associated_with",
      "tail": "org.springframework.util.StopWatch",
      "tail_type": "class"
    },
    {
      "head": "MemoryManagementPrinciple",
      "head_type": "designPrincipleInterpretation",
      "relation": "associated_with",
      "tail": "org.springframework.util.StopWatch",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.StopWatch#getTotalTimeNanos()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getTotalTimeNanos",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StopWatch#getTotalTimeNanos()",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.StopWatch#getTotalTimeNanos()",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.StopWatch#getTotalTimeNanos()",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.StringUtils#containsWhitespace(CharSequence)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "check for whitespace characters",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils#containsWhitespace(CharSequence)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "input may be null",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.StringUtils#containsWhitespace(CharSequence)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "string validation",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.StringUtils#containsWhitespace(CharSequence)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for checking whitespace",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.StringUtils#containsWhitespace(CharSequence)",
      "head_type": "method",
      "relation": "have",
      "tail": "interpretation of whitespace characters",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.StringUtils#containsWhitespace(CharSequence)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle of string utility methods",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.StringUtils#containsWhitespace(CharSequence)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "Character#isWhitespace",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.StringUtils#uriDecode(String,Charset)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "uri decoding",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils#uriDecode(String,Charset)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "source contains invalid encoded sequences",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.StringUtils#uriDecode(String,Charset)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "encoded URI component value",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.StringUtils#uriDecode(String,Charset)",
      "head_type": "method",
      "relation": "have",
      "tail": "Decodes a given encoded URI component value based on specific rules",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.StringUtils#uriDecode(String,Charset)",
      "head_type": "method",
      "relation": "have",
      "tail": "Efficiently decodes URI components using a ByteArrayOutputStream and character handling",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "uri decoding",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "java.net.URLDecoder#decode(String, String)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.StringUtils#uriDecode(String,Charset)",
      "head_type": "method",
      "relation": "have",
      "tail": "public static String uriDecode(String source, Charset charset) {\n    int length = source.length();\n    if (length == 0) {\n        return source;\n    }\n    Assert.notNull(charset, \"Charset must not be null\");\n    ByteArrayOutputStream baos = new ByteArrayOutputStream(length);\n    boolean changed = false;\n    for (int i = 0; i < length; i++) {\n        int ch = source.charAt(i);\n        if (ch == '%') {\n            if (i + 2 < length) {\n                char hex1 = source.charAt(i + 1);\n                char hex2 = source.charAt(i + 2);\n                int u = Character.digit(hex1, 16);\n                int l = Character.digit(hex2, 16);\n                if (u == -1 || l == -1) {\n                    throw new IllegalArgumentException(\"Invalid encoded sequence \\\"\" + source.substring(i) + \"\\\"\");\n                }\n                baos.write((char) ((u << 4) + l));\n                i += 2;\n                changed = true;\n            } else {\n                throw new IllegalArgumentException(\"Invalid encoded sequence \\\"\" + source.substring(i) + \"\\\"\");\n            }\n        } else {\n            baos.write(ch);\n        }\n    }\n    return (changed ? StreamUtils.copyToString(baos, charset) : source);\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.StringUtils#collectionToCommaDelimitedString(Collection<?>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "convert a Collection into a delimited String",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils#collectionToCommaDelimitedString(Collection<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "Useful for toString() implementations",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.StringUtils#collectionToCommaDelimitedString(Collection<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "Convert a Collection into a delimited String (for example, CSV)",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.StringUtils#collectionToCommaDelimitedString(Collection<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "The method takes a Collection as input and returns a String that is the concatenation of the elements of the Collection, separated by a delimiter. In this case, the delimiter is a comma (','). This is commonly used for creating a comma-separated values (CSV) string from a collection of items. It is particularly useful in the implementation of toString() methods where a concise and readable representation of a collection is needed.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.StringUtils#collectionToCommaDelimitedString(Collection<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "package com.example.util; import java.util.Collection; import java.util.Arrays; import org.springframework.util.StringUtils; public class Main { public static void main(String[] args) { Collection<String> collection = Arrays.asList(\"apple\", \"banana\", \"cherry\"); String result = StringUtils.collectionToCommaDelimitedString(collection); System.out.println(result); } }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.StringUtils#arrayToCommaDelimitedString(Object[])",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "convert array to CSV",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils#arrayToCommaDelimitedString(Object[])",
      "head_type": "method",
      "relation": "have",
      "tail": "Convert a String array into a comma delimited String (i.e., CSV). Useful for toString() implementations.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.StringUtils#arrayToCommaDelimitedString(Object[])",
      "head_type": "method",
      "relation": "have",
      "tail": "public static String arrayToCommaDelimitedString(@Nullable Object @Nullable [] arr) { return arrayToDelimitedString(arr, \",\"); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "convert array to CSV",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "Convert a String array into a comma delimited String (i.e., CSV). Useful for toString() implementations.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "convert array to CSV",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "public static String arrayToCommaDelimitedString(@Nullable Object @Nullable [] arr) { return arrayToDelimitedString(arr, \",\"); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#putIfAbsent(K,List<V>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "add elements to a collection if not present",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#putIfAbsent(K,List<V>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "operation not supported",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#putIfAbsent(K,List<V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.UnmodifiableMultiValueMap",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#putIfAbsent(K,List<V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#putIfAbsent(K,List<V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#putIfAbsent(K,List<V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#add(K,V)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "add elements to a collection",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#add(K,V)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "operation not supported for unmodifiable collection",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#add(K,V)",
      "head_type": "method",
      "relation": "have",
      "tail": "throwing an UnsupportedOperationException when attempting to add elements",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#add(K,V)",
      "head_type": "method",
      "relation": "have",
      "tail": "public void add(K key, @Nullable V value) { throw new UnsupportedOperationException(); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#add(K,V)",
      "head_type": "method",
      "relation": "have",
      "tail": "UnmodifiableMultiValueMap does not support add operation as it is designed to be unmodifiable",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#add(K,V)",
      "head_type": "method",
      "relation": "have",
      "tail": "Design principle of immutability ensures that once an object is created, its state cannot be changed",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#add(K,V)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.UnmodifiableMultiValueMap",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.UpdateMessageDigestInputStream",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "updateMessageDigest",
      "tail_type": "apiFunction"
    },
    {
      "head": "updateMessageDigest",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "IOException",
      "tail_type": "useConstraint"
    },
    {
      "head": "updateMessageDigest",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "update message digest with stream bytes",
      "tail_type": "useScenario"
    },
    {
      "head": "updateMessageDigest",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "update message digest with stream bytes sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.UpdateMessageDigestInputStream",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "java.io.InputStream",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.UpdateMessageDigestInputStream",
      "head_type": "class",
      "relation": "have",
      "tail": "related concept interpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.UpdateMessageDigestInputStream",
      "head_type": "class",
      "relation": "have",
      "tail": "design principle interpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#startPrefixMapping(String,String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "namespace management",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#startPrefixMapping(String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "startPrefixMapping handles namespace mapping by associating prefixes with URIs.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#startPrefixMapping(String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "public final void startPrefixMapping(String prefix, String uri) { currentNamespaceMapping().put(prefix, uri); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.AbstractStaxHandler#startPrefixMapping(String,String)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#endElementInternal(QName,Map<String,String>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "endElementInternal",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#endElementInternal(QName,Map<String,String>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.AbstractStaxHandler",
      "tail_type": "class"
    },
    {
      "head": "endElementInternal",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "Handles the end of an XML element.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler",
      "head_type": "class",
      "relation": "have",
      "tail": "Design principle: Encapsulate XML parsing logic.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "endElementInternal",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "public abstract void endElementInternal(QName name, Map<String, String> namespaceMapping) throws XMLStreamException;",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxXMLReader#setFeature(String,boolean)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "Feature Setting",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxXMLReader#setFeature(String,boolean)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "SAX Feature Constraints",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxXMLReader#setFeature(String,boolean)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "XML Parsing",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxXMLReader#setFeature(String,boolean)",
      "head_type": "method",
      "relation": "have",
      "tail": "Feature Setting Sample Code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxXMLReader#setFeature(String,boolean)",
      "head_type": "method",
      "relation": "have",
      "tail": "XML Parsing Concepts",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxXMLReader#setFeature(String,boolean)",
      "head_type": "method",
      "relation": "have",
      "tail": "Design Principles for Feature Setting",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxXMLReader#setFeature(String,boolean)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.AbstractStaxXMLReader",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxXMLReader#parse()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "parse XML",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxXMLReader#parse()",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "must handle XMLStreamException",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxXMLReader#parse()",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "XML parsing within SAX environment",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxXMLReader#parse()",
      "head_type": "method",
      "relation": "have",
      "tail": "private void parse() throws SAXException { try { parseInternal(); } catch (XMLStreamException ex) { Locator locator = null; if (ex.getLocation() != null) { locator = new StaxLocator(ex.getLocation()); } SAXParseException saxException = new SAXParseException(ex.getMessage(), locator, ex); if (getErrorHandler() != null) { getErrorHandler().fatalError(saxException); } else { throw saxException; } }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxXMLReader#parse()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.AbstractStaxXMLReader",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxXMLReader#parse()",
      "head_type": "method",
      "relation": "have",
      "tail": "Handles XML parsing exceptions by converting XMLStreamException to SAXParseException and optionally delegating to an error handler.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxXMLReader#parse()",
      "head_type": "method",
      "relation": "have",
      "tail": "This method demonstrates robust error handling and adherence to the SAX parsing contract by managing exceptions and providing locator information.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxXMLReader#parseInternal()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "parse StAX reader",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxXMLReader#parseInternal()",
      "head_type": "method",
      "relation": "have",
      "tail": "Template method that parses the StAX reader passed at construction-time.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxXMLReader",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.AbstractStaxXMLReader#parseInternal()",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLReader",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getErrorHandler()",
      "tail_type": "apiFunction"
    },
    {
      "head": "getErrorHandler()",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "ErrorHandler",
      "tail_type": "class"
    },
    {
      "head": "getErrorHandler()",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "Returns the error handler of this XML reader.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "getErrorHandler()",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "This method is overridden to provide a way to get the error handler.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "getErrorHandler()",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "public ErrorHandler getErrorHandler() {\n    return this.errorHandler;\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.DomContentHandler#endElement(String,String,String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "endElement",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.DomContentHandler#endElement(String,String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.xml.DomContentHandler#endElement(String,String,String) sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.DomContentHandler#endElement(String,String,String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.DomContentHandler",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.DomContentHandler#startPrefixMapping(String,String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "startPrefixMapping",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.DomContentHandler#startPrefixMapping(String,String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.DomContentHandler",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.DomContentHandler",
      "head_type": "class",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.DomContentHandler",
      "head_type": "class",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.DomUtils#getChildElementsByTagName(Element,String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "retrieveChildElementsByTagName",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.DomUtils#getChildElementsByTagName(Element,String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "directChildLevelConstraint",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.xml.DomUtils#getChildElementsByTagName(Element,String)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "domElementChildRetrieval",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.xml.DomUtils#getChildElementsByTagName(Element,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "domElementChildRetrievalSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.DomUtils#getChildElementsByTagName(Element,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedDomElementConcepts",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.DomUtils#getChildElementsByTagName(Element,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrinciplesForChildElementRetrieval",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "retrieveChildElementsByTagName",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.DomUtils",
      "tail_type": "class"
    },
    {
      "head": "directChildLevelConstraint",
      "head_type": "useConstraint",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.DomUtils",
      "tail_type": "class"
    },
    {
      "head": "domElementChildRetrieval",
      "head_type": "useScenario",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.DomUtils",
      "tail_type": "class"
    },
    {
      "head": "domElementChildRetrievalSampleCode",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.DomUtils",
      "tail_type": "class"
    },
    {
      "head": "relatedDomElementConcepts",
      "head_type": "relatedConceptInterpretation",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.DomUtils",
      "tail_type": "class"
    },
    {
      "head": "designPrinciplesForChildElementRetrieval",
      "head_type": "designPrincipleInterpretation",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.DomUtils",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.DomUtils#getTextValue(Element)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "extract text value from DOM element",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.DomUtils#getTextValue(Element)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "Element must not be null",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.xml.DomUtils#getTextValue(Element)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "extracting user-specified text from XML elements",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.xml.DomUtils#getTextValue(Element)",
      "head_type": "method",
      "relation": "have",
      "tail": "public static String getTextValue(Element valueEle) { ... }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.DomUtils#getTextValue(Element)",
      "head_type": "method",
      "relation": "have",
      "tail": "Appends CharacterData and EntityReference nodes into a single String, excluding Comment nodes.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.DomUtils#getTextValue(Element)",
      "head_type": "method",
      "relation": "have",
      "tail": "Design principle focuses on extracting actual user-specified text without default values.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.DomUtils#getTextValue(Element)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.DomUtils",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.DomUtils#nodeNameMatch(Node,Collection<?>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "node name matching",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.DomUtils#nodeNameMatch(Node,Collection<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "node name matching",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.xml.DomUtils#nodeNameMatch(Node,Collection<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "private static boolean nodeNameMatch(Node node, Collection<?> desiredNames) { return (desiredNames.contains(node.getNodeName()) || desiredNames.contains(node.getLocalName())); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.DomUtils#nodeNameMatch(Node,Collection<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.DomUtils#nodeNameMatch(Node,Collection<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.DomUtils#nodeNameMatch(Node,Collection<?>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.DomUtils",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.LocatorLocationAdapter#getSystemId()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getSystemId",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.LocatorLocationAdapter#getSystemId()",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.xml.LocatorLocationAdapter#getSystemId() returns the system identifier of the current document event.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.LocatorLocationAdapter#getSystemId()",
      "head_type": "method",
      "relation": "have",
      "tail": "The method is overridden from a parent class or interface.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.LocatorLocationAdapter#getSystemId()",
      "head_type": "method",
      "relation": "have",
      "tail": "public String getSystemId() {\n    return this.locator.getSystemId();\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.StaxEventXMLReader#handleEntityReference(EntityReference)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "handleEntityReference",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxEventXMLReader#handleEntityReference(EntityReference)",
      "head_type": "method",
      "relation": "have",
      "tail": "handleEntityReference(EntityReference) sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "handleEntityReference(EntityReference) sample code",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "private void handleEntityReference(EntityReference reference) throws SAXException {\n    if (getLexicalHandler() != null) {\n        getLexicalHandler().startEntity(reference.getName());\n    }\n    if (getLexicalHandler() != null) {\n        getLexicalHandler().endEntity(reference.getName());\n    }\n}",
      "tail_type": "code"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamXMLReader#handleComment()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "handleComment",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamXMLReader#handleComment()",
      "head_type": "method",
      "relation": "have",
      "tail": "handleComment() sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "handleComment() sample code",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "private void handleComment() throws SAXException {\n    if (getLexicalHandler() != null) {\n        getLexicalHandler().comment(this.reader.getTextCharacters(), this.reader.getTextStart(), this.reader.getTextLength());\n    }\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils#getXMLEventReader(Source)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "apiFunction",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils#getXMLEventReader(Source)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "useConstraint",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils#getXMLEventReader(Source)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "useScenario",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils#getXMLEventReader(Source)",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils#getXMLEventReader(Source)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils#getXMLEventReader(Source)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils#getXMLEventReader(Source)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.StaxUtils",
      "tail_type": "class"
    },
    {
      "head": "apiFunction",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.StaxUtils",
      "tail_type": "class"
    },
    {
      "head": "useConstraint",
      "head_type": "useConstraint",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.StaxUtils",
      "tail_type": "class"
    },
    {
      "head": "useScenario",
      "head_type": "useScenario",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.StaxUtils",
      "tail_type": "class"
    },
    {
      "head": "useSampleCode",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.StaxUtils",
      "tail_type": "class"
    },
    {
      "head": "relatedConceptInterpretation",
      "head_type": "relatedConceptInterpretation",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.StaxUtils",
      "tail_type": "class"
    },
    {
      "head": "designPrincipleInterpretation",
      "head_type": "designPrincipleInterpretation",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.StaxUtils",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamReader#getName()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getName",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamReader#getName()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.XMLEventStreamReader",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamReader#getName()",
      "head_type": "method",
      "relation": "have",
      "tail": "getNameUseSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "getNameUseSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "getNameSampleCodeContent",
      "tail_type": "useSampleCodeContent"
    },
    {
      "head": "org.springframework.util.xml.XmlValidationModeDetector#commentToken(String,String,boolean)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "parse state update",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.XmlValidationModeDetector#commentToken(String,String,boolean)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "token presence",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.xml.XmlValidationModeDetector#commentToken(String,String,boolean)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "xml parsing",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.xml.XmlValidationModeDetector#commentToken(String,String,boolean)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for updating parse state",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.XmlValidationModeDetector#commentToken(String,String,boolean)",
      "head_type": "method",
      "relation": "have",
      "tail": "xml parsing explanation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.XmlValidationModeDetector#commentToken(String,String,boolean)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle for updating parse state",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.XmlValidationModeDetector",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.XmlValidationModeDetector#commentToken(String,String,boolean)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.core.task.VirtualThreadDelegate#newVirtualThread(String,Runnable)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "create a new virtual thread",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.core.task.VirtualThreadDelegate#newVirtualThread(String,Runnable)",
      "head_type": "method",
      "relation": "have",
      "tail": "public Thread newVirtualThread(String name, Runnable task) {\n    return this.threadBuilder.name(name).unstarted(task);\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests#addFileWithCharSequenceAddsFile()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "addFileWithCharSequenceAddsFile",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests#addFileWithCharSequenceAddsFile()",
      "head_type": "method",
      "relation": "have",
      "tail": "GeneratedFilesTestsSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "GeneratedFilesTestsSampleCode",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.GeneratedFilesTests#addFileWithCharSequenceAddsFile()",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.aot.generate.PackagePrivateClass#stringBean()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "generateStringBean",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.PackagePrivateClass#stringBean()",
      "head_type": "method",
      "relation": "have",
      "tail": "public String stringBean() { return \"public\"; }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.PackagePrivateClass#stringBean()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.PackagePrivateClass",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.PublicClass",
      "head_type": "class",
      "relation": "have",
      "tail": "privateField",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.PublicClass",
      "head_type": "class",
      "relation": "have",
      "tail": "protectedField",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.PublicClass",
      "head_type": "class",
      "relation": "have",
      "tail": "packagePrivateClasses",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.PublicClass",
      "head_type": "class",
      "relation": "have",
      "tail": "protectedClassField",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.PublicClass",
      "head_type": "class",
      "relation": "have",
      "tail": "getProtectedMethod",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.SampleTypes",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "genericList",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.SampleTypes",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "mapWithNestedGenericInValueType",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.SampleTypes",
      "head_type": "class",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.SampleTypes",
      "head_type": "class",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.SampleTypes",
      "head_type": "class",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.SetTests#generateWhenSetOfClass()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "generate set of classes",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.SetTests#generateWhenSetOfClass()",
      "head_type": "method",
      "relation": "have",
      "tail": "generate set of classes sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "generate set of classes sample code",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "Set.of(InputStream.class, OutputStream.class)",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.SetTests#generateWhenSetOfClass()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "Set",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.SetTests#generateWhenSetOfClass()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "InputStream",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.SetTests#generateWhenSetOfClass()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "OutputStream",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.SetTests#generateWhenSetOfClass()",
      "head_type": "method",
      "relation": "have",
      "tail": "generate set of classes related concept interpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "generate set of classes related concept interpretation",
      "head_type": "relatedConceptInterpretation",
      "relation": "have",
      "tail": "Set is used to store unique elements in Java.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.SetTests#generateWhenSetOfClass()",
      "head_type": "method",
      "relation": "have",
      "tail": "generate set of classes design principle interpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "generate set of classes design principle interpretation",
      "head_type": "designPrincipleInterpretation",
      "relation": "have",
      "tail": "This method demonstrates the use of Set to store a collection of unique classes, adhering to the principle of ensuring uniqueness and immutability.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.hint.annotation.SampleMethodMetaAnnotatedBean#invoke()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "sample invocation",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.hint.annotation.SampleMethodMetaAnnotatedBean#invoke()",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.aot.hint.annotation.SampleInvoker",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.hint.annotation.SampleInvoker",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "sample invocation",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.hint.annotation.SampleMethodMetaAnnotatedBean#invoke()",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.hint.annotation.SampleMethodMetaAnnotatedBean#invoke()",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.hint.annotation.SampleMethodMetaAnnotatedBean#invoke()",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.hint.annotation.SampleMethodAnnotatedBeanWithInterface",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "managed method",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.hint.annotation.SampleMethodAnnotatedBeanWithInterface",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "not managed method",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.hint.annotation.SampleMethodAnnotatedBeanWithInterface",
      "head_type": "class",
      "relation": "have",
      "tail": "related concept interpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.hint.annotation.SampleMethodAnnotatedBeanWithInterface",
      "head_type": "class",
      "relation": "have",
      "tail": "design principle interpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.hint.annotation.SampleMethodAnnotatedBeanWithInterface",
      "head_type": "class",
      "relation": "have",
      "tail": "sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.hint.annotation.SampleCustomProcessor",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "reflectiveProcessing",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.hint.annotation.SampleCustomProcessor",
      "head_type": "class",
      "relation": "have",
      "tail": "managingMethodHints",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.aot.hint.annotation.SampleCustomProcessor",
      "head_type": "class",
      "relation": "have",
      "tail": "sampleCodeForReflectiveProcessing",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.hint.annotation.SampleCustomProcessor",
      "head_type": "class",
      "relation": "have",
      "tail": "relatedConceptsExplanation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.hint.annotation.SampleCustomProcessor",
      "head_type": "class",
      "relation": "have",
      "tail": "designPrinciplesExplanation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.hint.annotation.SampleCustomProcessor",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "TestMethodHintReflectiveProcessor",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.hint.annotation.SampleClassWithoutAnnotationAttribute",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getName",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.hint.annotation.SampleClassWithoutAnnotationAttribute",
      "head_type": "class",
      "relation": "have",
      "tail": "public String getName() { return \"test\"; }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.hint.annotation.SampleClassWithoutMethodLevelAnnotationAttribute#method()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "reflection binding registration",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.hint.annotation.SampleClassWithoutMethodLevelAnnotationAttribute#method()",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.hint.annotation.SampleClassWithoutMethodLevelAnnotationAttribute#method()",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.hint.annotation.SampleClassWithoutMethodLevelAnnotationAttribute#method()",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.hint.annotation.SampleClassWithoutMethodLevelAnnotationAttribute#method()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.hint.annotation.SampleClassWithoutMethodLevelAnnotationAttribute",
      "tail_type": "class"
    },
    {
      "tail": "introspection",
      "head_type": "class",
      "relation": "haveFunction",
      "head": "org.springframework.core.type.StandardClassMetadata",
      "tail_type": "apiFunction"
    },
    {
      "tail": "class metadata retrieval",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "head": "introspection",
      "tail_type": "useScenario"
    },
    {
      "tail": "class metadata retrieval",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "useScenario"
    },
    {
      "tail": "standard reflection usage",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "class must not be null",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "head": "introspection",
      "tail_type": "useConstraint"
    },
    {
      "tail": "class metadata retrieval",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "useScenario"
    },
    {
      "tail": "standard reflection usage",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "class must not be null",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "head": "introspection",
      "tail_type": "useConstraint"
    },
    {
      "tail": "class metadata retrieval",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "useScenario"
    },
    {
      "tail": "standard reflection usage",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "class must not be null",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "head": "introspection",
      "tail_type": "useConstraint"
    },
    {
      "tail": "class metadata retrieval",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "useScenario"
    },
    {
      "tail": "standard reflection usage",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "class must not be null",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "head": "introspection",
      "tail_type": "useConstraint"
    },
    {
      "tail": "class metadata retrieval",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "useScenario"
    },
    {
      "tail": "standard reflection usage",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "class must not be null",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "head": "introspection",
      "tail_type": "useConstraint"
    },
    {
      "tail": "class metadata retrieval",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "useScenario"
    },
    {
      "tail": "standard reflection usage",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "class must not be null",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "head": "introspection",
      "tail_type": "useConstraint"
    },
    {
      "tail": "class metadata retrieval",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "useScenario"
    },
    {
      "tail": "standard reflection usage",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "class must not be null",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "head": "introspection",
      "tail_type": "useConstraint"
    },
    {
      "tail": "class metadata retrieval",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "useScenario"
    },
    {
      "tail": "standard reflection usage",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "class must not be null",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "head": "introspection",
      "tail_type": "useConstraint"
    },
    {
      "tail": "class metadata retrieval",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "useScenario"
    },
    {
      "tail": "standard reflection usage",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "class must not be null",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "head": "introspection",
      "tail_type": "useConstraint"
    },
    {
      "tail": "class metadata retrieval",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "useScenario"
    },
    {
      "tail": "standard reflection usage",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "class must not be null",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "head": "introspection",
      "tail_type": "useConstraint"
    },
    {
      "tail": "class metadata retrieval",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "useScenario"
    },
    {
      "tail": "standard reflection usage",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "class must not be null",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "head": "introspection",
      "tail_type": "useConstraint"
    },
    {
      "tail": "class metadata retrieval",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "useScenario"
    },
    {
      "tail": "standard reflection usage",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "class must not be null",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "head": "introspection",
      "tail_type": "useConstraint"
    },
    {
      "tail": "class metadata retrieval",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "useScenario"
    },
    {
      "tail": "standard reflection usage",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "class must not be null",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "head": "introspection",
      "tail_type": "useConstraint"
    },
    {
      "tail": "class metadata retrieval",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "useScenario"
    },
    {
      "tail": "standard reflection usage",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "class must not be null",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "head": "introspection",
      "tail_type": "useConstraint"
    },
    {
      "tail": "class metadata retrieval",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "useScenario"
    },
    {
      "tail": "standard reflection usage",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "class must not be null",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "head": "introspection",
      "tail_type": "useConstraint"
    },
    {
      "tail": "class metadata retrieval",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "useScenario"
    },
    {
      "tail": "standard reflection usage",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "class must not be null",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "head": "introspection",
      "tail_type": "useConstraint"
    },
    {
      "tail": "class metadata retrieval",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "useScenario"
    },
    {
      "tail": "standard reflection usage",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "class must not be null",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "head": "introspection",
      "tail_type": "useConstraint"
    },
    {
      "tail": "class metadata retrieval",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "useScenario"
    },
    {
      "tail": "standard reflection usage",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "class must not be null",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "head": "introspection",
      "tail_type": "useConstraint"
    },
    {
      "tail": "class metadata retrieval",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "useScenario"
    },
    {
      "tail": "standard reflection usage",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "class must not be null",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "head": "introspection",
      "tail_type": "useConstraint"
    },
    {
      "tail": "class metadata retrieval",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "useScenario"
    },
    {
      "tail": "standard reflection usage",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "class must not be null",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "head": "introspection",
      "tail_type": "useConstraint"
    },
    {
      "tail": "class metadata retrieval",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "useScenario"
    },
    {
      "tail": "standard reflection usage",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "class must not be null",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "head": "introspection",
      "tail_type": "useConstraint"
    },
    {
      "tail": "class metadata retrieval",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "useScenario"
    },
    {
      "tail": "standard reflection usage",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "class must not be null",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "head": "introspection",
      "tail_type": "useConstraint"
    },
    {
      "tail": "class metadata retrieval",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "useScenario"
    },
    {
      "tail": "standard reflection usage",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "class must not be null",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "head": "introspection",
      "tail_type": "useConstraint"
    },
    {
      "tail": "class metadata retrieval",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "useScenario"
    },
    {
      "tail": "standard reflection usage",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "class must not be null",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "head": "introspection",
      "tail_type": "useConstraint"
    },
    {
      "tail": "class metadata retrieval",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "useScenario"
    },
    {
      "tail": "standard reflection usage",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "class must not be null",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "head": "introspection",
      "tail_type": "useConstraint"
    },
    {
      "tail": "class metadata retrieval",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "useScenario"
    },
    {
      "tail": "standard reflection usage",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "class must not be null",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "head": "introspection",
      "tail_type": "useConstraint"
    },
    {
      "tail": "class metadata retrieval",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "useScenario"
    },
    {
      "tail": "standard reflection usage",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "class must not be null",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "head": "introspection",
      "tail_type": "useConstraint"
    },
    {
      "tail": "class metadata retrieval",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "useScenario"
    },
    {
      "tail": "standard reflection usage",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "head": "introspection"
    },
    {
      "head": "org.springframework.core.type.StandardClassMetadata#getClassName()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getClassName",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.core.type.StandardClassMetadata#getClassName()",
      "head_type": "method",
      "relation": "have",
      "tail": "getClassName returns the name of the class",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.core.type.StandardClassMetadata#getClassName()",
      "head_type": "method",
      "relation": "have",
      "tail": "introspectedClass.getName() is used to retrieve the class name",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.core.type.StandardClassMetadata",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.core.type.StandardClassMetadata#getClassName()",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.core.type.StandardMethodMetadata#isAbstract()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "determine if method is abstract",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.core.type.StandardMethodMetadata#isAbstract()",
      "head_type": "method",
      "relation": "have",
      "tail": "check if the method is abstract",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.core.type.StandardMethodMetadata#isAbstract()",
      "head_type": "method",
      "relation": "have",
      "tail": "java\n@Override\npublic boolean isAbstract() {\n    return Modifier.isAbstract(this.introspectedMethod.getModifiers());\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.core.type.StandardMethodMetadata#isAbstract()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.core.type.StandardMethodMetadata",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#deactivatePatternCache()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "pattern cache deactivation",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#deactivatePatternCache()",
      "head_type": "method",
      "relation": "have",
      "tail": "Disables caching of tokenized patterns and string matchers",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#deactivatePatternCache()",
      "head_type": "method",
      "relation": "have",
      "tail": "private void deactivatePatternCache() {\n    this.cachePatterns = false;\n    this.tokenizedPatternCache.clear();\n    this.stringMatcherCache.clear();\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#deactivatePatternCache()",
      "head_type": "method",
      "relation": "designPrincipleInterpretation",
      "tail": "Efficiency and Memory Management",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#isPotentialMatch(String,String[])",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "pattern matching",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#isPotentialMatch(String,String[])",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "path must not contain multiple consecutive path separators",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#isPotentialMatch(String,String[])",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "matching URL patterns in web applications",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#isPotentialMatch(String,String[])",
      "head_type": "method",
      "relation": "have",
      "tail": "private boolean isPotentialMatch(String path, String[] pattDirs) {\n    if (!this.trimTokens) {\n        int pos = 0;\n        for (String pattDir : pattDirs) {\n            int skipped = skipSeparator(path, pos, this.pathSeparator);\n            pos += skipped;\n            skipped = skipSegment(path, pos, pattDir);\n            if (skipped < pattDir.length()) {\n                return (skipped > 0 || (pattDir.length() > 0 && isWildcardChar(pattDir.charAt(0))));\n            }\n            pos += skipped;\n        }\n    }\n    return true;\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#isPotentialMatch(String,String[])",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#isPotentialMatch(String,String[])",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#isPotentialMatch(String,String[])",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.AntPathMatcher",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.Assert#state(boolean,Supplier<String>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "assert boolean expression",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.Assert#state(boolean,Supplier<String>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "expression must be true",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.Assert#state(boolean,Supplier<String>)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "check initialization state",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.Assert#state(boolean,Supplier<String>)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for asserting state",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.Assert#state(boolean,Supplier<String>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.Assert",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.Assert#state(boolean,Supplier<String>)",
      "head_type": "method",
      "relation": "have",
      "tail": "related concept interpretation for asserting state",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.Assert#state(boolean,Supplier<String>)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle interpretation for asserting state",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.Assert#notEmpty(Map<?,?>,String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "assertMapNotEmpty",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.Assert#notEmpty(Map<?,?>,String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "mapNotNullOrEmpty",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.Assert#notEmpty(Map<?,?>,String)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "mapValidation",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.Assert#notEmpty(Map<?,?>,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.Assert#notEmpty(Map<?,?>,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.Assert#notEmpty(Map<?,?>,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.Assert#notEmpty(Map<?,?>,String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "IllegalArgumentException",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.Assert#isInstanceOf(Class<?>,Object,Supplier<String>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "assertion_checking",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.Assert#isInstanceOf(Class<?>,Object,Supplier<String>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "type_not_null",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.Assert#isInstanceOf(Class<?>,Object,Supplier<String>)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "object_instance_validation",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.Assert#isInstanceOf(Class<?>,Object,Supplier<String>)",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.Assert#isInstanceOf(Class<?>,Object,Supplier<String>)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.Assert#isInstanceOf(Class<?>,Object,Supplier<String>)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.Assert#isInstanceOf(Class<?>,Object,Supplier<String>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.Assert",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.Assert#endsWithSeparator(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "check if a string ends with a separator",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.Assert#endsWithSeparator(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "private static boolean endsWithSeparator(String msg) {\n    return (msg.endsWith(\":\") || msg.endsWith(\";\") || msg.endsWith(\",\") || msg.endsWith(\".\"));\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.Assert#endsWithSeparator(String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.Assert",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.ElementInstantiationException",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "constructor",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ElementInstantiationException",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "constructor with cause",
      "tail_type": "apiFunction"
    },
    {
      "head": "constructor",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "constructor with cause",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ElementInstantiationException",
      "head_type": "class",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ElementInstantiationException",
      "head_type": "class",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.backoff.ExponentialBackOff#setMultiplier(double)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "setMultiplier",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.backoff.ExponentialBackOff#setMultiplier(double)",
      "head_type": "method",
      "relation": "have",
      "tail": "Set the value to multiply the current interval by for each retry attempt.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.backoff.ExponentialBackOff#setMultiplier(double)",
      "head_type": "method",
      "relation": "have",
      "tail": "The method 'setMultiplier' is used to configure the multiplier value for exponential backoff, which is a strategy to manage retries in case of failures, increasing the delay between subsequent retries.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.backoff.ExponentialBackOff#setMultiplier(double)",
      "head_type": "method",
      "relation": "have",
      "tail": "public void setMultiplier(double multiplier) {\n    checkMultiplier(multiplier);\n    this.multiplier = multiplier;\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.backoff.FixedBackOff#start()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "start execution",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.backoff.FixedBackOff#start()",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.backoff.FixedBackOffExecution",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.backoff.FixedBackOff#start()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.backoff.BackOffExecution",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.backoff.FixedBackOffExecution",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "fixed backoff execution",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.backoff.FixedBackOffExecution",
      "head_type": "class",
      "relation": "designPrincipleInterpretation",
      "tail": "This class is designed to provide a fixed backoff execution strategy, which is a simple and straightforward approach to handle retries with a consistent delay between attempts.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#getAllInterfaces(Object)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getAllInterfaces",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ClassUtils#getAllInterfaces(Object)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "instance must not be null",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ClassUtils#getAllInterfaces(Object)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "analyze instance for interfaces",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ClassUtils#getAllInterfaces(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "Return all interfaces that the given instance implements as an array, including ones implemented by superclasses.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#getAllInterfaces(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is designed to retrieve all interfaces implemented by a given object, including those implemented by its superclasses. It ensures a comprehensive analysis of an object's interface hierarchy.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#getAllInterfaces(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "public static Class<?>[] getAllInterfaces(Object instance) {\n    Assert.notNull(instance, \"Instance must not be null\");\n    return getAllInterfacesForClass(instance.getClass());\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ClassUtils",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.ClassUtils#getAllInterfaces(Object)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.ClassUtils",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getQualifiedMethodName",
      "tail_type": "apiFunction"
    },
    {
      "head": "getQualifiedMethodName",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "org.springframework.util.ClassUtils",
      "tail_type": "class"
    },
    {
      "head": "getQualifiedMethodName",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "Return the qualified name of the given method, consisting of fully qualified interface/class name + '.' + method name.",
      "tail_type": "useScenario"
    },
    {
      "head": "getQualifiedMethodName",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "public static String getQualifiedMethodName(Method method) { return getQualifiedMethodName(method, null); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "getQualifiedMethodName",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "This method is used to obtain the fully qualified name of a given method, which includes the fully qualified name of the interface or class plus the method name.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "getQualifiedMethodName",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "The design principle of this method is to provide a convenient way to uniquely identify a method across different classes and interfaces, which is useful for logging, debugging, and reflection operations.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#getInterfaceMethodIfPossible(Method)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "determine corresponding interface method",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ClassUtils#getInterfaceMethodIfPossible(Method)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "method must be from an implementation class",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ClassUtils#getInterfaceMethodIfPossible(Method)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "invoking method via reflection without illegal access warning",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ClassUtils#getInterfaceMethodIfPossible(Method)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for determining interface method",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ClassUtils#getInterfaceMethodIfPossible(Method)",
      "head_type": "method",
      "relation": "have",
      "tail": "explanation of Java Module System and reflection",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#getInterfaceMethodIfPossible(Method)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle behind interface method determination",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#getInterfaceMethodIfPossible(Method)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.core.SimpleAliasRegistryTests",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.ClassUtils#getInterfaceMethodIfPossible(Method)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "getPubliclyAccessibleMethodIfPossible(Method, Class)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.CommonsLogWriter#write(char[],int,int)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "write characters to log",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.CommonsLogWriter#write(char[],int,int)",
      "head_type": "method",
      "relation": "have",
      "tail": "writes characters from a char array to the log with specified offset and length",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.CommonsLogWriter#write(char[],int,int)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.CommonsLogWriter",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.CommonsLogWriter#close()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "close",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.CommonsLogWriter#close()",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.CommonsLogWriter#close() sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.comparator.ComparableComparator",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "adapt Comparables to the Comparator interface",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.comparator.ComparableComparator",
      "head_type": "class",
      "relation": "constrained_by",
      "tail": "for internal use in other Comparators",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.comparator.ComparableComparator",
      "head_type": "class",
      "relation": "have",
      "tail": "shared instance of this default comparator",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.comparator.ComparableComparator",
      "head_type": "class",
      "relation": "have",
      "tail": "sample code for using ComparableComparator",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.comparator.ComparableComparator",
      "head_type": "class",
      "relation": "have",
      "tail": "related concept interpretation for ComparableComparator",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.comparator.ComparableComparator",
      "head_type": "class",
      "relation": "have",
      "tail": "design principle interpretation for ComparableComparator",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.comparator.ComparableComparator",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "Comparable",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.comparator.ComparableComparator",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "Comparator#naturalOrder()",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.comparator.Comparators#nullsLow(Comparator<T>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "decorator for the given comparator which accepts null values and sorts them lower than non-null values",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.comparator.Comparators#nullsLow(Comparator<T>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "null values should be sorted lower than non-null values",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.comparator.Comparators#nullsLow(Comparator<T>)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "comparator which accepts null values",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.comparator.Comparators#nullsLow(Comparator<T>)",
      "head_type": "method",
      "relation": "have",
      "tail": "Comparator#nullsFirst(Comparator)",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.comparator.Comparators#nullsLow(Comparator<T>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "Comparator",
      "tail_type": "class"
    },
    {
      "head": "Comparator#nullsFirst(Comparator)",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "Complete Java Example for Comparator#nullsFirst(Comparator)",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.comparator.Comparators#nullsLow(Comparator<T>)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.comparator.Comparators#nullsLow(Comparator<T>)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.CompositeCollection#toArray()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "convert collection to array",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.CompositeCollection#toArray()",
      "head_type": "method",
      "relation": "have",
      "tail": "convert collection to array sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "convert collection to array sample code",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "package com.healthMgr.common.email; import java.xxxx; public class OneClass { // specific code }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.CompositeMap#containsKey(Object)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "check key existence",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.CompositeMap#containsKey(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "check key existence in multiple maps",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.CompositeMap#containsKey(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "return true if key exists in any map",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.CompositeMap#containsKey(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "first map checked before second map",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.CompositeMap#containsKey(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "complete sample code for checking key existence",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.CompositeMap#containsKey(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "related concept interpretation for checking key existence",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.CompositeMap#containsKey(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle interpretation for checking key existence",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.CompositeMap#containsKey(Object)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.CompositeMap",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.concurrent.FutureAdapter#cancel(boolean)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "cancel operation",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.concurrent.FutureAdapter#cancel(boolean)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for cancel operation",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.concurrent.FutureAdapter#cancel(boolean)",
      "head_type": "method",
      "relation": "have",
      "tail": "related concept interpretation for cancel operation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.concurrent.FutureAdapter#cancel(boolean)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle interpretation for cancel operation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.concurrent.FutureAdapter#cancel(boolean)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.concurrent.FutureAdapter",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.ConcurrentLruCache#remove(K)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "immediate key removal",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ConcurrentLruCache#remove(K)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "key presence",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ConcurrentLruCache#remove(K)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "eviction of cache entries",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ConcurrentLruCache#remove(K)",
      "head_type": "method",
      "relation": "have",
      "tail": "public boolean remove(K key) { final Node<K, V> node = this.cache.remove(key); if (node == null) { return false; } markForRemoval(node); processWrite(new RemovalTask(node)); return true; }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ConcurrentLruCache#remove(K)",
      "head_type": "method",
      "relation": "have",
      "tail": "Removes a key-value pair from the cache immediately, ensuring that the cache does not retain any reference to the value associated with the specified key.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ConcurrentLruCache#remove(K)",
      "head_type": "method",
      "relation": "have",
      "tail": "The method is designed to ensure thread-safe removal of cache entries, adhering to the principle of immediate consistency in concurrent environments.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ConcurrentReferenceHashMap#getHash(Object)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "hashing",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ConcurrentReferenceHashMap#getHash(Object)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "null input handling",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ConcurrentReferenceHashMap#getHash(Object)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "hash collision reduction",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ConcurrentReferenceHashMap#getHash(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "Wang/Jenkins hashing algorithm",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ConcurrentReferenceHashMap#getHash(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "override for alternative hashing",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ConcurrentReferenceHashMap#getHash(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for hashing",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ConcurrentReferenceHashMap",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "ConcurrentHashMap",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.DefaultPropertiesPersister#store(Properties,OutputStream,String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "store properties",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.DefaultPropertiesPersister#store(Properties,OutputStream,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "store properties sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "store properties sample code",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "complete store properties example",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.DefaultPropertiesPersister#storeToXml(Properties,OutputStream,String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "store properties to XML",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.DefaultPropertiesPersister#storeToXml(Properties,OutputStream,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "storeToXml sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "storeToXml sample code",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "complete example of storeToXml method",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.FastByteArrayOutputStream#write(byte[],int,int)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "write data to output stream",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.FastByteArrayOutputStream#write(byte[],int,int)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "offset and length must be within the bounds of the data array",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.FastByteArrayOutputStream#write(byte[],int,int)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "stream must not be closed",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.FastByteArrayOutputStream#write(byte[],int,int)",
      "head_type": "method",
      "relation": "have",
      "tail": "write data to output stream sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "write data to output stream sample code",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "package com.healthMgr.common.email; import java.io.IOException; import java.io.OutputStream; import org.springframework.util.FastByteArrayOutputStream; public class WriteDataSample { public static void main(String[] args) throws IOException { FastByteArrayOutputStream fastByteArrayOutputStream = new FastByteArrayOutputStream(); byte[] data = {65, 66, 67}; fastByteArrayOutputStream.write(data, 0, data.length); } }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.FastByteArrayOutputStream#write(byte[],int,int)",
      "head_type": "method",
      "relation": "have",
      "tail": "write data to output stream related concept interpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "write data to output stream related concept interpretation",
      "head_type": "relatedConceptInterpretation",
      "relation": "have",
      "tail": "The write method is used to write bytes from a specified array to an output stream. It is a part of the OutputStream class and is overridden in FastByteArrayOutputStream to handle writing data to an internal buffer. The method checks for valid offset and length within the bounds of the array and ensures the stream is not closed before writing.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.FastByteArrayOutputStream#write(byte[],int,int)",
      "head_type": "method",
      "relation": "have",
      "tail": "write data to output stream design principle interpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "write data to output stream design principle interpretation",
      "head_type": "designPrincipleInterpretation",
      "relation": "have",
      "tail": "The design principle behind overriding the write method in FastByteArrayOutputStream is to efficiently manage and extend the internal buffer to accommodate the data being written. It ensures that the buffer is dynamically expanded as needed, optimizing memory usage and performance.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.FileCopyUtils#close(Closeable)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "close a Closeable resource",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.FileCopyUtils#close(Closeable)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "must handle IOException",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.FileCopyUtils#close(Closeable)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "resource cleanup",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.FileCopyUtils#close(Closeable)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for closing a Closeable resource",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.FileCopyUtils#close(Closeable)",
      "head_type": "method",
      "relation": "have",
      "tail": "interpretation of the Closeable interface",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.FileCopyUtils#close(Closeable)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle of exception handling",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.FileCopyUtils#close(Closeable)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "java.io.IOException",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.FileCopyUtils#close(Closeable)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "java.io.Closeable",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.FilteredMap#put(K,V)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "filteredPut",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.FilteredMap#put(K,V)",
      "head_type": "method",
      "relation": "have",
      "tail": "filteredPutSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "filteredPutSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "filteredPutSampleCodeContent",
      "tail_type": "useSampleCodeContent"
    },
    {
      "head": "org.springframework.util.function.SingletonSupplier#get()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "get shared singleton instance",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.function.SingletonSupplier#get()",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "null if no instance available",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.function.SingletonSupplier#get()",
      "head_type": "method",
      "relation": "have",
      "tail": "Get the shared singleton instance for this supplier. @return the singleton instance (or {@code null} if none)",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.function.SingletonSupplier#get()",
      "head_type": "method",
      "relation": "have",
      "tail": "public T get() { T instance = this.singletonInstance; if (instance == null) { this.writeLock.lock(); try { instance = this.singletonInstance; if (instance == null) { if (this.instanceSupplier != null) { instance = this.instanceSupplier.get(); } if (instance == null && this.defaultSupplier != null) { instance = this.defaultSupplier.get(); } this.singletonInstance = instance; } } finally { this.writeLock.unlock(); } } return instance; }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.function.SingletonSupplier#get()",
      "head_type": "method",
      "relation": "have",
      "tail": "Ensures thread-safe retrieval of a singleton instance, using a supplier if necessary.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.function.SingletonSupplier#get()",
      "head_type": "method",
      "relation": "have",
      "tail": "This method follows the Singleton design pattern, ensuring only one instance is created and shared.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.function.ThrowingSupplier",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getWithException",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.function.ThrowingSupplier",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "get",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.function.ThrowingSupplier",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "get",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.function.ThrowingSupplier",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "throwing",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.function.ThrowingSupplier",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "of",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.function.ThrowingSupplier",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "of",
      "tail_type": "apiFunction"
    },
    {
      "head": "getWithException",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "get",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "get",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "throwing",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "of",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "of",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.function.ThrowingSupplier",
      "head_type": "class",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.function.ThrowingSupplier",
      "head_type": "class",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.InvalidMimeTypeException",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "parseMimeType",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.InvalidMimeTypeException",
      "head_type": "class",
      "relation": "constrained_by",
      "tail": "invalid content type specification String",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.InvalidMimeTypeException",
      "head_type": "class",
      "relation": "have",
      "tail": "Exception thrown from MimeTypeUtils#parseMimeType(String) in case of encountering an invalid content type specification String.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.InvalidMimeTypeException",
      "head_type": "class",
      "relation": "have",
      "tail": "This exception is thrown when an invalid MIME type is encountered during parsing.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.InvalidMimeTypeException",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "MimeTypeUtils",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.InvalidMimeTypeException",
      "head_type": "class",
      "relation": "have",
      "tail": "public InvalidMimeTypeException(String mimeType, @Nullable String message) { super(message == null ? \"Invalid mime type \\\"\" + mimeType + \"\\\"\" : \"Invalid mime type \\\"\" + mimeType + \"\\\"\": \" + message); this.mimeType = mimeType; }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.InvalidMimeTypeException",
      "head_type": "class",
      "relation": "have",
      "tail": "public String getMimeType() { return this.mimeType; }",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "Setting a static method name for invocation",
      "head_type": "method",
      "relation": "haveFunction",
      "head": "org.springframework.util.MethodInvoker#setStaticMethod(String)",
      "tail_type": "apiFunction"
    },
    {
      "tail": "Method name must be fully qualified",
      "head_type": "method",
      "relation": "constrained_by",
      "head": "org.springframework.util.MethodInvoker#setStaticMethod(String)",
      "tail_type": "useConstraint"
    },
    {
      "tail": "Invoking static methods without specifying target class and method",
      "head_type": "method",
      "relation": "applied_to",
      "head": "org.springframework.util.MethodInvoker#setStaticMethod(String)",
      "tail_type": "useScenario"
    },
    {
      "tail": "Example: setStaticMethod(\"example.MyExampleClass.myExampleMethod\")",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.MethodInvoker#setStaticMethod(String)",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "This method provides a convenient way to invoke static methods by specifying a fully qualified method name.",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.MethodInvoker#setStaticMethod(String)",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "tail": "The design principle behind this method is to simplify the process of invoking static methods by providing a single point of configuration.",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.MethodInvoker#setStaticMethod(String)",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.MethodInvoker#getArguments()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "return method invocation arguments",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MethodInvoker#getArguments()",
      "head_type": "method",
      "relation": "have",
      "tail": "Return the arguments for the method invocation.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.MethodInvoker#getArguments()",
      "head_type": "method",
      "relation": "have",
      "tail": "public Object[] getArguments() { return (this.arguments != null ? this.arguments : EMPTY_ARGUMENTS); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.MimeType#toString()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "convert MimeType to string",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MimeType#toString()",
      "head_type": "method",
      "relation": "have",
      "tail": "convert MimeType to string sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "convert MimeType to string sample code",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "package com.healthMgr.common.email; import org.springframework.util.MimeType; public class MimeTypeToStringExample { public static void main(String[] args) { MimeType mimeType = new MimeType(\"text\", \"html\"); System.out.println(mimeType.toString()); } }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.MimeType#toString()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.MimeType",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.MimeType#toString()",
      "head_type": "method",
      "relation": "have",
      "tail": "related concept interpretation for MimeType#toString()",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "related concept interpretation for MimeType#toString()",
      "head_type": "relatedConceptInterpretation",
      "relation": "have",
      "tail": "MimeType represents a media type as defined in RFC 2046 and consists of a type and a subtype, for example, text/html. The toString() method is used to convert the MimeType object into its string representation.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.MimeType#toString()",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle interpretation for MimeType#toString()",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "design principle interpretation for MimeType#toString()",
      "head_type": "designPrincipleInterpretation",
      "relation": "have",
      "tail": "The design principle behind the toString() method in MimeType is to provide a convenient way to get the string representation of the media type, which can be useful for logging, debugging, or sending the media type in text-based protocols.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.MultiToSingleValueMapAdapter#toString()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "toString conversion",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MultiToSingleValueMapAdapter#toString()",
      "head_type": "method",
      "relation": "have",
      "tail": "Converts the targetMap to a string representation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.MultiToSingleValueMapAdapter#toString()",
      "head_type": "method",
      "relation": "have",
      "tail": "Utilizes the toString method of the targetMap object",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.MultiToSingleValueMapAdapter#toString()",
      "head_type": "method",
      "relation": "have",
      "tail": "Design principle of simplicity and readability in API design",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.MultiValueMap#add(K,V)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "addSingleValueToKey",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MultiValueMap#add(K,V)",
      "head_type": "method",
      "relation": "have",
      "tail": "addSingleValueToKeySampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "addSingleValueToKeySampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "org.springframework.util.MultiValueMap",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.MultiValueMap#add(K,V)",
      "head_type": "method",
      "relation": "have",
      "tail": "addSingleValueToKeyRelatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "addSingleValueToKeyRelatedConceptInterpretation",
      "head_type": "relatedConceptInterpretation",
      "relation": "have",
      "tail": "MultiValueMap",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.MultiValueMap#add(K,V)",
      "head_type": "method",
      "relation": "have",
      "tail": "addSingleValueToKeyDesignPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.MultiValueMapAdapter#isEmpty()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "checkEmptiness",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MultiValueMapAdapter#isEmpty()",
      "head_type": "method",
      "relation": "have",
      "tail": "Checks if the underlying targetMap is empty",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.MultiValueMapAdapter#isEmpty()",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is used to determine if the MultiValueMapAdapter is empty by delegating the check to the targetMap's isEmpty() method.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.MultiValueMapAdapter#isEmpty()",
      "head_type": "method",
      "relation": "have",
      "tail": "java\npackage org.springframework.util;\n\nimport java.util.Map;\n\npublic class MultiValueMapAdapterExample {\n    public static void main(String[] args) {\n        MultiValueMapAdapter<String, String> adapter = new MultiValueMapAdapter<>();\n        System.out.println(\"Is map empty? \" + adapter.isEmpty());\n    }\n}\n",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeHashCode(Object[])",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "hash code generation",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeHashCode(Object[])",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "null input returns 0",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeHashCode(Object[])",
      "head_type": "method",
      "relation": "have",
      "tail": "Return a hash code based on the contents of the specified array. If array is null, this method returns 0.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeHashCode(Object[])",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is deprecated as of version 6.1, in favor of Arrays#hashCode(Object[]).",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeHashCode(Object[])",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "Arrays#hashCode(Object[])",
      "tail_type": "method"
    },
    {
      "head": "hash code generation",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "org.springframework.util.ObjectUtils#nullSafeHashCode(Object[])",
      "tail_type": "method"
    },
    {
      "head": "null input returns 0",
      "head_type": "useConstraint",
      "relation": "applied_to",
      "tail": "org.springframework.util.ObjectUtils#nullSafeHashCode(Object[])",
      "tail_type": "method"
    },
    {
      "head": "Return a hash code based on the contents of the specified array. If array is null, this method returns 0.",
      "head_type": "relatedConceptInterpretation",
      "relation": "have",
      "tail": "org.springframework.util.ObjectUtils#nullSafeHashCode(Object[])",
      "tail_type": "method"
    },
    {
      "head": "This method is deprecated as of version 6.1, in favor of Arrays#hashCode(Object[]).",
      "head_type": "designPrincipleInterpretation",
      "relation": "have",
      "tail": "org.springframework.util.ObjectUtils#nullSafeHashCode(Object[])",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.PlaceholderParser#createSimplePlaceholderPart(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "createSimplePlaceholderPart",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.PlaceholderParser#createSimplePlaceholderPart(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "createSimplePlaceholderPart(String text) { ParsedSection section = parseSection(text); return new SimplePlaceholderPart(text, section.key(), section.fallback()); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "createSimplePlaceholderPart",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "createSimplePlaceholderPart(String text) { ParsedSection section = parseSection(text); return new SimplePlaceholderPart(text, section.key(), section.fallback()); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.PartResolutionContext#handleUnresolvablePlaceholder(String,String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "handleUnresolvablePlaceholder",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.PartResolutionContext#handleUnresolvablePlaceholder(String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "handleUnresolvablePlaceholder(String key, String text)",
      "tail_type": "useSampleCode"
    },
    {
      "head": "handleUnresolvablePlaceholder(String key, String text)",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "tail": "org.springframework.util.PartResolutionContext#handleUnresolvablePlaceholder(String,String)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.PartResolutionContext#handleUnresolvablePlaceholder(String,String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.PartResolutionContext",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#findFieldIgnoreCase(Class<?>,String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "findField",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#findFieldIgnoreCase(Class<?>,String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "caseInsensitiveSearch",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#findFieldIgnoreCase(Class<?>,String)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "introspection",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#findFieldIgnoreCase(Class<?>,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#findFieldIgnoreCase(Class<?>,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#findFieldIgnoreCase(Class<?>,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#findFieldIgnoreCase(Class<?>,String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.ReflectionUtils",
      "tail_type": "class"
    },
    {
      "head": "findField",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "findField",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "findField",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "introspection",
      "head_type": "useScenario",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "introspection",
      "head_type": "useScenario",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "introspection",
      "head_type": "useScenario",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#doWithLocalFields(Class<?>,FieldCallback)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "invokeCallbackOnFields",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#doWithLocalFields(Class<?>,FieldCallback)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "introspectionFailure",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#doWithLocalFields(Class<?>,FieldCallback)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "locallyDeclaredFieldsAnalysis",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#doWithLocalFields(Class<?>,FieldCallback)",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#doWithLocalFields(Class<?>,FieldCallback)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#doWithLocalFields(Class<?>,FieldCallback)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#doWithLocalFields(Class<?>,FieldCallback)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.ReflectionUtils",
      "tail_type": "class"
    },
    {
      "head": "invokeCallbackOnFields",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "introspectionFailure",
      "head_type": "useConstraint",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "locallyDeclaredFieldsAnalysis",
      "head_type": "useScenario",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#shallowCopyFieldState(Object,Object)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "copy all fields including inherited fields",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#shallowCopyFieldState(Object,Object)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "source and destination must be the same class or subclass",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#shallowCopyFieldState(Object,Object)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "objects must have public no-arg constructors",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#shallowCopyFieldState(Object,Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#shallowCopyFieldState(Object,Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#shallowCopyFieldState(Object,Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "relatedConceptInterpretation",
      "head_type": "relatedConceptInterpretation",
      "relation": "associated_with",
      "tail": "introspection",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "designPrincipleInterpretation",
      "head_type": "designPrincipleInterpretation",
      "relation": "associated_with",
      "tail": "public no-arg constructors",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "useSampleCode",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "tail": "shallowCopyFieldState method example",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#makeAccessible(Field)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "makeAccessible",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#makeAccessible(Field)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "fieldAccessibility",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#makeAccessible(Field)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "fieldModification",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#makeAccessible(Field)",
      "head_type": "method",
      "relation": "have",
      "tail": "java.lang.reflect.Field#setAccessible",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#makeAccessible(Field)",
      "head_type": "method",
      "relation": "have",
      "tail": "reflectionExplanation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#makeAccessible(Field)",
      "head_type": "method",
      "relation": "have",
      "tail": "accessibilityDesignPrinciple",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#makeAccessible(Field)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "java.lang.reflect.Field",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.SimpleRouteMatcher#getPatternComparator(Route)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getPatternComparator",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.SimpleRouteMatcher#getPatternComparator(Route)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.SimpleRouteMatcher",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.SimpleRouteMatcher",
      "head_type": "class",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "designPrincipleInterpretation",
      "head_type": "designPrincipleInterpretation",
      "relation": "have",
      "tail": "The design principle of the SimpleRouteMatcher class is to provide a simple and efficient way to match routes based on patterns. It uses a path matcher to compare patterns and determine the best match for a given route.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.StringUtils#cleanPath(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "path normalization",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils#cleanPath(String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "security context constraint",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.StringUtils#cleanPath(String)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "path comparison",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.StringUtils#cleanPath(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.StringUtils#cleanPath(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.StringUtils#cleanPath(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "path normalization",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "org.springframework.util.StringUtils",
      "tail_type": "class"
    },
    {
      "head": "security context constraint",
      "head_type": "useConstraint",
      "relation": "associated_with",
      "tail": "org.springframework.util.StringUtils#cleanPath(String)",
      "tail_type": "method"
    },
    {
      "head": "path comparison",
      "head_type": "useScenario",
      "relation": "associated_with",
      "tail": "org.springframework.util.StringUtils#cleanPath(String)",
      "tail_type": "method"
    },
    {
      "head": "useSampleCode",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "tail": "org.springframework.util.StringUtils#cleanPath(String)",
      "tail_type": "method"
    },
    {
      "head": "relatedConceptInterpretation",
      "head_type": "relatedConceptInterpretation",
      "relation": "associated_with",
      "tail": "org.springframework.util.StringUtils#cleanPath(String)",
      "tail_type": "method"
    },
    {
      "head": "designPrincipleInterpretation",
      "head_type": "designPrincipleInterpretation",
      "relation": "associated_with",
      "tail": "org.springframework.util.StringUtils#cleanPath(String)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.StringUtils#parseLocaleString(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "parseLocaleString",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils#parseLocaleString(String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "不接受BCP47语言标签格式",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.StringUtils#parseLocaleString(String)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "Spring解析需求",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.StringUtils#parseLocaleString(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "解析给定的字符串表示为Locale对象",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.StringUtils#parseLocaleString(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "不追求严格的Locale设计合规性",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.StringUtils#parseLocaleString(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "使用#parseLocale进行宽松解析",
      "tail_type": "useSampleCode"
    },
    {
      "head": "parseLocaleString",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "org.springframework.util.StringUtils",
      "tail_type": "class"
    },
    {
      "head": "不接受BCP47语言标签格式",
      "head_type": "useConstraint",
      "relation": "associated_with",
      "tail": "org.springframework.util.StringUtils#parseLocaleString(String)",
      "tail_type": "method"
    },
    {
      "head": "Spring解析需求",
      "head_type": "useScenario",
      "relation": "associated_with",
      "tail": "org.springframework.util.StringUtils#parseLocaleString(String)",
      "tail_type": "method"
    },
    {
      "head": "解析给定的字符串表示为Locale对象",
      "head_type": "relatedConceptInterpretation",
      "relation": "associated_with",
      "tail": "org.springframework.util.StringUtils#parseLocaleString(String)",
      "tail_type": "method"
    },
    {
      "head": "不追求严格的Locale设计合规性",
      "head_type": "designPrincipleInterpretation",
      "relation": "associated_with",
      "tail": "org.springframework.util.StringUtils#parseLocaleString(String)",
      "tail_type": "method"
    },
    {
      "head": "使用#parseLocale进行宽松解析",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "tail": "org.springframework.util.StringUtils#parseLocaleString(String)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.StringUtils#toStringArray(Collection<String>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "convertCollectionToStringArray",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils#toStringArray(Collection<String>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "collectionMustContainStringElementsOnly",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.StringUtils#toStringArray(Collection<String>)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "copyingCollectionIntoStringArray",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.StringUtils#toStringArray(Collection<String>)",
      "head_type": "method",
      "relation": "have",
      "tail": "convertCollectionToStringArraySampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.StringUtils#toStringArray(Collection<String>)",
      "head_type": "method",
      "relation": "have",
      "tail": "convertCollectionToStringArrayRelatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.StringUtils#toStringArray(Collection<String>)",
      "head_type": "method",
      "relation": "have",
      "tail": "convertCollectionToStringArrayDesignPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "convertCollectionToStringArraySampleCode",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "tail": "org.springframework.util.StringUtils#toStringArray(Collection<String>)",
      "tail_type": "method"
    },
    {
      "head": "convertCollectionToStringArrayRelatedConceptInterpretation",
      "head_type": "relatedConceptInterpretation",
      "relation": "associated_with",
      "tail": "org.springframework.util.StringUtils#toStringArray(Collection<String>)",
      "tail_type": "method"
    },
    {
      "head": "convertCollectionToStringArrayDesignPrincipleInterpretation",
      "head_type": "designPrincipleInterpretation",
      "relation": "associated_with",
      "tail": "org.springframework.util.StringUtils#toStringArray(Collection<String>)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.StringUtils#tokenizeToStringArray(String,String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "tokenize string to array",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils#tokenizeToStringArray(String,String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "delimiter characters must be single character",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.StringUtils#tokenizeToStringArray(String,String)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "string manipulation",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.StringUtils#tokenizeToStringArray(String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for tokenizing string to array",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.StringUtils#tokenizeToStringArray(String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "explanation of StringTokenizer and String manipulation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.StringUtils#tokenizeToStringArray(String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle of efficient string manipulation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.StringUtils#tokenizeToStringArray(String,String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "java.util.StringTokenizer",
      "tail_type": "class"
    },
    {
      "head": "java.util.StringTokenizer",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "tokenize string",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.unit.DataSize#hashCode()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "generate hash code",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.unit.DataSize#hashCode()",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.unit.DataSize",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.unit.DataSize#hashCode()",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.unit.DataSize#hashCode()",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.unit.DataSize#hashCode()",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#equals(Object)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "equality check",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#equals(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.UnmodifiableMultiValueMap#equals(Object) sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "equality check",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "org.springframework.util.UnmodifiableMultiValueMap#equals(Object)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#equals(Object) sample code",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "org.springframework.util.UnmodifiableMultiValueMap#equals(Object)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#putAll(Map<? extends K,? extends List<V>>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "org.springframework.util.UnmodifiableMultiValueMap#putAll",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#putAll",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "UnsupportedOperationException",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#putAll",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "org.springframework.util.UnmodifiableMultiValueMap#putAll(Map<? extends K,? extends List<V>>) useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#putAll",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#putAll",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueCollection#iterator()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "iterator",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueCollection#iterator()",
      "head_type": "method",
      "relation": "have",
      "tail": "UnmodifiableValueCollection",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueCollection#iterator()",
      "head_type": "method",
      "relation": "have",
      "tail": "Collections.unmodifiableList",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueCollection#iterator()",
      "head_type": "method",
      "relation": "have",
      "tail": "Delegate iterator",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueCollection#iterator()",
      "head_type": "method",
      "relation": "have",
      "tail": "UnmodifiableValueCollection Design Principle",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueCollection#iterator()",
      "head_type": "method",
      "relation": "have",
      "tail": "Sample Code for UnmodifiableValueCollection#iterator()",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#newNamespaceMapping()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "newNamespaceMapping",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#newNamespaceMapping()",
      "head_type": "method",
      "relation": "have",
      "tail": "private void newNamespaceMapping() { this.namespaceMappings.add(new HashMap<>()); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#newNamespaceMapping()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.AbstractStaxHandler",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.SimpleNamespaceContext",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getPrefix(String)",
      "tail_type": "apiFunction"
    },
    {
      "head": "getPrefix(String)",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "getPrefixesSet(namespaceUri)",
      "tail_type": "useSampleCode"
    },
    {
      "head": "getPrefix(String)",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "(!prefixes.isEmpty() ? prefixes.iterator().next() : null)",
      "tail_type": "useSampleCode"
    },
    {
      "head": "getPrefix(String)",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "prefixes",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "getPrefix(String)",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "namespaceUri",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "getPrefix(String)",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "prefixes.iterator().next()",
      "tail_type": "useSampleCode"
    },
    {
      "head": "getPrefix(String)",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "prefixes.isEmpty()",
      "tail_type": "useSampleCode"
    },
    {
      "head": "getPrefix(String)",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "prefixes",
      "tail_type": "useSampleCode"
    },
    {
      "head": "getPrefix(String)",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "namespaceUri",
      "tail_type": "useSampleCode"
    },
    {
      "head": "getPrefix(String)",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "prefixes",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "getPrefix(String)",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "namespaceUri",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "getPrefix(String)",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "prefixes.iterator().next()",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "getPrefix(String)",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "prefixes.isEmpty()",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "getPrefix(String)",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "prefixes",
      "tail_type": "useScenario"
    },
    {
      "head": "getPrefix(String)",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "namespaceUri",
      "tail_type": "useScenario"
    },
    {
      "head": "getPrefix(String)",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "prefixes.iterator().next()",
      "tail_type": "useScenario"
    },
    {
      "head": "getPrefix(String)",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "prefixes.isEmpty()",
      "tail_type": "useScenario"
    },
    {
      "head": "getPrefix(String)",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "prefixes",
      "tail_type": "useConstraint"
    },
    {
      "head": "getPrefix(String)",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "namespaceUri",
      "tail_type": "useConstraint"
    },
    {
      "head": "getPrefix(String)",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "prefixes.iterator().next()",
      "tail_type": "useConstraint"
    },
    {
      "head": "getPrefix(String)",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "prefixes.isEmpty()",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.xml.SimpleNamespaceContext#bindDefaultNamespaceUri(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "bind default namespace",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.SimpleNamespaceContext#bindDefaultNamespaceUri(String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "namespaceUri must be valid",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.xml.SimpleNamespaceContext#bindDefaultNamespaceUri(String)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "xml processing",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.xml.SimpleNamespaceContext#bindDefaultNamespaceUri(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "public void bindDefaultNamespaceUri(String namespaceUri) { bindNamespaceUri(XMLConstants.DEFAULT_NS_PREFIX, namespaceUri); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.SimpleNamespaceContext#bindDefaultNamespaceUri(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "related to XML namespace management",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.SimpleNamespaceContext#bindDefaultNamespaceUri(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle of encapsulating XML namespace operations",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.SimpleNamespaceContext#bindDefaultNamespaceUri(String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.SimpleNamespaceContext",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamHandler#startDocumentInternal()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "writeStartDocument",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamHandler#startDocumentInternal()",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.xml.StaxStreamHandler#startDocumentInternal()",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter#flush()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "flushing XML events",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter#flush()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.XMLEventStreamWriter",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter#flush()",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for flushing XML events",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#field(Class<?>,String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "field retrieval",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#field(Class<?>,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "private static Field field(Class<?> type, String name) {\n    Field field = ReflectionUtils.findField(type, name);\n    assertThat(field).isNotNull();\n    return field;\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#field(Class<?>,String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "ReflectionUtils",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#field(Class<?>,String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "assertThat",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.DefaultGenerationContextTests#withNameGeneratesUniqueName()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "unique name generation",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.DefaultGenerationContextTests#withNameGeneratesUniqueName()",
      "head_type": "method",
      "relation": "have",
      "tail": "unique name generation sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "unique name generation sample code",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "java\nimport org.junit.jupiter.api.Test;\nimport org.springframework.aot.generate.ClassNameGenerator;\nimport org.springframework.aot.generate.DefaultGenerationContext;\nimport org.springframework.aot.generate.GenerationContext;\n\npublic class UniqueNameGenerationExample {\n\n    @Test\n    public void uniqueNameGenerationExample() {\n        DefaultGenerationContext context = new DefaultGenerationContext(new ClassNameGenerator(\"com.example\"), null);\n        context.withName(\"Test\").getGeneratedClasses().addForFeature(\"Feature\", typeSpec -> {});\n        context.withName(\"Test\").getGeneratedClasses().addForFeature(\"Feature\", typeSpec -> {});\n        context.withName(\"Test\").getGeneratedClasses().addForFeature(\"Feature\", typeSpec -> {});\n        // Write generated content and verify unique names\n    }\n}\n",
      "tail_type": "String"
    },
    {
      "head": "org.springframework.aot.generate.DefaultGenerationContextTests#withNameGeneratesUniqueName()",
      "head_type": "method",
      "relation": "have",
      "tail": "related concept interpretation for unique name generation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "related concept interpretation for unique name generation",
      "head_type": "relatedConceptInterpretation",
      "relation": "have",
      "tail": "Unique name generation ensures that each generated class has a distinct name to avoid conflicts during code generation.",
      "tail_type": "String"
    },
    {
      "head": "org.springframework.aot.generate.DefaultGenerationContextTests#withNameGeneratesUniqueName()",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle interpretation for unique name generation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "design principle interpretation for unique name generation",
      "head_type": "designPrincipleInterpretation",
      "relation": "have",
      "tail": "The design principle behind unique name generation is to maintain clarity and avoid naming collisions, which is crucial for large-scale projects with numerous generated classes.",
      "tail_type": "String"
    },
    {
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#toCodeBlockWithStaticMethod()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "createStaticMethodReference",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#toCodeBlockWithStaticMethod()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "toCodeBlock",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#toCodeBlockWithStaticMethod()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "com.example.Test",
      "tail_type": "class"
    },
    {
      "head": "createStaticMethodReference",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "CodeBlock.of(\"com.example.Test::methodName\")",
      "tail_type": "useSampleCode"
    },
    {
      "head": "toCodeBlock",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "CodeBlock.of(\"com.example.Test::methodName\")",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#toCodeBlockWithStaticMethod()",
      "head_type": "method",
      "relation": "have",
      "tail": "assertThat(createStaticMethodReference(\"methodName\", TEST_CLASS_NAME).toCodeBlock()).isEqualTo(CodeBlock.of(\"com.example.Test::methodName\"));",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithNonMatchingArg()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "generate method reference",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithNonMatchingArg()",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "parameter type must match",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithNonMatchingArg()",
      "head_type": "method",
      "relation": "have",
      "tail": "generate method reference with non-matching argument",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithNonMatchingArg()",
      "head_type": "method",
      "relation": "have",
      "tail": "generate method reference with non-matching argument sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithNonMatchingArg()",
      "head_type": "method",
      "relation": "have",
      "tail": "related concept interpretation for method reference",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithNonMatchingArg()",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle interpretation for method reference",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithNonMatchingArg()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.DefaultMethodReferenceTests",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassesTests#addForFeatureComponentWhenTypeSpecCustomizerIsNullThrowsException()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "addForFeatureComponent",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassesTests#addForFeatureComponentWhenTypeSpecCustomizerIsNullThrowsException()",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "typeSpecCustomizerNotNull",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassesTests#addForFeatureComponentWhenTypeSpecCustomizerIsNullThrowsException()",
      "head_type": "method",
      "relation": "have",
      "tail": "typeSpecCustomizerNotNullException",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassesTests#addForFeatureComponentWhenTypeSpecCustomizerIsNullThrowsException()",
      "head_type": "method",
      "relation": "have",
      "tail": "GeneratedClassesAddForFeatureComponentSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassesTests#addForFeatureComponentWhenTypeSpecCustomizerIsNullThrowsException()",
      "head_type": "method",
      "relation": "have",
      "tail": "GeneratedClassesAddForFeatureComponentRelatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassesTests#addForFeatureComponentWhenTypeSpecCustomizerIsNullThrowsException()",
      "head_type": "method",
      "relation": "have",
      "tail": "GeneratedClassesAddForFeatureComponentDesignPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassesTests#addForFeatureComponentWhenTypeSpecCustomizerIsNullThrowsException()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.GeneratedClassesTests",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassTests#generateMethodNameWhenAllEmptyPartsGeneratesSetName()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "generateMethodName",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassTests#generateMethodNameWhenAllEmptyPartsGeneratesSetName()",
      "head_type": "method",
      "relation": "have",
      "tail": "GeneratedClass",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassTests#generateMethodNameWhenAllEmptyPartsGeneratesSetName()",
      "head_type": "method",
      "relation": "have",
      "tail": "GeneratedMethod",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassTests#generateMethodNameWhenAllEmptyPartsGeneratesSetName()",
      "head_type": "method",
      "relation": "have",
      "tail": "generateMethodNameWhenAllEmptyPartsGeneratesSetName useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "generateMethodNameWhenAllEmptyPartsGeneratesSetName useSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "org.springframework.aot.generate.GeneratedClassTests#generateMethodNameWhenAllEmptyPartsGeneratesSetName() sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests#addSourceFileWithJavaFileAddsFile()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "generateJavaFile",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests#addSourceFileWithJavaFileAddsFile()",
      "head_type": "method",
      "relation": "have",
      "tail": "generateJavaFileSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "generateJavaFileSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "generateJavaFileSampleCodeContent",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests#addSourceFileWithJavaFileInTheDefaultPackageThrowsException()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "addSourceFileWithJavaFileInTheDefaultPackageThrowsException",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests#addSourceFileWithJavaFileInTheDefaultPackageThrowsException()",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "processing classes in the default package is not supported",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests#addSourceFileWithJavaFileInTheDefaultPackageThrowsException()",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for adding a source file with a Java file in the default package",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests#addSourceFileWithJavaFileInTheDefaultPackageThrowsException()",
      "head_type": "method",
      "relation": "have",
      "tail": "related concept interpretation for adding a source file",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests#addSourceFileWithJavaFileInTheDefaultPackageThrowsException()",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle interpretation for adding a source file",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests#addSourceFileWithJavaFileInTheDefaultPackageThrowsException()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.GeneratedFilesTests",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFileAssert#hasOverride(boolean)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "assert override status",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFileAssert#hasOverride(boolean)",
      "head_type": "method",
      "relation": "have",
      "tail": "assert override status sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedMethodTests#toMethodReferenceWithInstanceMethod()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "toMethodReference",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedMethodTests#toMethodReferenceWithInstanceMethod()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "toInvokeCodeBlock",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedMethodTests#toMethodReferenceWithInstanceMethod()",
      "head_type": "method",
      "relation": "have",
      "tail": "GeneratedMethod generatedMethod = create(emptyMethod); MethodReference methodReference = generatedMethod.toMethodReference(); assertThat(methodReference).isNotNull(); assertThat(methodReference.toInvokeCodeBlock(ArgumentCodeGenerator.none(), TEST_CLASS_NAME)).isEqualTo(CodeBlock.of(\"spring()\"));",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedMethodTests#toMethodReferenceWithInstanceMethod()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.GeneratedMethod",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedMethodTests#toMethodReferenceWithInstanceMethod()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.MethodReference",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedMethodTests#toMethodReferenceWithInstanceMethod()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.CodeBlock",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedMethodTests#toMethodReferenceWithInstanceMethod()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.ArgumentCodeGenerator",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedTypeReferenceTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "hasSuitableReflectionTargetName",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedTypeReferenceTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "createWithClassName",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedTypeReferenceTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "createWithClassNameAndParent",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedTypeReferenceTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "nameOfCglibProxy",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedTypeReferenceTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "nameOfNestedCglibProxy",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedTypeReferenceTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "equalsWithIdenticalCanonicalNameIsTrue",
      "tail_type": "apiFunction"
    },
    {
      "head": "hasSuitableReflectionTargetName",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "createWithClassName",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "createWithClassNameAndParent",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "nameOfCglibProxy",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "nameOfNestedCglibProxy",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "equalsWithIdenticalCanonicalNameIsTrue",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedTypeReferenceTests",
      "head_type": "class",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedTypeReferenceTests",
      "head_type": "class",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedTypeReferenceTests#hasSuitableReflectionTargetName(TypeReference,String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "hasSuitableReflectionTargetName",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedTypeReferenceTests#hasSuitableReflectionTargetName(TypeReference,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "hasSuitableReflectionTargetName(TypeReference typeReference, String binaryName) { assertThat(typeReference.getName()).isEqualTo(binaryName); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedTypeReferenceTests#hasSuitableReflectionTargetName(TypeReference,String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.GeneratedTypeReferenceTests",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.InMemoryGeneratedFilesTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getGeneratedFileWhenFileExistsReturnsInputStreamSource",
      "tail_type": "apiFunction"
    },
    {
      "head": "getGeneratedFileWhenFileExistsReturnsInputStreamSource",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "getGeneratedFileWhenFileExistsReturnsInputStreamSource() { this.generatedFiles.addResourceFile(\"META-INF/test\", \"test\"); assertThat(this.generatedFiles.getGeneratedFile(Kind.RESOURCE, \"META-INF/test\")).isNotNull(); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "getGeneratedFileWhenFileExistsReturnsInputStreamSource",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "This method tests that when a file exists, getGeneratedFile returns an InputStreamSource.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "getGeneratedFileWhenFileExistsReturnsInputStreamSource",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "The method first adds a resource file to the generatedFiles object, then checks if the getGeneratedFile method returns a non-null value when called with the Kind.RESOURCE and the file path.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.ResolvableTypeTests#generateWhenUnresolvedNestedGenericType()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "generateWhenUnresolvedNestedGenericType",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.ResolvableTypeTests#generateWhenUnresolvedNestedGenericType()",
      "head_type": "method",
      "relation": "have",
      "tail": "generateWhenUnresolvedNestedGenericType_useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "generateWhenUnresolvedNestedGenericType_useSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "generateWhenUnresolvedNestedGenericType_sampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.ResolvableTypeTests#generateWhenUnresolvedNestedGenericType()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.ResolvableType",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.ResolvableTypeTests#generateWhenUnresolvedNestedGenericType()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "SampleTypes",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#isCandidateWithMatchingAnnotatedElement(Class<?>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "determine if a class is a candidate for registration",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#isCandidateWithMatchingAnnotatedElement(Class<?>)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "test if various annotated beans and interfaces are candidates",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#isCandidateWithMatchingAnnotatedElement(Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "SampleTypeAnnotatedBean.class, SampleFieldAnnotatedBean.class, SampleConstructorAnnotatedBean.class, SampleMethodAnnotatedBean.class, SampleInterface.class, SampleMethodMetaAnnotatedBeanWithAlias.class, SampleMethodAnnotatedBeanWithInterface.class",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#isCandidateWithMatchingAnnotatedElement(Class<?>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "SampleTypeAnnotatedBean",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#isCandidateWithMatchingAnnotatedElement(Class<?>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "SampleFieldAnnotatedBean",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#isCandidateWithMatchingAnnotatedElement(Class<?>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "SampleConstructorAnnotatedBean",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#isCandidateWithMatchingAnnotatedElement(Class<?>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "SampleMethodAnnotatedBean",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#isCandidateWithMatchingAnnotatedElement(Class<?>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "SampleInterface",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#isCandidateWithMatchingAnnotatedElement(Class<?>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "SampleMethodMetaAnnotatedBeanWithAlias",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#isCandidateWithMatchingAnnotatedElement(Class<?>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "SampleMethodAnnotatedBeanWithInterface",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#isCandidateWithMatchingAnnotatedElement(Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#isCandidateWithMatchingAnnotatedElement(Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.hint.annotation.RegisterReflectionForBindingProcessorTests#registerReflectionForBindingOnClassItself()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "registerReflectionHints",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.hint.annotation.RegisterReflectionForBindingProcessorTests#registerReflectionForBindingOnClassItself()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "RuntimeHintsPredicates.reflection().onType",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.hint.annotation.RegisterReflectionForBindingProcessorTests#registerReflectionForBindingOnClassItself()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "RuntimeHintsPredicates.reflection().onMethodInvocation",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.hint.annotation.RegisterReflectionForBindingProcessorTests#registerReflectionForBindingOnClassItself()",
      "head_type": "method",
      "relation": "have",
      "tail": "SampleClassWithoutAnnotationAttribute",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.hint.annotation.RegisterReflectionForBindingProcessorTests#registerReflectionForBindingOnClassItself()",
      "head_type": "method",
      "relation": "have",
      "tail": "String",
      "tail_type": "class"
    },
    {
      "head": "registerReflectionHints",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "SampleClassWithoutAnnotationAttribute",
      "tail_type": "class"
    },
    {
      "head": "RuntimeHintsPredicates.reflection().onType",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "SampleClassWithoutAnnotationAttribute",
      "tail_type": "class"
    },
    {
      "head": "RuntimeHintsPredicates.reflection().onType",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "String",
      "tail_type": "class"
    },
    {
      "head": "RuntimeHintsPredicates.reflection().onMethodInvocation",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "SampleClassWithoutAnnotationAttribute",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.hint.annotation.RegisterReflectionForBindingProcessorTests#registerReflectionForBindingOnClassItself()",
      "head_type": "method",
      "relation": "have",
      "tail": "registerReflectionForBindingOnClassItself()",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.hint.annotation.RegisterReflectionReflectiveProcessorTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "registerReflectionHints",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.hint.annotation.RegisterReflectionReflectiveProcessorTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "assertBasicTypeHint",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.hint.annotation.RegisterReflectionReflectiveProcessorTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "hasOnlyMemberCategories",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.hint.annotation.RegisterReflectionReflectiveProcessorTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getTypeHint",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.hint.annotation.RegisterReflectionReflectiveProcessorTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "registerReflectionWithMemberCategory",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.hint.annotation.RegisterReflectionReflectiveProcessorTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "registerReflectionForMultipleTargets",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.hint.annotation.RegisterReflectionReflectiveProcessorTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "registerReflectionOnTargetClass",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.hint.annotation.RegisterReflectionReflectiveProcessorTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "registerReflectionForStaticField",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.hint.annotation.RegisterReflectionReflectiveProcessorTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "registerReflectionWithoutTarget",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.hint.annotation.RegisterReflectionReflectiveProcessorTests",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "RegisterReflectionReflectiveProcessor",
      "tail_type": "class"
    },
    {
      "head": "registerReflectionHints",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "AnnotatedElement",
      "tail_type": "class"
    },
    {
      "head": "registerReflectionHints",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "Method",
      "tail_type": "class"
    },
    {
      "head": "assertBasicTypeHint",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "Class<?>",
      "tail_type": "class"
    },
    {
      "head": "hasOnlyMemberCategories",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "TypeHint",
      "tail_type": "class"
    },
    {
      "head": "getTypeHint",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "Class<?>",
      "tail_type": "class"
    },
    {
      "head": "getTypeHint",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "TypeHint",
      "tail_type": "class"
    },
    {
      "head": "RegisterReflectionReflectiveProcessorTests",
      "head_type": "class",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "RegisterReflectionReflectiveProcessorTests",
      "head_type": "class",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "RegisterReflectionReflectiveProcessorTests",
      "head_type": "class",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.hint.annotation.AnnotatedTypeTests#registerReflectionWithMemberCategory()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "registerReflectionHints",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.hint.annotation.AnnotatedTypeTests#registerReflectionWithMemberCategory()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "assertBasicTypeHint",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.hint.annotation.AnnotatedTypeTests#registerReflectionWithMemberCategory()",
      "head_type": "method",
      "relation": "have",
      "tail": "RegistrationSimple.class",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.hint.annotation.AnnotatedTypeTests#registerReflectionWithMemberCategory()",
      "head_type": "method",
      "relation": "have",
      "tail": "SimplePojo.class",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.hint.annotation.AnnotatedTypeTests#registerReflectionWithMemberCategory()",
      "head_type": "method",
      "relation": "have",
      "tail": "MemberCategory.INVOKE_PUBLIC_METHODS",
      "tail_type": "useScenario"
    },
    {
      "head": "registerReflectionHints",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "RegistrationSimple.class",
      "tail_type": "class"
    },
    {
      "head": "assertBasicTypeHint",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "SimplePojo.class",
      "tail_type": "class"
    },
    {
      "head": "assertBasicTypeHint",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "MemberCategory.INVOKE_PUBLIC_METHODS",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.aot.hint.annotation.AnnotatedTypeTests#registerReflectionWithMemberCategory()",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.hint.annotation.AnnotatedTypeTests#registerReflectionWithMemberCategory()",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.hint.annotation.AnnotatedTypeTests#registerReflectionWithMemberCategory()",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.core.type.StandardAnnotationMetadata#getAnnotations()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getAnnotations",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.core.type.StandardAnnotationMetadata#getAnnotations()",
      "head_type": "method",
      "relation": "have",
      "tail": "MergedAnnotations",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.core.type.StandardAnnotationMetadata#getAnnotations()",
      "head_type": "method",
      "relation": "have",
      "tail": "this.mergedAnnotations",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.core.type.StandardAnnotationMetadata",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "MergedAnnotations",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.core.type.StandardClassMetadata#isAbstract()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "determine if the class is abstract",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.core.type.StandardClassMetadata#isAbstract()",
      "head_type": "method",
      "relation": "have",
      "tail": "check if the class is abstract",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.core.type.StandardClassMetadata#isAbstract()",
      "head_type": "method",
      "relation": "have",
      "tail": "java\nimport org.springframework.core.type.StandardClassMetadata;\nimport java.lang.reflect.Modifier;\n\nclass ExampleClass {\n    public static void main(String[] args) {\n        StandardClassMetadata metadata = new StandardClassMetadata(MyClass.class);\n        boolean isAbstract = metadata.isAbstract();\n        System.out.println(\"Is the class abstract? \" + isAbstract);\n    }\n}\n\nclass MyClass {\n    // Example class\n}\n",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.core.type.StandardClassMetadata#isAbstract()",
      "head_type": "method",
      "relation": "have",
      "tail": "This method checks if the class represented by the metadata is abstract. It uses java.lang.reflect.Modifier to determine this.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.core.type.StandardClassMetadata#isAbstract()",
      "head_type": "method",
      "relation": "have",
      "tail": "This method follows the principle of reflection, providing a way to inspect the properties of a class dynamically.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.core.type.StandardClassMetadata#equals(Object)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "equality check",
      "tail_type": "apiFunction"
    },
    {
      "head": "equality check",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "null safety",
      "tail_type": "useConstraint"
    },
    {
      "head": "equality check",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "object comparison",
      "tail_type": "useScenario"
    },
    {
      "head": "equality check",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "org.springframework.core.type.StandardClassMetadata#equals(Object) sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.core.type.StandardClassMetadata#equals(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.core.type.StandardClassMetadata#equals(Object) related concept interpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.core.type.StandardClassMetadata#equals(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.core.type.StandardClassMetadata#equals(Object) design principle interpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.core.type.StandardClassMetadata#equals(Object)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.core.type.StandardClassMetadata",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.core.type.StandardMethodMetadata#getIntrospectedMethod()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "returnUnderlyingMethod",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.core.type.StandardMethodMetadata#getIntrospectedMethod()",
      "head_type": "method",
      "relation": "have",
      "tail": "returnUnderlyingMethodSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.core.type.StandardMethodMetadata",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.core.type.StandardMethodMetadata#getIntrospectedMethod()",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.core.type.StandardMethodMetadata#getIntrospectedMethod()",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.core.type.StandardMethodMetadata#getIntrospectedMethod()",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.objenesis.SpringObjenesis",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "newInstantiatorOf",
      "tail_type": "apiFunction"
    },
    {
      "head": "newInstantiatorOf",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "Class<T>",
      "tail_type": "useScenario"
    },
    {
      "head": "newInstantiatorOf",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "ObjectInstantiator<T>",
      "tail_type": "useSampleCode"
    },
    {
      "head": "newInstantiatorOf",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "ObjenesisException",
      "tail_type": "useConstraint"
    },
    {
      "head": "newInstantiatorOf",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "NoClassDefFoundError",
      "tail_type": "useConstraint"
    },
    {
      "head": "newInstantiatorOf",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "newInstantiatorOf",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.objenesis(SpringObjenesis",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.objenesis(SpringObjenesis",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#isWildcardChar(char)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "Check if a character is a wildcard character",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#isWildcardChar(char)",
      "head_type": "method",
      "relation": "have",
      "tail": "private boolean isWildcardChar(char c) { for (char candidate : WILDCARD_CHARS) { if (c == candidate) { return true; } } return false; }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#isWildcardChar(char)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.AntPathMatcher",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.ElementFactory#createElement(int)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "createElement",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ElementFactory#createElement(int)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "ElementInstantiationException",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ElementFactory#createElement(int)",
      "head_type": "method",
      "relation": "have",
      "tail": "Create the element for the supplied index.",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ElementFactory#createElement(int)",
      "head_type": "method",
      "relation": "have",
      "tail": "Returns the element object.",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ElementFactory#createElement(int)",
      "head_type": "method",
      "relation": "have",
      "tail": "Propagates any exception thrown by a target constructor as-is.",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ElementFactory#createElement(int)",
      "head_type": "method",
      "relation": "have",
      "tail": "public E createElement(int index) throws ElementInstantiationException {\n    // Implementation code here\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ElementFactory#createElement(int)",
      "head_type": "method",
      "relation": "have",
      "tail": "The createElement method is used to instantiate an element based on the provided index.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ElementFactory#createElement(int)",
      "head_type": "method",
      "relation": "have",
      "tail": "The design principle behind createElement is to encapsulate the element creation process, ensuring that any exceptions during instantiation are properly handled and propagated.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.backoff.ExponentialBackOff#checkMultiplier(double)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "checkMultiplier",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.backoff.ExponentialBackOff#checkMultiplier(double)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "multiplier >= 1",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.backoff.ExponentialBackOff#checkMultiplier(double)",
      "head_type": "method",
      "relation": "have",
      "tail": "Invalid multiplier. Should be greater than or equal to 1.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.backoff.ExponentialBackOff#checkMultiplier(double)",
      "head_type": "method",
      "relation": "have",
      "tail": "A multiplier of 1 is equivalent to a fixed interval.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.backoff.ExponentialBackOff#checkMultiplier(double)",
      "head_type": "method",
      "relation": "have",
      "tail": "private void checkMultiplier(double multiplier) {\n    Assert.isTrue(multiplier >= 1, () -> \"Invalid multiplier '\" + multiplier + \"'. Should be greater than \" + \"or equal to 1. A multiplier of 1 is equivalent to a fixed interval.\");\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.CollectionUtils#isEmpty(Map<?,? extends Object>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "check if a Map is empty",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.CollectionUtils#isEmpty(Map<?,? extends Object>)",
      "head_type": "method",
      "relation": "have",
      "tail": "Return true if the Map is null or empty, otherwise return false.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.CollectionUtils#isEmpty(Map<?,? extends Object>)",
      "head_type": "method",
      "relation": "have",
      "tail": "public static boolean isEmpty(@Nullable Map<?, ? extends @Nullable Object> map) { return (map == null || map.isEmpty()); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.CollectionUtils#isEmpty(Map<?,? extends Object>)",
      "head_type": "method",
      "relation": "have",
      "tail": "The method uses a simple null check and isEmpty check to determine if the Map is empty.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.CollectionUtils#findCommonElementType(Collection<?>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "find common element type",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.CollectionUtils#findCommonElementType(Collection<?>)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "check common element type in a collection",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.CollectionUtils#findCommonElementType(Collection<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "package org.springframework.util; import java.util.Collection; import org.springframework.lang.Nullable; public class CollectionUtils { public static @Nullable Class<?> findCommonElementType(Collection<?> collection) { if (isEmpty(collection)) { return null; } Class<?> candidate = null; for (Object val : collection) { if (val != null) { if (candidate == null) { candidate = val.getClass(); } else if (candidate != val.getClass()) { return null; } } } return candidate; } }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.CollectionUtils#findCommonElementType(Collection<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "The method aims to determine the common type of elements within a given collection. It iterates through the collection, checking the class of each element. If all elements share the same class, that class is returned. If elements have different classes or the collection is empty, the method returns null. This is useful in scenarios where type consistency of elements in a collection is required for further processing or validation.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.CollectionUtils#findCommonElementType(Collection<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "The design principle behind this method is to provide a utility that helps in determining the consistency of element types within a collection. This is crucial for ensuring type safety and optimizing performance in applications that rely on collections with homogeneous element types. The method is designed to be efficient and straightforward, iterating through the collection only once and immediately returning when a type mismatch is detected.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.CollectionUtils#toIterator(Enumeration<E>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "adapt Enumeration to Iterator",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.CollectionUtils#toIterator(Enumeration<E>)",
      "head_type": "method",
      "relation": "have",
      "tail": "Adapt an Enumeration to an Iterator",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.CollectionUtils#toIterator(Enumeration<E>)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method converts an Enumeration to an Iterator, facilitating the use of Enumeration objects in contexts that expect Iterators.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.CollectionUtils#toIterator(Enumeration<E>)",
      "head_type": "method",
      "relation": "have",
      "tail": "package com.adaptation.example;\n\nimport java.util.*;\n\npublic class EnumerationToIteratorExample {\n    public static void main(String[] args) {\n        Enumeration<String> enumeration = Collections.enumeration(Arrays.asList(\"apple\", \"banana\", \"cherry\"));\n        Iterator<String> iterator = org.springframework.util.CollectionUtils.toIterator(enumeration);\n        while (iterator.hasNext()) {\n            System.out.println(iterator.next());\n        }\n    }\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.CollectionUtils#toMultiValueMap(Map<K,List<V>>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "adapt a Map<K, List<V>> to an MultiValueMap<K, V>",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.CollectionUtils#toMultiValueMap(Map<K,List<V>>)",
      "head_type": "method",
      "relation": "have",
      "tail": "adapt a Map<K, List<V>> to an MultiValueMap<K, V>",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.CollectionUtils#toMultiValueMap(Map<K,List<V>>)",
      "head_type": "method",
      "relation": "have",
      "tail": "Adapting a Map<K, List<V>> to an MultiValueMap<K, V> allows for easier manipulation of multi-valued keys.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.CollectionUtils#toMultiValueMap(Map<K,List<V>>)",
      "head_type": "method",
      "relation": "have",
      "tail": "The design principle behind adapting a Map<K, List<V>> to an MultiValueMap<K, V> is to provide a more convenient and expressive API for handling multi-valued keys.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.CollectionUtils#toMultiValueMap(Map<K,List<V>>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "MultiValueMapAdapter",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.CommonsLogWriter#flush()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "flushing logs",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.CommonsLogWriter#flush()",
      "head_type": "method",
      "relation": "have",
      "tail": "used to ensure that all pending log messages are written out to the destination",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.CommonsLogWriter#flush()",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle is to provide a simple abstraction over the logging framework",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.CommonsLogWriter#flush()",
      "head_type": "method",
      "relation": "have",
      "tail": "package org.springframework.util; public class CommonsLogWriter { @Override public void flush() { // implementation code } }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ConcurrentLruCache#sizeLimit()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "return maximum number of entries in the cache",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ConcurrentLruCache#sizeLimit()",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "deprecated in favor of capacity() as of 6.0",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ConcurrentLruCache#sizeLimit()",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ConcurrentLruCache#sizeLimit()",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ConcurrentLruCache#sizeLimit()",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ConcurrentReferenceHashMap#replace(K,V,V)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "replace",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ConcurrentReferenceHashMap#replace(K,V,V)",
      "head_type": "method",
      "relation": "have",
      "tail": "replace sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "replace sample code",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "package com.healthMgr.common.email; import java.xxxx; public class OneClass { // specific code }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.EntrySet#remove(Object)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "removeElement",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.EntrySet#remove(Object)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "elementMustBeEntryInstance",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.EntrySet#remove(Object)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "removingEntryFromMap",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.EntrySet#remove(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.EntrySet",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.EntrySet#remove(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.EntrySet#remove(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.EntrySet#remove(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.EntrySet",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.EntrySet#remove(Object)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.FilteredCollection#clear()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "clearing a collection",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.FilteredCollection#clear()",
      "head_type": "method",
      "relation": "have",
      "tail": "Clears the underlying delegate collection",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.FilteredCollection#clear()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.FilteredCollection",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.function.SingletonSupplier#ofNullable(T)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "building a SingletonSupplier with a given singleton instance",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.function.SingletonSupplier#ofNullable(T)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "instance can be potentially null",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.function.SingletonSupplier#ofNullable(T)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "supplying a singleton instance",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.function.SingletonSupplier#ofNullable(T)",
      "head_type": "method",
      "relation": "have",
      "tail": "public static <T> SingletonSupplier<T> ofNullable(@Nullable T instance) { return (instance != null ? new SingletonSupplier<>(instance) : null); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.function.SingletonSupplier#ofNullable(T)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.function.SingletonSupplier#ofNullable(T)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.function.SingletonSupplier#ofNullable(T)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.function.SingletonSupplier",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.function.ThrowingConsumer#acceptWithException(T)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "performing an operation with exception handling",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.function.ThrowingConsumer#acceptWithException(T)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "possibility of throwing a checked exception",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.function.ThrowingConsumer#acceptWithException(T)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "scenarios requiring exception handling in functional interfaces",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.function.ThrowingConsumer#acceptWithException(T)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code demonstrating exception handling in functional interfaces",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.function.ThrowingConsumer#acceptWithException(T)",
      "head_type": "method",
      "relation": "have",
      "tail": "related concept interpretation for exception handling in functional interfaces",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.function.ThrowingConsumer#acceptWithException(T)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle interpretation for exception handling in functional interfaces",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.function.ThrowingConsumer#acceptWithException(T)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.function.ThrowingConsumer",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.function.ThrowingSupplier#throwing(BiFunction<String,Exception,RuntimeException>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "exception wrapping",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.function.ThrowingSupplier#throwing(BiFunction<String,Exception,RuntimeException>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "exceptionWrapper must not be null",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.function.ThrowingSupplier#throwing(BiFunction<String,Exception,RuntimeException>)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "handling checked exceptions in functional interfaces",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.function.ThrowingSupplier#throwing(BiFunction<String,Exception,RuntimeException>)",
      "head_type": "method",
      "relation": "have",
      "tail": "return a new ThrowingSupplier instance",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.function.ThrowingSupplier#throwing(BiFunction<String,Exception,RuntimeException>)",
      "head_type": "method",
      "relation": "have",
      "tail": "related concept interpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.function.ThrowingSupplier#throwing(BiFunction<String,Exception,RuntimeException>)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle interpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.function.ThrowingSupplier#throwing(BiFunction<String,Exception,RuntimeException>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.function.ThrowingSupplier",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.InstanceFilter#match(T,Collection<? extends T>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "match instance with candidates",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.InstanceFilter#match(T,Collection<? extends T>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "candidates collection cannot be null",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.InstanceFilter#match(T,Collection<? extends T>)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "check if an instance matches any candidate in a list",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.InstanceFilter#match(T,Collection<? extends T>)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for matching instance with candidates",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.InstanceFilter#match(T,Collection<? extends T>)",
      "head_type": "method",
      "relation": "have",
      "tail": "related concept interpretation for instance matching",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.InstanceFilter#match(T,Collection<? extends T>)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle interpretation for instance matching",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.InstanceFilter",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.InstanceFilter#match(T,Collection<? extends T>)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.LinkedCaseInsensitiveMap",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "caseInsensitiveKeyStorage",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.LinkedCaseInsensitiveMap",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "localeBasedKeyConversion",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.LinkedCaseInsensitiveMap",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "linkedHashMapBasedStorage",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.LinkedCaseInsensitiveMap",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "orderPreservation",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.LinkedCaseInsensitiveMap",
      "head_type": "class",
      "relation": "constrained_by",
      "tail": "nullKeyUnsupported",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.LinkedCaseInsensitiveMap",
      "head_type": "class",
      "relation": "applied_to",
      "tail": "resultsTableKeyAccess",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.LinkedCaseInsensitiveMap",
      "head_type": "class",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.LinkedCaseInsensitiveMap",
      "head_type": "class",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "caseInsensitiveKeyStorage",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "localeBasedKeyConversion",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "linkedHashMapBasedStorage",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "orderPreservation",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "nullKeyUnsupported",
      "head_type": "useConstraint",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "resultsTableKeyAccess",
      "head_type": "useScenario",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.LinkedCaseInsensitiveMap#getLocale()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "case-insensitive key conversion",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.LinkedCaseInsensitiveMap#getLocale()",
      "head_type": "method",
      "relation": "have",
      "tail": "Return the locale used by this `LinkedCaseInsensitiveMap`.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.LinkedCaseInsensitiveMap#getLocale()",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is used to retrieve the locale that is set for the `LinkedCaseInsensitiveMap`. The locale is essential for the map to perform case-insensitive key conversion, which means that keys are treated as equal regardless of their case (e.g., 'key', 'Key', and 'KEY' would be considered the same).",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.LinkedCaseInsensitiveMap#getLocale()",
      "head_type": "method",
      "relation": "have",
      "tail": "package com.example.demo;\n\nimport java.util.Locale;\n\npublic class Main {\n    public static void main(String[] args) {\n        LinkedCaseInsensitiveMap<String> map = new LinkedCaseInsensitiveMap<>(Locale.US);\n        map.put(\"Key\", \"Value1\");\n        map.put(\"key\", \"Value2\");\n        System.out.println(map.get(\"KEY\")); // Output: Value2\n        System.out.println(map.getLocale()); // Output: en_US\n    }\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.LinkedCaseInsensitiveMap#getLocale()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.LinkedCaseInsensitiveMap",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.Values#forEach(Consumer<? super V>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "forEach",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.Values#forEach(Consumer<? super V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "Iterates over each value and applies the given action.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.Values#forEach(Consumer<? super V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "public void forEach(Consumer<? super V> action) { this.delegate.forEach(action); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.Values#forEach(Consumer<? super V>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.Values",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.LinkedMultiValueMap#clone()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "create a regular copy of this Map",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.LinkedMultiValueMap#clone()",
      "head_type": "method",
      "relation": "have",
      "tail": "a shallow copy of this Map, reusing this Map's value-holding List entries",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.LinkedMultiValueMap#clone()",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "standard Map.put semantics",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.LinkedMultiValueMap#clone()",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "Map.put",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.LinkedMultiValueMap#clone()",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "Map.putAll",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.LinkedMultiValueMap#clone()",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "LinkedMultiValueMap#LinkedMultiValueMap",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.LinkedMultiValueMap#clone()",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "deepCopy",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.LinkedMultiValueMap#clone()",
      "head_type": "method",
      "relation": "have",
      "tail": "Create a regular copy of this Map",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.LinkedMultiValueMap#clone()",
      "head_type": "method",
      "relation": "have",
      "tail": "Create a regular copy of this Map",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.LinkedMultiValueMap#clone()",
      "head_type": "method",
      "relation": "have",
      "tail": "package com.healthMgr.common.email; import java.util.List; import java.util.Map; import org.springframework.util.LinkedMultiValueMap; public class OneClass { public static void main(String[] args) { LinkedMultiValueMap<String, List<String>> map = new LinkedMultiValueMap<>(); map.add(\"key1\", List.of(\"value1\")); map.add(\"key2\", List.of(\"value2\")); LinkedMultiValueMap<String, List<String>> clonedMap = new LinkedMultiValueMap<>(map); System.out.println(\"Original Map: \" + map); System.out.println(\"Cloned Map: \" + clonedMap); } }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.MethodInvoker#getTargetClass()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getTargetClass",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MethodInvoker#getTargetClass()",
      "head_type": "method",
      "relation": "have",
      "tail": "Return the target class on which to call the target method.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.MethodInvoker",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.MethodInvoker#getTargetClass()",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.MethodInvoker#setTargetMethod(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "set the name of the method to be invoked",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MethodInvoker#setTargetMethod(String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "depending on a target object being set",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.MethodInvoker#setTargetMethod(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "Refers to either a static method or a non-static method",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.MethodInvoker#setTargetMethod(String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.MethodInvoker",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.MethodInvoker#setTargetMethod(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "public void setTargetMethod(@Nullable String targetMethod) {    this.targetMethod = targetMethod;}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.MimeType#isQuotedString(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "check if a string is quoted",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MimeType#isQuotedString(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "private boolean isQuotedString(String s) {\n    if (s.length() < 2) {\n        return false;\n    }\n    return ((s.startsWith(\"\\\"\") && s.endsWith(\"\\\"\")) || (s.startsWith(\"'\") && s.endsWith(\"'\")));\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.MultiToSingleValueMapAdapter#adaptValue(V)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "adapt a single value to a list",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MultiToSingleValueMapAdapter#adaptValue(V)",
      "head_type": "method",
      "relation": "have",
      "tail": "if the input value is not null, return a singleton list containing the value; otherwise, return null",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.MultiToSingleValueMapAdapter#adaptValue(V)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.MultiToSingleValueMapAdapter",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.MultiValueMapAdapter#get(Object)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "retrieve values associated with a key",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MultiValueMapAdapter#get(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is used to fetch the list of values associated with a specified key from the MultiValueMapAdapter.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.MultiValueMapAdapter#get(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "The method ensures that if the key exists, all corresponding values are returned in a list. If the key does not exist, it returns null.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.MultiValueMapAdapter#get(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "package com.example.demo;\n\nimport java.util.List;\nimport java.util.Map;\nimport org.springframework.util.MultiValueMapAdapter;\n\npublic class MultiValueMapAdapterExample {\n    public static void main(String[] args) {\n        MultiValueMapAdapter<String, String> mapAdapter = new MultiValueMapAdapter<>();\n        mapAdapter.add(\"key1\", \"value1\");\n        mapAdapter.add(\"key1\", \"value2\");\n        mapAdapter.add(\"key2\", \"value3\");\n\n        List<String> valuesForKey1 = mapAdapter.get(\"key1\");\n        System.out.println(\"Values for 'key1': \" + valuesForKey1);\n    }\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ObjectUtils#isCompatibleWithThrowsClause(Throwable,Class<?>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "exception compatibility checking",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ObjectUtils#isCompatibleWithThrowsClause(Throwable,Class<?>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "exception must be checked",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ObjectUtils#isCompatibleWithThrowsClause(Throwable,Class<?>)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "handling exceptions in method declarations",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ObjectUtils#isCompatibleWithThrowsClause(Throwable,Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for exception compatibility checking",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ObjectUtils#isCompatibleWithThrowsClause(Throwable,Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "interpretation of checked exceptions",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ObjectUtils#isCompatibleWithThrowsClause(Throwable,Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principles for robust exception handling",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ObjectUtils#isCompatibleWithThrowsClause(Throwable,Class<?>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.core.SimpleAliasRegistryTests",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeHashCode(Object)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "nullSafeHashCode",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeHashCode(Object)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "null input returns 0",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeHashCode(Object)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "hash code generation for objects and arrays",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeHashCode(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for nullSafeHashCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeHashCode(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "interpretation of related concepts for nullSafeHashCode",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeHashCode(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle interpretation for nullSafeHashCode",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeHashCode(Object)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "java.util.Arrays",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeHashCode(Object)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "java.lang.Object",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeToString(Object[])",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "String representation of array",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeToString(Object[])",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "array must not be null",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeToString(Object[])",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "convert array to string",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeToString(Object[])",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for array to string conversion",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeToString(Object[])",
      "head_type": "method",
      "relation": "have",
      "tail": "related concept interpretation for array to string conversion",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeToString(Object[])",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle interpretation for array to string conversion",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ObjectUtils",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.ObjectUtils#nullSafeToString(Object[])",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.SimplePlaceholderPart",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "placeholder resolution",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.SimplePlaceholderPart",
      "head_type": "class",
      "relation": "have",
      "tail": "A Part implementation that represents a single placeholder with a hard-coded fallback.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.SimplePlaceholderPart",
      "head_type": "class",
      "relation": "have",
      "tail": "The class provides a way to resolve placeholders within a string, with support for a fallback value if the placeholder cannot be resolved.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.SimplePlaceholderPart",
      "head_type": "class",
      "relation": "have",
      "tail": "public SimplePlaceholderPart(String text, String key, @Nullable String fallback) { ... }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.PropertyPlaceholderHelper#replacePlaceholders(String,Properties)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "replace placeholders",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.PropertyPlaceholderHelper#replacePlaceholders(String,Properties)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "properties must not be null",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.PropertyPlaceholderHelper#replacePlaceholders(String,Properties)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "replace placeholders in a string with properties",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.PropertyPlaceholderHelper#replacePlaceholders(String,Properties)",
      "head_type": "method",
      "relation": "have",
      "tail": "replace placeholders in a string with properties sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.PropertyPlaceholderHelper#replacePlaceholders(String,Properties)",
      "head_type": "method",
      "relation": "have",
      "tail": "related concept interpretation for replace placeholders",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.PropertyPlaceholderHelper#replacePlaceholders(String,Properties)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle interpretation for replace placeholders",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "replace placeholders in a string with properties sample code",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "complete sample code for replace placeholders",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#findMethod(Class<?>,String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "findMethod",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#findMethod(Class<?>,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "findMethodSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "findMethodSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "findMethodSampleCodeContent",
      "tail_type": "codeContent"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#findMethod(Class<?>,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "findMethodRelatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "findMethodRelatedConceptInterpretation",
      "head_type": "relatedConceptInterpretation",
      "relation": "have",
      "tail": "findMethodRelatedConceptInterpretationContent",
      "tail_type": "interpretationContent"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#findMethod(Class<?>,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "findMethodDesignPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "findMethodDesignPrincipleInterpretation",
      "head_type": "designPrincipleInterpretation",
      "relation": "have",
      "tail": "findMethodDesignPrincipleInterpretationContent",
      "tail_type": "interpretationContent"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#getUniqueDeclaredMethods(Class<?>,MethodFilter)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getUniqueDeclaredMethods",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#getUniqueDeclaredMethods(Class<?>,MethodFilter)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "IllegalStateException if introspection fails",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#getUniqueDeclaredMethods(Class<?>,MethodFilter)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "introspection of leaf class and superclasses for unique methods",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#getUniqueDeclaredMethods(Class<?>,MethodFilter)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for getUniqueDeclaredMethods",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#getUniqueDeclaredMethods(Class<?>,MethodFilter)",
      "head_type": "method",
      "relation": "have",
      "tail": "related concept interpretation for unique method retrieval",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#getUniqueDeclaredMethods(Class<?>,MethodFilter)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle interpretation for unique method retrieval",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "getUniqueDeclaredMethods",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "introspection of leaf class and superclasses for unique methods",
      "tail_type": "useScenario"
    },
    {
      "head": "introspection of leaf class and superclasses for unique methods",
      "head_type": "useScenario",
      "relation": "have",
      "tail": "sample code for getUniqueDeclaredMethods",
      "tail_type": "useSampleCode"
    },
    {
      "head": "introspection of leaf class and superclasses for unique methods",
      "head_type": "useScenario",
      "relation": "have",
      "tail": "related concept interpretation for unique method retrieval",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "introspection of leaf class and superclasses for unique methods",
      "head_type": "useScenario",
      "relation": "have",
      "tail": "design principle interpretation for unique method retrieval",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ResourceUtils#getFile(URI)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "Resolving a resource URI to a file",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ResourceUtils#getFile(URI)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "FileNotFoundException if the URL cannot be resolved to a file",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ResourceUtils#getFile(URI)",
      "head_type": "method",
      "relation": "have",
      "tail": "Resolving a resource URI to a file in the file system",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ResourceUtils#getFile(URI)",
      "head_type": "method",
      "relation": "have",
      "tail": "public static File getFile(URI resourceUri) throws FileNotFoundException { return getFile(resourceUri, \"URI\"); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ResourceUtils#getFile(URI)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is used to resolve a resource URI to a java.io.File object, which represents a file in the file system.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ResourceUtils#getFile(URI)",
      "head_type": "method",
      "relation": "have",
      "tail": "The design principle behind this method is to provide a straightforward way to convert a resource URI into a File object, simplifying file operations within the application.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ResourceUtils",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.ResourceUtils#getFile(URI)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.ResourceUtils#toURI(URL)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "create URI instance",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ResourceUtils#toURI(URL)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "URL must be a valid URI",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ResourceUtils#toURI(URL)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "converting URL to URI",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ResourceUtils#toURI(URL)",
      "head_type": "method",
      "relation": "have",
      "tail": "java.net.URL#toURI()",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ResourceUtils#toURI(URL)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ResourceUtils#toURI(URL)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ResourceUtils#toURI(URL)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "java.net.URL",
      "tail_type": "class"
    },
    {
      "head": "create URI instance",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "java.net.URL#toURI()",
      "tail_type": "useSampleCode"
    },
    {
      "head": "create URI instance",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "create URI instance",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.StopWatch",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "stopwatch",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StopWatch",
      "head_type": "class",
      "relation": "have",
      "tail": "StopWatch()",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.StopWatch",
      "head_type": "class",
      "relation": "have",
      "tail": "StopWatch(String id)",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.StopWatch",
      "head_type": "class",
      "relation": "have",
      "tail": "getId()",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.StopWatch",
      "head_type": "class",
      "relation": "have",
      "tail": "setKeepTaskList(boolean keepTaskList)",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.StopWatch",
      "head_type": "class",
      "relation": "have",
      "tail": "start()",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.StopWatch",
      "head_type": "class",
      "relation": "have",
      "tail": "start(String taskName)",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.StopWatch",
      "head_type": "class",
      "relation": "have",
      "tail": "stop()",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.StopWatch",
      "head_type": "class",
      "relation": "have",
      "tail": "isRunning()",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.StopWatch",
      "head_type": "class",
      "relation": "have",
      "tail": "currentTaskName()",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.StopWatch",
      "head_type": "class",
      "relation": "have",
      "tail": "lastTaskInfo()",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.StopWatch",
      "head_type": "class",
      "relation": "have",
      "tail": "getLastTaskInfo()",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.StopWatch",
      "head_type": "class",
      "relation": "have",
      "tail": "getLastTaskName()",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.StopWatch",
      "head_type": "class",
      "relation": "have",
      "tail": "getLastTaskTimeNanos()",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.StopWatch",
      "head_type": "class",
      "relation": "have",
      "tail": "getLastTaskTimeMillis()",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.StopWatch",
      "head_type": "class",
      "relation": "have",
      "tail": "getTaskInfo()",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.StopWatch",
      "head_type": "class",
      "relation": "have",
      "tail": "getTaskCount()",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.StopWatch",
      "head_type": "class",
      "relation": "have",
      "tail": "getTotalTimeNanos()",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.StopWatch",
      "head_type": "class",
      "relation": "have",
      "tail": "getTotalTimeMillis()",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.StopWatch",
      "head_type": "class",
      "relation": "have",
      "tail": "getTotalTimeSeconds()",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.StopWatch",
      "head_type": "class",
      "relation": "have",
      "tail": "getTotalTime(TimeUnit timeUnit)",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.StopWatch",
      "head_type": "class",
      "relation": "have",
      "tail": "prettyPrint()",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.StopWatch",
      "head_type": "class",
      "relation": "have",
      "tail": "prettyPrint(TimeUnit timeUnit)",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.StopWatch",
      "head_type": "class",
      "relation": "have",
      "tail": "shortSummary()",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.StopWatch",
      "head_type": "class",
      "relation": "have",
      "tail": "toString()",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.StopWatch",
      "head_type": "class",
      "relation": "have",
      "tail": "TaskInfo",
      "tail_type": "class"
    },
    {
      "head": "TaskInfo",
      "head_type": "class",
      "relation": "have",
      "tail": "TaskInfo(String taskName, long timeNanos)",
      "tail_type": "useSampleCode"
    },
    {
      "head": "TaskInfo",
      "head_type": "class",
      "relation": "have",
      "tail": "getTaskName()",
      "tail_type": "useSampleCode"
    },
    {
      "head": "TaskInfo",
      "head_type": "class",
      "relation": "have",
      "tail": "getTimeNanos()",
      "tail_type": "useSampleCode"
    },
    {
      "head": "TaskInfo",
      "head_type": "class",
      "relation": "have",
      "tail": "getTimeMillis()",
      "tail_type": "useSampleCode"
    },
    {
      "head": "TaskInfo",
      "head_type": "class",
      "relation": "have",
      "tail": "getTimeSeconds()",
      "tail_type": "useSampleCode"
    },
    {
      "head": "TaskInfo",
      "head_type": "class",
      "relation": "have",
      "tail": "getTime(TimeUnit timeUnit)",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.StopWatch",
      "head_type": "class",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.StopWatch",
      "head_type": "class",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.NonClosingInputStream#close()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "close stream",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.NonClosingInputStream#close()",
      "head_type": "method",
      "relation": "have",
      "tail": "This method closes the input stream and releases any system resources associated with it.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.NonClosingInputStream#close()",
      "head_type": "method",
      "relation": "have",
      "tail": "The method follows the principle of resource management, ensuring that resources are properly released even if not directly closed by the client.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.NonClosingInputStream#close()",
      "head_type": "method",
      "relation": "have",
      "tail": "package com.example;\nimport java.io NonClosingInputStream;\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        NonClosingInputStream ncis = new NonClosingInputStream(new FileInputStream(\"file.txt\"));\n        ncis.close();\n    }\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.StringUtils#trimAllWhitespace(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "trim all whitespace",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils#trimAllWhitespace(String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "input string must not be null",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.StringUtils#trimAllWhitespace(String)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "removing whitespace from a string",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.StringUtils#trimAllWhitespace(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for trimming whitespace",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.StringUtils#trimAllWhitespace(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "related concept interpretation for trimming whitespace",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.StringUtils#trimAllWhitespace(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle interpretation for trimming whitespace",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.StringUtils#trimAllWhitespace(String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "java.lang.Character#isWhitespace",
      "tail_type": "method"
    },
    {
      "head": "trim all whitespace",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "sample code for trimming whitespace",
      "tail_type": "useSampleCode"
    },
    {
      "head": "trim all whitespace",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "related concept interpretation for trimming whitespace",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "trim all whitespace",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "design principle interpretation for trimming whitespace",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#replaceAll(BiFunction<? super K,? super List<V>,? extends List<V>>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "replaceAll",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#replaceAll(BiFunction<? super K,? super List<V>,? extends List<V>>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "UnsupportedOperationException",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#replaceAll(BiFunction<? super K,? super List<V>,? extends List<V>>)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.UnmodifiableMultiValueMap",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#replaceAll(BiFunction<? super K,? super List<V>,? extends List<V>>)",
      "head_type": "method",
      "relation": "have",
      "tail": "replaceAll(BiFunction<? super K,? super List<V>,? extends List<V>>)",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#replaceAll(BiFunction<? super K,? super List<V>,? extends List<V>>)",
      "head_type": "method",
      "relation": "have",
      "tail": "replaceAll(BiFunction<? super K,? super List<V>,? extends List<V>>) is a method that throws an UnsupportedOperationException when called.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#replaceAll(BiFunction<? super K,? super List<V>,? extends List<V>>)",
      "head_type": "method",
      "relation": "have",
      "tail": "The design principle behind replaceAll(BiFunction<? super K,? super List<V>,? extends List<V>>) is to enforce immutability by preventing modifications to the map.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySpliterator#hasCharacteristics(int)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "characteristics checking",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySpliterator#hasCharacteristics(int)",
      "head_type": "method",
      "relation": "have",
      "tail": "delegates characteristics checking to the delegate object",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySpliterator#hasCharacteristics(int)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.UnmodifiableEntrySpliterator",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySpliterator",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "characteristics checking",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySpliterator",
      "head_type": "class",
      "relation": "have",
      "tail": "delegates characteristics checking to the delegate object",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueCollection#size()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "size determination",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueCollection#size()",
      "head_type": "method",
      "relation": "have",
      "tail": "Delegation pattern used for size determination",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueCollection#size()",
      "head_type": "method",
      "relation": "have",
      "tail": "public int size() { return this.delegate.size(); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueCollection#size()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.UnmodifiableValueCollection",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueCollection#remove(Object)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "org.springframework.util.UnmodifiableValueCollection#remove(Object)",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueCollection#remove(Object)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "UnsupportedOperationException",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueCollection#remove(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "public boolean remove(Object o) { throw new UnsupportedOperationException(); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueCollection#remove(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.UnmodifiableValueCollection#remove(Object)",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueCollection#remove(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.UnmodifiableValueCollection#remove(Object)",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueSpliterator",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getComparator()",
      "tail_type": "apiFunction"
    },
    {
      "head": "getComparator()",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "Returns the comparator associated with the delegate.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "getComparator()",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "public Comparator<? super List<T>> getComparator() { return this.delegate.getComparator(); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "getComparator()",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "Delegates the call to the comparator of the delegate object.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueSpliterator",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.UnmodifiableValueSpliterator",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#endElement(String,String,String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "endElementInternal",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#endElement(String,String,String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "removeNamespaceMapping",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#endElement(String,String,String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "XMLStreamException",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#endElement(String,String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#endElement(String,String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#endElement(String,String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLReader",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getEntityResolver()",
      "tail_type": "apiFunction"
    },
    {
      "head": "getEntityResolver()",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "EntityResolver",
      "tail_type": "class"
    },
    {
      "head": "getEntityResolver()",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "This method is used to obtain the EntityResolver.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "getEntityResolver()",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "This method is designed to follow the principle of encapsulation, providing a way to access the EntityResolver.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "getEntityResolver()",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "public EntityResolver getEntityResolver() {\n    return this.entityResolver;\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLStreamReader#hasText()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "check if the current event has text content",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLStreamReader#hasText()",
      "head_type": "method",
      "relation": "have",
      "tail": "int eventType = getEventType(); return (eventType == XMLStreamConstants.SPACE || eventType == XMLStreamConstants.CHARACTERS || eventType == XMLStreamConstants.COMMENT || eventType == XMLStreamConstants.CDATA || eventType == XMLStreamConstants.ENTITY_REFERENCE);",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLStreamReader#hasText()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.AbstractXMLStreamReader",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLStreamReader#hasText()",
      "head_type": "method",
      "relation": "have",
      "tail": "This method checks if the current XML event being processed by the XMLStreamReader has text content. It does so by obtaining the event type and comparing it against various XMLStreamConstants that represent text-containing events such as SPACE, CHARACTERS, COMMENT, CDATA, and ENTITY_REFERENCE.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLStreamReader#hasText()",
      "head_type": "method",
      "relation": "have",
      "tail": "The design principle behind this method is to provide a convenient way to determine if the current XML event contains textual content that may be relevant to the application. This is important for processing XML documents where text content needs to be handled differently from other types of events.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.DomUtils#getChildElements(Element)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "retrieve all child elements",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.DomUtils#getChildElements(Element)",
      "head_type": "method",
      "relation": "have",
      "tail": "a List of child org.w3c.dom.Element instances",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.DomUtils#getChildElements(Element)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.DomUtils",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.DomUtils",
      "head_type": "class",
      "relation": "have",
      "tail": "retrieve all child elements",
      "tail_type": "apiFunction"
    },
    {
      "head": "retrieve all child elements",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "a List of child org.w3c.dom.Element instances",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.DomUtils",
      "head_type": "class",
      "relation": "have",
      "tail": "a List of child org.w3c.dom.Element instances",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.DomUtils#getChildElements(Element)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.DomUtils#getChildElements(Element)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.DomUtils",
      "head_type": "class",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.DomUtils",
      "head_type": "class",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.ListBasedXMLEventReader#close()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "close XMLEventReader",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.ListBasedXMLEventReader#close()",
      "head_type": "method",
      "relation": "have",
      "tail": "Clears the internal list of events",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.ListBasedXMLEventReader#close()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.XMLEventReader",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.ListBasedXMLEventReader#close()",
      "head_type": "method",
      "relation": "designPrincipleInterpretation",
      "tail": "Ensure resources are freed properly by clearing internal states",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.SimpleSaxErrorHandler#fatalError(SAXParseException)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "handle fatal error",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.SimpleSaxErrorHandler#fatalError(SAXParseException)",
      "head_type": "method",
      "relation": "have",
      "tail": "throw SAXParseException",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.SimpleSaxErrorHandler#fatalError(SAXParseException)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.SimpleSaxErrorHandler",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.SimpleSaxErrorHandler",
      "head_type": "class",
      "relation": "have",
      "tail": "related to error handling in XML parsing",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.SimpleSaxErrorHandler",
      "head_type": "class",
      "relation": "have",
      "tail": "design principle of robust error handling",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.LocatorLocationAdapter",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getLineNumber",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.LocatorLocationAdapter",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getColumnNumber",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.LocatorLocationAdapter",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getCharacterOffset",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.LocatorLocationAdapter",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getPublicId",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.LocatorLocationAdapter",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getSystemId",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.LocatorLocationAdapter",
      "head_type": "class",
      "relation": "have",
      "tail": "LocatorLocationAdapter(Locator locator)",
      "tail_type": "useSampleCode"
    },
    {
      "head": "LocatorLocationAdapter(Locator locator)",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "tail": "Locator",
      "tail_type": "class"
    },
    {
      "head": "getLineNumber",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "Locator",
      "tail_type": "class"
    },
    {
      "head": "getColumnNumber",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "Locator",
      "tail_type": "class"
    },
    {
      "head": "getPublicId",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "Locator",
      "tail_type": "class"
    },
    {
      "head": "getSystemId",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "Locator",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.LocatorLocationAdapter",
      "head_type": "class",
      "relation": "have",
      "tail": "LocatorLocationAdapter is a class that adapts a SAX Locator to the Location interface.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.LocatorLocationAdapter",
      "head_type": "class",
      "relation": "have",
      "tail": "The class is designed to wrap a SAX Locator, providing a bridge between SAX and other XML processing APIs that require Location information.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.TransformerUtils#enableIndenting(Transformer)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "enable indenting",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.TransformerUtils#enableIndenting(Transformer)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "the underlying XSLT engine is Xalan",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.xml.TransformerUtils#enableIndenting(Transformer)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "the supplied Transformer",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.xml.TransformerUtils#enableIndenting(Transformer)",
      "head_type": "method",
      "relation": "have",
      "tail": "the supplied Transformer",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.xml.TransformerUtils#enableIndenting(Transformer)",
      "head_type": "method",
      "relation": "have",
      "tail": "Enable indenting for the supplied Transformer",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.TransformerUtils#enableIndenting(Transformer)",
      "head_type": "method",
      "relation": "have",
      "tail": "TransformerUtils is designed to provide utility methods for working with Transformers",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.TransformerUtils#enableIndenting(Transformer)",
      "head_type": "method",
      "relation": "have",
      "tail": "package com.example.xml.util;\n\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.stream.StreamResult;\nimport javax.xml.transform.stream.StreamSource;\n\npublic class TransformerUtilsExample {\n    public static void main(String[] args) throws Exception {\n        TransformerFactory factory = TransformerFactory.newInstance();\n        Transformer transformer = factory.newTransformer(new StreamSource(\"path/to/xslt/file.xslt\"));\n        TransformerUtils.enableIndenting(transformer);\n        transformer.transform(new StreamSource(\"path/to/xml/file.xml\"), new StreamResult(System.out));\n    }\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.TransformerUtils#enableIndenting(Transformer)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "javax.xml.transform.Transformer",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.TransformerUtils#enableIndenting(Transformer)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.TransformerUtils",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamReader",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getEventType()",
      "tail_type": "apiFunction"
    },
    {
      "head": "getEventType()",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.XMLEventStreamReader",
      "tail_type": "class"
    },
    {
      "head": "getEventType()",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter#writeStartElement(String,String,String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "writeStartElement",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter#writeStartElement(String,String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "writeStartElementSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "writeStartElementSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "writeStartElementSampleCodeContent",
      "tail_type": "content"
    },
    {
      "head": "org.springframework.core.task.VirtualThreadDelegate",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "virtualThreadFactory",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.core.task.VirtualThreadDelegate",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "newVirtualThread",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.core.task.VirtualThreadDelegate",
      "head_type": "class",
      "relation": "have",
      "tail": "Internal delegate for virtual thread handling on JDK 21",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.core.task.VirtualThreadDelegate",
      "head_type": "class",
      "relation": "have",
      "tail": "This is the actual version compiled against JDK 21",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.core.task.VirtualThreadDelegate",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "VirtualThreadTaskExecutor",
      "tail_type": "class"
    },
    {
      "head": "virtualThreadFactory",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "private final Thread.Builder threadBuilder = Thread.ofVirtual();\npublic ThreadFactory virtualThreadFactory() {\n    return this.threadBuilder.factory();\n}\npublic ThreadFactory virtualThreadFactory(String threadNamePrefix) {\n    return this.threadBuilder.name(threadNamePrefix, 0).factory();\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "newVirtualThread",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "public Thread newVirtualThread(String name, Runnable task) {\n    return this.threadBuilder.name(name).unstarted(task);\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#forMemberWhenPublicClassWithPrivateField()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "Access Control for Member",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#forMemberWhenPublicClassWithPrivateField()",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.aot.generate.AccessControlTests#forMemberWhenPublicClassWithPrivateField() Sample Code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#forMemberWhenPublicClassWithPrivateField() Sample Code",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "Complete Example for Access Control for Member",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "Access Control for Member",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "org.springframework.aot.generate.AccessControlTests#forMemberWhenPublicClassWithPrivateField() Sample Code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "Access Control for Member",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "Complete Example for Access Control for Member",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithNonMatchingDeclaringClass()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "toInvokeCodeBlockWithNonMatchingDeclaringClass",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithNonMatchingDeclaringClass()",
      "head_type": "method",
      "relation": "have",
      "tail": "void toInvokeCodeBlockWithNonMatchingDeclaringClass() { MethodSpec method = createTestMethod(\"methodName\", new TypeName[0]); MethodReference methodReference = new DefaultMethodReference(method, TEST_CLASS_NAME); assertThat(methodReference.toInvokeCodeBlock(ArgumentCodeGenerator.none(), INITIALIZER_CLASS_NAME)).isEqualTo(CodeBlock.of(\"new com.example.Test().methodName()\")); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithNonMatchingDeclaringClass()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.DefaultMethodReferenceTests",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithNonMatchingDeclaringClass()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.DefaultMethodReference",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithNonMatchingDeclaringClass()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "com.example.Test",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithNonMatchingDeclaringClass()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "methodName",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithNonMatchingDeclaringClass()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "ArgumentCodeGenerator.none()",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithNonMatchingDeclaringClass()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "CodeBlock.of(\"new com.example.Test().methodName()\")",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithNonMatchingDeclaringClass()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "TEST_CLASS_NAME",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithNonMatchingDeclaringClass()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "INITIALIZER_CLASS_NAME",
      "tail_type": "apiFunction"
    },
    {
      "head": "toInvokeCodeBlockWithNonMatchingDeclaringClass",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "void toInvokeCodeBlockWithNonMatchingDeclaringClass() { MethodSpec method = createTestMethod(\"methodName\", new TypeName[0]); MethodReference methodReference = new DefaultMethodReference(method, TEST_CLASS_NAME); assertThat(methodReference.toInvokeCodeBlock(ArgumentCodeGenerator.none(), INITIALIZER_CLASS_NAME)).isEqualTo(CodeBlock.of(\"new com.example.Test().methodName()\")); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "toInvokeCodeBlockWithNonMatchingDeclaringClass",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "methodName",
      "tail_type": "apiFunction"
    },
    {
      "head": "toInvokeCodeBlockWithNonMatchingDeclaringClass",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "ArgumentCodeGenerator.none()",
      "tail_type": "apiFunction"
    },
    {
      "head": "toInvokeCodeBlockWithNonMatchingDeclaringClass",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "CodeBlock.of(\"new com.example.Test().methodName()\")",
      "tail_type": "apiFunction"
    },
    {
      "head": "toInvokeCodeBlockWithNonMatchingDeclaringClass",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "TEST_CLASS_NAME",
      "tail_type": "apiFunction"
    },
    {
      "head": "toInvokeCodeBlockWithNonMatchingDeclaringClass",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "INITIALIZER_CLASS_NAME",
      "tail_type": "apiFunction"
    },
    {
      "head": "toInvokeCodeBlockWithNonMatchingDeclaringClass",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.DefaultMethodReferenceTests",
      "tail_type": "class"
    },
    {
      "head": "toInvokeCodeBlockWithNonMatchingDeclaringClass",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.DefaultMethodReference",
      "tail_type": "class"
    },
    {
      "head": "toInvokeCodeBlockWithNonMatchingDeclaringClass",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "com.example.Test",
      "tail_type": "class"
    },
    {
      "tail": "generate code block for method invocation",
      "head_type": "method",
      "relation": "haveFunction",
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithMatchingArg()",
      "tail_type": "apiFunction"
    },
    {
      "tail": "generate code block for method invocation",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithMatchingArg()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "org.springframework.aot.generate.DefaultMethodReferenceTests",
      "head_type": "method",
      "relation": "associated_with",
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithMatchingArg()",
      "tail_type": "class"
    },
    {
      "tail": "related concept interpretation",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithMatchingArg()",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "tail": "design principle interpretation",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithMatchingArg()",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests#addSourceFileWithCharSequenceWhenClassNameIsInTheDefaultPackageThrowsException()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "addSourceFileWithCharSequence",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests#addSourceFileWithCharSequenceWhenClassNameIsInTheDefaultPackageThrowsException()",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "classNameDefaultPackageConstraint",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests#addSourceFileWithCharSequenceWhenClassNameIsInTheDefaultPackageThrowsException()",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "defaultPackageProcessingScenario",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests#addSourceFileWithCharSequenceWhenClassNameIsInTheDefaultPackageThrowsException()",
      "head_type": "method",
      "relation": "have",
      "tail": "addSourceFileWithCharSequenceSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests#addSourceFileWithCharSequenceWhenClassNameIsInTheDefaultPackageThrowsException()",
      "head_type": "method",
      "relation": "have",
      "tail": "defaultPackageProcessingConcept",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests#addSourceFileWithCharSequenceWhenClassNameIsInTheDefaultPackageThrowsException()",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleForDefaultPackageProcessing",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "addSourceFileWithCharSequenceSampleCode",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.GeneratedFilesTests",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.TestFileHandler",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "constructor with InputStreamSource parameter",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.TestFileHandler",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "constructor without parameters",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.TestFileHandler",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "copy method",
      "tail_type": "apiFunction"
    },
    {
      "head": "constructor with InputStreamSource parameter",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "initializes content and calls super",
      "tail_type": "useSampleCode"
    },
    {
      "head": "constructor without parameters",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "calls constructor with null content",
      "tail_type": "useSampleCode"
    },
    {
      "head": "copy method",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "copies content and sets override",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.TestFileHandler",
      "head_type": "class",
      "relation": "have",
      "tail": "manages test file content and override settings",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.TestFileHandler",
      "head_type": "class",
      "relation": "have",
      "tail": "designed to handle test file operations with flexibility",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.PrimitiveTests#generateWhenChar()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "generate character code",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.PrimitiveTests#generateWhenChar()",
      "head_type": "method",
      "relation": "have",
      "tail": "generate character code sample",
      "tail_type": "useSampleCode"
    },
    {
      "head": "generate character code sample",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "java\nimport org.junit.jupiter.api.Test;\nimport static org.assertj.core.api.Assertions.assertThat;\n\nclass PrimitiveTests {\n\n    @Test\n    void generateWhenChar() {\n        assertThat(generateCode('a')).hasToString(\"'a'\");\n    }\n\n    private String generateCode(char c) {\n        return String.valueOf(c);\n    }\n}\n",
      "tail_type": "String"
    },
    {
      "head": "org.springframework.aot.generate.ListTests#generateWhenStringList()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "generateListCode",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.ListTests#generateWhenStringList()",
      "head_type": "method",
      "relation": "have",
      "tail": "generateListCodeSample",
      "tail_type": "useSampleCode"
    },
    {
      "head": "generateListCodeSample",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "generateListCodeSampleContent",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.ListTests#generateWhenStringList()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.ListTests",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.ListTests#generateWhenEmptyList()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "generateWhenEmptyList",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.ListTests#generateWhenEmptyList()",
      "head_type": "method",
      "relation": "have",
      "tail": "generateWhenEmptyListSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "generateWhenEmptyListSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "org.springframework.aot.generate.ListTests",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.SetTests#generateWhenEmptySet()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "generateWhenEmptySet",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.SetTests#generateWhenEmptySet()",
      "head_type": "method",
      "relation": "have",
      "tail": "generateWhenEmptySetSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "generateWhenEmptySetSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "org.springframework.aot.generate.SetTests",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldProcessAnnotationOnInheritedClass()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "processAnnotation",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldProcessAnnotationOnInheritedClass()",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "inheritedClassProcessing",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldProcessAnnotationOnInheritedClass()",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldProcessAnnotationOnInheritedClass()",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldProcessAnnotationOnInheritedClass()",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldProcessAnnotationOnInheritedClass()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "SampleMethodAnnotatedBeanWithInheritance",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldProcessAnnotationOnInheritedClass()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "SampleInheritedClass",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.hint.annotation.SampleInheritedClass",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "reflectiveOperation",
      "tail_type": "apiFunction"
    },
    {
      "head": "reflectiveOperation",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "org.springframework.aot.hint.annotation.SampleInheritedClass",
      "tail_type": "useSampleCode"
    },
    {
      "head": "reflectiveOperation",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "This apiFunction is used to perform reflective operations within the class.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "reflectiveOperation",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "Reflective operations should be used carefully to maintain performance and security.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.hint.annotation.RegisterReflectionReflectiveProcessorTests#assertBasicTypeHint(Class<?>,List<String>,List<MemberCategory>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "assertBasicTypeHint",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.hint.annotation.RegisterReflectionReflectiveProcessorTests#assertBasicTypeHint(Class<?>,List<String>,List<MemberCategory>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "TypeHint",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.hint.annotation.RegisterReflectionReflectiveProcessorTests#assertBasicTypeHint(Class<?>,List<String>,List<MemberCategory>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "ExecutableHint",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.hint.annotation.RegisterReflectionReflectiveProcessorTests#assertBasicTypeHint(Class<?>,List<String>,List<MemberCategory>)",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "useSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "private void assertBasicTypeHint(Class<?> type, List<String> methodNames, List<MemberCategory> memberCategories) {\n    TypeHint typeHint = getTypeHint(type);\n    assertThat(typeHint.methods()).map(ExecutableHint::getName).hasSameElementsAs(methodNames);\n    assertThat(typeHint.getMemberCategories()).hasSameElementsAs(memberCategories);\n    assertThat(typeHint.fields()).isEmpty();\n    assertThat(typeHint.constructors()).isEmpty();\n}",
      "tail_type": "String"
    },
    {
      "head": "org.springframework.aot.hint.annotation.AnnotatedTypeTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "registerReflectionWithMemberCategory",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.hint.annotation.AnnotatedTypeTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "registerReflectionForMultipleTargets",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.hint.annotation.AnnotatedTypeTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "registerReflectionOnTargetClass",
      "tail_type": "apiFunction"
    },
    {
      "head": "registerReflectionWithMemberCategory",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "registerReflectionHints(RegistrationSimple.class); assertBasicTypeHint(SimplePojo.class, NO_METHODS, List.of(MemberCategory.INVOKE_PUBLIC_METHODS));",
      "tail_type": "useSampleCode"
    },
    {
      "head": "registerReflectionForMultipleTargets",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "registerReflectionHints(RegistrationMultipleTargets.class); assertThat(hints.reflection().typeHints()).allSatisfy(hasOnlyMemberCategories(MemberCategory.INVOKE_PUBLIC_METHODS)); assertThat(hints.reflection().typeHints().map(TypeHint::getType)).hasSameElementsAs(TypeReference.listOf(Number.class, Double.class, Integer.class, Float.class));",
      "tail_type": "useSampleCode"
    },
    {
      "head": "registerReflectionOnTargetClass",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "registerReflectionHints(AnnotatedSimplePojo.class); assertBasicTypeHint(AnnotatedSimplePojo.class, NO_METHODS, List.of(MemberCategory.INVOKE_DECLARED_CONSTRUCTORS));",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.core.type.StandardAnnotationMetadata#getDeclaredMethods()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getDeclaredMethods",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.core.type.StandardAnnotationMetadata#getDeclaredMethods()",
      "head_type": "method",
      "relation": "have",
      "tail": "getDeclaredMethods returns a set of MethodMetadata",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.core.type.StandardAnnotationMetadata#getDeclaredMethods()",
      "head_type": "method",
      "relation": "have",
      "tail": "ReflectionUtils used for introspection",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.core.type.StandardAnnotationMetadata#getDeclaredMethods()",
      "head_type": "method",
      "relation": "have",
      "tail": "StandardMethodMetadata created for each method",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.core.type.StandardAnnotationMetadata#getDeclaredMethods()",
      "head_type": "method",
      "relation": "have",
      "tail": "nestedAnnotationsAsMap used for method metadata",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.core.type.StandardAnnotationMetadata#getDeclaredMethods()",
      "head_type": "method",
      "relation": "have",
      "tail": "getDeclaredMethods sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.core.type.StandardClassMetadata#getEnclosingClassName()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getEnclosingClassName",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.core.type.StandardClassMetadata#getEnclosingClassName()",
      "head_type": "method",
      "relation": "have",
      "tail": "getEnclosingClassName returns the name of the enclosing class",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.core.type.StandardClassMetadata#getEnclosingClassName()",
      "head_type": "method",
      "relation": "have",
      "tail": "getEnclosingClassName handles null introspectedClass",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.core.type.StandardClassMetadata#getEnclosingClassName()",
      "head_type": "method",
      "relation": "have",
      "tail": "getEnclosingClassName uses introspectedClass",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.core.type.StandardClassMetadata",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getEnclosingClassName",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.core.type.StandardClassMetadata",
      "head_type": "class",
      "relation": "have",
      "tail": "getEnclosingClassName returns the name of the enclosing class",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.core.type.StandardClassMetadata",
      "head_type": "class",
      "relation": "have",
      "tail": "getEnclosingClassName handles null introspectedClass",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.core.type.StandardClassMetadata",
      "head_type": "class",
      "relation": "have",
      "tail": "getEnclosingClassName uses introspectedClass",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.core.type.StandardMethodMetadata#isStatic()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "check if method is static",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.core.type.StandardMethodMetadata#isStatic()",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for checking if a method is static",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.core.type.StandardMethodMetadata#isStatic()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.core.type.StandardMethodMetadata",
      "tail_type": "class"
    },
    {
      "tail": "generate hash code",
      "head_type": "method",
      "relation": "haveFunction",
      "head": "org.springframework.core.type.StandardMethodMetadata#hashCode()",
      "tail_type": "apiFunction"
    },
    {
      "tail": "override method",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.core.type.StandardMethodMetadata#hashCode()",
      "tail_type": "apiFunction"
    },
    {
      "tail": "introspectedMethod",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.core.type.StandardMethodMetadata#hashCode()",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "tail": "org.springframework.core.type.StandardMethodMetadata",
      "head_type": "relatedConceptInterpretation",
      "relation": "associated_with",
      "head": "introspectedMethod",
      "tail_type": "class"
    },
    {
      "tail": "java.lang.Override",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.core.type.StandardMethodMetadata#hashCode()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "java.lang.Integer",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.core.type.StandardMethodMetadata#hashCode()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "java.lang.Object",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.core.type.StandardMethodMetadata#hashCode()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "org.springframework.core.annotation.SynthesizedAnnotation",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.core.type.StandardMethodMetadata#hashCode()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "org.springframework.core.type.MethodMetadata",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.core.type.StandardMethodMetadata#hashCode()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "org.springframework.core.type.StandardAnnotationMetadata",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.core.type.StandardMethodMetadata#hashCode()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "org.springframework.core.type.ClassMetadata",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.core.type.StandardMethodMetadata#hashCode()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "org.springframework.core.type.AnnotationMetadata",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.core.type.StandardMethodMetadata#hashCode()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "org.springframework.core.type.MethodMetadata",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.core.type.StandardMethodMetadata#hashCode()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "org.springframework.core.type.StandardMethodMetadata",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.core.type.StandardMethodMetadata#hashCode()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "org.springframework.core.type.StandardAnnotationMetadata",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.core.type.StandardMethodMetadata#hashCode()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "org.springframework.core.type.StandardMethodMetadata",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.core.type.StandardMethodMetadata#hashCode()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "org.springframework.core.type.StandardAnnotationMetadata",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.core.type.StandardMethodMetadata#hashCode()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "org.springframework.core.type.StandardMethodMetadata",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.core.type.StandardMethodMetadata#hashCode()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "org.springframework.core.type.StandardAnnotationMetadata",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.core.type.StandardMethodMetadata#hashCode()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "org.springframework.core.type.StandardMethodMetadata",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.core.type.StandardMethodMetadata#hashCode()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "org.springframework.core.type.StandardAnnotationMetadata",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.core.type.StandardMethodMetadata#hashCode()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "org.springframework.core.type.StandardMethodMetadata",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.core.type.StandardMethodMetadata#hashCode()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "org.springframework.core.type.StandardAnnotationMetadata",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.core.type.StandardMethodMetadata#hashCode()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "org.springframework.core.type.StandardMethodMetadata",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.core.type.StandardMethodMetadata#hashCode()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "org.springframework.core.type.StandardAnnotationMetadata",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.core.type.StandardMethodMetadata#hashCode()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "org.springframework.core.type.StandardMethodMetadata",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.core.type.StandardMethodMetadata#hashCode()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "org.springframework.core.type.StandardAnnotationMetadata",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.core.type.StandardMethodMetadata#hashCode()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "org.springframework.core.type.StandardMethodMetadata",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.core.type.StandardMethodMetadata#hashCode()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "org.springframework.core.type.StandardAnnotationMetadata",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.core.type.StandardMethodMetadata#hashCode()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "org.springframework.core.type.StandardMethodMetadata",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.core.type.StandardMethodMetadata#hashCode()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "org.springframework.core.type.StandardAnnotationMetadata",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.core.type.StandardMethodMetadata#hashCode()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "org.springframework.core.type.StandardMethodMetadata",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.core.type.StandardMethodMetadata#hashCode()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "org.springframework.core.type.StandardAnnotationMetadata",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.core.type.StandardMethodMetadata#hashCode()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "org.springframework.core.type.StandardMethodMetadata",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.core.type.StandardMethodMetadata#hashCode()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "org.springframework.core.type.StandardAnnotationMetadata",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.core.type.StandardMethodMetadata#hashCode()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "org.springframework.core.type.StandardMethodMetadata",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.core.type.StandardMethodMetadata#hashCode()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "org.springframework.core.type.StandardAnnotationMetadata",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.core.type.StandardMethodMetadata#hashCode()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "org.springframework.core.type.StandardMethodMetadata",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.core.type.StandardMethodMetadata#hashCode()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "org.springframework.core.type.StandardAnnotationMetadata",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.core.type.StandardMethodMetadata#hashCode()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "org.springframework.core.type.StandardMethodMetadata",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.core.type.StandardMethodMetadata#hashCode()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "org.springframework.core.type.StandardAnnotationMetadata",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.core.type.StandardMethodMetadata#hashCode()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "org.springframework.core.type.StandardMethodMetadata",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.core.type.StandardMethodMetadata#hashCode()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "org.springframework.core.type.StandardAnnotationMetadata",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.core.type.StandardMethodMetadata#hashCode()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "org.springframework.core.type.StandardMethodMetadata",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.core.type.StandardMethodMetadata#hashCode()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "org.springframework.core.type.StandardAnnotationMetadata",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.core.type.StandardMethodMetadata#hashCode()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "org.springframework.core.type.StandardMethodMetadata",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.core.type.StandardMethodMetadata#hashCode()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "org.springframework.core.type.StandardAnnotationMetadata",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.core.type.StandardMethodMetadata#hashCode()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "org.springframework.core.type.StandardMethodMetadata",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.core.type.StandardMethodMetadata#hashCode()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "org.springframework.core.type.StandardAnnotationMetadata",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.core.type.StandardMethodMetadata#hashCode()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "org.springframework.core.type.StandardMethodMetadata",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.core.type.StandardMethodMetadata#hashCode()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "org.springframework.core.type.StandardAnnotationMetadata",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.core.type.StandardMethodMetadata#hashCode()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "org.springframework.core.type.StandardMethodMetadata",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.core.type.StandardMethodMetadata#hashCode()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "org.springframework.core.type.StandardAnnotationMetadata",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.core.type.StandardMethodMetadata#hashCode()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "org.springframework.core.type.StandardMethodMetadata",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.core.type.StandardMethodMetadata#hashCode()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "org.springframework.core.type.StandardAnnotationMetadata",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.core.type.StandardMethodMetadata#hashCode()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "org.springframework.core.type.StandardMethodMetadata",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.core.type.StandardMethodMetadata#hashCode()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "org.springframework.core.type.StandardAnnotationMetadata",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.core.type.StandardMethodMetadata#hashCode()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "org.springframework.core.type.StandardMethodMetadata",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.core.type.StandardMethodMetadata#hashCode()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "org.springframework.core.type.StandardAnnotationMetadata",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.core.type.StandardMethodMetadata#hashCode()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "org.springframework.core.type.StandardMethodMetadata",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.core.type.StandardMethodMetadata#hashCode()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "org.springframework.core.type.StandardAnnotationMetadata",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.core.type.StandardMethodMetadata#hashCode()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "org.springframework.core.type.StandardMethodMetadata",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.core.type.StandardMethodMetadata#hashCode()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "org.springframework.core.type.StandardAnnotationMetadata",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.core.type.StandardMethodMetadata#hashCode()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "org.springframework.core.type.StandardMethodMetadata",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.core.type.StandardMethodMetadata#hashCode()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "org.springframework.core.type.StandardAnnotationMetadata",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.core.type.StandardMethodMetadata#hashCode()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "org.springframework.core.type.StandardMethodMetadata",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.core.type.StandardMethodMetadata#hashCode()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "org.springframework.core.type.StandardAnnotationMetadata",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.core.type.StandardMethodMetadata#hashCode()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "org.springframework.core.type.StandardMethodMetadata",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.core.type.StandardMethodMetadata#hashCode()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "org.springframework.core.type.StandardAnnotationMetadata",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.core.type.StandardMethodMetadata#hashCode()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "org.springframework.core.type.StandardMethodMetadata",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.core.type.StandardMethodMetadata#hashCode()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "org.springframework.core.type.StandardAnnotationMetadata",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.core.type.StandardMethodMetadata#hashCode()",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#tokenizePattern(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "tokenizePattern",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#tokenizePattern(String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "setCachePatterns",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#tokenizePattern(String)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "tokenizePath",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#tokenizePattern(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "tokenizePath",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#tokenizePattern(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#tokenizePattern(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#tokenizePattern(String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.AntPathMatcher",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.Assert#isNull(Object,String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "assertNull",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.Assert#isNull(Object,String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "objectMustBeNull",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.Assert#isNull(Object,String)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "checkForObjectNullity",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.Assert#isNull(Object,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.Assert#isNull(Object,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.Assert#isNull(Object,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.Assert#isNull(Object,String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "IllegalArgumentException",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.Assert#notEmpty(Object[],String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "assertArrayNotEmpty",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.Assert#notEmpty(Object[],String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "nullOrEmptyArrayCheck",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.Assert#notEmpty(Object[],String)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "arrayValidation",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.Assert#notEmpty(Object[],String)",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.Assert#notEmpty(Object[],String)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.Assert#notEmpty(Object[],String)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "assertArrayNotEmpty",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "org.springframework.util.Assert",
      "tail_type": "class"
    },
    {
      "head": "nullOrEmptyArrayCheck",
      "head_type": "useConstraint",
      "relation": "associated_with",
      "tail": "org.springframework.util.Assert",
      "tail_type": "class"
    },
    {
      "head": "arrayValidation",
      "head_type": "useScenario",
      "relation": "associated_with",
      "tail": "org.springframework.util.Assert",
      "tail_type": "class"
    },
    {
      "head": "useSampleCode",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "tail": "org.springframework.util.Assert",
      "tail_type": "class"
    },
    {
      "head": "relatedConceptInterpretation",
      "head_type": "relatedConceptInterpretation",
      "relation": "associated_with",
      "tail": "org.springframework.util.Assert",
      "tail_type": "class"
    },
    {
      "head": "designPrincipleInterpretation",
      "head_type": "designPrincipleInterpretation",
      "relation": "associated_with",
      "tail": "org.springframework.util.Assert",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.AutoPopulatingList#iterator()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "iterator",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.AutoPopulatingList#iterator()",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.AutoPopulatingList#iterator() sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.AutoPopulatingList#iterator() sample code",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "org.springframework.util.AutoPopulatingList#iterator() code content",
      "tail_type": "codeContent"
    },
    {
      "head": "org.springframework.util.ClassUtils#getPubliclyAccessibleMethodIfPossible(Method,Class<?>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "get publicly accessible method",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ClassUtils#getPubliclyAccessibleMethodIfPossible(Method,Class<?>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "method must be public and declared in a public type",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ClassUtils#getPubliclyAccessibleMethodIfPossible(Method,Class<?>)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "Java Module System",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ClassUtils#getPubliclyAccessibleMethodIfPossible(Method,Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ClassUtils#getPubliclyAccessibleMethodIfPossible(Method,Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#getPubliclyAccessibleMethodIfPossible(Method,Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "get publicly accessible method",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "org.springframework.util.ClassUtils#getPubliclyAccessibleMethodIfPossible(Method,Class<?>)",
      "tail_type": "method"
    },
    {
      "head": "method must be public and declared in a public type",
      "head_type": "useConstraint",
      "relation": "associated_with",
      "tail": "org.springframework.util.ClassUtils#getPubliclyAccessibleMethodIfPossible(Method,Class<?>)",
      "tail_type": "method"
    },
    {
      "head": "Java Module System",
      "head_type": "useScenario",
      "relation": "associated_with",
      "tail": "org.springframework.util.ClassUtils#getPubliclyAccessibleMethodIfPossible(Method,Class<?>)",
      "tail_type": "method"
    },
    {
      "head": "useSampleCode",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "tail": "org.springframework.util.ClassUtils#getPubliclyAccessibleMethodIfPossible(Method,Class<?>)",
      "tail_type": "method"
    },
    {
      "head": "relatedConceptInterpretation",
      "head_type": "relatedConceptInterpretation",
      "relation": "associated_with",
      "tail": "org.springframework.util.ClassUtils#getPubliclyAccessibleMethodIfPossible(Method,Class<?>)",
      "tail_type": "method"
    },
    {
      "head": "designPrincipleInterpretation",
      "head_type": "designPrincipleInterpretation",
      "relation": "associated_with",
      "tail": "org.springframework.util.ClassUtils#getPubliclyAccessibleMethodIfPossible(Method,Class<?>)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.comparator.Comparators#nullsHigh()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "nullsHigh",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.comparator.Comparators#nullsHigh()",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "null values sorted higher",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.comparator.Comparators#nullsHigh()",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "comparable adapter",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.comparator.Comparators#nullsHigh()",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.comparator.Comparators#nullsHigh()",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.comparator.Comparators#nullsHigh()",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.comparator.Comparators#nullsHigh()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "Comparator#nullsLast(Comparator)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.ConcurrencyThrottleSupport#isThrottleActive()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "throttle status check",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ConcurrencyThrottleSupport#isThrottleActive()",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "concurrency limit must be non-negative",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ConcurrencyThrottleSupport#isThrottleActive()",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "concurrency control scenarios",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ConcurrencyThrottleSupport#isThrottleActive()",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for checking throttle status",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ConcurrencyThrottleSupport#isThrottleActive()",
      "head_type": "method",
      "relation": "have",
      "tail": "throttle and concurrency explanation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ConcurrencyThrottleSupport#isThrottleActive()",
      "head_type": "method",
      "relation": "have",
      "tail": "design principles for concurrency throttle",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ConcurrencyThrottleSupport#isThrottleActive()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.ConcurrencyThrottleSupport",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.ConcurrencyThrottleSupport#beforeAccess()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "concurrency throttle",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ConcurrencyThrottleSupport#beforeAccess()",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "concurrency limit",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ConcurrencyThrottleSupport#beforeAccess()",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "main execution logic",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ConcurrencyThrottleSupport#beforeAccess()",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for beforeAccess()",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ConcurrencyThrottleSupport#beforeAccess()",
      "head_type": "method",
      "relation": "have",
      "tail": "related concept interpretation for beforeAccess()",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ConcurrencyThrottleSupport#beforeAccess()",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle interpretation for beforeAccess()",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ConcurrencyThrottleSupport#beforeAccess()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.ConcurrencyThrottleSupport",
      "tail_type": "class"
    },
    {
      "head": "sample code for beforeAccess()",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "complete sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "related concept interpretation for beforeAccess()",
      "head_type": "relatedConceptInterpretation",
      "relation": "have",
      "tail": "detailed description of related concepts",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "design principle interpretation for beforeAccess()",
      "head_type": "designPrincipleInterpretation",
      "relation": "have",
      "tail": "detailed description of design principles",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.concurrent.FutureAdapter#isDone()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "check completion status",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.concurrent.FutureAdapter#isDone()",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.concurrent.FutureAdapter",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.concurrent.FutureAdapter",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.concurrent.Future",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.concurrent.FutureAdapter#isDone()",
      "head_type": "method",
      "relation": "have",
      "tail": "Delegation pattern",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.concurrent.FutureAdapter#isDone()",
      "head_type": "method",
      "relation": "have",
      "tail": "This method checks if the underlying task is completed by delegating the call to the adaptee's isDone method.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.concurrent.FutureAdapter#isDone()",
      "head_type": "method",
      "relation": "have",
      "tail": "java\npackage org.springframework.util.concurrent;\n\nimport java.util.concurrent.Future;\n\npublic class FutureAdapterExample {\n    public static void main(String[] args) {\n        Future<String> adaptee = new FutureAdapterExample();\n        FutureAdapter<String> adapter = new FutureAdapter<>(adaptee);\n        boolean isDone = adapter.isDone();\n        System.out.println(\"Is the task done? \" + isDone);\n    }\n\n    public boolean isDone() {\n        // Simulate task completion status\n        return true;\n    }\n}\n",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ConcurrentLruCache#get(K)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "retrieveEntryFromCache",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ConcurrentLruCache#get(K)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "triggerValueGeneration",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ConcurrentLruCache#get(K)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "keyNotNull",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ConcurrentLruCache#get(K)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "cacheEntryRetrieval",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ConcurrentLruCache#get(K)",
      "head_type": "method",
      "relation": "have",
      "tail": "cacheEntryRetrievalSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ConcurrentLruCache#get(K)",
      "head_type": "method",
      "relation": "have",
      "tail": "concurrentLruCacheExplanation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ConcurrentLruCache#get(K)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrinciplesOfConcurrentLruCache",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "retrieveEntryFromCache",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "org.springframework.util.ConcurrentLruCache",
      "tail_type": "class"
    },
    {
      "head": "triggerValueGeneration",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "org.springframework.util.ConcurrentLruCache",
      "tail_type": "class"
    },
    {
      "head": "keyNotNull",
      "head_type": "useConstraint",
      "relation": "associated_with",
      "tail": "org.springframework.util.ConcurrentLruCache",
      "tail_type": "class"
    },
    {
      "head": "cacheEntryRetrieval",
      "head_type": "useScenario",
      "relation": "associated_with",
      "tail": "org.springframework.util.ConcurrentLruCache",
      "tail_type": "class"
    },
    {
      "head": "cacheEntryRetrievalSampleCode",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "tail": "org.springframework.util.ConcurrentLruCache",
      "tail_type": "class"
    },
    {
      "head": "concurrentLruCacheExplanation",
      "head_type": "relatedConceptInterpretation",
      "relation": "associated_with",
      "tail": "org.springframework.util.ConcurrentLruCache",
      "tail_type": "class"
    },
    {
      "head": "designPrinciplesOfConcurrentLruCache",
      "head_type": "designPrincipleInterpretation",
      "relation": "associated_with",
      "tail": "org.springframework.util.ConcurrentLruCache",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.AddTask#evictEntries()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "evictEntries",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.AddTask#evictEntries()",
      "head_type": "method",
      "relation": "have",
      "tail": "Cache Eviction",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "Cache Eviction",
      "head_type": "relatedConceptInterpretation",
      "relation": "have",
      "tail": "Cache eviction is a process used to remove entries from a cache when the cache reaches its capacity limit. This is often done to free up space for new entries and to ensure that the cache does not grow indefinitely. The eviction policy determines which entries are removed, and common policies include Least Recently Used (LRU), First In First Out (FIFO), and Random Replacement.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.AddTask#evictEntries()",
      "head_type": "method",
      "relation": "have",
      "tail": "private void evictEntries() {\n    while (currentSize.get() > capacity) {\n        final Node<K, V> node = evictionQueue.poll();\n        if (node == null) {\n            return;\n        }\n        cache.remove(node.key, node);\n        markAsRemoved(node);\n    }\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.RemovalTask#run()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "eviction",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.RemovalTask#run()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "removal",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.RemovalTask#run()",
      "head_type": "method",
      "relation": "have",
      "tail": "evictionQueue.remove(this.node)",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.RemovalTask#run()",
      "head_type": "method",
      "relation": "have",
      "tail": "markAsRemoved(this.node)",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.RemovalTask#run()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "evictionQueue",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.RemovalTask#run()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "node",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.RemovalTask#run()",
      "head_type": "method",
      "relation": "designPrincipleInterpretation",
      "tail": "This method follows the principle of explicit removal, ensuring that once an item is evicted, it is clearly marked and removed from the queue to prevent further processing.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ReadOperations",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "detectNumberOfBuffers",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ReadOperations",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "recordRead",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ReadOperations",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "drain",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ReadOperations",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "clear",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ReadOperations",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "drainReadBuffer",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ReadOperations",
      "head_type": "class",
      "relation": "have",
      "tail": "recordedCount",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ReadOperations",
      "head_type": "class",
      "relation": "have",
      "tail": "readCount",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ReadOperations",
      "head_type": "class",
      "relation": "have",
      "tail": "processedCount",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ReadOperations",
      "head_type": "class",
      "relation": "have",
      "tail": "buffers",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ReadOperations",
      "head_type": "class",
      "relation": "have",
      "tail": "evictionQueue",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ReadOperations",
      "head_type": "class",
      "relation": "have",
      "tail": "BUFFER_COUNT",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ReadOperations",
      "head_type": "class",
      "relation": "have",
      "tail": "BUFFERS_MASK",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ReadOperations",
      "head_type": "class",
      "relation": "have",
      "tail": "MAX_PENDING_OPERATIONS",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ReadOperations",
      "head_type": "class",
      "relation": "have",
      "tail": "MAX_DRAIN_COUNT",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ReadOperations",
      "head_type": "class",
      "relation": "have",
      "tail": "BUFFER_SIZE",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ReadOperations",
      "head_type": "class",
      "relation": "have",
      "tail": "BUFFER_INDEX_MASK",
      "tail_type": "useScenario"
    },
    {
      "head": "detectNumberOfBuffers",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "BUFFER_COUNT",
      "tail_type": "useSampleCode"
    },
    {
      "head": "recordRead",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "recordedCount",
      "tail_type": "useSampleCode"
    },
    {
      "head": "recordRead",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "readCount",
      "tail_type": "useSampleCode"
    },
    {
      "head": "recordRead",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "processedCount",
      "tail_type": "useSampleCode"
    },
    {
      "head": "recordRead",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "buffers",
      "tail_type": "useSampleCode"
    },
    {
      "head": "recordRead",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "evictionQueue",
      "tail_type": "useSampleCode"
    },
    {
      "head": "recordRead",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "pending",
      "tail_type": "useSampleCode"
    },
    {
      "head": "recordRead",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "MAX_PENDING_OPERATIONS",
      "tail_type": "useSampleCode"
    },
    {
      "head": "drain",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "start",
      "tail_type": "useSampleCode"
    },
    {
      "head": "drain",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "end",
      "tail_type": "useSampleCode"
    },
    {
      "head": "drain",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "i",
      "tail_type": "useSampleCode"
    },
    {
      "head": "drain",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "BUFFERS_MASK",
      "tail_type": "useSampleCode"
    },
    {
      "head": "clear",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "i",
      "tail_type": "useSampleCode"
    },
    {
      "head": "clear",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "j",
      "tail_type": "useSampleCode"
    },
    {
      "head": "clear",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "BUFFER_COUNT",
      "tail_type": "useSampleCode"
    },
    {
      "head": "clear",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "BUFFER_SIZE",
      "tail_type": "useSampleCode"
    },
    {
      "head": "clear",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "buffers",
      "tail_type": "useSampleCode"
    },
    {
      "head": "drainReadBuffer",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "writeCount",
      "tail_type": "useSampleCode"
    },
    {
      "head": "drainReadBuffer",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "i",
      "tail_type": "useSampleCode"
    },
    {
      "head": "drainReadBuffer",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "index",
      "tail_type": "useSampleCode"
    },
    {
      "head": "drainReadBuffer",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "buffer",
      "tail_type": "useSampleCode"
    },
    {
      "head": "drainReadBuffer",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "node",
      "tail_type": "useSampleCode"
    },
    {
      "head": "drainReadBuffer",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "evictionQueue",
      "tail_type": "useSampleCode"
    },
    {
      "head": "drainReadBuffer",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "readCount",
      "tail_type": "useSampleCode"
    },
    {
      "head": "drainReadBuffer",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "processedCount",
      "tail_type": "useSampleCode"
    },
    {
      "head": "drainReadBuffer",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "MAX_DRAIN_COUNT",
      "tail_type": "useSampleCode"
    },
    {
      "head": "drainReadBuffer",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "BUFFER_INDEX_MASK",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ReadOperations",
      "head_type": "class",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ReadOperations",
      "head_type": "class",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.Segment#restructureIfNecessary(boolean)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "restructure underlying data structure",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.Segment#restructureIfNecessary(boolean)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "allowResize parameter",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.Segment#restructureIfNecessary(boolean)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "garbage collected references",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.Segment#restructureIfNecessary(boolean)",
      "head_type": "method",
      "relation": "have",
      "tail": "void restructureIfNecessary(boolean allowResize) { ... }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.Segment#restructureIfNecessary(boolean)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.Segment#restructureIfNecessary(boolean)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.Segment",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.Segment#restructureIfNecessary(boolean)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.EntrySet#iterator()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "iterator",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.EntrySet#iterator()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.EntrySet",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.EntrySet#iterator()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "EntryIterator",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.EntrySet#iterator()",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.EntrySet#iterator()",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.EntrySet#iterator()",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.CustomizableThreadCreator#nextThreadName()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "generateThreadName",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.CustomizableThreadCreator#nextThreadName()",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "threadCreation",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.CustomizableThreadCreator#nextThreadName()",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.CustomizableThreadCreator",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.CustomizableThreadCreator#nextThreadName()",
      "head_type": "method",
      "relation": "have",
      "tail": "Generates a unique name for a new thread by appending an incrementing count to a specified prefix.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.CustomizableThreadCreator#nextThreadName()",
      "head_type": "method",
      "relation": "have",
      "tail": "The method follows the principle of maintaining a consistent naming convention for threads, which is crucial for debugging and monitoring purposes.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.CustomizableThreadCreator#nextThreadName()",
      "head_type": "method",
      "relation": "have",
      "tail": "java\npackage org.springframework.util;\n\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class CustomizableThreadCreator {\n\n    private String threadNamePrefix = \"SimpleAsyncTaskExecutor-\";\n    private final AtomicInteger threadCount = new AtomicInteger(0);\n\n    public String nextThreadName() {\n        return getThreadNamePrefix() + this.threadCount.incrementAndGet();\n    }\n\n    public String getThreadNamePrefix() {\n        return this.threadNamePrefix;\n    }\n\n    public void setThreadNamePrefix(String threadNamePrefix) {\n        this.threadNamePrefix = threadNamePrefix;\n    }\n}\n",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.DefaultPropertiesPersister#loadFromXml(Properties,InputStream)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "load properties from XML",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.DefaultPropertiesPersister#loadFromXml(Properties,InputStream)",
      "head_type": "method",
      "relation": "have",
      "tail": "loadFromXml method loads properties from an XML input stream",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.DefaultPropertiesPersister#loadFromXml(Properties,InputStream)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method utilizes the Properties class to load data from XML format",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.DefaultPropertiesPersister#loadFromXml(Properties,InputStream)",
      "head_type": "method",
      "relation": "have",
      "tail": "package com.example.demo;\n\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.util.Properties;\n\npublic class LoadPropertiesFromXml {\n    public static void main(String[] args) {\n        Properties props = new Properties();\n        try (FileInputStream fis = new FileInputStream(\"config.xml\")) {\n            props.loadFromXML(fis);\n            System.out.println(\"Database URL: \" + props.getProperty(\"db.url\"));\n            System.out.println(\"Database User: \" + props.getProperty(\"db.user\"));\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.DigestUtils#appendDigestAsHex(String,byte[],StringBuilder)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "appendDigestAsHex",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.DigestUtils#appendDigestAsHex(String,byte[],StringBuilder)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.DigestUtils",
      "tail_type": "class"
    },
    {
      "head": "appendDigestAsHex",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "Appending a hexadecimal digest to a StringBuilder",
      "tail_type": "useScenario"
    },
    {
      "head": "Appending a hexadecimal digest to a StringBuilder",
      "head_type": "useScenario",
      "relation": "have",
      "tail": "private static StringBuilder appendDigestAsHex(String algorithm, byte[] bytes, StringBuilder builder) {\n    char[] hexDigest = digestAsHexChars(algorithm, bytes);\n    return builder.append(hexDigest);\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "appendDigestAsHex",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "This method appends the hexadecimal representation of a digest to a given StringBuilder.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "appendDigestAsHex",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "The method is designed to be efficient and reusable, adhering to the principle of DRY (Don't Repeat Yourself).",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.FastByteArrayOutputStream#nextPowerOf2(int)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "nextPowerOf2",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.FastByteArrayOutputStream#nextPowerOf2(int)",
      "head_type": "method",
      "relation": "have",
      "tail": "Get the next power of 2 of a number (ex, the next power of 2 of 119 is 128)",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.FastByteArrayOutputStream#nextPowerOf2(int)",
      "head_type": "method",
      "relation": "have",
      "tail": "package com.healthMgr.util; import java.xxxx; public class FastByteArrayOutputStream { private static int nextPowerOf2(int val) { val--; val = (val >> 1) | val; val = (val >> 2) | val; val = (val >> 4) | val; val = (val >> 8) | val; val = (val >> 16) | val; val++; return val; } }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.FilteredMap#clear()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "clearing a map",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.FilteredMap#clear()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.FilteredMap",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.FilteredMap#clear()",
      "head_type": "method",
      "relation": "have",
      "tail": "delegates map clearing to the delegate object",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.FilteredMap#clear()",
      "head_type": "method",
      "relation": "have",
      "tail": "the delegate object handles the clearing operation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.FilteredMap#clear()",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle of delegation for map operations",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.FilteredMap#keySet()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "filteredKeySet",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.FilteredMap#keySet()",
      "head_type": "method",
      "relation": "have",
      "tail": "return a new FilteredSet",
      "tail_type": "useSampleCode"
    },
    {
      "head": "filteredKeySet",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "create a new FilteredSet",
      "tail_type": "useSampleCode"
    },
    {
      "head": "filteredKeySet",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "related to delegate and filter",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "filteredKeySet",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "design principle of creating a filtered set",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.LinkedCaseInsensitiveMap#containsValue(Object)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "check if the map contains a specific value",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.LinkedCaseInsensitiveMap#containsValue(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method checks if the underlying targetMap contains the specified value.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.LinkedCaseInsensitiveMap#containsValue(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "public boolean containsValue(Object value) {\n    return this.targetMap.containsValue(value);\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.KeySet#spliterator()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "spliterator",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.KeySet#spliterator()",
      "head_type": "method",
      "relation": "have",
      "tail": "Delegate spliterator",
      "tail_type": "useSampleCode"
    },
    {
      "head": "Delegate spliterator",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "tail": "org.springframework.util.KeySet",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.KeySet#spliterator()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.KeySet",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.Values#spliterator()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "spliterator",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.Values#spliterator()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.Values",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.Values#spliterator()",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.MimeType#getType()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "return primary type",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MimeType#getType()",
      "head_type": "method",
      "relation": "have",
      "tail": "Return the primary type.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.MimeType#getType()",
      "head_type": "method",
      "relation": "have",
      "tail": "public String getType() { return this.type; }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.MimeType#isPresentIn(Collection<? extends MimeType>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "MimeType presence check",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MimeType#isPresentIn(Collection<? extends MimeType>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "Collection must not be null",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.MimeType#isPresentIn(Collection<? extends MimeType>)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "Checking if a MimeType is present in a collection",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.MimeType#isPresentIn(Collection<? extends MimeType>)",
      "head_type": "method",
      "relation": "have",
      "tail": "public boolean isPresentIn(Collection<? extends MimeType> mimeTypes) {\n    for (MimeType mimeType : mimeTypes) {\n        if (mimeType.equalsTypeAndSubtype(this)) {\n            return true;\n        }\n    }\n    return false;\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.MimeType#isPresentIn(Collection<? extends MimeType>)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is used to check if a given MimeType is present in a collection of MimeTypes. It iterates through the collection and compares each MimeType's type and subtype with the current MimeType, ignoring any parameters.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.MimeType#isPresentIn(Collection<? extends MimeType>)",
      "head_type": "method",
      "relation": "have",
      "tail": "The design principle behind this method is to provide a way to check for the presence of a MimeType in a collection without considering additional parameters. This allows for a more flexible comparison based on the essential characteristics of a MimeType, which are its type and subtype.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "MimeType presence check",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "org.springframework.util.MimeType",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.NumberUtils#isHexNumber(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "Determine whether the given value String indicates a hex number",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.NumberUtils#isHexNumber(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "private static boolean isHexNumber(String value) { int index = (value.startsWith(\"-\") ? 1 : 0); return (value.startsWith(\"0x\", index) || value.startsWith(\"0X\", index) || value.startsWith(\"#\", index)); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.NumberUtils#isHexNumber(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "The method checks if the input string represents a hexadecimal number, which is indicated by a prefix of '0x', '0X', or '#' after an optional '-' sign. This is useful for determining whether to use Integer.decode instead of Integer.valueOf for parsing the string.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.NumberUtils#isHexNumber(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "The design principle behind this method is to provide a utility function that simplifies the process of identifying hexadecimal numbers. This is part of a broader design pattern in the Spring framework to offer helper methods that make common tasks more straightforward and less error-prone.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.NestedPlaceholderPart#resolve(PartResolutionContext)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "resolve nested placeholders",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.NestedPlaceholderPart#resolve(PartResolutionContext)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "ensuring no circular dependencies",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.NestedPlaceholderPart#resolve(PartResolutionContext)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "resolving placeholders in configuration files",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.NestedPlaceholderPart#resolve(PartResolutionContext)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.NestedPlaceholderPart",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.NestedPlaceholderPart#resolve(PartResolutionContext)",
      "head_type": "method",
      "relation": "have",
      "tail": "related to placeholder resolution in Spring framework",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.NestedPlaceholderPart#resolve(PartResolutionContext)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle of modularity and reusability",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.NestedPlaceholderPart#resolve(PartResolutionContext)",
      "head_type": "method",
      "relation": "have",
      "tail": "public String resolve(PartResolutionContext resolutionContext) {\n    String resolvedKey = Part.resolveAll(this.keyParts, resolutionContext);\n    String value = resolveRecursively(resolutionContext, resolvedKey);\n    if (value != null) {\n        return value;\n    } else if (this.defaultParts != null) {\n        return Part.resolveAll(this.defaultParts, resolutionContext);\n    }\n    return resolutionContext.handleUnresolvablePlaceholder(resolvedKey, text());\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.PropertiesPersister#storeToXml(Properties,OutputStream,String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "storeToXml",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.PropertiesPersister#storeToXml(Properties,OutputStream,String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "IOException",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.PropertiesPersister#storeToXml(Properties,OutputStream,String)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "Properties object to XML OutputStream",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.PropertiesPersister#storeToXml(Properties,OutputStream,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "Write the contents of the given Properties object to the given XML OutputStream",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.PropertiesPersister#storeToXml(Properties,OutputStream,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "The method writes the properties to an XML OutputStream, allowing for a descriptive header",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.PropertiesPersister#storeToXml(Properties,OutputStream,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is designed to serialize Properties objects into an XML format, adhering to the standard Java Properties XML structure",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "storeToXml",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "org.springframework.util.PropertiesPersister",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.SingleToMultiValueMapAdapter",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "adapt a given MultiValueMap to the Map contract",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.SingleToMultiValueMapAdapter",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "MultiValueMapAdapter",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.SingleToMultiValueMapAdapter",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "MultiToSingleValueMapAdapter",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.SingleToMultiValueMapAdapter",
      "head_type": "class",
      "relation": "have",
      "tail": "delegates to a Map<K, V>",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.SingleToMultiValueMapAdapter",
      "head_type": "class",
      "relation": "have",
      "tail": "The class is designed to adapt a MultiValueMap to the Map contract by delegating operations to an underlying Map<K, V> instance.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.SingleToMultiValueMapAdapter",
      "head_type": "class",
      "relation": "have",
      "tail": "The design principle followed is to provide a convenient adapter that allows a MultiValueMap to be used as a regular Map, ensuring compatibility with Map-based APIs.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.TaskInfo#getTimeNanos()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "获取任务执行时间",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.TaskInfo#getTimeNanos()",
      "head_type": "method",
      "relation": "have",
      "tail": "返回任务执行所花费的时间（纳秒）",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.TaskInfo#getTimeNanos()",
      "head_type": "method",
      "relation": "have",
      "tail": "获取任务执行时间的具体实现方式",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.TaskInfo#getTimeNanos()",
      "head_type": "method",
      "relation": "have",
      "tail": "设计原则：提供一种高效且精确的方式来获取任务执行时间",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.TaskInfo#getTimeNanos()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.TaskInfo",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.TaskInfo#getTimeMillis()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "获取任务执行时间",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.TaskInfo#getTimeMillis()",
      "head_type": "method",
      "relation": "have",
      "tail": "获取任务执行时间的毫秒值",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.TaskInfo#getTimeMillis()",
      "head_type": "method",
      "relation": "have",
      "tail": "此方法返回任务执行所花费的时间，单位为毫秒。",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.TaskInfo#getTimeMillis()",
      "head_type": "method",
      "relation": "have",
      "tail": "设计原则：提供一种高效的方式来获取任务执行时间。",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.StreamUtils#copy(InputStream,OutputStream)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "copy contents of InputStream to OutputStream",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StreamUtils#copy(InputStream,OutputStream)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "InputStream and OutputStream must be non-null",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.StreamUtils#copy(InputStream,OutputStream)",
      "head_type": "method",
      "relation": "have",
      "tail": "Leaves both streams open when done",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.StreamUtils#copy(InputStream,OutputStream)",
      "head_type": "method",
      "relation": "have",
      "tail": "Returns the number of bytes copied",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.StreamUtils#copy(InputStream,OutputStream)",
      "head_type": "method",
      "relation": "have",
      "tail": "Throws IOException in case of I/O errors",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.StreamUtils#copy(InputStream,OutputStream)",
      "head_type": "method",
      "relation": "have",
      "tail": "public static int copy(InputStream in, OutputStream out) throws IOException {\n    Assert.notNull(in, \"No InputStream specified\");\n    Assert.notNull(out, \"No OutputStream specified\");\n    int count = (int) in.transferTo(out);\n    out.flush();\n    return count;\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.StreamUtils#copy(InputStream,OutputStream)",
      "head_type": "method",
      "relation": "have",
      "tail": "Related to stream handling and I/O operations",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.StreamUtils#copy(InputStream,OutputStream)",
      "head_type": "method",
      "relation": "have",
      "tail": "Follows the principle of simplicity and efficiency in I/O operations",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.StringUtils#pathEquals(String,String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "path comparison",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils#pathEquals(String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "normalized path comparison",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.StringUtils#pathEquals(String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "string path normalization",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.StringUtils#pathEquals(String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "efficient path comparison design",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.StringUtils#pathEquals(String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for path comparison",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.StringUtils#parseTimeZoneString(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "parseTimeZoneString",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils#parseTimeZoneString(String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "invalidTimeZoneSpecification",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.StringUtils#parseTimeZoneString(String)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "timeZoneStringParsing",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.StringUtils#parseTimeZoneString(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "timeZoneStringParsingSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.StringUtils#parseTimeZoneString(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "timeZoneStringParsingConcept",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.StringUtils#parseTimeZoneString(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleForTimeZoneParsing",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "timeZoneStringParsingSampleCode",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "tail": "org.springframework.util.StringUtils#parseTimeZoneString(String)",
      "tail_type": "method"
    },
    {
      "head": "timeZoneStringParsingConcept",
      "head_type": "relatedConceptInterpretation",
      "relation": "associated_with",
      "tail": "org.springframework.util.StringUtils#parseTimeZoneString(String)",
      "tail_type": "method"
    },
    {
      "head": "designPrincipleForTimeZoneParsing",
      "head_type": "designPrincipleInterpretation",
      "relation": "associated_with",
      "tail": "org.springframework.util.StringUtils#parseTimeZoneString(String)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.StringUtils#commaDelimitedListToSet(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "convert a comma delimited list into a set",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils#commaDelimitedListToSet(String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "input string can be null or empty",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.StringUtils#commaDelimitedListToSet(String)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "CSV file processing",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.StringUtils#commaDelimitedListToSet(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "LinkedHashSet preserves original order",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.StringUtils#commaDelimitedListToSet(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "suppress duplicates",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.StringUtils#commaDelimitedListToSet(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "public static Set<String> commaDelimitedListToSet(@Nullable String str) {\n    String[] tokens = commaDelimitedListToStringArray(str);\n    return new LinkedHashSet<>(Arrays.asList(tokens));\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.StringUtils#commaDelimitedListToSet(String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.StringUtils",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.unit.DataSize#toMegabytes()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "convert to megabytes",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.unit.DataSize#toMegabytes()",
      "head_type": "method",
      "relation": "have",
      "tail": "Return the number of megabytes in this instance.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.unit.DataSize#toMegabytes()",
      "head_type": "method",
      "relation": "have",
      "tail": "public long toMegabytes() { return this.bytes / BYTES_PER_MB; }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.unit.DataSize#toMegabytes()",
      "head_type": "method",
      "relation": "have",
      "tail": "This method converts the number of bytes in this instance to megabytes.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "lazy loading",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap",
      "head_type": "class",
      "relation": "constrained_by",
      "tail": "circular aliases are prohibited",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap",
      "head_type": "class",
      "relation": "applied_to",
      "tail": "multiple aliases for a single name",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap",
      "head_type": "class",
      "relation": "have",
      "tail": "UnmodifiableMultiValueMap(MultiValueMap<? extends K, ? extends V> delegate)",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap",
      "head_type": "class",
      "relation": "have",
      "tail": "Unmodifiable wrapper for MultiValueMap",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap",
      "head_type": "class",
      "relation": "have",
      "tail": "Design principles include immutability and delegation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.core.SimpleAliasRegistryTests",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySet#clear()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "org.springframework.util.UnmodifiableEntrySet#clear()",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySet#clear()",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "UnsupportedOperationException",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySet#clear()",
      "head_type": "method",
      "relation": "have",
      "tail": "public void clear() { throw new UnsupportedOperationException(); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySet#clear()",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySet#clear()",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueSpliterator#estimateSize()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "estimation of size",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueSpliterator#estimateSize()",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.UnmodifiableValueSpliterator",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueSpliterator",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util",
      "tail_type": "package"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueSpliterator#estimateSize()",
      "head_type": "method",
      "relation": "have",
      "tail": "Delegate pattern",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueSpliterator#estimateSize()",
      "head_type": "method",
      "relation": "have",
      "tail": "Principle of least astonishment",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueSpliterator#estimateSize()",
      "head_type": "method",
      "relation": "have",
      "tail": "java\npublic class UnmodifiableValueSpliteratorExample {\n    public static void main(String[] args) {\n        UnmodifiableValueSpliterator spliterator = new UnmodifiableValueSpliterator();\n        long size = spliterator.estimateSize();\n        System.out.println(\"Estimated size: \" + size);\n    }\n}\n",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#currentNamespaceMapping()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "currentNamespaceMapping",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#currentNamespaceMapping()",
      "head_type": "method",
      "relation": "have",
      "tail": "currentNamespaceMapping",
      "tail_type": "useSampleCode"
    },
    {
      "head": "currentNamespaceMapping",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "private Map<String, String> currentNamespaceMapping() {\n    return this.namespaceMappings.get(this.namespaceMappings.size() - 1);\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLStreamReader",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getPrefix()",
      "tail_type": "apiFunction"
    },
    {
      "head": "getPrefix()",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "Parser must be on START_ELEMENT or END_ELEMENT state",
      "tail_type": "useConstraint"
    },
    {
      "head": "getPrefix()",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "getPrefix() useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "getPrefix() useSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "getPrefix() useSampleCode content",
      "tail_type": "content"
    },
    {
      "head": "org.springframework.util.xml.SimpleTransformErrorListener#error(TransformerException)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "handle XSLT transformation error",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.SimpleTransformErrorListener#error(TransformerException)",
      "head_type": "method",
      "relation": "have",
      "tail": "log XSLT transformation error",
      "tail_type": "useSampleCode"
    },
    {
      "head": "handle XSLT transformation error",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "TransformerException must be thrown",
      "tail_type": "useConstraint"
    },
    {
      "head": "handle XSLT transformation error",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "error handling in XSLT transformation",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.xml.SimpleTransformErrorListener#error(TransformerException)",
      "head_type": "method",
      "relation": "have",
      "tail": "related to logging and error handling",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.SimpleTransformErrorListener#error(TransformerException)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle of robust error handling",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.LocatorLocationAdapter#getLineNumber()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "get line number",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.LocatorLocationAdapter#getLineNumber()",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.xml.LocatorLocationAdapter#getLineNumber() returns the line number from the locator.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.LocatorLocationAdapter#getLineNumber()",
      "head_type": "method",
      "relation": "have",
      "tail": "public int getLineNumber() { return this.locator.getLineNumber(); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.LocatorLocationAdapter",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.LocatorLocationAdapter#getLineNumber()",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.xml.StaxEventXMLReader#handleNotationDeclaration(NotationDeclaration)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "handleNotationDeclaration",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxEventXMLReader#handleNotationDeclaration(NotationDeclaration)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.StaxEventXMLReader",
      "tail_type": "class"
    },
    {
      "head": "handleNotationDeclaration",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "handleNotationDeclaration",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "handleNotationDeclaration",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxEventXMLReader#handleEntityDeclaration(EntityDeclaration)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "handleEntityDeclaration",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxEventXMLReader#handleEntityDeclaration(EntityDeclaration)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.StaxEventXMLReader",
      "tail_type": "class"
    },
    {
      "head": "handleEntityDeclaration",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "handleEntityDeclaration",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "handleEntityDeclaration",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamHandler#endElementInternal(QName,Map<String,String>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "end XML element processing",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamHandler#endElementInternal(QName,Map<String,String>)",
      "head_type": "method",
      "relation": "have",
      "tail": "writes end element to the stream",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamHandler#endElementInternal(QName,Map<String,String>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.StaxStreamHandler",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamHandler#skippedEntityInternal(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "skipping internal entity",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamHandler#skippedEntityInternal(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamHandler#skippedEntityInternal(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamHandler#skippedEntityInternal(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamHandler#skippedEntityInternal(String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.StaxStreamHandler",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamXMLReader#handleStartElement()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "xml parsing",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamXMLReader#handleStartElement()",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "SAXException handling",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamXMLReader#handleStartElement()",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "namespace handling",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamXMLReader#handleStartElement()",
      "head_type": "method",
      "relation": "have",
      "tail": "namespace handling sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamXMLReader#handleStartElement()",
      "head_type": "method",
      "relation": "have",
      "tail": "related concept interpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamXMLReader#handleStartElement()",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle interpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamXMLReader#handleStartElement()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.StaxStreamXMLReader",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils#createCustomStaxResult(XMLEventWriter)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "createCustomStaxResult",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils#createCustomStaxResult(XMLEventWriter)",
      "head_type": "method",
      "relation": "have",
      "tail": "Create a custom, non-JAXP 1.4 StAX Result for the given XMLEventWriter.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils#createCustomStaxResult(XMLEventWriter)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is designed to wrap an XMLEventWriter into a custom StAX Result, which is not part of the JAXP 1.4 standard.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils#createCustomStaxResult(XMLEventWriter)",
      "head_type": "method",
      "relation": "have",
      "tail": "public static Result createCustomStaxResult(XMLEventWriter eventWriter) {\n    return new StaxResult(eventWriter);\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "createCustomStaxResult",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "XMLEventWriter",
      "tail_type": "useScenario"
    },
    {
      "head": "createCustomStaxResult",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "The input XMLEventWriter must be non-null.",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils#getXMLEventWriter(Result)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "XMLEventWriter retrieval",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils#getXMLEventWriter(Result)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "IllegalArgumentException on non-StAXResult",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils#getXMLEventWriter(Result)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "StAXResult handling",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils#getXMLEventWriter(Result)",
      "head_type": "method",
      "relation": "have",
      "tail": "Complete example for using getXMLEventWriter",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils#getXMLEventWriter(Result)",
      "head_type": "method",
      "relation": "have",
      "tail": "Explanation of StAXResult and XMLEventWriter",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils#getXMLEventWriter(Result)",
      "head_type": "method",
      "relation": "have",
      "tail": "Design principles behind getXMLEventWriter",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.StaxUtils#getXMLEventWriter(Result)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils#createContentHandler(XMLEventWriter)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "createContentHandler",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils#createContentHandler(XMLEventWriter)",
      "head_type": "method",
      "relation": "have",
      "tail": "Create a SAX ContentHandler that writes events to the given StAX XMLEventWriter.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils#createContentHandler(XMLEventWriter)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method facilitates the integration between SAX and StAX parsers by creating a ContentHandler that outputs to a StAX XMLEventWriter.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils#createContentHandler(XMLEventWriter)",
      "head_type": "method",
      "relation": "have",
      "tail": "public static ContentHandler createContentHandler(XMLEventWriter eventWriter) {\n    return new StaxEventHandler(eventWriter);\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "createContentHandler",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.StaxUtils",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "createContentHandler",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter#writeEmptyElement(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "write an empty XML element",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter#writeEmptyElement(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "writeEmptyElement(String) writes an empty XML element with the specified local name",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter#writeEmptyElement(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "The method writeEmptyElement(String) is used to generate an empty XML element with a specified local name",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter#writeEmptyElement(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "The design principle behind writeEmptyElement(String) is to provide a straightforward way to create empty XML elements, ensuring consistency and simplicity in XML document generation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "example.type.TestInterfaceImpl",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "lazy loading",
      "tail_type": "apiFunction"
    },
    {
      "head": "example.type.TestInterfaceImpl",
      "head_type": "class",
      "relation": "constrained_by",
      "tail": "circular aliases are prohibited",
      "tail_type": "useConstraint"
    },
    {
      "head": "example.type.TestInterfaceImpl",
      "head_type": "class",
      "relation": "applied_to",
      "tail": "multiple aliases for a single name",
      "tail_type": "useScenario"
    },
    {
      "head": "example.type.TestInterfaceImpl",
      "head_type": "class",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "example.type.TestInterfaceImpl",
      "head_type": "class",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "example.type.TestInterfaceImpl",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.core.SimpleAliasRegistryTests",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.DefaultGenerationContextTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getGeneratedClassesReturnsClassNameGenerator",
      "tail_type": "apiFunction"
    },
    {
      "head": "getGeneratedClassesReturnsClassNameGenerator",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "DefaultGenerationContext",
      "tail_type": "class"
    },
    {
      "head": "getGeneratedClassesReturnsClassNameGenerator",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "void getGeneratedClassesReturnsClassNameGenerator() { DefaultGenerationContext context = new DefaultGenerationContext(this.generatedClasses, this.generatedFiles, this.runtimeHints); assertThat(context.getGeneratedClasses()).isSameAs(this.generatedClasses); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#createLocalMethodReference(String,TypeName)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "createLocalMethodReference",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#createLocalMethodReference(String,TypeName)",
      "head_type": "method",
      "relation": "have",
      "tail": "createLocalMethodReference sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "createLocalMethodReference sample code",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "private MethodReference createLocalMethodReference(String name, TypeName... argumentTypes) {\n    return createMethodReference(name, argumentTypes, null);\n}",
      "tail_type": "code"
    },
    {
      "head": "org.springframework.aot.generate.FileSystemGeneratedFilesTests#handleFileWhenFileExistsProvidesFileHandler()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "fileHandling",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.FileSystemGeneratedFilesTests#handleFileWhenFileExistsProvidesFileHandler()",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "fileExistenceVerification",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.aot.generate.FileSystemGeneratedFilesTests#handleFileWhenFileExistsProvidesFileHandler()",
      "head_type": "method",
      "relation": "have",
      "tail": "fileExistenceVerificationSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "fileExistenceVerificationSampleCode",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.FileSystemGeneratedFilesTests#handleFileWhenFileExistsProvidesFileHandler()",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.aot.generate.FileSystemGeneratedFilesTests#handleFileWhenFileExistsProvidesFileHandler()",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.FileSystemGeneratedFilesTests#handleFileWhenFileExistsProvidesFileHandler()",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassTests#generateJavaFileOnInnerClassThrowsException()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "generateJavaFile",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassTests#generateJavaFileOnInnerClassThrowsException()",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "inner class exception",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassTests#generateJavaFileOnInnerClassThrowsException()",
      "head_type": "method",
      "relation": "have",
      "tail": "void generateJavaFileOnInnerClassThrowsException() { ... }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassTests#generateJavaFileOnInnerClassThrowsException()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.GeneratedClass",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassTests#generateJavaFileOnInnerClassThrowsException()",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassTests#generateJavaFileOnInnerClassThrowsException()",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.MethodNameTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "MethodName.of",
      "tail_type": "apiFunction"
    },
    {
      "head": "MethodName.of",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "parts must not be null",
      "tail_type": "useConstraint"
    },
    {
      "head": "MethodName.of",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "create method name from parts",
      "tail_type": "useScenario"
    },
    {
      "head": "MethodName.of",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "sample code for MethodName.of",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.MethodNameTests",
      "head_type": "class",
      "relation": "have",
      "tail": "related concept interpretation for MethodName.of",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.MethodNameTests",
      "head_type": "class",
      "relation": "have",
      "tail": "design principle interpretation for MethodName.of",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "MethodName.of",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "MethodName",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.MethodNameTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "MethodName.and",
      "tail_type": "apiFunction"
    },
    {
      "head": "MethodName.and",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "parts must not be null",
      "tail_type": "useConstraint"
    },
    {
      "head": "MethodName.and",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "append parts to method name",
      "tail_type": "useScenario"
    },
    {
      "head": "MethodName.and",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "sample code for MethodName.and",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.MethodNameTests",
      "head_type": "class",
      "relation": "have",
      "tail": "related concept interpretation for MethodName.and",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.MethodNameTests",
      "head_type": "class",
      "relation": "have",
      "tail": "design principle interpretation for MethodName.and",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "MethodName.and",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "MethodName",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.MethodNameTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "MethodName.hashCodeAndEquals",
      "tail_type": "apiFunction"
    },
    {
      "head": "MethodName.hashCodeAndEquals",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "check method name equality",
      "tail_type": "useScenario"
    },
    {
      "head": "MethodName.hashCodeAndEquals",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "sample code for MethodName.hashCodeAndEquals",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.MethodNameTests",
      "head_type": "class",
      "relation": "have",
      "tail": "related concept interpretation for MethodName.hashCodeAndEquals",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.MethodNameTests",
      "head_type": "class",
      "relation": "have",
      "tail": "design principle interpretation for MethodName.hashCodeAndEquals",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "MethodName.hashCodeAndEquals",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "MethodName",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.ExceptionTests#generateWhenListOfUnsupportedElement()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "generateCode",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.ExceptionTests#generateWhenListOfUnsupportedElement()",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "UnsupportedElementList",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.aot.generate.ExceptionTests#generateWhenListOfUnsupportedElement()",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "CodeGenerationErrorHandling",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.aot.generate.ExceptionTests#generateWhenListOfUnsupportedElement()",
      "head_type": "method",
      "relation": "have",
      "tail": "generateWhenListOfUnsupportedElement() Sample Code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.ExceptionTests#generateWhenListOfUnsupportedElement()",
      "head_type": "method",
      "relation": "have",
      "tail": "Code Generation Error Handling Explanation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.ExceptionTests#generateWhenListOfUnsupportedElement()",
      "head_type": "method",
      "relation": "have",
      "tail": "Robust Code Generation Design",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.ExceptionTests#generateWhenListOfUnsupportedElement()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.ValueCodeGenerationException",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#process(Class<?>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "register runtime hints",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#process(Class<?>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.hint.RuntimeHints",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#process(Class<?>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrar",
      "tail_type": "class"
    },
    {
      "head": "register runtime hints",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "register runtime hints",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "register runtime hints",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.hint.annotation.SampleTypeAndFieldAnnotatedBean",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "reflectiveAnnotationUsage",
      "tail_type": "apiFunction"
    },
    {
      "head": "reflectiveAnnotationUsage",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "reflectiveAnnotationUsage",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "reflectiveAnnotationUsage",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.hint.annotation.RegisterReflectionForBindingProcessorTests#registerReflectionForBindingOnMethod()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "registerReflectionHints",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.hint.annotation.RegisterReflectionForBindingProcessorTests#registerReflectionForBindingOnMethod()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "MethodLevelAnnotatedBean.class.getMethod(\"method\")",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.hint.annotation.RegisterReflectionForBindingProcessorTests#registerReflectionForBindingOnMethod()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "RuntimeHintsPredicates.reflection().onType(SampleClassWithGetter.class)",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.hint.annotation.RegisterReflectionForBindingProcessorTests#registerReflectionForBindingOnMethod()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "RuntimeHintsPredicates.reflection().onType(String.class)",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.hint.annotation.RegisterReflectionForBindingProcessorTests#registerReflectionForBindingOnMethod()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "RuntimeHintsPredicates.reflection().onMethodInvocation(SampleClassWithGetter.class, \"getName\")",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.hint.annotation.RegisterReflectionForBindingProcessorTests#registerReflectionForBindingOnMethod()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "SampleClassWithGetter",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.hint.annotation.RegisterReflectionForBindingProcessorTests#registerReflectionForBindingOnMethod()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "String",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.hint.annotation.RegisterReflectionForBindingProcessorTests#registerReflectionForBindingOnMethod()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "MethodLevelAnnotatedBean",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.hint.annotation.RegisterReflectionForBindingProcessorTests#registerReflectionForBindingOnMethod()",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.hint.annotation.RegisterReflectionForBindingProcessorTests#registerReflectionForBindingOnMethod()",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.hint.annotation.RegisterReflectionForBindingProcessorTests#registerReflectionForBindingOnMethod()",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#isPattern(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "pattern matching",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#isPattern(String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "null input returns false",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#isPattern(String)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "checking if a string is a pattern",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#isPattern(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for isPattern method",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#isPattern(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "interpretation of pattern matching",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#isPattern(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle of isPattern method",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#isPattern(String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.AntPathMatcher",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#tokenizePath(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "tokenizePath",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#tokenizePath(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "Tokenize the given path into parts, based on this matcher's settings.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "tokenizePath",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "Tokenize the given path into parts, based on this matcher's settings.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#tokenizePath(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "protected String[] tokenizePath(String path) {\n    return StringUtils.tokenizeToStringArray(path, this.pathSeparator, this.trimTokens, true);\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.PatternInfo#getDoubleWildcards()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getDoubleWildcards",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.PatternInfo#getDoubleWildcards()",
      "head_type": "method",
      "relation": "have",
      "tail": "public int getDoubleWildcards() { return this.doubleWildcards; }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.PatternInfo",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.PatternInfo#getDoubleWildcards()",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.PatternInfo#getDoubleWildcards()",
      "head_type": "method",
      "relation": "designPrincipleInterpretation",
      "tail": "Encapsulation of internal state, providing controlled access through methods.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.backoff.ExponentialBackOffExecution#computeNextInterval()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "computeNextInterval",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.backoff.ExponentialBackOffExecution#computeNextInterval()",
      "head_type": "method",
      "relation": "have",
      "tail": "Calculate the next backoff interval",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.backoff.ExponentialBackOffExecution#computeNextInterval()",
      "head_type": "method",
      "relation": "have",
      "tail": "Ensure the backoff interval does not exceed the maximum interval",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.backoff.ExponentialBackOffExecution#computeNextInterval()",
      "head_type": "method",
      "relation": "have",
      "tail": "package com.healthMgr.common.email; import java.xxxx; public class OneClass { private long computeNextInterval() { long maxInterval = getMaxInterval(); if (this.currentInterval >= maxInterval) { return maxInterval; } else if (this.currentInterval < 0) { long initialInterval = getInitialInterval(); this.currentInterval = Math.min(initialInterval, maxInterval); } else { this.currentInterval = multiplyInterval(maxInterval); } return this.currentInterval; } }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ClassUtils#getAllInterfacesForClassAsSet(Class<?>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getAllInterfacesForClassAsSet",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ClassUtils#getAllInterfacesForClassAsSet(Class<?>)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "class analysis for interfaces",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ClassUtils#getAllInterfacesForClassAsSet(Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.ClassUtils",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.ClassUtils#getAllInterfacesForClassAsSet(Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#getAllInterfacesForClassAsSet(Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#getAllInterfacesForClassAsSet(Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ClassUtils#getMethod(Class<?>,String,Class<?>...)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getMethod",
      "tail_type": "apiFunction"
    },
    {
      "head": "getMethod",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "Expected method not found",
      "tail_type": "useConstraint"
    },
    {
      "head": "getMethod",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "unique method retrieval",
      "tail_type": "useScenario"
    },
    {
      "head": "getMethod",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "public method retrieval",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "getMethod",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "exception translation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "getMethod",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ClassUtils",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "getMethod",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.CollectionUtils#newLinkedHashMap(int)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "Instantiate a new LinkedHashMap",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.CollectionUtils#newLinkedHashMap(int)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "expected number of elements",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.CollectionUtils#newLinkedHashMap(int)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "avoid resize/rehash operations",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.CollectionUtils#newLinkedHashMap(int)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for newLinkedHashMap",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.CollectionUtils#newLinkedHashMap(int)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "LinkedHashMap",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.CollectionUtils#newLinkedHashMap(int)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "LinkedCaseInsensitiveMap",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.CollectionUtils#newLinkedHashMap(int)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "LinkedMultiValueMap",
      "tail_type": "class"
    },
    {
      "head": "sample code for newLinkedHashMap",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "complete example for newLinkedHashMap",
      "tail_type": "useSampleCode"
    },
    {
      "head": "Instantiate a new LinkedHashMap",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "explanation of instantiating LinkedHashMap",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "avoid resize/rehash operations",
      "head_type": "useScenario",
      "relation": "have",
      "tail": "design principles of resize/rehash",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.comparator.Comparators#comparable()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "Comparable adapter",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.comparator.Comparators#comparable()",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "Return a Comparable adapter",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.comparator.Comparators#comparable()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "Comparator#naturalOrder()",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.comparator.Comparators#comparable()",
      "head_type": "method",
      "relation": "have",
      "tail": "Return a Comparable adapter",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.comparator.Comparators#comparable()",
      "head_type": "method",
      "relation": "have",
      "tail": "Return a Comparable adapter",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.comparator.Comparators#comparable()",
      "head_type": "method",
      "relation": "have",
      "tail": "package com.comparator; import java.util.Comparator; public class ComparableAdapter { public static <T> Comparator<T> comparable() { return (Comparator<T>) Comparator.naturalOrder(); } }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.comparator.Comparators#nullsLow()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "nullsLow",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.comparator.Comparators#nullsLow()",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "null values and sorts them lower than non-null values",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.comparator.Comparators#nullsLow()",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "comparable adapter",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.comparator.Comparators#nullsLow()",
      "head_type": "method",
      "relation": "have",
      "tail": "Return a Comparable adapter which accepts null values and sorts them lower than non-null values.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.comparator.Comparators#nullsLow()",
      "head_type": "method",
      "relation": "have",
      "tail": "The design principle behind this method is to provide a utility for sorting which gracefully handles null values, ensuring that they are considered lower than any non-null values. This is particularly useful in scenarios where data may contain nulls and a consistent sorting behavior is desired.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.comparator.Comparators#nullsLow()",
      "head_type": "method",
      "relation": "have",
      "tail": "package com.healthMgr.common.email; import java.util.Comparator; public class OneClass { public static void main(String[] args) { Comparator<String> comparator = Comparator.nullsLow(); String[] strings = {null, \"apple\", \"banana\", null}; Arrays.sort(strings, comparator); System.out.println(Arrays.toString(strings)); } }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.comparator.Comparators#nullsLow()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "Comparator",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.CompositeCollection#contains(Object)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "check containment",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.CompositeCollection#contains(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "check if an object is contained in the first collection",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.CompositeCollection#contains(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "return true if the object is contained in the first collection; otherwise, check the second collection",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.CompositeCollection#contains(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "package com.example.demo; import java.util.Arrays; import java.util.Collection; import org.springframework.util.CompositeCollection; public class Main { public static void main(String[] args) { Collection<Integer> first = Arrays.asList(1, 2, 3); Collection<Integer> second = Arrays.asList(4, 5, 6); CompositeCollection<Integer> composite = new CompositeCollection<>(first, second); System.out.println(composite.contains(1)); System.out.println(composite.contains(7)); } }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.CompositeCollection#contains(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method checks if the provided object is contained within the composite collection. It first checks the first collection, and if not found, it checks the second collection.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.CompositeCollection#contains(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "The design principle followed here is to provide a convenient way to work with multiple collections as a single entity, enhancing code readability and maintainability.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.CompositeMap#get(Object)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": " retrieval of values based on keys",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.CompositeMap#get(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method retrieves a value to which the specified key is mapped in this CompositeMap or its backing maps.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.CompositeMap#get(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "The method first attempts to retrieve the value from the first map. If the key is not found, it then attempts to retrieve the value from the second map.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.CompositeMap#get(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "package com.example.demo;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport org.springframework.util.CompositeMap;\n\npublic class CompositeMapExample {\n    public static void main(String[] args) {\n        Map<String, Integer> firstMap = new HashMap<>();\n        firstMap.put(\"one\", 1);\n        firstMap.put(\"two\", 2);\n\n        Map<String, Integer> secondMap = new HashMap<>();\n        secondMap.put(\"three\", 3);\n        secondMap.put(\"four\", 4);\n\n        CompositeMap<String, Integer> compositeMap = new CompositeMap<>(firstMap, secondMap);\n\n        System.out.println(\"Value for 'one': \" + compositeMap.get(\"one\"));\n        System.out.println(\"Value for 'three': \" + compositeMap.get(\"three\"));\n        System.out.println(\"Value for 'five' (not present): \" + compositeMap.get(\"five\"));\n    }\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.CompositeMap#putAll(Map<? extends K,? extends V>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "putAllFunction",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.CompositeMap#putAll(Map<? extends K,? extends V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "putAllFunction accept(Map<K, V>)",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.CompositeMap#putAll(Map<? extends K,? extends V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "put(K key, V value)",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.CompositeMap#putAll(Map<? extends K,? extends V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.CompositeMap#putAll(Map<? extends K,? extends V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ConcurrentReferenceHashMap#createReferenceManager()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "createReferenceManager",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ConcurrentReferenceHashMap#createReferenceManager()",
      "head_type": "method",
      "relation": "have",
      "tail": "Factory method that returns the ReferenceManager",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ConcurrentReferenceHashMap#createReferenceManager()",
      "head_type": "method",
      "relation": "have",
      "tail": "This method will be called once for each Segment",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ConcurrentReferenceHashMap#createReferenceManager()",
      "head_type": "method",
      "relation": "have",
      "tail": "protected ReferenceManager createReferenceManager() { return new ReferenceManager(); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ConcurrentReferenceHashMap#createReferenceManager()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "ReferenceManager",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.ConcurrentReferenceHashMap#createReferenceManager()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "Segment",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.Segment#getSize()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "return the size of the current references array",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.Segment",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.Segment#getSize()",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.Segment#getSize()",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.Reference#get()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "return referenced entry",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.Reference#get()",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "entry availability",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.Reference#get()",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.Reference",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.Reference",
      "head_type": "class",
      "relation": "have",
      "tail": "org.springframework.util.Reference#get()",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.Reference#get()",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.Reference#get()",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.EntryIterator#hasNext()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "checkNextElement",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.EntryIterator#hasNext()",
      "head_type": "method",
      "relation": "have",
      "tail": "ensures that the next element is ready to be returned",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.EntryIterator#hasNext()",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle of lazy loading",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.EntryIterator#hasNext()",
      "head_type": "method",
      "relation": "have",
      "tail": "public boolean hasNext() { getNextIfNecessary(); return (this.next != null); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.CustomizableThreadCreator#getThreadNamePrefix()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getThreadNamePrefix",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.CustomizableThreadCreator#getThreadNamePrefix()",
      "head_type": "method",
      "relation": "have",
      "tail": "Return the thread name prefix to use for the names of newly created threads.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "getThreadNamePrefix",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "Return the thread name prefix to use for the names of newly created threads.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.CustomizableThreadCreator",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.CustomizableThreadCreator#getThreadNamePrefix()",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.CustomizableThreadCreator#getThreadNamePrefix()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.CustomizableThreadCreator",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.DefaultPropertiesPersister#storeToXml(Properties,OutputStream,String,String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "store properties to XML",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.DefaultPropertiesPersister#storeToXml(Properties,OutputStream,String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "storeToXml sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "storeToXml sample code",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "complete example of storeToXml",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.DigestUtils#getDigest(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "create MessageDigest",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.DigestUtils#getDigest(String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "thread-safety",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.DigestUtils#getDigest(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "relatedConceptInterpretation",
      "head_type": "relatedConceptInterpretation",
      "relation": "associated_with",
      "tail": "MessageDigest",
      "tail_type": "class"
    },
    {
      "head": "relatedConceptInterpretation",
      "head_type": "relatedConceptInterpretation",
      "relation": "associated_with",
      "tail": "thread-safety",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.DigestUtils#getDigest(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.DigestUtils#digestAsHexChars(String,byte[])",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "convert byte array to hexadecimal string",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.DigestUtils#digestAsHexChars(String,byte[])",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.DigestUtils#digestAsHexChars(String,byte[])",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.DigestUtils#digestAsHexChars(String,byte[])",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.DigestUtils#digestAsHexChars(String,byte[])",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.DigestUtils",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.FastByteArrayOutputStream#getInputStream()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getInputStream",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.FastByteArrayOutputStream#getInputStream()",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "undefinedBehaviorAfterMethodCall",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.FastByteArrayOutputStream#getInputStream()",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "retrieveContents",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.FastByteArrayOutputStream#getInputStream()",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.FastByteArrayOutputStream#getInputStream()",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.FastByteArrayOutputStream#getInputStream()",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.FastByteArrayOutputStream#getInputStream()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.FastByteArrayOutputStream",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.FastByteArrayInputStream#read(byte[],int,int)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "read data from byte array",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.FastByteArrayInputStream#read(byte[],int,int)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "offset and length must be non-negative and within array bounds",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.FastByteArrayInputStream#read(byte[],int,int)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "reading data from a stream",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.FastByteArrayInputStream#read(byte[],int,int)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for reading data from byte array",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.FastByteArrayInputStream#read(byte[],int,int)",
      "head_type": "method",
      "relation": "have",
      "tail": "interpretation of related concepts for reading data from byte array",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.FastByteArrayInputStream#read(byte[],int,int)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle interpretation for reading data from byte array",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.FastByteArrayInputStream#read(byte[],int,int)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.FastByteArrayInputStream",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.FastByteArrayInputStream#updateCurrentBufferLength()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "update current buffer length",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.FastByteArrayInputStream#updateCurrentBufferLength()",
      "head_type": "method",
      "relation": "have",
      "tail": "updateCurrentBufferLength() updates the length of the current buffer based on the current state of the FastByteArrayOutputStream.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.FastByteArrayInputStream#updateCurrentBufferLength()",
      "head_type": "method",
      "relation": "have",
      "tail": "The method ensures that the currentBufferLength is correctly set, reflecting the current buffer's length or the index of the FastByteArrayOutputStream if it's the last buffer.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.FastByteArrayInputStream#updateCurrentBufferLength()",
      "head_type": "method",
      "relation": "have",
      "tail": "private void updateCurrentBufferLength() {\n    if (this.currentBuffer == this.fastByteArrayOutputStream.buffers.getLast()) {\n        this.currentBufferLength = this.fastByteArrayOutputStream.index;\n    } else {\n        this.currentBufferLength = (this.currentBuffer != null ? this.currentBuffer.length : 0);\n    }\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.FastByteArrayInputStream",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.FastByteArrayOutputStream",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.FileSystemUtils#deleteRecursively(Path)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "delete directory recursively",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.FileSystemUtils#deleteRecursively(Path)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "IOException may occur",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.FileSystemUtils#deleteRecursively(Path)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "deleting directories and files",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.FileSystemUtils#deleteRecursively(Path)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for deleting directories and files",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.FileSystemUtils#deleteRecursively(Path)",
      "head_type": "method",
      "relation": "have",
      "tail": "explanation of recursive deletion",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.FileSystemUtils#deleteRecursively(Path)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle behind recursive deletion",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "delete directory recursively",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "org.springframework.util.FileSystemUtils",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.FilteredMap",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "filtered_map",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.FilteredMap",
      "head_type": "class",
      "relation": "constrained_by",
      "tail": "predicate_requirement",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.FilteredMap",
      "head_type": "class",
      "relation": "applied_to",
      "tail": "composite_map_usage",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.FilteredMap",
      "head_type": "class",
      "relation": "have",
      "tail": "filtered_map_sample_code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.FilteredMap",
      "head_type": "class",
      "relation": "have",
      "tail": "filtered_map_concept",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.FilteredMap",
      "head_type": "class",
      "relation": "have",
      "tail": "filtered_map_design_principle",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.FilteredMap",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.CompositeMap",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.function.ThrowingConsumer",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "acceptWithException",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.function.ThrowingConsumer",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "accept",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.function.ThrowingConsumer",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "throwing",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.function.ThrowingConsumer",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "of",
      "tail_type": "apiFunction"
    },
    {
      "head": "acceptWithException",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "accept",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "throwing",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "of",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.function.ThrowingConsumer",
      "head_type": "class",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.function.ThrowingConsumer",
      "head_type": "class",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.function.ThrowingSupplier#of(ThrowingSupplier<T>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "create ThrowingSupplier",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.function.ThrowingSupplier#of(ThrowingSupplier<T>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "lambda expression or method reference must throw a checked exception",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.function.ThrowingSupplier#of(ThrowingSupplier<T>)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "working with method references",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.function.ThrowingSupplier#of(ThrowingSupplier<T>)",
      "head_type": "method",
      "relation": "have",
      "tail": "optional.orElseGet(ThrowingSupplier.of(Example::methodThatCanThrowCheckedException));",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.function.ThrowingSupplier#of(ThrowingSupplier<T>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.function.ThrowingSupplier",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.function.ThrowingSupplier#of(ThrowingSupplier<T>)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is a convenience method for creating a ThrowingSupplier instance. It wraps any checked exception thrown by the supplied lambda expression or method reference.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.function.ThrowingSupplier#of(ThrowingSupplier<T>)",
      "head_type": "method",
      "relation": "have",
      "tail": "The design principle of this method is to provide a convenient way to create a ThrowingSupplier instance that can handle checked exceptions. It enhances code readability and maintainability by allowing the use of lambda expressions and method references.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.InstanceFilter",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "instance filtering",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.InstanceFilter",
      "head_type": "class",
      "relation": "constrained_by",
      "tail": "instances must not be null",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.InstanceFilter",
      "head_type": "class",
      "relation": "applied_to",
      "tail": "matching instances based on includes and excludes collections",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.InstanceFilter",
      "head_type": "class",
      "relation": "have",
      "tail": "sample code for filtering instances",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.InstanceFilter",
      "head_type": "class",
      "relation": "have",
      "tail": "explanation of instance filtering",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.InstanceFilter",
      "head_type": "class",
      "relation": "have",
      "tail": "design principles of InstanceFilter",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.InstanceFilter",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.Assert",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.InstanceFilter",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "java.util.Collection",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.InstanceFilter",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "java.lang.Object",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.LinkedCaseInsensitiveMap#remove(Object)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "caseInsensitiveRemoval",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.LinkedCaseInsensitiveMap#remove(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "Handles case-insensitive key removal from the map.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.LinkedCaseInsensitiveMap#remove(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "public V remove(Object key) {\n    if (key instanceof String string) {\n        String caseInsensitiveKey = removeCaseInsensitiveKey(string);\n        if (caseInsensitiveKey != null) {\n            return this.targetMap.remove(caseInsensitiveKey);\n        }\n    }\n    return null;\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.LinkedCaseInsensitiveMap#removeEldestEntry(Map.Entry<String,V>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "removeEldestEntry",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.LinkedCaseInsensitiveMap#removeEldestEntry(Map.Entry<String,V>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "entryTypeConstraint",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.LinkedCaseInsensitiveMap#removeEldestEntry(Map.Entry<String,V>)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "mapSizeManagement",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.LinkedCaseInsensitiveMap#removeEldestEntry(Map.Entry<String,V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "mapSizeManagementSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.LinkedCaseInsensitiveMap#removeEldestEntry(Map.Entry<String,V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "mapSizeManagementConcept",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.LinkedCaseInsensitiveMap#removeEldestEntry(Map.Entry<String,V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleOfRemoveEldestEntry",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.LinkedCaseInsensitiveMap#removeEldestEntry(Map.Entry<String,V>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "LinkedHashMap",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.Values#iterator()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "iterator",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.Values#iterator()",
      "head_type": "method",
      "relation": "have",
      "tail": "ValuesIterator",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.Values#iterator()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.Values",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.ObjectUtils",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "nullSafeHashCode(float[])",
      "tail_type": "apiFunction"
    },
    {
      "head": "nullSafeHashCode(float[])",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "deprecated as of 6.1",
      "tail_type": "useConstraint"
    },
    {
      "head": "nullSafeHashCode(float[])",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "return a hash code based on the contents of the specified array",
      "tail_type": "useScenario"
    },
    {
      "head": "nullSafeHashCode(float[])",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "public static int nullSafeHashCode(float @Nullable [] array) { return Arrays.hashCode(array); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "nullSafeHashCode(float[])",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "nullSafeHashCode(float[])",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ObjectUtils",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "java.util.Arrays",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.PathMatcher#match(String,String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "path matching",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.PathMatcher#match(String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is used to match a given path against a specified pattern. It returns true if the path matches the pattern, otherwise it returns false.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.PathMatcher#match(String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "The design principle behind this method is to provide a flexible and efficient way to match paths against patterns, which is essential for routing and URL mapping in web applications.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.PathMatcher#match(String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "public boolean match(String pattern, String path) {\n    // Implementation details go here\n    return true; // or false based on the match\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.PartResolutionContext#flagPlaceholderAsVisited(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "flagging placeholders as visited",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.PartResolutionContext#flagPlaceholderAsVisited(String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "avoiding circular placeholder references",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.PartResolutionContext#flagPlaceholderAsVisited(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "managing placeholder resolution",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.PartResolutionContext#flagPlaceholderAsVisited(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "ensuring placeholders are only visited once",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.PartResolutionContext#flagPlaceholderAsVisited(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "public void flagPlaceholderAsVisited(String placeholder) {\n    if (this.visitedPlaceholders == null) {\n        this.visitedPlaceholders = new HashSet<>(4);\n    }\n    if (!this.visitedPlaceholders.add(placeholder)) {\n        throw new PlaceholderResolutionException(\"Circular placeholder reference '%s'\".formatted(placeholder), placeholder, null);\n    }\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ReflectionUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "USER_DECLARED_METHODS",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ReflectionUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "COPYABLE_FIELDS",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ReflectionUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "CGLIB_RENAMED_METHOD_PREFIX",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ReflectionUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "handleReflectionException",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ReflectionUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "handleInvocationTargetException",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ReflectionUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "rethrowRuntimeException",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ReflectionUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "rethrowException",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ReflectionUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "accessibleConstructor",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ReflectionUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "makeAccessible",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ReflectionUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "findMethod",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ReflectionUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "hasSameParams",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ReflectionUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "invokeMethod",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ReflectionUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "declaresException",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ReflectionUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "doWithLocalMethods",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ReflectionUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "doWithMethods",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ReflectionUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "doWithMethods",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ReflectionUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "getAllDeclaredMethods",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ReflectionUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "getUniqueDeclaredMethods",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ReflectionUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "getDeclaredMethods",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ReflectionUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "findDefaultMethodsOnInterfaces",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ReflectionUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "isEqualsMethod",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ReflectionUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "isHashCodeMethod",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ReflectionUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "isToStringMethod",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ReflectionUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "isObjectMethod",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ReflectionUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "isCglibRenamedMethod",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ReflectionUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "makeAccessible",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ReflectionUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "findField",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ReflectionUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "findField",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ReflectionUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "findFieldIgnoreCase",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ReflectionUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "setField",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ReflectionUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "getField",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ReflectionUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "doWithLocalFields",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ReflectionUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "doWithFields",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ReflectionUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "doWithFields",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ReflectionUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "getDeclaredFields",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ReflectionUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "shallowCopyFieldState",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ReflectionUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "isPublicStaticFinal",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ReflectionUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "makeAccessible",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ReflectionUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "clearCache",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ReflectionUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "MethodCallback",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ReflectionUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "MethodFilter",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ReflectionUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "FieldCallback",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ReflectionUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "FieldFilter",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#accessibleConstructor(Class<T>,Class<?>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "Obtain accessible constructor",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#accessibleConstructor(Class<T>,Class<?>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "NoSuchMethodException if no such constructor exists",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#accessibleConstructor(Class<T>,Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "relatedConceptInterpretation",
      "head_type": "relatedConceptInterpretation",
      "relation": "have",
      "tail": "Reflection: The process of inspecting and modifying a class's structure at runtime.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#accessibleConstructor(Class<T>,Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "useSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "package com.example;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Method;\n\npublic class ReflectionExample {\n    public static void main(String[] args) {\n        try {\n            Constructor<SampleClass> constructor = ReflectionUtils.accessibleConstructor(SampleClass.class, String.class);\n            SampleClass instance = constructor.newInstance(\"example\");\n            System.out.println(instance.getMessage());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n\nclass SampleClass {\n    private String message;\n\n    public SampleClass(String message) {\n        this.message = message;\n    }\n\n    public String getMessage() {\n        return message;\n    }\n}",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#isCglibRenamedMethod(Method)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "CGLIB renamed method detection",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#isCglibRenamedMethod(Method)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "Method must follow CGLIB renaming pattern",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#isCglibRenamedMethod(Method)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "Checking if a method is renamed by CGLIB",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#isCglibRenamedMethod(Method)",
      "head_type": "method",
      "relation": "have",
      "tail": "package com.example;\n\nimport org.springframework.util.ReflectionUtils;\n\npublic class Example {\n    public static void main(String[] args) {\n        // Example usage of isCglibRenamedMethod\n        try {\n            Method method = Example.class.getMethod(\"exampleMethod\");\n            boolean isRenamed = ReflectionUtils.isCglibRenamedMethod(method);\n            System.out.println(\"Is method renamed by CGLIB? \" + isRenamed);\n        } catch (NoSuchMethodException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void exampleMethod() {\n        // Example method\n    }\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#isCglibRenamedMethod(Method)",
      "head_type": "method",
      "relation": "have",
      "tail": "CGLIB (Code Generation Library) is a powerful bytecode manipulation library that allows developers to extend and modify Java classes at runtime. Renamed methods in CGLIB follow a specific pattern to avoid naming conflicts, typically by prefixing the method name with 'CGLIB$'. This function checks if a given method adheres to this pattern, indicating it has been renamed by CGLIB.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#isCglibRenamedMethod(Method)",
      "head_type": "method",
      "relation": "have",
      "tail": "The design principle behind this method is to provide a utility for identifying methods that have been renamed by CGLIB during runtime bytecode enhancement. This is crucial for frameworks and libraries that rely on CGLIB for dynamic code generation, ensuring that method invocations are correctly handled even when method names are altered. The method encapsulates the logic to detect CGLIB's renaming pattern, abstracting this complexity away from the user.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#getDeclaredFields(Class<?>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "caching",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#getDeclaredFields(Class<?>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "class must not be null",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#getDeclaredFields(Class<?>)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "introspection",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#getDeclaredFields(Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "This variant retrieves Class#getDeclaredFields() from a local cache in order to avoid defensive array copying.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#getDeclaredFields(Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method optimizes the retrieval of declared fields by caching them, reducing the overhead of repeated introspection.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#getDeclaredFields(Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "package com.healthMgr.common.email; import java.lang.reflect.Field; import java.util.HashMap; import java.util.Map; import org.springframework.util.ReflectionUtils; public class OneClass { public static void main(String[] args) { Class<?> clazz = OneClass.class; Field[] fields = ReflectionUtils.getDeclaredFields(clazz); for (Field field : fields) { System.out.println(field.getName()); } } }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#getDeclaredFields(Class<?>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "Class<?> clazz",
      "tail_type": "class"
    },
    {
      "head": "caching",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "This variant retrieves Class#getDeclaredFields() from a local cache in order to avoid defensive array copying.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "introspection",
      "head_type": "useScenario",
      "relation": "have",
      "tail": "This variant retrieves Class#getDeclaredFields() from a local cache in order to avoid defensive array copying.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.MethodFilter#and(MethodFilter)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "composite filter creation",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MethodFilter#and(MethodFilter)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "MethodFilter argument must not be null",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.MethodFilter#and(MethodFilter)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "applying multiple filters sequentially",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.MethodFilter#and(MethodFilter)",
      "head_type": "method",
      "relation": "have",
      "tail": "Create a composite filter based on this filter <em>and</em> the provided filter. <p>If this filter does not match, the next filter will not be applied.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.MethodFilter#and(MethodFilter)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is designed to create a composite filter that combines the current filter with another provided filter. It ensures that the next filter is only applied if the current filter matches. This design adheres to the principle of short-circuiting, where subsequent conditions are not evaluated if a prior condition fails, enhancing performance and efficiency.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.MethodFilter#and(MethodFilter)",
      "head_type": "method",
      "relation": "have",
      "tail": "package com.healthMgr.common.email; import java.xxxx; public class OneClass { // specific code }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.MethodFilter#and(MethodFilter)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.core.SimpleAliasRegistryTests",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.ResourceUtils#isJarFileURL(URL)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "check if URL points to a jar file",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ResourceUtils#isJarFileURL(URL)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "URL must have 'file' protocol and end with '.jar' extension",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ResourceUtils#isJarFileURL(URL)",
      "head_type": "method",
      "relation": "have",
      "tail": "Used to determine if a given URL points to a JAR file",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ResourceUtils#isJarFileURL(URL)",
      "head_type": "method",
      "relation": "have",
      "tail": "Design principle: simplicity and clarity in checking file types",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ResourceUtils#isJarFileURL(URL)",
      "head_type": "method",
      "relation": "have",
      "tail": "public static boolean isJarFileURL(URL url) {\n    return (URL_PROTOCOL_FILE.equals(url.getProtocol()) && url.getPath().toLowerCase(Locale.ROOT).endsWith(JAR_FILE_EXTENSION));\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.SingleToMultiValueMapAdapter#add(K,V)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "add elements to map",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.SingleToMultiValueMapAdapter#add(K,V)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "Duplicate key is not allowed",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.SingleToMultiValueMapAdapter#add(K,V)",
      "head_type": "method",
      "relation": "have",
      "tail": "Adding elements to a map when the key does not exist",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.SingleToMultiValueMapAdapter#add(K,V)",
      "head_type": "method",
      "relation": "have",
      "tail": "public void add(K key, @Nullable V value) { if (!this.targetMap.containsKey(key)) { this.targetMap.put(key, value); } else { throw new UnsupportedOperationException(\"Duplicate key: \" + key); } }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.SingleToMultiValueMapAdapter#add(K,V)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is used to add elements to a map. If the key does not exist in the map, the key-value pair is added. If the key already exists, an UnsupportedOperationException is thrown.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.SingleToMultiValueMapAdapter#add(K,V)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method follows the principle of ensuring that each key in the map is unique. It prevents the addition of duplicate keys, maintaining the integrity of the map.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.SingleToMultiValueMapAdapter#add(K,V)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.SingleToMultiValueMapAdapter",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.unit.DataSize#toString()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "convertDataSizeToString",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.unit.DataSize#toString()",
      "head_type": "method",
      "relation": "have",
      "tail": "Converts the data size to a string representation.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.unit.DataSize#toString()",
      "head_type": "method",
      "relation": "have",
      "tail": "public String toString() { return String.format(\"%dB\", this.bytes); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySet#toArray(T[])",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "convert array",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySet#toArray(T[])",
      "head_type": "method",
      "relation": "have",
      "tail": "The method converts an array from one type to another.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySet#toArray(T[])",
      "head_type": "method",
      "relation": "have",
      "tail": "This method ensures that the returned array is unmodifiable.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySet#toArray(T[])",
      "head_type": "method",
      "relation": "have",
      "tail": "public <T> T[] toArray(T[] a) {\n    T[] result = this.delegate.toArray(a);\n    filterArray(result);\n    return result;\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueSpliterator#forEachRemaining(Consumer<? super List<T>>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "forEachRemaining",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueSpliterator#forEachRemaining(Consumer<? super List<T>>)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.UnmodifiableValueSpliterator#forEachRemaining(Consumer<? super List<T>>) useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueSpliterator#forEachRemaining(Consumer<? super List<T>>) useSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "org.springframework.util.UnmodifiableValueSpliterator#forEachRemaining(Consumer<? super List<T>>) useSampleCode Content",
      "tail_type": "content"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#processingInstruction(String,String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "processingInstruction",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#processingInstruction(String,String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "SAXException",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#processingInstruction(String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "processingInstructionInternal(target, data);",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#processingInstruction(String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#processingInstruction(String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.AbstractStaxHandler#processingInstruction(String,String)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#skippedEntity(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "handle skippedEntity",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#skippedEntity(String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "XMLStreamException handling",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#skippedEntity(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#skippedEntity(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#skippedEntity(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#skippedEntity(String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.AbstractStaxHandler",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#startDTD(String,String,String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "start Document Type Definition (DTD)",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#startDTD(String,String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "startDTD(String name, String publicId, String systemId)",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#startDTD(String,String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is used to handle the start of a Document Type Definition (DTD) in an XML document.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#startDTD(String,String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "The method constructs a string representation of the DTD and calls another method, dtdInternal, to process it further.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#startDTD(String,String,String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.AbstractStaxHandler",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#removeNamespaceMapping()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "remove namespace mapping",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#removeNamespaceMapping()",
      "head_type": "method",
      "relation": "have",
      "tail": "private void removeNamespaceMapping() {\n    this.namespaceMappings.remove(this.namespaceMappings.size() - 1);\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "remove namespace mapping",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "private void removeNamespaceMapping() {\n    this.namespaceMappings.remove(this.namespaceMappings.size() - 1);\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#removeNamespaceMapping()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.AbstractStaxHandler",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.DomContentHandler#startElement(String,String,String,Attributes)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "xmlElementCreation",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.DomContentHandler#startElement(String,String,String,Attributes)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "xmlAttributeHandling",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.DomContentHandler#startElement(String,String,String,Attributes)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "xmlNamespaceManagement",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.DomContentHandler#startElement(String,String,String,Attributes)",
      "head_type": "method",
      "relation": "have",
      "tail": "xmlElementCreationSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "xmlElementCreationSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "xmlElementCreationSampleCodeContent",
      "tail_type": "useSampleCodeContent"
    },
    {
      "head": "org.springframework.util.xml.DomContentHandler#startElement(String,String,String,Attributes)",
      "head_type": "method",
      "relation": "have",
      "tail": "xmlAttributeHandlingInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "xmlAttributeHandlingInterpretation",
      "head_type": "relatedConceptInterpretation",
      "relation": "have",
      "tail": "xmlAttributeHandlingDescription",
      "tail_type": "relatedConceptDescription"
    },
    {
      "head": "org.springframework.util.xml.DomContentHandler#startElement(String,String,String,Attributes)",
      "head_type": "method",
      "relation": "have",
      "tail": "xmlNamespaceManagementInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "xmlNamespaceManagementInterpretation",
      "head_type": "relatedConceptInterpretation",
      "relation": "have",
      "tail": "xmlNamespaceManagementDescription",
      "tail_type": "relatedConceptDescription"
    },
    {
      "head": "org.springframework.util.xml.DomContentHandler#startElement(String,String,String,Attributes)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "designPrincipleInterpretation",
      "head_type": "designPrincipleInterpretation",
      "relation": "have",
      "tail": "designPrincipleDescription",
      "tail_type": "designPrincipleDescription"
    },
    {
      "head": "org.springframework.util.xml.SimpleTransformErrorListener#warning(TransformerException)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "handle XSLT transformation warning",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.SimpleTransformErrorListener#warning(TransformerException)",
      "head_type": "method",
      "relation": "have",
      "tail": "public void warning(TransformerException ex) throws TransformerException { logger.warn(\"XSLT transformation warning\", ex); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "handle XSLT transformation warning",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "TransformerException must be thrown",
      "tail_type": "useConstraint"
    },
    {
      "head": "handle XSLT transformation warning",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "logging XSLT transformation warnings",
      "tail_type": "useScenario"
    },
    {
      "head": "handle XSLT transformation warning",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "Logs a warning when an XSLT transformation encounters a recoverable error.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "handle XSLT transformation warning",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "Design principle: Fail-fast with clear logging for recoverable errors.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils#createEventStreamWriter(XMLEventWriter,XMLEventFactory)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "create XMLStreamWriter from XMLEventWriter",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils#createEventStreamWriter(XMLEventWriter,XMLEventFactory)",
      "head_type": "method",
      "relation": "have",
      "tail": "Return a XMLStreamWriter that writes to a XMLEventWriter",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils#createEventStreamWriter(XMLEventWriter,XMLEventFactory)",
      "head_type": "method",
      "relation": "have",
      "tail": "XMLStreamWriter writes to XMLEventWriter",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils#createEventStreamWriter(XMLEventWriter,XMLEventFactory)",
      "head_type": "method",
      "relation": "have",
      "tail": "Efficient XML processing using event-based writer",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "create XMLStreamWriter from XMLEventWriter",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils",
      "head_type": "class",
      "relation": "have",
      "tail": "Return a XMLStreamWriter that writes to a XMLEventWriter",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils",
      "head_type": "class",
      "relation": "have",
      "tail": "XMLStreamWriter writes to XMLEventWriter",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils",
      "head_type": "class",
      "relation": "have",
      "tail": "Efficient XML processing using event-based writer",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils#createEventStreamWriter(XMLEventWriter,XMLEventFactory)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.StaxUtils",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamReader",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getPITarget()",
      "tail_type": "apiFunction"
    },
    {
      "head": "getPITarget()",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "useSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "org.springframework.util.xml.XMLEventStreamReader",
      "tail_type": "class"
    },
    {
      "head": "getPITarget()",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "relatedConceptInterpretation",
      "head_type": "relatedConceptInterpretation",
      "relation": "have",
      "tail": "ProcessingInstruction",
      "tail_type": "class"
    },
    {
      "head": "getPITarget()",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "designPrincipleInterpretation",
      "head_type": "designPrincipleInterpretation",
      "relation": "have",
      "tail": "State Design Pattern",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamReader",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getPIData()",
      "tail_type": "apiFunction"
    },
    {
      "head": "getPIData()",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "getPIData()",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "getPIData()",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamReader",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.XMLEventStreamReaderTests",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamReader#getText()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "retrieve text content from XML event",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamReader#getText()",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "event must be of type Characters or Comment",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamReader#getText()",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "parsing XML content",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamReader#getText()",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamReader#getText()",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamReader#getText()",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamReader#getText()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.XMLEventStreamReader",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter#writeComment(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "writeComment",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter#writeComment(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is used to write a comment in an XML document.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter#writeComment(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "The method ensures that any empty element is closed before writing the comment.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter#writeComment(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "public void writeComment(String data) throws XMLStreamException {\n    closeEmptyElementIfNecessary();\n    this.eventWriter.add(this.eventFactory.createComment(data));\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter#writeProcessingInstruction(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "writeProcessingInstruction",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter#writeProcessingInstruction(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.xml.XMLEventStreamWriter",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter#writeProcessingInstruction(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "XMLStreamException",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter#writeProcessingInstruction(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "Processing Instruction Writing",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter#writeProcessingInstruction(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "Efficient XML Processing",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter#writeProcessingInstruction(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "Sample Code for writeProcessingInstruction",
      "tail_type": "useSampleCode"
    },
    {
      "head": "example.type.SomeClassWithSomeComponentInterface",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "lazy loading",
      "tail_type": "apiFunction"
    },
    {
      "head": "example.type.SomeClassWithSomeComponentInterface",
      "head_type": "class",
      "relation": "constrained_by",
      "tail": "circular aliases are prohibited",
      "tail_type": "useConstraint"
    },
    {
      "head": "example.type.SomeClassWithSomeComponentInterface",
      "head_type": "class",
      "relation": "applied_to",
      "tail": "multiple aliases for a single name",
      "tail_type": "useScenario"
    },
    {
      "head": "example.type.SomeClassWithSomeComponentInterface",
      "head_type": "class",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "example.type.SomeClassWithSomeComponentInterface",
      "head_type": "class",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "example.type.SomeClassWithSomeComponentInterface",
      "head_type": "class",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "example.type.SomeClassWithSomeComponentInterface",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.core.SimpleAliasRegistryTests",
      "tail_type": "class"
    },
    {
      "head": "example.type.SomeClassMarkedWithNonInheritedAnnotation",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "NonInheritedAnnotationHandling",
      "tail_type": "apiFunction"
    },
    {
      "head": "example.type.SomeClassMarkedWithNonInheritedAnnotation",
      "head_type": "class",
      "relation": "have",
      "tail": "NonInheritedAnnotationUsageSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "example.type.SomeClassMarkedWithNonInheritedAnnotation",
      "head_type": "class",
      "relation": "have",
      "tail": "NonInheritedAnnotationRelatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "example.type.SomeClassMarkedWithNonInheritedAnnotation",
      "head_type": "class",
      "relation": "have",
      "tail": "NonInheritedAnnotationDesignPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#isAccessibleWhenPackagePrivateVisibilityInDifferentPackage()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "Access Control Test",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#isAccessibleWhenPackagePrivateVisibilityInDifferentPackage()",
      "head_type": "method",
      "relation": "have",
      "tail": "Sample Code for Access Control Test",
      "tail_type": "useSampleCode"
    },
    {
      "head": "Sample Code for Access Control Test",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "Complete Example for Access Control",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#forResolvableTypeWhenPackagePrivateGeneric()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "Access Control",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#forResolvableTypeWhenPackagePrivateGeneric()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "Resolvable Type Handling",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#forResolvableTypeWhenPackagePrivateGeneric()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "Visibility Determination",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#forResolvableTypeWhenPackagePrivateGeneric()",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.aot.generate.AccessControlTests#forResolvableTypeWhenPackagePrivateGeneric() Sample Code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#forResolvableTypeWhenPackagePrivateGeneric()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.AccessControl",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#forResolvableTypeWhenPackagePrivateGeneric()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.ResolvableType",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#forResolvableTypeWhenPackagePrivateGeneric()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.Visibility",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#forResolvableTypeWhenPackagePrivateGeneric() Sample Code",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "Complete Example for Access Control with Resolvable Type",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.DefaultGenerationContextTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getRuntimeHintsReturnsRuntimeHints",
      "tail_type": "apiFunction"
    },
    {
      "head": "getRuntimeHintsReturnsRuntimeHints",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.DefaultGenerationContextTests",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.DefaultGenerationContextTests",
      "head_type": "class",
      "relation": "have",
      "tail": "getRuntimeHintsReturnsRuntimeHints",
      "tail_type": "useSampleCode"
    },
    {
      "head": "getRuntimeHintsReturnsRuntimeHints",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "org.springframework.aot.generate.DefaultGenerationContextTests",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassesTests#addForFeatureUsesDefaultTarget()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "addForFeature",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassesTests#addForFeatureUsesDefaultTarget()",
      "head_type": "method",
      "relation": "have",
      "tail": "GeneratedClass",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassesTests#addForFeatureUsesDefaultTarget()",
      "head_type": "method",
      "relation": "have",
      "tail": "assertThat(generatedClass.getName()).hasToString(\"com.example.Test__Test\")",
      "tail_type": "useSampleCode"
    },
    {
      "head": "addForFeature",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "GeneratedClassesTests",
      "tail_type": "class"
    },
    {
      "head": "GeneratedClassesTests",
      "head_type": "class",
      "relation": "have",
      "tail": "addForFeatureUsesDefaultTarget()",
      "tail_type": "method"
    },
    {
      "head": "addForFeature",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "GeneratedClass",
      "tail_type": "class"
    },
    {
      "head": "addForFeature",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "assertThat(generatedClass.getName()).hasToString(\"com.example.Test__Test\")",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.SetTests#generateWhenLinkedHashSet()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "generateCode",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.SetTests#generateWhenLinkedHashSet()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "resolve",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.SetTests#generateWhenLinkedHashSet()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "hasImport",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.SetTests#generateWhenLinkedHashSet()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "hasValueCode",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.SetTests#generateWhenLinkedHashSet()",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "useSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "org.springframework.aot.generate.SetTests#generateWhenLinkedHashSet()",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.aot.generate.SetTests#generateWhenLinkedHashSet()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.SetTests",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.SetTests",
      "head_type": "class",
      "relation": "have",
      "tail": "org.springframework.aot.generate.SetTests#generateWhenLinkedHashSet()",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.aot.hint.annotation.TestTypeHintReflectiveProcessor",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "registerTypeHint",
      "tail_type": "apiFunction"
    },
    {
      "head": "registerTypeHint",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "org.springframework.aot.hint.annotation.TestTypeHintReflectiveProcessor",
      "tail_type": "class"
    },
    {
      "head": "registerTypeHint",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "ReflectionHints hints, Class<?> type",
      "tail_type": "useScenario"
    },
    {
      "head": "registerTypeHint",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "super.registerTypeHint(hints, type); hints.registerType(type, MemberCategory.INVOKE_DECLARED_METHODS);",
      "tail_type": "useSampleCode"
    },
    {
      "head": "registerTypeHint",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "This method is used to register type hints for reflective processing in the Spring AOT framework.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "registerTypeHint",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "The method follows the principle of extending the parent class's functionality and adding specific type hints for method invocations.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.hint.annotation.RegisterReflectionForBindingProcessorTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "registerReflectionHints",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.hint.annotation.RegisterReflectionForBindingProcessorTests",
      "head_type": "class",
      "relation": "have",
      "tail": "registerReflectionForBindingOnClass",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.aot.hint.annotation.RegisterReflectionForBindingProcessorTests",
      "head_type": "class",
      "relation": "have",
      "tail": "registerReflectionForBindingOnMethod",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.aot.hint.annotation.RegisterReflectionForBindingProcessorTests",
      "head_type": "class",
      "relation": "have",
      "tail": "registerReflectionForBindingOnClassItself",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.aot.hint.annotation.RegisterReflectionForBindingProcessorTests",
      "head_type": "class",
      "relation": "have",
      "tail": "throwExceptionWithoutAnnotationAttributeOnMethod",
      "tail_type": "useScenario"
    },
    {
      "head": "registerReflectionHints",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "registerReflectionForBindingOnClass",
      "tail_type": "useScenario"
    },
    {
      "head": "registerReflectionHints",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "registerReflectionForBindingOnMethod",
      "tail_type": "useScenario"
    },
    {
      "head": "registerReflectionHints",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "registerReflectionForBindingOnClassItself",
      "tail_type": "useScenario"
    },
    {
      "head": "registerReflectionHints",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "throwExceptionWithoutAnnotationAttributeOnMethod",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.aot.hint.annotation.RegisterReflectionForBindingProcessorTests",
      "head_type": "class",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.hint.annotation.RegisterReflectionForBindingProcessorTests",
      "head_type": "class",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.hint.annotation.RegisterReflectionForBindingProcessorTests",
      "head_type": "class",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.hint.annotation.RegisterReflectionForBindingProcessorTests",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "RegisterReflectionForBindingProcessor",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.hint.annotation.RegisterReflectionForBindingProcessorTests",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "Sebastien Deleuze",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.hint.annotation.RegisterReflectionForBindingProcessorTests",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "Stephane Nicoll",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "tail": "introspection",
      "head_type": "class",
      "relation": "haveFunction",
      "head": "org.springframework.core.type.StandardAnnotationMetadata",
      "tail_type": "apiFunction"
    },
    {
      "tail": "class introspection",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "head": "introspection",
      "tail_type": "useScenario"
    },
    {
      "tail": "useSampleCode",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "relatedConceptInterpretation",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "tail": "designPrincipleInterpretation",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "tail": "class must be introspectable",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "head": "introspection",
      "tail_type": "useConstraint"
    },
    {
      "tail": "useSampleCode",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "relatedConceptInterpretation",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "tail": "designPrincipleInterpretation",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "tail": "class must be introspectable",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "head": "introspection",
      "tail_type": "useConstraint"
    },
    {
      "tail": "useSampleCode",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "relatedConceptInterpretation",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "tail": "designPrincipleInterpretation",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "tail": "class must be introspectable",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "head": "introspection",
      "tail_type": "useConstraint"
    },
    {
      "tail": "useSampleCode",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "relatedConceptInterpretation",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "tail": "designPrincipleInterpretation",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "tail": "class must be introspectable",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "head": "introspection",
      "tail_type": "useConstraint"
    },
    {
      "tail": "useSampleCode",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "relatedConceptInterpretation",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "tail": "designPrincipleInterpretation",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "tail": "class must be introspectable",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "head": "introspection",
      "tail_type": "useConstraint"
    },
    {
      "tail": "useSampleCode",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "relatedConceptInterpretation",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "tail": "designPrincipleInterpretation",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "tail": "class must be introspectable",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "head": "introspection",
      "tail_type": "useConstraint"
    },
    {
      "tail": "useSampleCode",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "relatedConceptInterpretation",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "tail": "designPrincipleInterpretation",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "tail": "class must be introspectable",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "head": "introspection",
      "tail_type": "useConstraint"
    },
    {
      "tail": "useSampleCode",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "relatedConceptInterpretation",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "tail": "designPrincipleInterpretation",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "tail": "class must be introspectable",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "head": "introspection",
      "tail_type": "useConstraint"
    },
    {
      "tail": "useSampleCode",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "relatedConceptInterpretation",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "tail": "designPrincipleInterpretation",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "tail": "class must be introspectable",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "head": "introspection",
      "tail_type": "useConstraint"
    },
    {
      "tail": "useSampleCode",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "relatedConceptInterpretation",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "tail": "designPrincipleInterpretation",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "tail": "class must be introspectable",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "head": "introspection",
      "tail_type": "useConstraint"
    },
    {
      "tail": "useSampleCode",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "relatedConceptInterpretation",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "tail": "designPrincipleInterpretation",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "tail": "class must be introspectable",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "head": "introspection",
      "tail_type": "useConstraint"
    },
    {
      "tail": "useSampleCode",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "relatedConceptInterpretation",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "tail": "designPrincipleInterpretation",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "tail": "class must be introspectable",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "head": "introspection",
      "tail_type": "useConstraint"
    },
    {
      "tail": "useSampleCode",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "relatedConceptInterpretation",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "tail": "designPrincipleInterpretation",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "tail": "class must be introspectable",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "head": "introspection",
      "tail_type": "useConstraint"
    },
    {
      "tail": "useSampleCode",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "relatedConceptInterpretation",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "tail": "designPrincipleInterpretation",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "tail": "class must be introspectable",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "head": "introspection",
      "tail_type": "useConstraint"
    },
    {
      "tail": "useSampleCode",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "relatedConceptInterpretation",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "tail": "designPrincipleInterpretation",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "tail": "class must be introspectable",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "head": "introspection",
      "tail_type": "useConstraint"
    },
    {
      "tail": "useSampleCode",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "relatedConceptInterpretation",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "tail": "designPrincipleInterpretation",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "tail": "class must be introspectable",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "head": "introspection",
      "tail_type": "useConstraint"
    },
    {
      "tail": "useSampleCode",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "relatedConceptInterpretation",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "tail": "designPrincipleInterpretation",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "tail": "class must be introspectable",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "head": "introspection",
      "tail_type": "useConstraint"
    },
    {
      "tail": "useSampleCode",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "relatedConceptInterpretation",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "tail": "designPrincipleInterpretation",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "tail": "class must be introspectable",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "head": "introspection",
      "tail_type": "useConstraint"
    },
    {
      "tail": "useSampleCode",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "relatedConceptInterpretation",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "tail": "designPrincipleInterpretation",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "tail": "class must be introspectable",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "head": "introspection",
      "tail_type": "useConstraint"
    },
    {
      "tail": "useSampleCode",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "relatedConceptInterpretation",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "tail": "designPrincipleInterpretation",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "introspection",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#skipSeparator(String,int,String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "skip separator",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#skipSeparator(String,int,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "private int skipSeparator(String path, int pos, String separator) {\n    int skipped = 0;\n    while (path.startsWith(separator, pos + skipped)) {\n        skipped += separator.length();\n    }\n    return skipped;\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#skipSeparator(String,int,String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.AntPathMatcher",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.Assert#isInstanceOf(Class<?>,Object)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "assertion",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.Assert#isInstanceOf(Class<?>,Object)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "IllegalArgumentException if the object is not an instance of type",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.Assert#isInstanceOf(Class<?>,Object)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "check if an object is an instance of a specific class",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.Assert#isInstanceOf(Class<?>,Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code: Assert.instanceOf(Foo.class, foo);",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.Assert#isInstanceOf(Class<?>,Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "related concept interpretation: This method is used to assert that a given object is an instance of a specified class. It is commonly used in unit testing to validate the type of objects.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.Assert#isInstanceOf(Class<?>,Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle interpretation: The design principle behind this method is to enforce type safety and prevent runtime errors by ensuring that objects conform to expected types.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.Assert#isInstanceOf(Class<?>,Object)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.Assert",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.AutoPopulatingList#lastIndexOf(Object)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "searching for an object's last occurrence in a list",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.AutoPopulatingList#lastIndexOf(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "override annotation indicates this method overrides a method from its superclass",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.AutoPopulatingList#lastIndexOf(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "the method returns the index of the last occurrence of the specified element in the list, or -1 if the list does not contain the element",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.AutoPopulatingList#lastIndexOf(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "the method internally calls the lastIndexOf method of the backingList object",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.AutoPopulatingList#lastIndexOf(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "the method is part of the AutoPopulatingList class which extends the functionality of a regular list",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.backoff.BackOffExecution",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "nextBackOff",
      "tail_type": "apiFunction"
    },
    {
      "head": "nextBackOff",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "Return the number of milliseconds to wait before retrying the operation or STOP to indicate that no further attempt should be made for the operation.",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.backoff.BackOffExecution",
      "head_type": "class",
      "relation": "have",
      "tail": "Represent a particular back-off execution. Implementations do not need to be thread safe.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.backoff.BackOffExecution",
      "head_type": "class",
      "relation": "have",
      "tail": "Author: Stephane Nicoll, Since: 4.1, See: BackOff",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#getAllInterfacesForClassAsSet(Class<?>,ClassLoader)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getAllInterfacesForClassAsSet",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ClassUtils#getAllInterfacesForClassAsSet(Class<?>,ClassLoader)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "class must not be null",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ClassUtils#getAllInterfacesForClassAsSet(Class<?>,ClassLoader)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "analyze class for interfaces",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ClassUtils#getAllInterfacesForClassAsSet(Class<?>,ClassLoader)",
      "head_type": "method",
      "relation": "have",
      "tail": "Return all interfaces that the given class implements as a Set, including ones implemented by superclasses",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#getAllInterfacesForClassAsSet(Class<?>,ClassLoader)",
      "head_type": "method",
      "relation": "have",
      "tail": "The method iterates through the class hierarchy to collect all interfaces",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#getAllInterfacesForClassAsSet(Class<?>,ClassLoader)",
      "head_type": "method",
      "relation": "have",
      "tail": "package com.example;\n\nimport org.springframework.util.ClassUtils;\n\npublic class Example {\n    public static void main(String[] args) {\n        Set<Class<?>> interfaces = ClassUtils.getAllInterfacesForClassAsSet(Example.class, Example.class.getClassLoader());\n        interfaces.forEach(System.out::println);\n    }\n}\n",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ClassUtils#getAllInterfacesForClassAsSet(Class<?>,ClassLoader)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.ClassUtils",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.ClassUtils#getShortNameAsProperty(Class<?>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getShortNameAsProperty",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ClassUtils#getShortNameAsProperty(Class<?>)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "nested class",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ClassUtils#getShortNameAsProperty(Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "Return the short string name of a Java class in uncapitalized JavaBeans property format",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#getShortNameAsProperty(Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "Strips the outer class name in case of a nested class",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#getShortNameAsProperty(Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "package com.example.util; import java.lang.Class; import org.springframework.util.StringUtils; public class ClassUtils { public static String getShortNameAsProperty(Class<?> clazz) { String shortName = clazz.getSimpleName(); int dotIndex = shortName.lastIndexOf('.'); shortName = (dotIndex != -1 ? shortName.substring(dotIndex + 1) : shortName); return StringUtils.uncapitalizeAsProperty(shortName); } }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "getShortNameAsProperty",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "nested class",
      "tail_type": "useScenario"
    },
    {
      "head": "getShortNameAsProperty",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "Return the short string name of a Java class in uncapitalized JavaBeans property format",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "getShortNameAsProperty",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "Strips the outer class name in case of a nested class",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "getShortNameAsProperty",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "package com.example.util; import java.lang.Class; import org.springframework.util.StringUtils; public class ClassUtils { public static String getShortNameAsProperty(Class<?> clazz) { String shortName = clazz.getSimpleName(); int dotIndex = shortName.lastIndexOf('.'); shortName = (dotIndex != -1 ? shortName.substring(dotIndex + 1) : shortName); return StringUtils.uncapitalizeAsProperty(shortName); } }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ClassUtils#hasMethod(Class<?>,Method)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "check existence of a public method",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ClassUtils#hasMethod(Class<?>,Method)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "class and method must not be null",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ClassUtils#hasMethod(Class<?>,Method)",
      "head_type": "method",
      "relation": "have",
      "tail": "used to determine if a class has a specific public method",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#hasMethod(Class<?>,Method)",
      "head_type": "method",
      "relation": "have",
      "tail": "design follows the principle of reflection",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#hasMethod(Class<?>,Method)",
      "head_type": "method",
      "relation": "have",
      "tail": "public static boolean hasMethod(Class<?> clazz, Method method) {\n    Assert.notNull(clazz, \"Class must not be null\");\n    Assert.notNull(method, \"Method must not be null\");\n    if (clazz == method.getDeclaringClass()) {\n        return true;\n    }\n    String methodName = method.getName();\n    Class<?>[] paramTypes = method.getParameterTypes();\n    return getMethodOrNull(clazz, methodName, paramTypes) != null;\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.CollectionUtils#newLinkedHashSet(int)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "Instantiate a new LinkedHashSet",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.CollectionUtils#newLinkedHashSet(int)",
      "head_type": "method",
      "relation": "have",
      "tail": "LinkedHashSet with initial capacity",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.CollectionUtils#newLinkedHashSet(int)",
      "head_type": "method",
      "relation": "have",
      "tail": "Avoid resize/rehash operations",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.CollectionUtils#newLinkedHashSet(int)",
      "head_type": "method",
      "relation": "have",
      "tail": "Sample Code for newLinkedHashSet",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.CollectionUtils#newLinkedHashSet(int)",
      "head_type": "method",
      "relation": "have",
      "tail": "Related Concept Interpretation for newLinkedHashSet",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.CollectionUtils#newLinkedHashSet(int)",
      "head_type": "method",
      "relation": "have",
      "tail": "Design Principle Interpretation for newLinkedHashSet",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.CollectionUtils#newLinkedHashSet(int)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.CollectionUtils",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.CollectionUtils#unmodifiableMultiValueMap(MultiValueMap<? extends K,? extends V>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "unmodifiableMultiValueMap",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.CollectionUtils#unmodifiableMultiValueMap(MultiValueMap<? extends K,? extends V>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "targetMapNotNull",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.CollectionUtils#unmodifiableMultiValueMap(MultiValueMap<? extends K,? extends V>)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "createUnmodifiableView",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.CollectionUtils#unmodifiableMultiValueMap(MultiValueMap<? extends K,? extends V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "sampleCodeForUnmodifiableMultiValueMap",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.CollectionUtils#unmodifiableMultiValueMap(MultiValueMap<? extends K,? extends V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretationForUnmodifiableMultiValueMap",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.CollectionUtils#unmodifiableMultiValueMap(MultiValueMap<? extends K,? extends V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretationForUnmodifiableMultiValueMap",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.CollectionUtils#unmodifiableMultiValueMap(MultiValueMap<? extends K,? extends V>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "UnmodifiableMultiValueMap",
      "tail_type": "class"
    },
    {
      "head": "UnmodifiableMultiValueMap",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "unmodifiableViewCreation",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.CompositeCollection#addAll(Collection<? extends E>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "add elements to collection",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.CompositeCollection#addAll(Collection<? extends E>)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.CompositeCollection",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.CompositeCollection#addAll(Collection<? extends E>)",
      "head_type": "method",
      "relation": "have",
      "tail": "add elements to collection sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "add elements to collection sample code",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "org.springframework.util.CompositeCollection",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.CompositeCollection#addAll(Collection<? extends E>)",
      "head_type": "method",
      "relation": "have",
      "tail": "related concept interpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "related concept interpretation",
      "head_type": "relatedConceptInterpretation",
      "relation": "have",
      "tail": "Collection",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.CompositeCollection#addAll(Collection<? extends E>)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle interpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "design principle interpretation",
      "head_type": "designPrincipleInterpretation",
      "relation": "have",
      "tail": "add elements to collection",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ConcurrencyThrottleSupport#readObject(ObjectInputStream)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "Serialization support",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ConcurrencyThrottleSupport#readObject(ObjectInputStream)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "IOException, ClassNotFoundException",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ConcurrencyThrottleSupport#readObject(ObjectInputStream)",
      "head_type": "method",
      "relation": "have",
      "tail": "Initialize transient fields",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ConcurrencyThrottleSupport#readObject(ObjectInputStream)",
      "head_type": "method",
      "relation": "have",
      "tail": "Rely on default serialization",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ConcurrencyThrottleSupport#readObject(ObjectInputStream)",
      "head_type": "method",
      "relation": "have",
      "tail": "LogFactory usage",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ConcurrencyThrottleSupport#readObject(ObjectInputStream)",
      "head_type": "method",
      "relation": "have",
      "tail": "Design principles for serialization",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ConcurrencyThrottleSupport#readObject(ObjectInputStream)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.LogFactory",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.concurrent.FutureAdapter#adaptInternal(S)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "adapt a result",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.concurrent.FutureAdapter#adaptInternal(S)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "ExecutionException must be thrown on failure",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.concurrent.FutureAdapter#adaptInternal(S)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "adapt results from another computation",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.concurrent.FutureAdapter#adaptInternal(S)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.concurrent.FutureAdapter#adaptInternal(S) Sample Code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.concurrent.FutureAdapter#adaptInternal(S)",
      "head_type": "method",
      "relation": "have",
      "tail": "Adapts the result of another computation to the expected type",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.concurrent.FutureAdapter#adaptInternal(S)",
      "head_type": "method",
      "relation": "have",
      "tail": "Design Principle Interpretation for org.springframework.util.concurrent.FutureAdapter#adaptInternal(S)",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.concurrent.FutureAdapter",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.concurrent.FutureAdapter#adaptInternal(S)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.ConcurrentLruCache#processRead(Node<K,V>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "processRead",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ConcurrentLruCache#processRead(Node<K,V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "processRead(Node<K,V>) sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "processRead(Node<K,V>) sample code",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "private void processRead(Node<K, V> node) {\n    boolean drainRequested = this.readOperations.recordRead(node);\n    final DrainStatus status = this.drainStatus.get();\n    if (status.shouldDrainBuffers(drainRequested)) {\n        drainOperations();\n    }\n}",
      "tail_type": "code"
    },
    {
      "head": "org.springframework.util.Node#getPrevious()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "retrieve the previous node",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.Node#getPrevious()",
      "head_type": "method",
      "relation": "have",
      "tail": "method to get the previous node in a doubly linked list",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.Node#getPrevious()",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle of encapsulation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.Node#getPrevious()",
      "head_type": "method",
      "relation": "have",
      "tail": "public Node<K, V> getPrevious() { return this.prev; }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.EvictionQueue#remove(Node<K,V>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "elementRemoval",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.EvictionQueue#remove(Node<K,V>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "elementPresenceCheck",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.EvictionQueue#remove(Node<K,V>)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "evictionManagement",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.EvictionQueue#remove(Node<K,V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "void remove(Node<K, V> e) {\n    if (contains(e)) {\n        unlink(e);\n    }\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.EvictionQueue#remove(Node<K,V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is used to remove a specific node from the eviction queue. It first checks if the node exists in the queue and if it does, it proceeds to unlink it from the queue.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.EvictionQueue#remove(Node<K,V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "The design principle behind this method is to ensure that only existing nodes are removed from the eviction queue, maintaining the integrity and consistency of the queue.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.EvictionQueue#remove(Node<K,V>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.EvictionQueue",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.ConcurrentReferenceHashMap#put(K,V)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "add or update an entry",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ConcurrentReferenceHashMap#put(K,V)",
      "head_type": "method",
      "relation": "have",
      "tail": "add or update an entry sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "add or update an entry sample code",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "org.springframework.util.ConcurrentReferenceHashMap#put(K,V) sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ConcurrentReferenceHashMap#remove(Object)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "removeElement",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ConcurrentReferenceHashMap#remove(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "executeTaskWithRestructure",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ConcurrentReferenceHashMap#remove(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "taskExecutionWithSkipIfEmpty",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ConcurrentReferenceHashMap#remove(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "concurrentModificationHandling",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ConcurrentReferenceHashMap#remove(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "threadSafeElementRemoval",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ConcurrentReferenceHashMap#remove(Object)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.ConcurrentReferenceHashMap",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.Segment#restructure(boolean,Reference<K,V>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "restructure",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.Segment#restructure(boolean,Reference<K,V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "restructureSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "restructureSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "restructureCompleteExample",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.Task#execute(Reference<K,V>,Entry<K,V>,Entries<V>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "execute task",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.Task#execute(Reference<K,V>,Entry<K,V>,Entries<V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "execute task with reference, entry, and entries",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.Task#execute(Reference<K,V>,Entry<K,V>,Entries<V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "protected T execute(@Nullable Reference<K, V> ref, @Nullable Entry<K, V> entry, @Nullable Entries<V> entries) { return execute(ref, entry); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.Task#execute(Reference<K,V>,Entry<K,V>,Entries<V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "The method is used to execute a task with a given reference, entry, and entries. It returns the result of the task.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.Task#execute(Reference<K,V>,Entry<K,V>,Entries<V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "The design principle of this method is to provide a flexible way to execute tasks with different parameters. It allows for null values and uses a protected access modifier to ensure that it can be overridden by subclasses.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.Task#execute(Reference<K,V>,Entry<K,V>,Entries<V>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.Task",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.FastByteArrayOutputStream#resize(int)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "resize internal buffer",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.FastByteArrayOutputStream#resize(int)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "IllegalArgumentException if capacity is smaller than current size",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.FastByteArrayOutputStream#resize(int)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "adjusting buffer size",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.FastByteArrayOutputStream#resize(int)",
      "head_type": "method",
      "relation": "have",
      "tail": "resize internal buffer sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.FastByteArrayOutputStream#resize(int)",
      "head_type": "method",
      "relation": "have",
      "tail": "related concept interpretation for resize internal buffer",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.FastByteArrayOutputStream#resize(int)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle interpretation for resize internal buffer",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.FastByteArrayOutputStream#resize(int)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.FastByteArrayOutputStream",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.FastByteArrayOutputStream#addBuffer(int)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "add new buffer",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.FastByteArrayOutputStream#addBuffer(int)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "minCapacity must be greater than 0",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.FastByteArrayOutputStream#addBuffer(int)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "storing data exceeding current buffer capacity",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.FastByteArrayOutputStream#addBuffer(int)",
      "head_type": "method",
      "relation": "have",
      "tail": "private void addBuffer(int minCapacity) { if (this.buffers.peekLast() != null) { this.alreadyBufferedSize += this.index; this.index = 0; } if (this.nextBlockSize < minCapacity) { this.nextBlockSize = nextPowerOf2(minCapacity); } this.buffers.add(new byte[this.nextBlockSize]); this.nextBlockSize *= 2; }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.FastByteArrayOutputStream#addBuffer(int)",
      "head_type": "method",
      "relation": "have",
      "tail": "related to dynamic array expansion",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.FastByteArrayOutputStream#addBuffer(int)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle of efficient memory management",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.FastByteArrayOutputStream#addBuffer(int)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.FastByteArrayOutputStream",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.FilteredIterator#hasNext()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "checkNextAvailability",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.FilteredIterator#hasNext()",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.FilteredIterator#hasNext()",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.FilteredIterator#hasNext()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.FilteredIterator",
      "tail_type": "class"
    },
    {
      "tail": "add entries from another map",
      "head_type": "method",
      "relation": "haveFunction",
      "head": "org.springframework.util.LinkedCaseInsensitiveMap#putAll(Map<? extends String,? extends V>)",
      "tail_type": "apiFunction"
    },
    {
      "tail": "org.springframework.util.LinkedCaseInsensitiveMap#putAll(Map<? extends String,? extends V>) sample code",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.LinkedCaseInsensitiveMap#putAll(Map<? extends String,? extends V>)",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "complete example of putAll method",
      "head_type": "useSampleCode",
      "relation": "have",
      "head": "org.springframework.util.LinkedCaseInsensitiveMap#putAll(Map<? extends String,? extends V>) sample code",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.LinkedCaseInsensitiveMap#removeCaseInsensitiveKey(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "removeCaseInsensitiveKey",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.LinkedCaseInsensitiveMap#removeCaseInsensitiveKey(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.LinkedCaseInsensitiveMap",
      "tail_type": "class"
    },
    {
      "head": "removeCaseInsensitiveKey",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "private String removeCaseInsensitiveKey(String key) { return this.caseInsensitiveKeys.remove(convertKey(key)); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.LinkedCaseInsensitiveMap",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.LinkedCaseInsensitiveMap#removeCaseInsensitiveKey(String)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.EntrySet#iterator()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "iterator",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.EntrySet#iterator()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.EntrySet",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.EntrySet#iterator()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "EntrySetIterator",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.EntrySet",
      "head_type": "class",
      "relation": "have",
      "tail": "org.springframework.util.EntrySet#iterator()",
      "tail_type": "method"
    },
    {
      "head": "EntrySetIterator",
      "head_type": "class",
      "relation": "have",
      "tail": "org.springframework.util.EntrySet#iterator()",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.MimeType#isCompatibleWith(MimeType)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "MIME Type Compatibility Check",
      "tail_type": "apiFunction"
    },
    {
      "head": "MIME Type Compatibility Check",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "Non-null MIME Type Parameter",
      "tail_type": "useConstraint"
    },
    {
      "head": "MIME Type Compatibility Check",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "Content Negotiation",
      "tail_type": "useScenario"
    },
    {
      "head": "MIME Type Compatibility Check",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "Sample Code for MIME Type Compatibility",
      "tail_type": "useSampleCode"
    },
    {
      "head": "MIME Type Compatibility Check",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "MIME Type Hierarchy",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "MIME Type Compatibility Check",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "Design Principles of MIME Type Compatibility",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.MimeType",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.http.MediaType",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.MimeType#appendTo(StringBuilder)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "string builder manipulation",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MimeType#appendTo(StringBuilder)",
      "head_type": "method",
      "relation": "have",
      "tail": "appending type and subtype to string builder",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.MimeType#appendTo(StringBuilder)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "StringBuilder",
      "tail_type": "class"
    },
    {
      "head": "string builder manipulation",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "appending parameters to string builder",
      "tail_type": "useScenario"
    },
    {
      "head": "appending type and subtype to string builder",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "protected void appendTo(StringBuilder builder) {\n    builder.append(this.type);\n    builder.append('/');\n    builder.append(this.subtype);\n    appendTo(this.parameters, builder);\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.MimeType#readObject(ObjectInputStream)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "custom serialization",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MimeType#readObject(ObjectInputStream)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "default serialization",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.MimeType#readObject(ObjectInputStream)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "transient field initialization",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.MimeType#readObject(ObjectInputStream)",
      "head_type": "method",
      "relation": "have",
      "tail": "custom serialization sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.MimeType#readObject(ObjectInputStream)",
      "head_type": "method",
      "relation": "have",
      "tail": "custom serialization concept",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.MimeType#readObject(ObjectInputStream)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle for custom serialization",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.MimeType#readObject(ObjectInputStream)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.MimeType",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.MimeType#valueOf(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "parseMimeType",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MimeType#valueOf(String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "inputMustBeAValidMimeTypeString",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.MimeType#valueOf(String)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "convertStringToMimeType",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.MimeType#valueOf(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "convertStringToMimeTypeSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.MimeType#valueOf(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.MimeType#valueOf(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.MimeType#valueOf(String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.core.convert.ConversionService",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.MimeType#valueOf(String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "MimeTypeUtils",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.MimeTypeUtils#parseMimeTypeInternal(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "parseMimeType",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MimeTypeUtils#parseMimeTypeInternal(String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "mimeTypeNotEmpty",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.MimeTypeUtils#parseMimeTypeInternal(String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "validMimeTypeFormat",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.MimeTypeUtils#parseMimeTypeInternal(String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "wildcardTypeRestriction",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.MimeTypeUtils#parseMimeTypeInternal(String)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "mimeTypeParsing",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.MimeTypeUtils#parseMimeTypeInternal(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "mimeTypeParsingExample",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.MimeTypeUtils#parseMimeTypeInternal(String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "MimeType",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.MimeTypeUtils#parseMimeTypeInternal(String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "InvalidMimeTypeException",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.MimeTypeUtils#parseMimeTypeInternal(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "mimeTypeStructureInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.MimeTypeUtils#parseMimeTypeInternal(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "robustnessPrinciple",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.MultiValueMap",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getFirst",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MultiValueMap",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "add",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MultiValueMap",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "addAll",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MultiValueMap",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "addIfAbsent",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MultiValueMap",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "set",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MultiValueMap",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "setAll",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MultiValueMap",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "toSingleValueMap",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MultiValueMap",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "asSingleValueMap",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MultiValueMap",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "fromSingleValue",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MultiValueMap",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "fromMultiValue",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MultiValueMap",
      "head_type": "class",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.MultiValueMap",
      "head_type": "class",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.MultiValueMap",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "Map",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.MultiValueMap",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "MultiValueMapAdapter",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.MultiValueMap",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "SingleToMultiValueMapAdapter",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.MultiValueMap",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "MultiToSingleValueMapAdapter",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.MultiValueMap#set(K,V)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "setSingleValue",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MultiValueMap#set(K,V)",
      "head_type": "method",
      "relation": "have",
      "tail": "void set(K key, @Nullable V value);",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.MultiValueMap#set(K,V)",
      "head_type": "method",
      "relation": "have",
      "tail": "Set the given single value under the given key.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.MultiValueMap#set(K,V)",
      "head_type": "method",
      "relation": "have",
      "tail": "Ensure that the value is correctly set for the specified key.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.MultiValueMapAdapter#set(K,V)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "add a single value to a key in a MultiValueMap",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MultiValueMapAdapter#set(K,V)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.MultiValueMapAdapter#set(K,V) sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.MultiValueMapAdapter#set(K,V)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.MultiValueMapAdapter",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.MultiValueMapAdapter#containsValue(Object)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "check if the map contains a specific value",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MultiValueMapAdapter#containsValue(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method checks if the underlying targetMap contains the specified value.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.MultiValueMapAdapter#containsValue(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "public boolean containsValue(Object value) {\n    return this.targetMap.containsValue(value);\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.MultiValueMapAdapter#entrySet()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "entrySet",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MultiValueMapAdapter#entrySet()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "MultiValueMapAdapter",
      "tail_type": "class"
    },
    {
      "head": "entrySet",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "Return a set view of the mappings contained in the map.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "entrySet",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "public Set<Entry<K, List<V>>> entrySet() { return this.targetMap.entrySet(); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.AbstractPart#text()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "text retrieval",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.AbstractPart#text()",
      "head_type": "method",
      "relation": "have",
      "tail": "This method overrides a superclass method to provide the specific functionality of returning the text content.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.AbstractPart#text()",
      "head_type": "method",
      "relation": "have",
      "tail": "public String text() {\n    return this.text;\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.SimplePlaceholderPart#resolve(PartResolutionContext)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "resolve placeholder",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.SimplePlaceholderPart#resolve(PartResolutionContext)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "handle unresolvable placeholder",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.SimplePlaceholderPart#resolve(PartResolutionContext)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "use fallback value",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.SimplePlaceholderPart#resolve(PartResolutionContext)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "fallback value must be set",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.SimplePlaceholderPart#resolve(PartResolutionContext)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "resolution context provided",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.SimplePlaceholderPart#resolve(PartResolutionContext)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.SimplePlaceholderPart#resolve(PartResolutionContext)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.SimplePlaceholderPart#resolve(PartResolutionContext)",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.SimplePlaceholderPart",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.SimplePlaceholderPart#resolve(PartResolutionContext)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.PropertiesPersister",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "load",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.PropertiesPersister",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "store",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.PropertiesPersister",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "loadFromXml",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.PropertiesPersister",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "storeToXml",
      "tail_type": "apiFunction"
    },
    {
      "head": "load",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "IOException",
      "tail_type": "useConstraint"
    },
    {
      "head": "store",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "IOException",
      "tail_type": "useConstraint"
    },
    {
      "head": "loadFromXml",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "IOException",
      "tail_type": "useConstraint"
    },
    {
      "head": "storeToXml",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "IOException",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.PropertiesPersister",
      "head_type": "class",
      "relation": "have",
      "tail": "Strategy interface for persisting java.util.Properties, allowing for pluggable parsing strategies.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.PropertiesPersister",
      "head_type": "class",
      "relation": "have",
      "tail": "DefaultPropertiesPersister",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.PropertiesPersister",
      "head_type": "class",
      "relation": "have",
      "tail": "java.util.Properties",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.PropertiesPersister",
      "head_type": "class",
      "relation": "have",
      "tail": "Juergen Hoeller",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.PropertiesPersister",
      "head_type": "class",
      "relation": "have",
      "tail": "10.03.2004",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#doWithFields(Class<?>,FieldCallback)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "introspection",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#doWithFields(Class<?>,FieldCallback)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "IllegalStateException if introspection fails",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#doWithFields(Class<?>,FieldCallback)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "target class analysis",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#doWithFields(Class<?>,FieldCallback)",
      "head_type": "method",
      "relation": "have",
      "tail": "callback invocation for each field",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#doWithFields(Class<?>,FieldCallback)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#doWithFields(Class<?>,FieldCallback)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#doWithFields(Class<?>,FieldCallback)",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "introspection",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "introspection",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "introspection",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "IllegalStateException if introspection fails",
      "head_type": "useConstraint",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "IllegalStateException if introspection fails",
      "head_type": "useConstraint",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "IllegalStateException if introspection fails",
      "head_type": "useConstraint",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "target class analysis",
      "head_type": "useScenario",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "target class analysis",
      "head_type": "useScenario",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "target class analysis",
      "head_type": "useScenario",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "callback invocation for each field",
      "head_type": "useScenario",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "callback invocation for each field",
      "head_type": "useScenario",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "callback invocation for each field",
      "head_type": "useScenario",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ResourceUtils#extractArchiveURL(URL)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "extract the URL for the outermost archive",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ResourceUtils#extractArchiveURL(URL)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "jar/war URL must point to a resource in a jar file or to a jar file itself",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ResourceUtils#extractArchiveURL(URL)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "jar file nested within a war file",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ResourceUtils#extractArchiveURL(URL)",
      "head_type": "method",
      "relation": "have",
      "tail": "In the case of a jar file nested within a war file, this will return a URL to the war file since that is the one resolvable in the file system.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ResourceUtils#extractArchiveURL(URL)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is designed to handle URLs that may point to resources within jar files or to the jar files themselves. It specifically addresses scenarios where a jar file is nested within a war file, returning a URL to the war file as it is resolvable in the file system.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ResourceUtils#extractArchiveURL(URL)",
      "head_type": "method",
      "relation": "have",
      "tail": "public static URL extractArchiveURL(URL jarUrl) throws MalformedURLException {\n    String urlFile = jarUrl.getFile();\n    int endIndex = urlFile.indexOf(WAR_URL_SEPARATOR);\n    if (endIndex != -1) {\n        String warFile = urlFile.substring(0, endIndex);\n        if (URL_PROTOCOL_WAR.equals(jarUrl.getProtocol())) {\n            return toURL(warFile);\n        }\n        int startIndex = warFile.indexOf(WAR_URL_PREFIX);\n        if (startIndex != -1) {\n            return toURL(warFile.substring(startIndex + WAR_URL_PREFIX.length()));\n        }\n    }\n    return extractJarFileURL(jarUrl);\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ResourceUtils#toRelativeURL(URL,String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "create a clean URL instance",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ResourceUtils#toRelativeURL(URL,String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "MalformedURLException if the end result is not a valid URL",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ResourceUtils#toRelativeURL(URL,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "going through URI construction and then URL conversion",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ResourceUtils#toRelativeURL(URL,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "Create a clean URL instance for the given root URL and relative path, going through URI construction and then URL conversion.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ResourceUtils#toRelativeURL(URL,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is designed to handle URL and URI construction, ensuring that the resultant URL is valid and clean. It leverages existing URL and string manipulation utilities to achieve this.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ResourceUtils#toRelativeURL(URL,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "package com.healthMgr.common.email;\nimport java.net.URL;\nimport java.net.MalformedURLException;\nimport org.springframework.util.StringUtils;\n\npublic class URLExample {\n    public static void main(String[] args) {\n        try {\n            URL root = new URL(\"http://example.com/\");\n            String relativePath = \"path/to/resource#fragment\";\n            URL relativeURL = ResourceUtils.toRelativeURL(root, relativePath);\n            System.out.println(\"Relative URL: \" + relativeURL);\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        }\n    }\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ResourceUtils#toRelativeURL(URL,String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "StringUtils",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.ResourceUtils#toRelativeURL(URL,String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "ResourceUtils",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.DefaultRoute#toString()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "toString",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.DefaultRoute#toString()",
      "head_type": "method",
      "relation": "have",
      "tail": "Converts the route to a string representation.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.DefaultRoute#toString()",
      "head_type": "method",
      "relation": "have",
      "tail": "public String toString() { return value(); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.StopWatch#getLastTaskTimeMillis()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "获取最后一个任务所花费的时间（毫秒）",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StopWatch#getLastTaskTimeMillis()",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "已弃用，建议使用lastTaskInfo()方法",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.StopWatch#getLastTaskTimeMillis()",
      "head_type": "method",
      "relation": "have",
      "tail": "使用场景：获取最后一个任务的时间信息",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.StopWatch#getLastTaskTimeMillis()",
      "head_type": "method",
      "relation": "have",
      "tail": "示例代码：\npackage com.example;\nimport org.springframework.util.StopWatch;\npublic class StopWatchExample {\n    public static void main(String[] args) {\n        StopWatch stopWatch = new StopWatch();\n        stopWatch.start();\n        // 执行任务\n        stopWatch.stop();\n        long lastTaskTime = stopWatch.getLastTaskTimeMillis();\n        System.out.println(\"最后一个任务耗时（毫秒）: \" + lastTaskTime);\n    }\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.StopWatch#getLastTaskTimeMillis()",
      "head_type": "method",
      "relation": "have",
      "tail": "相关概念解释：该方法用于获取最后一个任务所花费的时间，单位为毫秒。",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.StopWatch#getLastTaskTimeMillis()",
      "head_type": "method",
      "relation": "have",
      "tail": "设计原则解释：该方法的设计原则是提供一种便捷的方式来获取最后一个任务的执行时间，便于性能分析和监控。",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.StopWatch#getLastTaskTimeMillis()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.StopWatch",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.StopWatch",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "获取最后一个任务所花费的时间（毫秒）",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StreamUtils#copyToString(ByteArrayOutputStream,Charset)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "copy contents of ByteArrayOutputStream into String",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StreamUtils#copyToString(ByteArrayOutputStream,Charset)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "ByteArrayOutputStream and Charset must be not null",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.StreamUtils#copyToString(ByteArrayOutputStream,Charset)",
      "head_type": "method",
      "relation": "have",
      "tail": "Copy the contents of the given ByteArrayOutputStream into a String using the specified Charset.",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.StreamUtils#copyToString(ByteArrayOutputStream,Charset)",
      "head_type": "method",
      "relation": "have",
      "tail": "public static String copyToString(ByteArrayOutputStream baos, Charset charset) {\n    Assert.notNull(baos, \"No ByteArrayOutputStream specified\");\n    Assert.notNull(charset, \"No Charset specified\");\n    return baos.toString(charset);\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.StreamUtils#copyToString(ByteArrayOutputStream,Charset)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method efficiently converts the contents of a ByteArrayOutputStream into a String using a specified Charset.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.StreamUtils#copyToString(ByteArrayOutputStream,Charset)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method follows the principle of efficiency by directly converting the ByteArrayOutputStream to a String without intermediate steps like creating a byte array.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.StreamUtils#copy(byte[],OutputStream)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "copy contents of byte array to OutputStream",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StreamUtils#copy(byte[],OutputStream)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "input byte array must be specified",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.StreamUtils#copy(byte[],OutputStream)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "OutputStream must be specified",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.StreamUtils#copy(byte[],OutputStream)",
      "head_type": "method",
      "relation": "have",
      "tail": "Leaves the stream open when done",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.StreamUtils#copy(byte[],OutputStream)",
      "head_type": "method",
      "relation": "have",
      "tail": "public static void copy(byte[] in, OutputStream out) throws IOException { Assert.notNull(in, \"No input byte array specified\"); Assert.notNull(out, \"No OutputStream specified\"); out.write(in); out.flush(); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.StreamUtils#copy(byte[],OutputStream)",
      "head_type": "method",
      "relation": "have",
      "tail": "Copy the contents of the given byte array to the given OutputStream.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.StreamUtils#copy(byte[],OutputStream)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is designed to handle I/O operations efficiently by ensuring that the OutputStream is not closed after the operation, which is a common requirement in scenarios where the stream needs to be used further down the line.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.StringUtils#trimArrayElements(String[])",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "trimmingStringArrayElements",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils#trimArrayElements(String[])",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "arrayMustNotBeNull",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.StringUtils#trimArrayElements(String[])",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "emptyOrNonNullStringArray",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.StringUtils#trimArrayElements(String[])",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.StringUtils#trimArrayElements(String[])",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.StringUtils#trimArrayElements(String[])",
      "head_type": "method",
      "relation": "have",
      "tail": "trimsEachNonNullElementOfArray",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.StringUtils#trimArrayElements(String[])",
      "head_type": "method",
      "relation": "have",
      "tail": "efficientlyHandlesPotentiallyEmptyArrays",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "trimmingStringArrayElements",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "org.springframework.util.StringUtils",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#compute(K,BiFunction<? super K,? super List<V>,? extends List<V>>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "compute",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#compute(K,BiFunction<? super K,? super List<V>,? extends List<V>>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "UnsupportedOperationException",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#compute(K,BiFunction<? super K,? super List<V>,? extends List<V>>)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.UnmodifiableMultiValueMap",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#compute(K,BiFunction<? super K,? super List<V>,? extends List<V>>)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is not supported and will always throw an UnsupportedOperationException.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#compute(K,BiFunction<? super K,? super List<V>,? extends List<V>>)",
      "head_type": "method",
      "relation": "have",
      "tail": "The design principle behind this method is to ensure the immutability of the map.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#compute(K,BiFunction<? super K,? super List<V>,? extends List<V>>)",
      "head_type": "method",
      "relation": "have",
      "tail": "public List<V> compute(K key, BiFunction<? super K, ? super List<V>, ? extends List<V>> remappingFunction) {\n    throw new UnsupportedOperationException();\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySet",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "unmodifiableEntrySet",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySet",
      "head_type": "class",
      "relation": "have",
      "tail": "UnmodifiableEntrySet is a Set implementation that provides an unmodifiable view of the underlying set.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySet",
      "head_type": "class",
      "relation": "have",
      "tail": "The class is designed to wrap any set of Map.Entry objects and make it unmodifiable, ensuring that the underlying set cannot be altered through this wrapper.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySet",
      "head_type": "class",
      "relation": "have",
      "tail": "package com.healthMgr.common.util;\n\nimport java.util.*;\n\npublic class UnmodifiableEntrySetExample {\n    public static void main(String[] args) {\n        Set<Map.Entry<String, List<Integer>>> originalSet = new HashSet<>();\n        originalSet.add(new AbstractMap.SimpleEntry<>(\"key1\", Arrays.asList(1, 2, 3)));\n        \n        UnmodifiableEntrySet<String, Integer> unmodifiableSet = new UnmodifiableEntrySet<>(originalSet);\n        \n        // Attempting to modify the set will throw an UnsupportedOperationException\n        try {\n            unmodifiableSet.add(new AbstractMap.SimpleEntry<>(\"key2\", Arrays.asList(4, 5, 6)));\n        } catch (UnsupportedOperationException e) {\n            System.out.println(\"Cannot add elements to the unmodifiable set.\");\n        }\n        \n        // Iterating over the set\n        for (Map.Entry<String, List<Integer>> entry : unmodifiableSet) {\n            System.out.println(\"Key: \" + entry.getKey() + \", Value: \" + entry.getValue());\n        }\n    }\n}\n",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLStreamReader#getTextLength()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getTextLength",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLStreamReader#getTextLength()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.AbstractXMLStreamReader",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLStreamReader#getTextLength()",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.DomContentHandler#endDocument()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "endDocument",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.DomContentHandler#endDocument()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.DomContentHandler",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter#writeAttribute(String,String,String,String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "writeAttribute",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter#writeAttribute(String,String,String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "writeAttributeSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.XmlValidationModeDetector#startComment(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "consuming START_COMMENT token",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.XmlValidationModeDetector#startComment(String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "token must be START_COMMENT",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.xml.XmlValidationModeDetector#startComment(String)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "xml validation mode detection",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.xml.XmlValidationModeDetector#startComment(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "xml validation mode detection sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.XmlValidationModeDetector#startComment(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "xml validation mode detection related concept interpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.XmlValidationModeDetector#startComment(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "xml validation mode detection design principle interpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.XmlValidationModeDetector#startComment(String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.XmlValidationModeDetector",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.DefaultGenerationContextTests#createWithOnlyGeneratedFilesCreatesContext()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "createContextWithGeneratedFiles",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.DefaultGenerationContextTests#createWithOnlyGeneratedFilesCreatesContext()",
      "head_type": "method",
      "relation": "have",
      "tail": "sampleCodeForCreateContextWithGeneratedFiles",
      "tail_type": "useSampleCode"
    },
    {
      "head": "createContextWithGeneratedFiles",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "createContextWithGeneratedFilesScenario",
      "tail_type": "useScenario"
    },
    {
      "head": "createContextWithGeneratedFiles",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "createContextWithGeneratedFilesConstraint",
      "tail_type": "useConstraint"
    },
    {
      "head": "sampleCodeForCreateContextWithGeneratedFiles",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "createContextWithGeneratedFiles",
      "tail_type": "apiFunction"
    },
    {
      "head": "createContextWithGeneratedFilesScenario",
      "head_type": "useScenario",
      "relation": "have",
      "tail": "createContextWithGeneratedFiles",
      "tail_type": "apiFunction"
    },
    {
      "head": "createContextWithGeneratedFilesConstraint",
      "head_type": "useConstraint",
      "relation": "have",
      "tail": "createContextWithGeneratedFiles",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.DefaultGenerationContextTests",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.DefaultGenerationContextTests#createWithOnlyGeneratedFilesCreatesContext()",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.aot.generate.DefaultGenerationContextTests",
      "head_type": "class",
      "relation": "have",
      "tail": "relatedConceptInterpretationForDefaultGenerationContextTests",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.DefaultGenerationContextTests",
      "head_type": "class",
      "relation": "have",
      "tail": "designPrincipleInterpretationForDefaultGenerationContextTests",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithStaticMethodAndMatchingDeclaringClass()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "generate invoke code block",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithStaticMethodAndMatchingDeclaringClass()",
      "head_type": "method",
      "relation": "have",
      "tail": "generate invoke code block sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "generate invoke code block sample code",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "package com.generateCodeBlock;\nimport org.springframework.aot.generate.MethodReference;\nimport org.springframework.aot.generate.CodeBlock;\npublic class InvokeCodeBlockExample {\n    public static void main(String[] args) {\n        MethodReference methodReference = createStaticMethodReference(\"methodName\", \"TEST_CLASS_NAME\");\n        CodeBlock codeBlock = methodReference.toInvokeCodeBlock(ArgumentCodeGenerator.none(), \"TEST_CLASS_NAME\");\n        System.out.println(codeBlock.toString());\n    }\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithStaticMethodAndMatchingDeclaringClass()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.MethodReference",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithStaticMethodAndMatchingDeclaringClass()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.CodeBlock",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithStaticMethodAndMatchingDeclaringClass()",
      "head_type": "method",
      "relation": "have",
      "tail": "generate invoke code block related concept interpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "generate invoke code block related concept interpretation",
      "head_type": "relatedConceptInterpretation",
      "relation": "have",
      "tail": "The generate invoke code block functionality allows for the dynamic creation of code blocks that represent method invocations. It is particularly useful in scenarios where method calls need to be generated at runtime, such as in code generation or dynamic proxy creation.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithStaticMethodAndMatchingDeclaringClass()",
      "head_type": "method",
      "relation": "have",
      "tail": "generate invoke code block design principle interpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "generate invoke code block design principle interpretation",
      "head_type": "designPrincipleInterpretation",
      "relation": "have",
      "tail": "The design principle behind the generate invoke code block functionality is to provide a flexible and reusable mechanism for generating method invocation code blocks. This principle ensures that the code generation process is both efficient and adaptable to various use cases, promoting modularity and maintainability in the codebase.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassesTests#writeToInvokeTypeSpecCustomizer()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "addForFeatureComponent",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassesTests#writeToInvokeTypeSpecCustomizer()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "writeTo",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassesTests#writeToInvokeTypeSpecCustomizer()",
      "head_type": "method",
      "relation": "have",
      "tail": "verifyNoInteractions(typeSpecCustomizer)",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassesTests#writeToInvokeTypeSpecCustomizer()",
      "head_type": "method",
      "relation": "have",
      "tail": "verify(typeSpecCustomizer).accept(any())",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassesTests#writeToInvokeTypeSpecCustomizer()",
      "head_type": "method",
      "relation": "have",
      "tail": "assertThat(generatedFiles.getGeneratedFiles(Kind.SOURCE)).hasSize(1)",
      "tail_type": "useScenario"
    },
    {
      "head": "addForFeatureComponent",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "Add a component for a feature",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "writeTo",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "Write generated classes to files",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassesTests#writeToInvokeTypeSpecCustomizer()",
      "head_type": "method",
      "relation": "have",
      "tail": "package org.springframework.aot.generate;\n\nimport org.junit.jupiter.api.Test;\nimport org.mockito.Mockito;\n\npublic class GeneratedClassesTests {\n\n    @Test\n    void writeToInvokeTypeSpecCustomizer() {\n        Consumer<TypeSpec.Builder> typeSpecCustomizer = Mockito.mock();\n        this.generatedClasses.addForFeatureComponent(\"one\", TestComponent.class, typeSpecCustomizer);\n        Mockito.verifyNoInteractions(typeSpecCustomizer);\n        InMemoryGeneratedFiles generatedFiles = new InMemoryGeneratedFiles();\n        this.generatedClasses.writeTo(generatedFiles);\n        Mockito.verify(typeSpecCustomizer).accept(Mockito.any());\n        assertThat(generatedFiles.getGeneratedFiles(Kind.SOURCE)).hasSize(1);\n    }\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.EnumTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "generateWhenEnum",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.EnumTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "generateWhenEnumWithClassBody",
      "tail_type": "apiFunction"
    },
    {
      "head": "generateWhenEnum",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "generateWhenEnumWithClassBody",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.EnumTests#generateWhenEnumWithClassBody()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "generateCode",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.EnumTests#generateWhenEnumWithClassBody()",
      "head_type": "method",
      "relation": "have",
      "tail": "generateWhenEnumWithClassBodySampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "generateWhenEnumWithClassBodySampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "generateWhenEnumWithClassBodySampleCodeContent",
      "tail_type": "useSampleCodeContent"
    },
    {
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldProcessDifferentAnnotationsOnTypeAndField()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "process annotations on type and field",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldProcessDifferentAnnotationsOnTypeAndField()",
      "head_type": "method",
      "relation": "have",
      "tail": "SampleTypeAndFieldAnnotatedBean.class",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldProcessDifferentAnnotationsOnTypeAndField()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "SampleTypeAndFieldAnnotatedBean",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldProcessDifferentAnnotationsOnTypeAndField()",
      "head_type": "method",
      "relation": "have",
      "tail": "assert that the type hint contains only the specified field",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldProcessDifferentAnnotationsOnTypeAndField()",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle of processing annotations",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldInvokeCustomProcessor()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "reflection processing",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldInvokeCustomProcessor()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "custom processor invocation",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldInvokeCustomProcessor()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "runtime hints registration",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldInvokeCustomProcessor()",
      "head_type": "method",
      "relation": "have",
      "tail": "SampleCustomProcessor",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldInvokeCustomProcessor()",
      "head_type": "method",
      "relation": "have",
      "tail": "String",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldInvokeCustomProcessor()",
      "head_type": "method",
      "relation": "have",
      "tail": "RuntimeHintsPredicates",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldInvokeCustomProcessor()",
      "head_type": "method",
      "relation": "have",
      "tail": "reflection hints",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldInvokeCustomProcessor()",
      "head_type": "method",
      "relation": "have",
      "tail": "custom processor",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldInvokeCustomProcessor()",
      "head_type": "method",
      "relation": "have",
      "tail": "runtime hints",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldInvokeCustomProcessor()",
      "head_type": "method",
      "relation": "have",
      "tail": "Reflection processing involves invoking custom processors and registering runtime hints.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldInvokeCustomProcessor()",
      "head_type": "method",
      "relation": "have",
      "tail": "Design principle involves ensuring that reflective operations are captured and hints are registered for optimal runtime performance.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldInvokeCustomProcessor()",
      "head_type": "method",
      "relation": "have",
      "tail": "@Test\nvoid shouldInvokeCustomProcessor() {\n    process(SampleCustomProcessor.class);\n    assertThat(RuntimeHintsPredicates.reflection().onMethodInvocation(SampleCustomProcessor.class, \"managed\")).accepts(this.runtimeHints);\n    assertThat(RuntimeHintsPredicates.reflection().onType(String.class).withMemberCategory(MemberCategory.INVOKE_DECLARED_METHODS)).accepts(this.runtimeHints);\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.hint.annotation.SampleMethodMetaAnnotatedBeanWithAlias#invoke()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "retry invocation",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.hint.annotation.SampleMethodMetaAnnotatedBeanWithAlias#invoke()",
      "head_type": "method",
      "relation": "have",
      "tail": "void invoke();",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.hint.annotation.SampleMethodMetaAnnotatedBeanWithAlias#notManaged()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "voidFunction",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.hint.annotation.SampleMethodMetaAnnotatedBeanWithAlias#notManaged()",
      "head_type": "method",
      "relation": "have",
      "tail": "void notManaged() ;",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.hint.annotation.SampleClassWithGetter#getName()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "retrieve a predefined string value",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.hint.annotation.SampleClassWithGetter#getName()",
      "head_type": "method",
      "relation": "have",
      "tail": "public String getName() {\n    return \"test\";\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.hint.annotation.SampleClassWithGetter#getName()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.hint.annotation.SampleClassWithGetter",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.hint.annotation.SampleClassWithoutMethodLevelAnnotationAttribute",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "reflection binding registration",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.hint.annotation.SampleClassWithoutMethodLevelAnnotationAttribute",
      "head_type": "class",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.hint.annotation.SampleClassWithoutMethodLevelAnnotationAttribute",
      "head_type": "class",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.hint.annotation.SampleClassWithoutMethodLevelAnnotationAttribute",
      "head_type": "class",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.core.type.MethodMetadata#isOverridable()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "determine if method is overridable",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.core.type.MethodMetadata#isOverridable()",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "method not marked as static, final, or private",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.core.type.MethodMetadata#isOverridable()",
      "head_type": "method",
      "relation": "have",
      "tail": "related to object-oriented programming principles",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.core.type.MethodMetadata#isOverridable()",
      "head_type": "method",
      "relation": "have",
      "tail": "design follows principle of encapsulation and inheritance",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.core.type.MethodMetadata#isOverridable()",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for determining if a method is overridable",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.objenesis(SpringObjenesis)",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getInstantiatorOf(Class<T>)",
      "tail_type": "apiFunction"
    },
    {
      "head": "getInstantiatorOf(Class<T>)",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "ObjectInstantiator<?>",
      "tail_type": "class"
    },
    {
      "head": "getInstantiatorOf(Class<T>)",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "this.cache",
      "tail_type": "class"
    },
    {
      "head": "getInstantiatorOf(Class<T>)",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "newInstantiatorOf(clazz)",
      "tail_type": "method"
    },
    {
      "head": "getInstantiatorOf(Class<T>)",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "getInstantiatorOf(Class<T>)",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "getInstantiatorOf(Class<T>)",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.PatternInfo#getLength()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getLength",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.PatternInfo#getLength()",
      "head_type": "method",
      "relation": "have",
      "tail": "Returns the length of the given pattern, where template variables are considered to be 1 long.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.PatternInfo#getLength()",
      "head_type": "method",
      "relation": "have",
      "tail": "public int getLength() {\n    if (this.length == null) {\n        this.length = (this.pattern != null ? VARIABLE_PATTERN.matcher(this.pattern).replaceAll(\"#\").length() : 0);\n    }\n    return this.length;\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.Assert#hasLength(String,Supplier<String>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "assertStringNotEmpty",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.Assert#hasLength(String,Supplier<String>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "nullOrEmptyStringProhibited",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.Assert#hasLength(String,Supplier<String>)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "stringValidation",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.Assert#hasLength(String,Supplier<String>)",
      "head_type": "method",
      "relation": "have",
      "tail": "stringValidationSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.Assert#hasLength(String,Supplier<String>)",
      "head_type": "method",
      "relation": "have",
      "tail": "stringValidationRelatedConcept",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.Assert#hasLength(String,Supplier<String>)",
      "head_type": "method",
      "relation": "have",
      "tail": "stringValidationDesignPrinciple",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.Assert#hasLength(String,Supplier<String>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "StringUtils#hasLength",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.Assert#notEmpty(Collection<?>,Supplier<String>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "assert collection not empty",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.Assert#notEmpty(Collection<?>,Supplier<String>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "collection must not be null and must contain at least one element",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.Assert#notEmpty(Collection<?>,Supplier<String>)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "check if a collection contains elements",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.Assert#notEmpty(Collection<?>,Supplier<String>)",
      "head_type": "method",
      "relation": "have",
      "tail": "The collection to check must not be null and must contain at least one element. If the collection is null or empty, an IllegalArgumentException is thrown.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.Assert#notEmpty(Collection<?>,Supplier<String>)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is designed to ensure that a given collection is not null and contains elements. It is a part of the assertion utility class which is commonly used for validating input parameters in methods. The design principle behind this method is to fail fast and early, providing clear and meaningful error messages when assertions fail.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.Assert#notEmpty(Collection<?>,Supplier<String>)",
      "head_type": "method",
      "relation": "have",
      "tail": "java\npackage com.example.demo;\n\nimport org.springframework.util.Assert;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.function.Supplier;\n\npublic class AssertNotEmptyExample {\n    public static void main(String[] args) {\n        Collection<String> collection = Collections.singletonList(\"item\");\n        Supplier<String> messageSupplier = () -> \"The collection must contain elements\";\n\n        // Example usage of Assert.notEmpty\n        Assert.notEmpty(collection, messageSupplier);\n        System.out.println(\"Collection is not empty. Success!\");\n    }\n}\n",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.AutoPopulatingList",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "lazy loading",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.AutoPopulatingList",
      "head_type": "class",
      "relation": "applied_to",
      "tail": "data binding to Lists",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.AutoPopulatingList",
      "head_type": "class",
      "relation": "have",
      "tail": "Simple List wrapper class that allows for elements to be automatically populated as they are requested",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.AutoPopulatingList",
      "head_type": "class",
      "relation": "have",
      "tail": "not thread-safe; use java.util.Collections#synchronizedList for a thread-safe version",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.AutoPopulatingList",
      "head_type": "class",
      "relation": "have",
      "tail": "Inspired by LazyList from Commons Collections",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.AutoPopulatingList",
      "head_type": "class",
      "relation": "have",
      "tail": "package com.healthMgr.common.email; import java.util.List; public class OneClass { private final List<E> backingList; private final ElementFactory<E> elementFactory; public OneClass(Class<? extends E> elementClass) { this(new ArrayList<>(), elementClass); } public OneClass(List<E> backingList, Class<? extends E> elementClass) { this(backingList, new ReflectiveElementFactory<>(elementClass)); } public OneClass(ElementFactory<E> elementFactory) { this(new ArrayList<>(), elementFactory); } public OneClass(List<E> backingList, ElementFactory<E> elementFactory) { Assert.notNull(backingList, \"Backing List must not be null\"); Assert.notNull(elementFactory, \"Element factory must not be null\"); this.backingList = backingList; this.elementFactory = elementFactory; } }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.AutoPopulatingList#retainAll(Collection<?>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "retainAll",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.AutoPopulatingList#retainAll(Collection<?>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "AutoPopulatingList",
      "tail_type": "class"
    },
    {
      "head": "AutoPopulatingList",
      "head_type": "class",
      "relation": "have",
      "tail": "org.springframework.util.AutoPopulatingList",
      "tail_type": "class"
    },
    {
      "head": "retainAll",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "public boolean retainAll(Collection<?> c) { return this.backingList.retainAll(c); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "retainAll",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "This method is used to retain only the elements in this list that are contained in the specified collection.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "retainAll",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "This method follows the principle of maintaining consistency between the list and the backing list.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.backoff.BackOff",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "start a new back off execution",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.backoff.BackOff",
      "head_type": "class",
      "relation": "have",
      "tail": "Provide a BackOffExecution that indicates the rate at which an operation should be retried",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.backoff.BackOff",
      "head_type": "class",
      "relation": "have",
      "tail": "Users of this interface are expected to use it like this",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.backoff.BackOff",
      "head_type": "class",
      "relation": "have",
      "tail": "BackOffExecution exec = backOff.start();\n\n// In the operation recovery/retry loop:\nlong waitInterval = exec.nextBackOff();\nif (waitInterval == BackOffExecution.STOP) {\n    // do not retry operation\n}\nelse {\n    // sleep, for example, Thread.sleep(waitInterval)\n    // retry operation\n}\n\nOnce the underlying operation has completed successfully,\nthe execution instance can be discarded.",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.backoff.BackOff",
      "head_type": "class",
      "relation": "have",
      "tail": "author: Stephane Nicoll, since: 4.1",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.backoff.BackOff",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "BackOffExecution",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.backoff.ExponentialBackOff#setInitialInterval(long)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "setInitialInterval",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.backoff.ExponentialBackOff#setInitialInterval(long)",
      "head_type": "method",
      "relation": "have",
      "tail": "Set the initial interval in milliseconds",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.backoff.ExponentialBackOff#setInitialInterval(long)",
      "head_type": "method",
      "relation": "have",
      "tail": "public void setInitialInterval(long initialInterval) {    this.initialInterval = initialInterval;}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.backoff.ExponentialBackOff#setMaxElapsedTime(long)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "set maximum elapsed time",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.backoff.ExponentialBackOff#setMaxElapsedTime(long)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "maxElapsedTime must be non-negative",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.backoff.ExponentialBackOff#setMaxElapsedTime(long)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "controlling backoff execution",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.backoff.ExponentialBackOff#setMaxElapsedTime(long)",
      "head_type": "method",
      "relation": "have",
      "tail": "set maximum elapsed time sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.backoff.ExponentialBackOff#setMaxElapsedTime(long)",
      "head_type": "method",
      "relation": "have",
      "tail": "related concept interpretation for setMaxElapsedTime",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.backoff.ExponentialBackOff#setMaxElapsedTime(long)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle interpretation for setMaxElapsedTime",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.backoff.ExponentialBackOff#setMaxElapsedTime(long)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "BackOffExecution",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.ClassUtils#isVoidType(Class<?>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "check if a type represents Void or void",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ClassUtils#isVoidType(Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for checking Void or void type",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ClassUtils#isVoidType(Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "interpretation of Void and void types",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#isVoidType(Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle behind Void type checking",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#isVoidType(Class<?>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "Void",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.ClassUtils#isVoidType(Class<?>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "Void#TYPE",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.ClassUtils#convertResourcePathToClassName(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "convertResourcePathToClassName",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ClassUtils#convertResourcePathToClassName(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "Convert a '/'-based resource path to a '.'-based fully qualified class name.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#convertResourcePathToClassName(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "Ensure the resource path is not null.",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ClassUtils#convertResourcePathToClassName(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "Replace '/' with '.' in the resource path to get the class name.",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ClassUtils#convertResourcePathToClassName(String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.ClassUtils",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.ClassUtils#determineCommonAncestor(Class<?>,Class<?>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "determine common ancestor",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ClassUtils#determineCommonAncestor(Class<?>,Class<?>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "null input returns the other class",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ClassUtils#determineCommonAncestor(Class<?>,Class<?>)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "introspection of two classes",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ClassUtils#determineCommonAncestor(Class<?>,Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "finds common superclass or interface",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#determineCommonAncestor(Class<?>,Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "efficiently traverses class hierarchy",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#determineCommonAncestor(Class<?>,Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "public static Class<?> determineCommonAncestor(@Nullable Class<?> clazz1, @Nullable Class<?> clazz2) {\n    if (clazz1 == null) {\n        return clazz2;\n    }\n    if (clazz2 == null) {\n        return clazz1;\n    }\n    if (clazz1.isAssignableFrom(clazz2)) {\n        return clazz1;\n    }\n    if (clazz2.isAssignableFrom(clazz1)) {\n        return clazz2;\n    }\n    Class<?> ancestor = clazz1;\n    do {\n        ancestor = ancestor.getSuperclass();\n        if (ancestor == null || Object.class == ancestor) {\n            return null;\n        }\n    } while (!ancestor.isAssignableFrom(clazz2));\n    return ancestor;\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ClassUtils#getStaticMethod(Class<?>,String,Class<?>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getStaticMethod",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ClassUtils#getStaticMethod(Class<?>,String,Class<?>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "IllegalArgumentException",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ClassUtils#getStaticMethod(Class<?>,String,Class<?>)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "classMethodRetrieval",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ClassUtils#getStaticMethod(Class<?>,String,Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "getStaticMethodSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ClassUtils#getStaticMethod(Class<?>,String,Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "classMethodRetrievalConcept",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#getStaticMethod(Class<?>,String,Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "staticMethodDesignPrinciple",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "getStaticMethodSampleCode",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "tail": "org.springframework.util.ClassUtils#getStaticMethod(Class<?>,String,Class<?>)",
      "tail_type": "method"
    },
    {
      "head": "classMethodRetrievalConcept",
      "head_type": "relatedConceptInterpretation",
      "relation": "associated_with",
      "tail": "org.springframework.util.ClassUtils#getStaticMethod(Class<?>,String,Class<?>)",
      "tail_type": "method"
    },
    {
      "head": "staticMethodDesignPrinciple",
      "head_type": "designPrincipleInterpretation",
      "relation": "associated_with",
      "tail": "org.springframework.util.ClassUtils#getStaticMethod(Class<?>,String,Class<?>)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.CompositeIterator#next()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "iterate over multiple iterators",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.CompositeIterator#next()",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is used to iterate over multiple iterators and return the next element.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.CompositeIterator#next()",
      "head_type": "method",
      "relation": "have",
      "tail": "The method ensures that all iterators are exhausted before throwing a NoSuchElementException.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.CompositeIterator#next()",
      "head_type": "method",
      "relation": "have",
      "tail": "java\npackage org.springframework.util;\n\nimport java.util.Iterator;\nimport java.util.NoSuchElementException;\n\npublic class CompositeIteratorExample {\n    public static void main(String[] args) {\n        List<Iterator<String>> iterators = new ArrayList<>();\n        iterators.add(Arrays.asList(\"a\", \"b\", \"c\").iterator());\n        iterators.add(Arrays.asList(\"d\", \"e\", \"f\").iterator());\n\n        CompositeIterator<String> compositeIterator = new CompositeIterator<>(iterators);\n        while (compositeIterator.hasNext()) {\n            System.out.println(compositeIterator.next());\n        }\n    }\n}\n",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.CompositeMap#entrySet()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "entrySet",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.CompositeMap#entrySet()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.CompositeMap",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.CompositeMap#entrySet()",
      "head_type": "method",
      "relation": "have",
      "tail": "Return a set view of the mappings contained in this map.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.CompositeMap#entrySet()",
      "head_type": "method",
      "relation": "have",
      "tail": "The method should follow the general contract of the entrySet() method as defined in the Map interface.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.CompositeMap#entrySet()",
      "head_type": "method",
      "relation": "have",
      "tail": "public Set<Entry<K, V>> entrySet() { return new CompositeSet<>(this.first.entrySet(), this.second.entrySet()); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.concurrent.DelegatingCompletableFuture#cancel(boolean)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "cancel operation",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.concurrent.DelegatingCompletableFuture#cancel(boolean)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is used to attempt to cancel execution of this task.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.concurrent.DelegatingCompletableFuture#cancel(boolean)",
      "head_type": "method",
      "relation": "have",
      "tail": "The method should be designed to be thread-safe and handle concurrent invocations.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.concurrent.DelegatingCompletableFuture#cancel(boolean)",
      "head_type": "method",
      "relation": "have",
      "tail": "package com.example;\n\nimport java.util.concurrent.CompletableFuture;\n\npublic class CancelExample {\n    public static void main(String[] args) {\n        CompletableFuture<String> future = new CompletableFuture<>();\n        future.cancel(false);\n        System.out.println(\"Future cancelled: \" + future.isCancelled());\n    }\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ConcurrentReferenceHashMap#containsKey(Object)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "checkKeyExistence",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ConcurrentReferenceHashMap#containsKey(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "threadSafeEnvironment",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ConcurrentReferenceHashMap#containsKey(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "nullSafeComparison",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ConcurrentReferenceHashMap#containsKey(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "concurrentHashMapMechanism",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ConcurrentReferenceHashMap#containsKey(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrinciplesForConcurrency",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ConcurrentReferenceHashMap#isEmpty()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "check emptiness of ConcurrentReferenceHashMap",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ConcurrentReferenceHashMap#isEmpty()",
      "head_type": "method",
      "relation": "have",
      "tail": "Iterates over each segment to determine if the map is empty",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ConcurrentReferenceHashMap#isEmpty()",
      "head_type": "method",
      "relation": "have",
      "tail": "Returns true if all segments have a count of 0, indicating the map is empty",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ConcurrentReferenceHashMap#isEmpty()",
      "head_type": "method",
      "relation": "have",
      "tail": "public boolean isEmpty() {\n    for (Segment segment : this.segments) {\n        if (segment.getCount() > 0) {\n            return false;\n        }\n    }\n    return true;\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ConcurrentReferenceHashMap#isEmpty()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.ConcurrentReferenceHashMap",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.Reference#getHash()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "hash retrieval",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.Reference#getHash()",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is used to retrieve the hash code of the reference object.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.Reference#getHash()",
      "head_type": "method",
      "relation": "have",
      "tail": "The design principle behind this method is to provide a way to get a unique hash code for the reference, which can be used in hash-based data structures like HashMaps.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.Reference#getHash()",
      "head_type": "method",
      "relation": "have",
      "tail": "public class Reference {\n    public int getHash() {\n        // Implementation code here\n        return 0; // Placeholder return\n    }\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.FilteredSet#equals(Object)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "equality check",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.FilteredSet#equals(Object)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "nullability of other object",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.FilteredSet#equals(Object)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "comparing sets for equality",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.FilteredSet#equals(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.FilteredSet#containsAll(Set<?>)",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.FilteredSet#equals(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "related concept interpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.FilteredSet#equals(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle interpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.FilteredSet#equals(Object)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.Set",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.function.ThrowingFunction",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "applying a function that may throw a checked exception",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.function.ThrowingFunction",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "applying a function with exception wrapping",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.function.ThrowingFunction",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "creating a ThrowingFunction with a custom exception wrapper",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.function.ThrowingFunction",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "converting a method that throws a checked exception to a Function",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.function.ThrowingFunction",
      "head_type": "class",
      "relation": "have",
      "tail": "sample code for using ThrowingFunction to map a stream",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.function.ThrowingFunction",
      "head_type": "class",
      "relation": "have",
      "tail": "sample code for creating a ThrowingFunction with a custom exception wrapper",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.function.ThrowingFunction",
      "head_type": "class",
      "relation": "have",
      "tail": "interpretation of the concept of a function that can throw exceptions",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.function.ThrowingFunction",
      "head_type": "class",
      "relation": "have",
      "tail": "design principles behind ThrowingFunction",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.function.ThrowingFunction",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "java.util.function.Function",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.function.ThrowingFunction",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "BiFunction",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.function.ThrowingFunction",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "RuntimeException",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.function.ThrowingFunction",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "IllegalStateException",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.InvalidMimeTypeException#getMimeType()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getMimeType",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.InvalidMimeTypeException#getMimeType()",
      "head_type": "method",
      "relation": "have",
      "tail": "Return the offending content type.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.InvalidMimeTypeException",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.InvalidMimeTypeException#getMimeType()",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.LinkedCaseInsensitiveMap#equals(Object)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "equality check",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.LinkedCaseInsensitiveMap#equals(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.LinkedCaseInsensitiveMap#equals(Object) checks if the given object is equal to this map.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "equality check",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "org.springframework.util.LinkedCaseInsensitiveMap#equals(Object) checks if the given object is equal to this map.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "equality check",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "package com.example.util;\n\nimport java.util.Map;\nimport java.util.LinkedHashMap;\n\npublic class LinkedCaseInsensitiveMap<K, V> extends LinkedHashMap<K, V> {\n    @Override\n    public boolean equals(Object other) {\n        return (this == other || this.targetMap.equals(other));\n    }\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.MimeType#isMoreSpecific(MimeType)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "MimeType Comparison",
      "tail_type": "apiFunction"
    },
    {
      "head": "MimeType Comparison",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "Wildcard Type Constraint",
      "tail_type": "useConstraint"
    },
    {
      "head": "MimeType Comparison",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "Specificity Determination",
      "tail_type": "useScenario"
    },
    {
      "head": "MimeType Comparison",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "Sample Code for MimeType Comparison",
      "tail_type": "useSampleCode"
    },
    {
      "head": "MimeType Comparison",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "Related Concepts Interpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "MimeType Comparison",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "Design Principle Interpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.MimeType#isMoreSpecific(MimeType)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.MimeType",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.MultiToSingleValueMapAdapter#containsValue(Object)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "check for value presence",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MultiToSingleValueMapAdapter#containsValue(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "Iterates over entry set to find value",
      "tail_type": "useSampleCode"
    },
    {
      "head": "check for value presence",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "value must be nullable",
      "tail_type": "useConstraint"
    },
    {
      "head": "check for value presence",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "determine if map contains a specific value",
      "tail_type": "useScenario"
    },
    {
      "head": "Iterates over entry set to find value",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "public boolean containsValue(@Nullable Object value) { Iterator<Entry<K, V>> i = entrySet().iterator(); if (value == null) { while (i.hasNext()) { Entry<K, V> e = i.next(); if (e.getValue() == null) { return true; } } } else { while (i.hasNext()) { Entry<K, V> e = i.next(); if (value.equals(e.getValue())) { return true; } } } return false; }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.MultiToSingleValueMapAdapter#containsValue(Object)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.MultiToSingleValueMapAdapter",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.MultiToSingleValueMapAdapter",
      "head_type": "class",
      "relation": "have",
      "tail": "Adapter for converting multi-value map to single-value map",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.MultiToSingleValueMapAdapter",
      "head_type": "class",
      "relation": "have",
      "tail": "Efficiency in iterating over entries",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.MultiValueMap#fromMultiValue(Map<K,List<V>>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "adapt a multi-value map",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MultiValueMap#fromMultiValue(Map<K,List<V>>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "map must not be null",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.MultiValueMap#fromMultiValue(Map<K,List<V>>)",
      "head_type": "method",
      "relation": "have",
      "tail": "Return a MultiValueMap<K, V> that adapts the given multi-value Map<K, List<V>>.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.MultiValueMap#fromMultiValue(Map<K,List<V>>)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is used to adapt a given multi-value map, ensuring that the input map is not null.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.MultiValueMap#fromMultiValue(Map<K,List<V>>)",
      "head_type": "method",
      "relation": "have",
      "tail": "static <K, V> MultiValueMap<K, V> fromMultiValue(Map<K, List<V>> map) {\n    Assert.notNull(map, \"Map must not be null\");\n    return new MultiValueMapAdapter<>(map);\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.MultiValueMapAdapter#remove(Object)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "remove a key-value pair",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MultiValueMapAdapter#remove(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.MultiValueMapAdapter",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.MultiValueMapAdapter",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.MultiValueMap",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.MultiValueMapAdapter#remove(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "public List<V> remove(Object key) { return this.targetMap.remove(key); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.MultiValueMapAdapter#remove(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "Removes a key-value pair from the map",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.MultiValueMapAdapter#remove(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "Design principle of removing elements from a map",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.MultiValueMapAdapter#putAll(Map<? extends K,? extends List<V>>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "add multiple key-value pairs to the map",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MultiValueMapAdapter#putAll(Map<? extends K,? extends List<V>>)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.MultiValueMapAdapter#putAll(Map<? extends K,? extends List<V>>) - UseSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.MultiValueMapAdapter#putAll(Map<? extends K,? extends List<V>>) - UseSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "public void putAll(Map<? extends K, ? extends List<V>> map) {\n    this.targetMap.putAll(map);\n}",
      "tail_type": "code"
    },
    {
      "head": "org.springframework.util.ObjectUtils#containsConstant(Enum<?>[],String,boolean)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "check enum constant presence",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ObjectUtils#containsConstant(Enum<?>[],String,boolean)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "constant name must not be null or empty",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ObjectUtils#containsConstant(Enum<?>[],String,boolean)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "searching enum constants",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ObjectUtils#containsConstant(Enum<?>[],String,boolean)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for checking enum constant presence",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ObjectUtils#containsConstant(Enum<?>[],String,boolean)",
      "head_type": "method",
      "relation": "have",
      "tail": "interpretation of related concepts for enum constant search",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ObjectUtils#containsConstant(Enum<?>[],String,boolean)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle interpretation for enum constant search method",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "check enum constant presence",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "org.springframework.util.ObjectUtils#containsConstant(Enum<?>[],String,boolean)",
      "tail_type": "method"
    },
    {
      "head": "constant name must not be null or empty",
      "head_type": "useConstraint",
      "relation": "associated_with",
      "tail": "org.springframework.util.ObjectUtils#containsConstant(Enum<?>[],String,boolean)",
      "tail_type": "method"
    },
    {
      "head": "searching enum constants",
      "head_type": "useScenario",
      "relation": "associated_with",
      "tail": "org.springframework.util.ObjectUtils#containsConstant(Enum<?>[],String,boolean)",
      "tail_type": "method"
    },
    {
      "head": "sample code for checking enum constant presence",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "tail": "org.springframework.util.ObjectUtils#containsConstant(Enum<?>[],String,boolean)",
      "tail_type": "method"
    },
    {
      "head": "interpretation of related concepts for enum constant search",
      "head_type": "relatedConceptInterpretation",
      "relation": "associated_with",
      "tail": "org.springframework.util.ObjectUtils#containsConstant(Enum<?>[],String,boolean)",
      "tail_type": "method"
    },
    {
      "head": "design principle interpretation for enum constant search method",
      "head_type": "designPrincipleInterpretation",
      "relation": "associated_with",
      "tail": "org.springframework.util.ObjectUtils#containsConstant(Enum<?>[],String,boolean)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeEquals(Object,Object)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "content-based equality check",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeEquals(Object,Object)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "null handling",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeEquals(Object,Object)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "comparing two objects for equality",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeEquals(Object,Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for nullSafeEquals",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeEquals(Object,Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "related concept interpretation for nullSafeEquals",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeEquals(Object,Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle interpretation for nullSafeEquals",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeEquals(Object,Object)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "java.util.Arrays",
      "tail_type": "class"
    },
    {
      "head": "java.util.Arrays",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.ObjectUtils#nullSafeEquals(Object,Object)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.ObjectUtils",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "nullSafeHashCode(double[])",
      "tail_type": "apiFunction"
    },
    {
      "head": "nullSafeHashCode(double[])",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "deprecated as of 6.1",
      "tail_type": "useConstraint"
    },
    {
      "head": "nullSafeHashCode(double[])",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "hash code generation for double array",
      "tail_type": "useScenario"
    },
    {
      "head": "nullSafeHashCode(double[])",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "sample code for nullSafeHashCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "nullSafeHashCode(double[])",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "related concept interpretation for nullSafeHashCode",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "nullSafeHashCode(double[])",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "design principle interpretation for nullSafeHashCode",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ObjectUtils",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "java.util.Arrays",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.PlaceholderParser#createNestedPlaceholderPart(String,List<Part>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "createNestedPlaceholderPart",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.PlaceholderParser#createNestedPlaceholderPart(String,List<Part>)",
      "head_type": "method",
      "relation": "have",
      "tail": "createNestedPlaceholderPart(String,List<Part>)",
      "tail_type": "useSampleCode"
    },
    {
      "head": "createNestedPlaceholderPart(String,List<Part>)",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "tail": "org.springframework.util.PlaceholderParser",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#isEqualsMethod(Method)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "determine if a method is an 'equals' method",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#isEqualsMethod(Method)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for determining if a method is an 'equals' method",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#isEqualsMethod(Method)",
      "head_type": "method",
      "relation": "have",
      "tail": "related concept interpretation for determining if a method is an 'equals' method",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#isEqualsMethod(Method)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle interpretation for determining if a method is an 'equals' method",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#isEqualsMethod(Method)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "java.lang.Object#equals(Object)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.SimpleRouteMatcher#matchAndExtract(String,Route)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "match and extract",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.SimpleRouteMatcher#matchAndExtract(String,Route)",
      "head_type": "method",
      "relation": "have",
      "tail": "match and extract sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.SimpleRouteMatcher#matchAndExtract(String,Route)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.SimpleRouteMatcher",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.SingleToMultiValueMapAdapter#getFirst(K)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getFirst",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.SingleToMultiValueMapAdapter#getFirst(K)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.MultiValueMap",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.SingleToMultiValueMapAdapter#getFirst(K)",
      "head_type": "method",
      "relation": "have",
      "tail": "getFirst(K key) { return this.targetMap.get(key); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.SingleToMultiValueMapAdapter#setAll(Map<K,V>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "setAll",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.SingleToMultiValueMapAdapter#setAll(Map<K,V>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "SingleToMultiValueMapAdapter",
      "tail_type": "class"
    },
    {
      "head": "setAll",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "org.springframework.util.SingleToMultiValueMapAdapter#setAll(Map<K,V>)",
      "tail_type": "useSampleCode"
    },
    {
      "head": "SingleToMultiValueMapAdapter",
      "head_type": "class",
      "relation": "have",
      "tail": "org.springframework.util.SingleToMultiValueMapAdapter#setAll(Map<K,V>)",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.SingleToMultiValueMapAdapter#putAll(Map<? extends K,? extends List<V>>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "add multiple key-value pairs to the map",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.SingleToMultiValueMapAdapter#putAll(Map<? extends K,? extends List<V>>)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.SingleToMultiValueMapAdapter#putAll(Map<? extends K,? extends List<V>>) - UseSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.SingleToMultiValueMapAdapter#putAll(Map<? extends K,? extends List<V>>) - UseSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "Complete Example for putAll method",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.SingleToMultiValueMapAdapter#toString()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "toString conversion",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.SingleToMultiValueMapAdapter#toString()",
      "head_type": "method",
      "relation": "have",
      "tail": "Converts the targetMap to a string representation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.SingleToMultiValueMapAdapter#toString()",
      "head_type": "method",
      "relation": "have",
      "tail": "public String toString() { return this.targetMap.toString(); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.SingleToMultiValueMapAdapter#toString()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.SingleToMultiValueMapAdapter",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.TaskInfo#getTime(TimeUnit)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "获取任务执行时间",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.TaskInfo#getTime(TimeUnit)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "timeUnit参数必须有效",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.TaskInfo#getTime(TimeUnit)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "需要获取任务执行时间的场景",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.TaskInfo#getTime(TimeUnit)",
      "head_type": "method",
      "relation": "have",
      "tail": "获取任务执行时间的示例代码",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.TaskInfo#getTime(TimeUnit)",
      "head_type": "method",
      "relation": "have",
      "tail": "获取任务执行时间的概念解释",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.TaskInfo#getTime(TimeUnit)",
      "head_type": "method",
      "relation": "have",
      "tail": "获取任务执行时间的设计原则解释",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.TaskInfo#getTime(TimeUnit)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.TaskInfo",
      "tail_type": "class"
    },
    {
      "tail": "decorating OutputStream",
      "head_type": "method",
      "relation": "haveFunction",
      "head": "org.springframework.util.StreamUtils#nonClosing(OutputStream)",
      "tail_type": "apiFunction"
    },
    {
      "tail": "OutputStream must not be null",
      "head_type": "method",
      "relation": "constrained_by",
      "head": "org.springframework.util.StreamUtils#nonClosing(OutputStream)",
      "tail_type": "useConstraint"
    },
    {
      "tail": "decorating OutputStream sample code",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.StreamUtils#nonClosing(OutputStream)",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "decorating OutputStream concept interpretation",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.StreamUtils#nonClosing(OutputStream)",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "tail": "decorating OutputStream design principle interpretation",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.StreamUtils#nonClosing(OutputStream)",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.NonClosingOutputStream",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "override write method",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.NonClosingOutputStream",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "override close method",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.NonClosingOutputStream",
      "head_type": "class",
      "relation": "have",
      "tail": "performance improvement",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "override write method",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "write(byte[] b, int off, int let)",
      "tail_type": "useSampleCode"
    },
    {
      "head": "override close method",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "close()",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.StringUtils#substringMatch(CharSequence,int,CharSequence)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "string matching",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils#substringMatch(CharSequence,int,CharSequence)",
      "head_type": "method",
      "relation": "have",
      "tail": "Test whether the given string matches the given substring at the given index.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.StringUtils#substringMatch(CharSequence,int,CharSequence)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method checks if a substring matches a specified part of a given string starting from a particular index. It returns true if the substring matches, otherwise false.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.StringUtils#substringMatch(CharSequence,int,CharSequence)",
      "head_type": "method",
      "relation": "have",
      "tail": "public static boolean substringMatch(CharSequence str, int index, CharSequence substring) {\n    if (index + substring.length() > str.length()) {\n        return false;\n    }\n    for (int i = 0; i < substring.length(); i++) {\n        if (str.charAt(index + i) != substring.charAt(i)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.StringValueResolver",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "resolveStringValue",
      "tail_type": "apiFunction"
    },
    {
      "head": "resolveStringValue",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "IllegalArgumentException",
      "tail_type": "useConstraint"
    },
    {
      "head": "resolveStringValue",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "ConfigurableBeanFactory",
      "tail_type": "useScenario"
    },
    {
      "head": "resolveStringValue",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "resolveAliases",
      "tail_type": "useScenario"
    },
    {
      "head": "resolveStringValue",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "BeanDefinitionVisitor",
      "tail_type": "useScenario"
    },
    {
      "head": "resolveStringValue",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "StringValueResolver",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "resolveStringValue",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "resolveStringValue",
      "tail_type": "useSampleCode"
    },
    {
      "head": "resolveStringValue",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "resolveStringValue",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.StringValueResolver",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "ConfigurableBeanFactory",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.StringValueResolver",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "BeanDefinitionVisitor",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.TypeUtils",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getUpperBounds(WildcardType)",
      "tail_type": "apiFunction"
    },
    {
      "head": "getUpperBounds(WildcardType)",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "private static Type[] getUpperBounds(WildcardType wildcardType) { Type[] upperBounds = wildcardType.getUpperBounds(); return (upperBounds.length == 0 ? IMPLICIT_UPPER_BOUNDS : upperBounds); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "getUpperBounds(WildcardType)",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "WildcardType must not be null",
      "tail_type": "useConstraint"
    },
    {
      "head": "getUpperBounds(WildcardType)",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "Retrieving upper bounds of a wildcard type",
      "tail_type": "useScenario"
    },
    {
      "head": "getUpperBounds(WildcardType)",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "Retrieves the upper bounds of a wildcard type, providing an implicit bound if none are specified.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "getUpperBounds(WildcardType)",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "Design principle: Provide a default when no specific bounds are set, ensuring type safety.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.unit.DataSizeUtils",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "lazy loading",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.unit.DataSizeUtils",
      "head_type": "class",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.unit.DataSizeUtils",
      "head_type": "class",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.unit.DataSizeUtils",
      "head_type": "class",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#replace(K,List<V>,List<V>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "replace",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#replace(K,List<V>,List<V>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "UnsupportedOperationException",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#replace(K,List<V>,List<V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is not supported and will always throw an UnsupportedOperationException.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#replace(K,List<V>,List<V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "The method is designed to enforce immutability, preventing any modifications to the map.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#replace(K,List<V>,List<V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "package com.example.util;\n\nimport java.util.List;\n\npublic class UnmodifiableMultiValueMapExample {\n    public static void main(String[] args) {\n        // Example usage of UnmodifiableMultiValueMap\n    }\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySet#add(Entry<K,List<V>>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "addEntry",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySet#add(Entry<K,List<V>>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "unsupportedOperation",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySet#add(Entry<K,List<V>>)",
      "head_type": "method",
      "relation": "have",
      "tail": "throwUnsupportedOperationException",
      "tail_type": "useSampleCode"
    },
    {
      "head": "throwUnsupportedOperationException",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "tail": "org.springframework.util.UnmodifiableEntrySet#add(Entry<K,List<V>>)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySet#add(Entry<K,List<V>>)",
      "head_type": "method",
      "relation": "have",
      "tail": "unsupportedOperationExceptionExplanation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "unsupportedOperationExceptionExplanation",
      "head_type": "relatedConceptInterpretation",
      "relation": "associated_with",
      "tail": "org.springframework.util.UnmodifiableEntrySet#add(Entry<K,List<V>>)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySet#add(Entry<K,List<V>>)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleForUnmodifiableCollections",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "designPrincipleForUnmodifiableCollections",
      "head_type": "designPrincipleInterpretation",
      "relation": "associated_with",
      "tail": "org.springframework.util.UnmodifiableEntrySet#add(Entry<K,List<V>>)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySpliterator#trySplit()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "splitting a spliterator",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySpliterator#trySplit()",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for splitting a spliterator",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySpliterator#trySplit()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.UnmodifiableEntrySpliterator",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySpliterator#trySplit()",
      "head_type": "method",
      "relation": "have",
      "tail": "related concept interpretation for splitting a spliterator",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySpliterator#trySplit()",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle interpretation for splitting a spliterator",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntry#equals(Object)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "equality check",
      "tail_type": "apiFunction"
    },
    {
      "head": "equality check",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "null safety",
      "tail_type": "useConstraint"
    },
    {
      "head": "equality check",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "Map.Entry comparison",
      "tail_type": "useScenario"
    },
    {
      "head": "equality check",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "equality check",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntry#equals(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntry#equals(Object)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.UnmodifiableEntry",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueCollection#retainAll(Collection<?>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "override method",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueCollection#retainAll(Collection<?>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "unsupported operation",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueCollection#retainAll(Collection<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "throwing an UnsupportedOperationException",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueCollection#retainAll(Collection<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "ensuring immutability of the collection",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueCollection#retainAll(Collection<?>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.UnmodifiableValueCollection",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueSpliterator",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "UnmodifiableValueSpliterator",
      "tail_type": "apiFunction"
    },
    {
      "head": "UnmodifiableValueSpliterator",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "UnmodifiableValueSpliterator delegate",
      "tail_type": "useSampleCode"
    },
    {
      "head": "UnmodifiableValueSpliterator",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "tryAdvance",
      "tail_type": "useSampleCode"
    },
    {
      "head": "UnmodifiableValueSpliterator",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "forEachRemaining",
      "tail_type": "useSampleCode"
    },
    {
      "head": "UnmodifiableValueSpliterator",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "trySplit",
      "tail_type": "useSampleCode"
    },
    {
      "head": "UnmodifiableValueSpliterator",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "estimateSize",
      "tail_type": "useSampleCode"
    },
    {
      "head": "UnmodifiableValueSpliterator",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "getExactSizeIfKnown",
      "tail_type": "useSampleCode"
    },
    {
      "head": "UnmodifiableValueSpliterator",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "characteristics",
      "tail_type": "useSampleCode"
    },
    {
      "head": "UnmodifiableValueSpliterator",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "hasCharacteristics",
      "tail_type": "useSampleCode"
    },
    {
      "head": "UnmodifiableValueSpliterator",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "getComparator",
      "tail_type": "useSampleCode"
    },
    {
      "head": "UnmodifiableValueSpliterator",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "UnmodifiableValueSpliterator",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueSpliterator#trySplit()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "splitting",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueSpliterator#trySplit()",
      "head_type": "method",
      "relation": "have",
      "tail": "UnmodifiableValueSpliterator",
      "tail_type": "class"
    },
    {
      "head": "UnmodifiableValueSpliterator",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.UnmodifiableValueSpliterator#trySplit()",
      "tail_type": "method"
    },
    {
      "head": "splitting",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "org.springframework.util.UnmodifiableValueSpliterator#trySplit()",
      "tail_type": "method"
    },
    {
      "head": "splitting",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "Splitting a spliterator into two",
      "tail_type": "useScenario"
    },
    {
      "head": "splitting",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "public Spliterator<List<T>> trySplit() {    Spliterator<List<T>> split = this.delegate.trySplit();    if (split != null) {        return new UnmodifiableValueSpliterator<>(split);    } else {        return null;    }}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "splitting",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "The trySplit method is used to split the spliterator into two parts, where one part is returned and the other is retained by the spliterator.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "splitting",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "The design principle behind splitting is to allow parallel processing of data by dividing the data source into multiple segments that can be processed independently.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLStreamReader#hasName()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "check xml element name",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLStreamReader#hasName()",
      "head_type": "method",
      "relation": "have",
      "tail": "This method checks if the current XML event is a start or end element, indicating the presence of a name.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLStreamReader#hasName()",
      "head_type": "method",
      "relation": "have",
      "tail": "public boolean hasName() {\n    int eventType = getEventType();\n    return (eventType == XMLStreamConstants.START_ELEMENT || eventType == XMLStreamConstants.END_ELEMENT);\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLStreamReader",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.AbstractXMLStreamReader#hasName()",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLStreamReader",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getLocalName()",
      "tail_type": "apiFunction"
    },
    {
      "head": "getLocalName()",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "getLocalName() returns the local part of the name.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "getLocalName()",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "The method getName() is called to obtain the full name.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "getLocalName()",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "getName().getLocalPart() extracts the local part from the full name.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "getLocalName()",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "The return value is of type String.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "getLocalName()",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "This method overrides a method from a parent class or interface.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "getLocalName()",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "This method is likely part of an XML processing class.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLStreamReader",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLStreamReader",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "XML processing",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.DomContentHandler#startDocument()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "startDocument",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.DomContentHandler#startDocument()",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.xml.DomContentHandler#startDocument() sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.DomUtils",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getChildElementsByTagName",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.DomUtils",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getChildElementByTagName",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.DomUtils",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getChildElementValueByTagName",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.DomUtils",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getChildElements",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.DomUtils",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getTextValue",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.DomUtils",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "nodeNameEquals",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.DomUtils",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "createContentHandler",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.DomUtils",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "nodeNameMatch",
      "tail_type": "apiFunction"
    },
    {
      "head": "getChildElementsByTagName",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "direct child element retrieval",
      "tail_type": "useScenario"
    },
    {
      "head": "getChildElementByTagName",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "first child element retrieval",
      "tail_type": "useScenario"
    },
    {
      "head": "getChildElementValueByTagName",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "first child element value retrieval",
      "tail_type": "useScenario"
    },
    {
      "head": "getChildElements",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "all child elements retrieval",
      "tail_type": "useScenario"
    },
    {
      "head": "getTextValue",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "text value extraction",
      "tail_type": "useScenario"
    },
    {
      "head": "nodeNameEquals",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "node name comparison",
      "tail_type": "useScenario"
    },
    {
      "head": "createContentHandler",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "SAX ContentHandler creation",
      "tail_type": "useScenario"
    },
    {
      "head": "nodeNameMatch",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "node name matching",
      "tail_type": "useScenario"
    },
    {
      "head": "getChildElementsByTagName",
      "head_type": "apiFunction",
      "relation": "useSampleCode",
      "tail": "List<Element> elements = DomUtils.getChildElementsByTagName(rootElement, \"childName1\", \"childName2\");",
      "tail_type": "useSampleCode"
    },
    {
      "head": "getChildElementByTagName",
      "head_type": "apiFunction",
      "relation": "useSampleCode",
      "tail": "Element element = DomUtils.getChildElementByTagName(rootElement, \"childName\");",
      "tail_type": "useSampleCode"
    },
    {
      "head": "getChildElementValueByTagName",
      "head_type": "apiFunction",
      "relation": "useSampleCode",
      "tail": "String value = DomUtils.getChildElementValueByTagName(rootElement, \"childName\");",
      "tail_type": "useSampleCode"
    },
    {
      "head": "getChildElements",
      "head_type": "apiFunction",
      "relation": "useSampleCode",
      "tail": "List<Element> elements = DomUtils.getChildElements(rootElement);",
      "tail_type": "useSampleCode"
    },
    {
      "head": "getTextValue",
      "head_type": "apiFunction",
      "relation": "useSampleCode",
      "tail": "String text = DomUtils.getTextValue(element);",
      "tail_type": "useSampleCode"
    },
    {
      "head": "nodeNameEquals",
      "head_type": "apiFunction",
      "relation": "useSampleCode",
      "tail": "boolean equals = DomUtils.nodeNameEquals(element, \"desiredName\");",
      "tail_type": "useSampleCode"
    },
    {
      "head": "createContentHandler",
      "head_type": "apiFunction",
      "relation": "useSampleCode",
      "tail": "ContentHandler handler = DomUtils.createContentHandler(node);",
      "tail_type": "useSampleCode"
    },
    {
      "head": "nodeNameMatch",
      "head_type": "apiFunction",
      "relation": "useSampleCode",
      "tail": "boolean match = DomUtils.nodeNameMatch(element, \"desiredName\");",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.DomUtils",
      "head_type": "class",
      "relation": "relatedConceptInterpretation",
      "tail": "This class provides utility methods for simplifying work with the Document Object Model (DOM) in Java, particularly focusing on operations related to nodes and elements. It includes methods for retrieving child elements by name, extracting text values, and comparing node names, among other functionalities. These methods are designed to complement the standard DOM API, offering a more convenient and concise way to manipulate XML documents.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.DomUtils",
      "head_type": "class",
      "relation": "designPrincipleInterpretation",
      "tail": "The design of the DomUtils class adheres to the principle of convenience and practicality in working with XML documents. It encapsulates common operations that are often repetitive or cumbersome when using the standard DOM API directly. By providing straightforward methods for tasks like retrieving elements by name or extracting text values, the class aims to reduce boilerplate code and improve developer productivity. The methods are designed to be intuitive and easy to use, aligning with the broader Spring Framework's philosophy of simplifying enterprise application development.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxEventHandler#charactersInternal(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "handle XML character data",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxEventHandler#charactersInternal(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "protected void charactersInternal(String data) throws XMLStreamException {    this.eventWriter.add(this.eventFactory.createCharacters(data));}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.StaxEventHandler#charactersInternal(String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.StaxEventHandler",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.StaxEventHandler",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "XML event handling",
      "tail_type": "apiFunction"
    },
    {
      "head": "handle XML character data",
      "head_type": "apiFunction",
      "relation": "relatedConceptInterpretation",
      "tail": "Handling XML character data involves processing the character data within an XML document. This typically includes text content within XML elements. Proper handling ensures that the data is correctly parsed and processed according to the XML specifications.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "XML event handling",
      "head_type": "apiFunction",
      "relation": "relatedConceptInterpretation",
      "tail": "XML event handling refers to the process of parsing XML documents by responding to events such as the start and end of elements, character data, and other XML structures. This approach allows for efficient and flexible processing of XML content.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "handle XML character data",
      "head_type": "apiFunction",
      "relation": "designPrincipleInterpretation",
      "tail": "The design principle behind handling XML character data is to ensure that the text content within XML elements is accurately captured and processed. This involves adhering to XML parsing rules and efficiently managing character data to maintain the integrity of the XML document structure.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "XML event handling",
      "head_type": "apiFunction",
      "relation": "designPrincipleInterpretation",
      "tail": "The design principle for XML event handling is to provide a flexible and efficient mechanism for parsing XML documents. By responding to events, the parser can process the XML content incrementally, which is particularly useful for large XML documents. This approach minimizes memory usage and allows for scalable XML processing.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxResult#getXMLStreamWriter()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "get XMLStreamWriter",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxResult#getXMLStreamWriter()",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "null if created with XMLEventConsumer",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.xml.StaxResult#getXMLStreamWriter()",
      "head_type": "method",
      "relation": "have",
      "tail": "Return the XMLStreamWriter used by this StaxResult",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxResult",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.StaxResult#getXMLStreamWriter()",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.xml.StaxResult#getXMLStreamWriter()",
      "head_type": "method",
      "relation": "have",
      "tail": "public XMLStreamWriter getXMLStreamWriter() { return this.streamWriter; }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamXMLReader#handleStartDocument()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "xmlVersionHandling",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamXMLReader#handleStartDocument()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "encodingSetting",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamXMLReader#handleStartDocument()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "documentLocatorSetting",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamXMLReader#handleStartDocument()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "contentHandlerInitialization",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamXMLReader#handleStartDocument()",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "validSAXExceptionHandling",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamXMLReader#handleStartDocument()",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "xmlDocumentParsing",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamXMLReader#handleStartDocument()",
      "head_type": "method",
      "relation": "have",
      "tail": "xmlVersionHandlingSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamXMLReader#handleStartDocument()",
      "head_type": "method",
      "relation": "have",
      "tail": "encodingSettingSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamXMLReader#handleStartDocument()",
      "head_type": "method",
      "relation": "have",
      "tail": "documentLocatorSettingSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamXMLReader#handleStartDocument()",
      "head_type": "method",
      "relation": "have",
      "tail": "contentHandlerInitializationSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamXMLReader#handleStartDocument()",
      "head_type": "method",
      "relation": "have",
      "tail": "xmlVersionHandlingExplanation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamXMLReader#handleStartDocument()",
      "head_type": "method",
      "relation": "have",
      "tail": "encodingSettingExplanation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamXMLReader#handleStartDocument()",
      "head_type": "method",
      "relation": "have",
      "tail": "documentLocatorSettingExplanation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamXMLReader#handleStartDocument()",
      "head_type": "method",
      "relation": "have",
      "tail": "contentHandlerInitializationExplanation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamXMLReader#handleStartDocument()",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrinciplesOfStaxStreamXMLReader",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamXMLReader#handleStartDocument()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.StaxStreamXMLReader",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamXMLReader#handleCharacters()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "handleCharacters",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamXMLReader#handleCharacters()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.StaxStreamXMLReader",
      "tail_type": "class"
    },
    {
      "head": "handleCharacters",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "private void handleCharacters() throws SAXException {\n    if (XMLStreamConstants.CDATA == this.reader.getEventType() && getLexicalHandler() != null) {\n        getLexicalHandler().startCDATA();\n    }\n    if (getContentHandler() != null) {\n        getContentHandler().characters(this.reader.getTextCharacters(), this.reader.getTextStart(), this.reader.getTextLength());\n    }\n    if (XMLStreamConstants.CDATA == this.reader.getEventType() && getLexicalHandler() != null) {\n        getLexicalHandler().endCDATA();\n    }\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "handleCharacters",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "This method handles character data from the XML stream.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "handleCharacters",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "The method ensures proper handling of CDATA sections and character data by delegating to the appropriate handlers.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils#createDefensiveInputFactory(Supplier<T>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "createDefensiveInputFactory",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils#createDefensiveInputFactory(Supplier<T>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "instanceSupplier must not be null",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils#createDefensiveInputFactory(Supplier<T>)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "custom instance creation",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils#createDefensiveInputFactory(Supplier<T>)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils#createDefensiveInputFactory(Supplier<T>)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils#createDefensiveInputFactory(Supplier<T>)",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "createDefensiveInputFactory",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.StaxUtils",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "createDefensiveInputFactory",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils#createXMLReader(XMLEventReader)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "create a SAX XMLReader from a StAX XMLEventReader",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils#createXMLReader(XMLEventReader)",
      "head_type": "method",
      "relation": "have",
      "tail": "Create a SAX XMLReader that reads from the given StAX XMLEventReader",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils#createXMLReader(XMLEventReader)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is used to bridge between StAX and SAX parsers",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils#createXMLReader(XMLEventReader)",
      "head_type": "method",
      "relation": "have",
      "tail": "The method facilitates the integration of StAX-based XML processing with SAX-based XML processing by creating a XMLReader that can read from a StAX XMLEventReader",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "create a SAX XMLReader from a StAX XMLEventReader",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils",
      "head_type": "class",
      "relation": "have",
      "tail": "Create a SAX XMLReader that reads from the given StAX XMLEventReader",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils",
      "head_type": "class",
      "relation": "have",
      "tail": "This method is used to bridge between StAX and SAX parsers",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils",
      "head_type": "class",
      "relation": "have",
      "tail": "The method facilitates the integration of StAX-based XML processing with SAX-based XML processing by creating a XMLReader that can read from a StAX XMLEventReader",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils#createXMLReader(XMLEventReader)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.StaxUtils",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils#createEventStreamReader(XMLEventReader)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "create XMLStreamReader from XMLEventReader",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils#createEventStreamReader(XMLEventReader)",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "useSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "sample code for createEventStreamReader",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils#createEventStreamReader(XMLEventReader)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "relatedConceptInterpretation",
      "head_type": "relatedConceptInterpretation",
      "relation": "have",
      "tail": "XMLStreamReader and XMLEventReader relationship",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils#createEventStreamReader(XMLEventReader)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "designPrincipleInterpretation",
      "head_type": "designPrincipleInterpretation",
      "relation": "have",
      "tail": "StAX API design principle",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "example.type.SomeClassAnnotatedWithComponent",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "lazy loading",
      "tail_type": "apiFunction"
    },
    {
      "head": "example.type.SomeClassAnnotatedWithComponent",
      "head_type": "class",
      "relation": "constrained_by",
      "tail": "circular aliases are prohibited",
      "tail_type": "useConstraint"
    },
    {
      "head": "example.type.SomeClassAnnotatedWithComponent",
      "head_type": "class",
      "relation": "applied_to",
      "tail": "multiple aliases for a single name",
      "tail_type": "useScenario"
    },
    {
      "head": "example.type.SomeClassAnnotatedWithComponent",
      "head_type": "class",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "example.type.SomeClassAnnotatedWithComponent",
      "head_type": "class",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "example.type.SomeClassAnnotatedWithComponent",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.core.SimpleAliasRegistryTests",
      "tail_type": "class"
    },
    {
      "head": "example.type.JdbcDaoSupport",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "database interaction",
      "tail_type": "apiFunction"
    },
    {
      "head": "example.type.JdbcDaoSupport",
      "head_type": "class",
      "relation": "have",
      "tail": "JDBC template operations",
      "tail_type": "useScenario"
    },
    {
      "head": "example.type.JdbcDaoSupport",
      "head_type": "class",
      "relation": "have",
      "tail": "JDBC template operations sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "example.type.JdbcDaoSupport",
      "head_type": "class",
      "relation": "have",
      "tail": "JDBC template operations related concepts",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "example.type.JdbcDaoSupport",
      "head_type": "class",
      "relation": "have",
      "tail": "JDBC template operations design principles",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.DefaultGenerationContextTests#createWhenRuntimeHintsIsNullThrowsException()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "handle null runtimeHints",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.DefaultGenerationContextTests#createWhenRuntimeHintsIsNullThrowsException()",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "runtimeHints must not be null",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.aot.generate.DefaultGenerationContextTests#createWhenRuntimeHintsIsNullThrowsException()",
      "head_type": "method",
      "relation": "have",
      "tail": "void createWhenRuntimeHintsIsNullThrowsException() { assertThatIllegalArgumentException().isThrownBy(() -> new DefaultGenerationContext(this.generatedClasses, this.generatedFiles, null)).withMessage(\"'runtimeHints' must not be null\"); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.DefaultGenerationContextTests",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.DefaultGenerationContext",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.DefaultGenerationContextTests#createWhenRuntimeHintsIsNullThrowsException()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.DefaultGenerationContext",
      "tail_type": "class"
    },
    {
      "head": "handle null runtimeHints",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "When runtimeHints is null, an IllegalArgumentException should be thrown.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "runtimeHints must not be null",
      "head_type": "useConstraint",
      "relation": "have",
      "tail": "The runtimeHints parameter is mandatory and cannot be null.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.FileSystemGeneratedFilesTests#handleFileWhenFileExistsFailsToCreate()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "handle existing file",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.FileSystemGeneratedFilesTests#handleFileWhenFileExistsFailsToCreate()",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "file existence",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.aot.generate.FileSystemGeneratedFilesTests#handleFileWhenFileExistsFailsToCreate()",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "file creation failure scenario",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.aot.generate.FileSystemGeneratedFilesTests#handleFileWhenFileExistsFailsToCreate()",
      "head_type": "method",
      "relation": "have",
      "tail": "file creation failure scenario",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.aot.generate.FileSystemGeneratedFilesTests#handleFileWhenFileExistsFailsToCreate()",
      "head_type": "method",
      "relation": "have",
      "tail": "related concept interpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.FileSystemGeneratedFilesTests#handleFileWhenFileExistsFailsToCreate()",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle interpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.FileSystemGeneratedFilesTests#handleFileWhenFileExistsFailsToCreate()",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.FileSystemGeneratedFilesTests#handleFileWhenFileExistsFailsToCreate()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "FileSystemGeneratedFiles",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassesTests#addForFeatureComponentWithSameNameReturnsDifferentInstances()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "addForFeatureComponent",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassesTests#addForFeatureComponentWithSameNameReturnsDifferentInstances()",
      "head_type": "method",
      "relation": "have",
      "tail": "GeneratedClass",
      "tail_type": "class"
    },
    {
      "head": "addForFeatureComponent",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "addForFeatureComponent",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "addForFeatureComponent",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "useSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "sampleCode",
      "tail_type": "sampleCode"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests#handleFileWhenFileExistsFailedToCreate()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "file handling",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests#handleFileWhenFileExistsFailedToCreate()",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "file existence",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests#handleFileWhenFileExistsFailedToCreate()",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "unit testing",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests#handleFileWhenFileExistsFailedToCreate()",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.aot.generate.GeneratedFilesTests",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests#handleFileWhenFileExistsFailedToCreate()",
      "head_type": "method",
      "relation": "have",
      "tail": "void handleFileWhenFileExistsFailedToCreate() { ... }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests#handleFileWhenFileExistsFailedToCreate()",
      "head_type": "method",
      "relation": "have",
      "tail": "related concept interpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests#handleFileWhenFileExistsFailedToCreate()",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle interpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests#handleFileWhenFileExistsFailedToCreate()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.GeneratedFilesTests",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.TestGeneratedFiles#handleFile(Kind,String,ThrowingConsumer<FileHandler>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "file handling",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.TestGeneratedFiles#handleFile(Kind,String,ThrowingConsumer<FileHandler>)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.aot.generate.TestGeneratedFiles",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.TestGeneratedFiles",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.TestGeneratedFiles#handleFile(Kind,String,ThrowingConsumer<FileHandler>)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.aot.generate.TestGeneratedFiles#handleFile(Kind,String,ThrowingConsumer<FileHandler>)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.TestGeneratedFiles#handleFile(Kind,String,ThrowingConsumer<FileHandler>)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.TestGeneratedFiles#handleFile(Kind,String,ThrowingConsumer<FileHandler>)",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.ArrayTests#generateWhenPrimitiveArray()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "generate code for primitive array",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.ArrayTests#generateWhenPrimitiveArray()",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for generating code for primitive array",
      "tail_type": "useSampleCode"
    },
    {
      "head": "generate code for primitive array",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "sample code for generating code for primitive array",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.ArrayTests#generateWhenPrimitiveArray()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.ArrayTests",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.ArrayTests#generateWhenClassArray()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "generate code for class array",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.ArrayTests#generateWhenClassArray()",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for generating class array",
      "tail_type": "useSampleCode"
    },
    {
      "head": "generate code for class array",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "sample code for generating class array",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.ArrayTests#generateWhenClassArray()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.ArrayTests",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#isCandidateWithNonMatchingAnnotatedElement(Class<?>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "determine candidate status",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#isCandidateWithNonMatchingAnnotatedElement(Class<?>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "candidate must not match annotated element",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#isCandidateWithNonMatchingAnnotatedElement(Class<?>)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "testing with non-matching classes",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#isCandidateWithNonMatchingAnnotatedElement(Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#isCandidateWithNonMatchingAnnotatedElement(Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for testing candidate status",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#isCandidateWithNonMatchingAnnotatedElement(Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "related concept interpretation for candidate determination",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#isCandidateWithNonMatchingAnnotatedElement(Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle interpretation for candidate determination",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#isCandidateWithNonMatchingAnnotatedElement(Class<?>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrar",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.hint.annotation.SampleMethodMetaAnnotatedBean#notManaged()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "void function",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.hint.annotation.SampleMethodAnnotatedBeanWithInheritance",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "managed method",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.hint.annotation.SampleMethodAnnotatedBeanWithInheritance",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "not managed method",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.hint.annotation.SampleMethodAnnotatedBeanWithInheritance",
      "head_type": "class",
      "relation": "have",
      "tail": "related concept interpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.hint.annotation.SampleMethodAnnotatedBeanWithInheritance",
      "head_type": "class",
      "relation": "have",
      "tail": "design principle interpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.hint.annotation.SampleMethodAnnotatedBeanWithInheritance",
      "head_type": "class",
      "relation": "have",
      "tail": "sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.hint.annotation.SampleClassWithoutAnnotationAttribute#getName()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "return a static string",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.hint.annotation.SampleClassWithoutAnnotationAttribute#getName()",
      "head_type": "method",
      "relation": "have",
      "tail": "public String getName() {\n    return \"test\";\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.core.type.StandardClassMetadata#isFinal()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "check if class is final",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.core.type.StandardClassMetadata#isFinal()",
      "head_type": "method",
      "relation": "have",
      "tail": "This method checks if the class represented by the introspectedClass object is declared as final.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.core.type.StandardClassMetadata#isFinal()",
      "head_type": "method",
      "relation": "have",
      "tail": "Using java.lang.reflect.Modifier to determine if class is final.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.core.type.StandardClassMetadata#isFinal()",
      "head_type": "method",
      "relation": "have",
      "tail": "java\npackage com.example;\n\nimport java.lang.reflect.Modifier;\n\npublic class FinalClassCheck {\n    public static void main(String[] args) {\n        Class<?> clazz = FinalClass.class;\n        boolean isFinal = Modifier.isFinal(clazz.getModifiers());\n        System.out.println(\"Is the class final? \" + isFinal);\n    }\n\n    public static final class FinalClass {\n        // Class contents\n    }\n}\n",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.core.type.StandardMethodMetadata#toString()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "toString representation",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.core.type.StandardMethodMetadata#toString()",
      "head_type": "method",
      "relation": "have",
      "tail": "Returns a string representation of the introspected method.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.core.type.StandardMethodMetadata#toString()",
      "head_type": "method",
      "relation": "have",
      "tail": "public String toString() { return this.introspectedMethod.toString(); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.Assert#isInstanceOf(Class<?>,Object,String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "assertion",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.Assert#isInstanceOf(Class<?>,Object,String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "type must not be null",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.Assert#isInstanceOf(Class<?>,Object,String)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "check if an object is an instance of a specific class",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.Assert#isInstanceOf(Class<?>,Object,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "Assert.instanceOf(Foo.class, foo, \"Foo expected\")",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.Assert#isInstanceOf(Class<?>,Object,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "IllegalArgumentException if the object is not an instance of type",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.Assert#isInstanceOf(Class<?>,Object,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is designed to ensure type safety by verifying that an object belongs to a specific class before casting or using it, thereby preventing runtime errors.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.Assert",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.Assert#isInstanceOf(Class<?>,Object,String)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.AutoPopulatingList#toArray(T[])",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "convert list to array",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.AutoPopulatingList#toArray(T[])",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.AutoPopulatingList",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.AutoPopulatingList#toArray(T[])",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.backoff.ExponentialBackOffExecution#toString()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "toString",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.backoff.ExponentialBackOffExecution#toString()",
      "head_type": "method",
      "relation": "have",
      "tail": "currentIntervalDescription",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.backoff.ExponentialBackOffExecution#toString()",
      "head_type": "method",
      "relation": "have",
      "tail": "StringJoiner",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.backoff.ExponentialBackOffExecution#toString()",
      "head_type": "method",
      "relation": "have",
      "tail": " multiplier",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.backoff.ExponentialBackOffExecution#toString()",
      "head_type": "method",
      "relation": "have",
      "tail": " attempts",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.backoff.ExponentialBackOffExecution#toString()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "ExponentialBackOffExecution",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.backoff.FixedBackOffExecution",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "backoff execution",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.backoff.FixedBackOffExecution",
      "head_type": "class",
      "relation": "have",
      "tail": "currentAttempts management",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.backoff.FixedBackOffExecution",
      "head_type": "class",
      "relation": "have",
      "tail": "nextBackOff calculation",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.backoff.FixedBackOffExecution",
      "head_type": "class",
      "relation": "have",
      "tail": "toString representation",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.backoff.FixedBackOffExecution",
      "head_type": "class",
      "relation": "have",
      "tail": "backoff interval management",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.backoff.FixedBackOffExecution",
      "head_type": "class",
      "relation": "have",
      "tail": "attempt limit handling",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.backoff.FixedBackOffExecution#nextBackOff()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "backoff interval calculation",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.backoff.FixedBackOffExecution#nextBackOff()",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.backoff.FixedBackOffExecution",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.backoff.FixedBackOffExecution#nextBackOff()",
      "head_type": "method",
      "relation": "have",
      "tail": "This method calculates the next backoff interval based on the current number of attempts and the maximum allowed attempts. If the current attempts are less than or equal to the maximum attempts, it returns the interval. Otherwise, it returns a constant value indicating that no further attempts should be made.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.backoff.FixedBackOffExecution#nextBackOff()",
      "head_type": "method",
      "relation": "have",
      "tail": "The design principle behind this method is to provide a simple and efficient way to calculate the backoff interval for retry operations. It ensures that the backoff interval increases exponentially with each attempt until a maximum limit is reached.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.backoff.FixedBackOffExecution#nextBackOff()",
      "head_type": "method",
      "relation": "have",
      "tail": "public long nextBackOff() {\n    this.currentAttempts++;\n    if (this.currentAttempts <= getMaxAttempts()) {\n        return getInterval();\n    } else {\n        return STOP;\n    }\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ClassUtils#registerCommonClasses(Class<?>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "register common classes",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ClassUtils#registerCommonClasses(Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "Register the given common classes with the ClassUtils cache.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "register common classes",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "org.springframework.util.ClassUtils",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.ClassUtils",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.ClassUtils#registerCommonClasses(Class<?>)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.CollectionUtils#lastElement(Set<T>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "retrieveLastElement",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.CollectionUtils#lastElement(Set<T>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "nullOrEmptySet",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.CollectionUtils#lastElement(Set<T>)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "linkedSet",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.CollectionUtils#lastElement(Set<T>)",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.CollectionUtils#lastElement(Set<T>)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.CollectionUtils#lastElement(Set<T>)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "retrieveLastElement",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "SortedSet",
      "tail_type": "class"
    },
    {
      "head": "retrieveLastElement",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "LinkedHashMap#keySet()",
      "tail_type": "method"
    },
    {
      "head": "retrieveLastElement",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "java.util.LinkedHashSet",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.CompositeMap#remove(Object)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "remove a key-value pair from the map",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.CompositeMap#remove(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "public V remove(Object key) { V firstResult = this.first.remove(key); V secondResult = this.second.remove(key); if (firstResult != null) { return firstResult; } else { return secondResult; } }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.CompositeMap#remove(Object)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.CompositeMap",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.CompositeMap#toString()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "toString representation of CompositeMap",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.CompositeMap#toString()",
      "head_type": "method",
      "relation": "have",
      "tail": "Iterates over entries to build string representation",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.CompositeMap#toString()",
      "head_type": "method",
      "relation": "have",
      "tail": "Handles self-referential maps in toString",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.CompositeMap#toString()",
      "head_type": "method",
      "relation": "have",
      "tail": "StringBuilder used for efficient string concatenation",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.CompositeMap#toString()",
      "head_type": "method",
      "relation": "have",
      "tail": "Returns an empty string for empty maps",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.CompositeMap#toString()",
      "head_type": "method",
      "relation": "have",
      "tail": "Example Code:\npublic String toString() {\n    Iterator<Entry<K, V>> i = entrySet().iterator();\n    if (!i.hasNext()) {\n        return \";\";\n    }\n    StringBuilder sb = new StringBuilder();\n    sb.append('{');\n    while (true) {\n        Entry<K, V> e = i.next();\n        K key = e.getKey();\n        V value = e.getValue();\n        sb.append(key == this ? \"(this Map)\" : key);\n        sb.append('=');\n        sb.append(value == this ? \"(this Map)\" : value);\n        if (!i.hasNext()) {\n            return sb.append('}').toString();\n        }\n        sb.append(',').append(' ');\n    }\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.CompositeMap#toString()",
      "head_type": "method",
      "relation": "have",
      "tail": "Related Concept Interpretation: The method overrides the default toString method to provide a custom string representation of the CompositeMap. It handles self-referential maps by checking if the key or value is the map itself and labels it as '(this Map)'. The use of StringBuilder ensures efficient string concatenation in a loop.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.CompositeMap#toString()",
      "head_type": "method",
      "relation": "have",
      "tail": "Design Principle Interpretation: The design principle demonstrated here is the override of default methods to provide more meaningful and context-specific information. By customizing the toString method, the class aims to enhance readability and debugging capabilities. It also shows consideration for special cases like self-referencing, which can be common in complex data structures.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ConcurrencyThrottleSupport#getConcurrencyLimit()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "get maximum number of concurrent access attempts",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ConcurrencyThrottleSupport#getConcurrencyLimit()",
      "head_type": "method",
      "relation": "have",
      "tail": "Return the maximum number of concurrent access attempts allowed.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ConcurrencyThrottleSupport",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.ConcurrencyThrottleSupport#getConcurrencyLimit()",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.ConcurrentReferenceHashMap#remove(Object,Object)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "removeElement",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ConcurrentReferenceHashMap#remove(Object,Object)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "nullSafety",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ConcurrentReferenceHashMap#remove(Object,Object)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "concurrentEnvironment",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ConcurrentReferenceHashMap#remove(Object,Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ConcurrentReferenceHashMap#remove(Object,Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ConcurrentReferenceHashMap#remove(Object,Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ConcurrentReferenceHashMap#remove(Object,Object)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.ConcurrentReferenceHashMap",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.ConcurrentReferenceHashMap#entrySet()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "entrySet",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ConcurrentReferenceHashMap#entrySet()",
      "head_type": "method",
      "relation": "have",
      "tail": "entrySet() method returns a set view of the mappings contained in the map.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ConcurrentReferenceHashMap#entrySet()",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is thread-safe and can be used concurrently.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ConcurrentReferenceHashMap#entrySet()",
      "head_type": "method",
      "relation": "have",
      "tail": "public Set<Map.Entry<K, V>> entrySet() {\n    Set<Map.Entry<K, V>> entrySet = this.entrySet;\n    if (entrySet == null) {\n        entrySet = new EntrySet();\n        this.entrySet = entrySet;\n    }\n    return entrySet;\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.FastByteArrayInputStream#available()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "check available bytes",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.FastByteArrayInputStream#available()",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.FastByteArrayOutputStream",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.FastByteArrayOutputStream",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.FastByteArrayInputStream",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.FastByteArrayInputStream#available()",
      "head_type": "method",
      "relation": "have",
      "tail": "return the number of available bytes",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.FilteredCollection#iterator()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "iterator",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.FilteredCollection#iterator()",
      "head_type": "method",
      "relation": "have",
      "tail": "FilteredIterator",
      "tail_type": "class"
    },
    {
      "head": "FilteredIterator",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.FilteredCollection#iterator()",
      "tail_type": "method"
    },
    {
      "head": "FilteredIterator",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "filtered iteration",
      "tail_type": "apiFunction"
    },
    {
      "head": "FilteredIterator",
      "head_type": "class",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "FilteredIterator",
      "head_type": "class",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "FilteredIterator",
      "head_type": "class",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.FilteredIterator#setNext()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "filtered iteration",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.FilteredIterator#setNext()",
      "head_type": "method",
      "relation": "have",
      "tail": "advance to the next element that matches the filter",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.FilteredIterator#setNext()",
      "head_type": "method",
      "relation": "have",
      "tail": "private boolean setNext() {\n    while (this.delegate.hasNext()) {\n        E next = this.delegate.next();\n        if (this.filter.test(next)) {\n            this.next = next;\n            this.hasNext = true;\n            return true;\n        }\n    }\n    return false;\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.FilteredIterator#setNext()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.FilteredIterator",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.FilteredSet",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "filtered set creation",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.FilteredSet",
      "head_type": "class",
      "relation": "constrained_by",
      "tail": "predicate matching",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.FilteredSet",
      "head_type": "class",
      "relation": "applied_to",
      "tail": "element filtering in collections",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.FilteredSet",
      "head_type": "class",
      "relation": "have",
      "tail": "sample code for creating and using a FilteredSet",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.FilteredSet",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "CompositeMap",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.FilteredSet",
      "head_type": "class",
      "relation": "have",
      "tail": "interpretation of related concepts like predicates and collections",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.FilteredSet",
      "head_type": "class",
      "relation": "have",
      "tail": "design principles behind FilteredSet focusing on flexibility and reusability",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.function.ThrowingBiFunction#of(ThrowingBiFunction<T,U,R>,BiFunction<String,Exception,RuntimeException>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "create ThrowingBiFunction",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.function.ThrowingBiFunction#of(ThrowingBiFunction<T,U,R>,BiFunction<String,Exception,RuntimeException>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "exceptionWrapper must handle thrown checked exceptions",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.function.ThrowingBiFunction#of(ThrowingBiFunction<T,U,R>,BiFunction<String,Exception,RuntimeException>)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "method references throwing checked exceptions",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.function.ThrowingBiFunction#of(ThrowingBiFunction<T,U,R>,BiFunction<String,Exception,RuntimeException>)",
      "head_type": "method",
      "relation": "have",
      "tail": "map.replaceAll(ThrowingBiFunction.of(Example::methodThatCanThrowCheckedException, IllegalStateException::new));",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.function.ThrowingBiFunction#of(ThrowingBiFunction<T,U,R>,BiFunction<String,Exception,RuntimeException>)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is a convenience method to create a ThrowingBiFunction where the apply method wraps any thrown checked exceptions using the given exceptionWrapper.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.function.ThrowingBiFunction#of(ThrowingBiFunction<T,U,R>,BiFunction<String,Exception,RuntimeException>)",
      "head_type": "method",
      "relation": "have",
      "tail": "The design principle is to provide a lambda friendly way to handle checked exceptions in functional interfaces.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.function.ThrowingBiFunction#of(ThrowingBiFunction<T,U,R>,BiFunction<String,Exception,RuntimeException>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.function.ThrowingBiFunction",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.ValuesIterator#next()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "retrieveNextValue",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ValuesIterator#next()",
      "head_type": "method",
      "relation": "have",
      "tail": "nextEntry().getValue()",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ValuesIterator#next()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.ValuesIterator",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.MethodInvoker#setArguments(Object)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "set method arguments",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MethodInvoker#setArguments(Object)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "arguments must be an array of Objects",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.MethodInvoker#setArguments(Object)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "invoking a method with specific arguments",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.MethodInvoker#setArguments(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "public void setArguments(@Nullable Object... arguments) { this.arguments = arguments; }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.MethodInvoker#setArguments(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.MethodInvoker#setArguments(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.MethodInvoker#setArguments(Object)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.MethodInvoker",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.MethodInvoker#getTypeDifferenceWeight(Class<?>[],Object[])",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "judging match between parameter types and arguments",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MethodInvoker#getTypeDifferenceWeight(Class<?>[],Object[])",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "requirement for matching parameter types and arguments",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.MethodInvoker#getTypeDifferenceWeight(Class<?>[],Object[])",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "method invocation with specific arguments",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.MethodInvoker#getTypeDifferenceWeight(Class<?>[],Object[])",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for invoking the method with arguments",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.MethodInvoker#getTypeDifferenceWeight(Class<?>[],Object[])",
      "head_type": "method",
      "relation": "have",
      "tail": "detailed explanation of the matching algorithm",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.MethodInvoker#getTypeDifferenceWeight(Class<?>[],Object[])",
      "head_type": "method",
      "relation": "have",
      "tail": "design principles behind the method's algorithm",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.MethodInvoker#getTypeDifferenceWeight(Class<?>[],Object[])",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.core.MethodInvoker",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.MimeType#checkParameters(String,String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "parameter validation",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MimeType#checkParameters(String,String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "parameters must be non-empty",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.MimeType#checkParameters(String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "ensures that parameters are valid and non-empty",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.MimeType#checkParameters(String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "design follows the principle of fail-fast to ensure data integrity",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.MimeType",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.MimeType#checkParameters(String,String)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.MimeType#equals(Object)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "compare MimeType",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MimeType#equals(Object)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "null object handling",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.MimeType#equals(Object)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "MimeType comparison",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.MimeType#equals(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "compare MimeType sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.MimeType#equals(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "MimeType comparison explanation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.MimeType#equals(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle of MimeType comparison",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.MimeType#equals(Object)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.MimeType",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.MultiValueMap#addAll(MultiValueMap<K,V>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "Add values from another MultiValueMap",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MultiValueMap#addAll(MultiValueMap<K,V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "Add all the values of the given MultiValueMap to the current values",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.MultiValueMap#addAll(MultiValueMap<K,V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "The method integrates values from another MultiValueMap into the current one, enhancing data aggregation capabilities",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.MultiValueMap#addAll(MultiValueMap<K,V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is designed to facilitate the merging of data from multiple sources, adhering to the principle of data integrity and consistency",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ObjectUtils#isEmpty(Object)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "check if an object is empty",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ObjectUtils#isEmpty(Object)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "must be an instance of Optional, Array, CharSequence, Collection, or Map",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ObjectUtils#isEmpty(Object)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "checking if various types of objects are empty",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ObjectUtils#isEmpty(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code demonstrating how to check if an object is empty",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ObjectUtils#isEmpty(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "interpretation of related concepts such as Optional, Array, CharSequence, Collection, and Map",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ObjectUtils#isEmpty(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle interpretation focusing on flexibility and type safety",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ObjectUtils#isEmpty(Object)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "Optional#isPresent()",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.ObjectUtils#isEmpty(Object)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "ObjectUtils#isEmpty(Object[])",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.ObjectUtils#isEmpty(Object)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "StringUtils#hasLength(CharSequence)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.ObjectUtils#isEmpty(Object)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "CollectionUtils#isEmpty(java.util.Collection)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.ObjectUtils#isEmpty(Object)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "CollectionUtils#isEmpty(java.util.Map)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeClassName(Object)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "Determine the class name for the given object",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeClassName(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "Returns a \"null\" String if obj is null",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeClassName(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "public static String nullSafeClassName(@Nullable Object obj) { return (obj != null ? obj.getClass().getName() : NULL_STRING); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeClassName(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "The method is designed to safely determine the class name of an object, returning a predefined string if the object is null to avoid NullPointerException.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeClassName(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "The design principle followed here is to provide a utility method that can be safely used without needing to check for null values explicitly, enhancing code readability and maintainability.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeToString(boolean[])",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "String representation of array",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeToString(boolean[])",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "array must not be null",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeToString(boolean[])",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "convert array to string",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeToString(boolean[])",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for array to string conversion",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeToString(boolean[])",
      "head_type": "method",
      "relation": "have",
      "tail": "explanation of null-safe operations",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeToString(boolean[])",
      "head_type": "method",
      "relation": "have",
      "tail": "design principles of null-safe methods",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ObjectUtils",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.ObjectUtils#nullSafeToString(boolean[])",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeToString(float[])",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "String representation of array",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeToString(float[])",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "array must not be null",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeToString(float[])",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "array elements to string",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeToString(float[])",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for array to string",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeToString(float[])",
      "head_type": "method",
      "relation": "have",
      "tail": "related concept interpretation for array to string",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeToString(float[])",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle interpretation for array to string",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ObjectUtils",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.ObjectUtils#nullSafeToString(float[])",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.PathMatcher#isPattern(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "pattern matching",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.PathMatcher#isPattern(String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "path must be a string",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.PathMatcher#isPattern(String)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "checking if a path is a pattern",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.PathMatcher#isPattern(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for checking if a path is a pattern",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.PathMatcher#isPattern(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "interpretation of pattern matching",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.PathMatcher#isPattern(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle of efficient pattern checking",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.PathMatcher#isPattern(String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.PathMatcher",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.Part#resolveAll(Iterable<Part>,PartResolutionContext)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "stringAppender",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.Part#resolveAll(Iterable<Part>,PartResolutionContext)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "placeholderReplacement",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.Part#resolveAll(Iterable<Part>,PartResolutionContext)",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.Part#resolveAll(Iterable<Part>,PartResolutionContext)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.Part#resolveAll(Iterable<Part>,PartResolutionContext)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "stringAppender",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "StringBuilder",
      "tail_type": "class"
    },
    {
      "head": "placeholderReplacement",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "PartResolutionContext",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.PlaceholderResolver",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "resolvePlaceholder",
      "tail_type": "apiFunction"
    },
    {
      "head": "resolvePlaceholder",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "String resolvePlaceholder(String placeholderName)",
      "tail_type": "useSampleCode"
    },
    {
      "head": "resolvePlaceholder",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "Resolves a placeholder to its replacement value.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "resolvePlaceholder",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "Design principle: Strategy pattern for placeholder resolution.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#hasSameParams(Method,Class<?>[])",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "parameter comparison",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#hasSameParams(Method,Class<?>[])",
      "head_type": "method",
      "relation": "have",
      "tail": "private static boolean hasSameParams(Method method, Class<?>[] paramTypes) {\n    return (paramTypes.length == method.getParameterCount() && Arrays.equals(paramTypes, method.getParameterTypes()));\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#hasSameParams(Method,Class<?>[])",
      "head_type": "method",
      "relation": "have",
      "tail": "This method checks if two methods have the same parameters by comparing their parameter types and count.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#hasSameParams(Method,Class<?>[])",
      "head_type": "method",
      "relation": "have",
      "tail": "The design principle followed here is to ensure that methods are compared based on their signature, specifically the parameters they accept. This is crucial for determining method equality or compatibility in various programming scenarios.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#makeAccessible(Method)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "makeAccessible",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#makeAccessible(Method)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "Modifier.isPublic(method.getModifiers()) || Modifier.isPublic(method.getDeclaringClass().getModifiers())",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#makeAccessible(Method)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "java.lang.reflect.Method",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#makeAccessible(Method)",
      "head_type": "method",
      "relation": "have",
      "tail": "setAccessible(true)",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#makeAccessible(Method)",
      "head_type": "method",
      "relation": "have",
      "tail": "Explicitly setting a method accessible if necessary to avoid unnecessary conflicts.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#makeAccessible(Method)",
      "head_type": "method",
      "relation": "have",
      "tail": "Principle of least privilege and reflection.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#makeAccessible(Method)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "java.lang.reflect.Method",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.SimpleRouteMatcher#parseRoute(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "parseRoute",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.SimpleRouteMatcher#parseRoute(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "Parsing a route string into a Route object",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.SimpleRouteMatcher#parseRoute(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method takes a string representation of a route and converts it into a Route object",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.SimpleRouteMatcher#parseRoute(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "java\npackage org.springframework.util;\n\npublic class SimpleRouteMatcher {\n    public Route parseRoute(String route) {\n        return new DefaultRoute(route);\n    }\n}\n",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.StringUtils#unqualify(String,char)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "unqualify a string qualified by a separator character",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils#unqualify(String,char)",
      "head_type": "method",
      "relation": "have",
      "tail": "Unqualify a string qualified by a separator character. For example, \"this:name:is:qualified\" returns \"qualified\" if using a ':' separator.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.StringUtils#unqualify(String,char)",
      "head_type": "method",
      "relation": "have",
      "tail": "public static String unqualify(String qualifiedName, char separator) { return qualifiedName.substring(qualifiedName.lastIndexOf(separator) + 1); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.StringUtils#delimitedListToStringArray(String,String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "convert a delimited list to a String array",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils#delimitedListToStringArray(String,String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "delimiter is a single string, not multiple characters",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.StringUtils#delimitedListToStringArray(String,String)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "input String is potentially null or empty",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.StringUtils#delimitedListToStringArray(String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "convert a String that is a delimited list into a String array",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.StringUtils#delimitedListToStringArray(String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle of using a single delimiter string",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.StringUtils#delimitedListToStringArray(String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "public static String[] delimitedListToStringArray(@Nullable String str, @Nullable String delimiter) { return delimitedListToStringArray(str, delimiter, null); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.StringUtils#delimitedListToStringArray(String,String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.StringUtils",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#containsValue(Object)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "value checking",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#containsValue(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.UnmodifiableMultiValueMap#containsValue(Object) sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#containsValue(Object)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.UnmodifiableMultiValueMap",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#remove(Object)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "remove elements from a collection",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#remove(Object)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "operation not supported for read-only collection",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#remove(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#remove(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#remove(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#addAll(MultiValueMap<K,V>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "add all elements from another MultiValueMap",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#addAll(MultiValueMap<K,V>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "operation not supported",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#addAll(MultiValueMap<K,V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "throwing an UnsupportedOperationException",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#addAll(MultiValueMap<K,V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "UnmodifiableMultiValueMap does not support addAll operation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#addAll(MultiValueMap<K,V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "Design principle of immutability in collections",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#merge(K,List<V>,BiFunction<? super List<V>,? super List<V>,? extends List<V>>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "merge",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#merge(K,List<V>,BiFunction<? super List<V>,? super List<V>,? extends List<V>>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "UnsupportedOperationException",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#merge(K,List<V>,BiFunction<? super List<V>,? super List<V>,? extends List<V>>)",
      "head_type": "method",
      "relation": "have",
      "tail": "UnmodifiableMultiValueMap does not support merge operation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#merge(K,List<V>,BiFunction<? super List<V>,? super List<V>,? extends List<V>>)",
      "head_type": "method",
      "relation": "have",
      "tail": "Design principle of UnmodifiableMultiValueMap",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#merge(K,List<V>,BiFunction<? super List<V>,? super List<V>,? extends List<V>>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.UnmodifiableMultiValueMap",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#clear()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "clearing a map",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#clear()",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "map is unmodifiable",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#clear()",
      "head_type": "method",
      "relation": "have",
      "tail": "throwing an UnsupportedOperationException",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#clear()",
      "head_type": "method",
      "relation": "have",
      "tail": "related to unmodifiable collections",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#clear()",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle of immutability",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueCollection#filterArray(Object[])",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "filterArray",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueCollection#filterArray(Object[])",
      "head_type": "method",
      "relation": "have",
      "tail": "private void filterArray(Object[] array) { for (int i = 0; i < array.length; i++) { if (array[i] instanceof List<?> list) { array[i] = Collections.unmodifiableList(list); } } }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueCollection#filterArray(Object[])",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.UnmodifiableValueCollection",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueCollection#filterArray(Object[])",
      "head_type": "method",
      "relation": "have",
      "tail": "This method iterates over an array and replaces any List objects with an unmodifiable version of that list.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueCollection#filterArray(Object[])",
      "head_type": "method",
      "relation": "have",
      "tail": "The design principle here is to ensure that the collection is unmodifiable, which is a common pattern in Java to provide thread-safe collections.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.UpdateMessageDigestInputStream#updateMessageDigest(MessageDigest,int)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "updateMessageDigest",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.UpdateMessageDigestInputStream#updateMessageDigest(MessageDigest,int)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "IOException",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.UpdateMessageDigestInputStream#updateMessageDigest(MessageDigest,int)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "stream processing",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.UpdateMessageDigestInputStream#updateMessageDigest(MessageDigest,int)",
      "head_type": "method",
      "relation": "have",
      "tail": "updateMessageDigest sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.UpdateMessageDigestInputStream#updateMessageDigest(MessageDigest,int)",
      "head_type": "method",
      "relation": "have",
      "tail": "stream processing explanation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.UpdateMessageDigestInputStream#updateMessageDigest(MessageDigest,int)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle explanation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "updateMessageDigest sample code",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "complete sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLEventReader#close()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "close XML event reader",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLEventReader#close()",
      "head_type": "method",
      "relation": "have",
      "tail": "public void close() { this.closed = true; }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLEventReader#close()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.AbstractXMLEventReader",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLEventReader",
      "head_type": "class",
      "relation": "have",
      "tail": "class for reading XML events",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLEventReader",
      "head_type": "class",
      "relation": "have",
      "tail": "design principle for efficient XML processing",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLStreamReader#getAttributeLocalName(int)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getAttributeLocalName",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLStreamReader#getAttributeLocalName(int)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.AbstractXMLStreamReader",
      "tail_type": "class"
    },
    {
      "head": "getAttributeLocalName",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "This method is used to retrieve the local name of an attribute in an XML element by specifying its index.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "getAttributeLocalName",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "This method is part of the XML processing capabilities provided by the Spring Framework, specifically designed to work with XML streams in a resource-efficient manner.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "getAttributeLocalName",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "java\npackage org.springframework.util.xml;\n\nimport javax.xml.namespace.QName;\n\npublic class AbstractXMLStreamReaderExample {\n    public static void main(String[] args) {\n        AbstractXMLStreamReader reader = new AbstractXMLStreamReader() {\n            @Override\n            public String getAttributeLocalName(int index) {\n                return getAttributeName(index).getLocalPart();\n            }\n            \n            // Other required methods of AbstractXMLStreamReader\n        };\n        \n        // Example usage\n        String localName = reader.getAttributeLocalName(0);\n        System.out.println(\"Local Name: \" + localName);\n    }\n}\n",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLStreamReader#require(int,String,String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "xml parsing",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLStreamReader#require(int,String,String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "xml structure validation",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLStreamReader#require(int,String,String)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "xml document processing",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLStreamReader#require(int,String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "xml document processing sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLStreamReader#require(int,String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "xml parsing explanation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLStreamReader#require(int,String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "xml structure validation design principles",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLStreamReader#require(int,String,String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.AbstractXMLStreamReader",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.DomContentHandler#characters(char[],int,int)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "append text data to parent node",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.DomContentHandler#characters(char[],int,int)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.xml.DomContentHandler#characters(char[],int,int) sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.DomContentHandler#characters(char[],int,int)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.DomContentHandler",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.DomContentHandler#characters(char[],int,int) sample code",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "org.springframework.util.xml.DomContentHandler#characters(char[],int,int) sample code content",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.ListBasedXMLEventReader",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "XMLEventReaderImplementation",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.ListBasedXMLEventReader",
      "head_type": "class",
      "relation": "have",
      "tail": "ListBasedXMLEventReaderSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "ListBasedXMLEventReaderSampleCode",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.ListBasedXMLEventReader",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.ListBasedXMLEventReader",
      "head_type": "class",
      "relation": "have",
      "tail": "RelatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.ListBasedXMLEventReader",
      "head_type": "class",
      "relation": "have",
      "tail": "DesignPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxEventXMLReader",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "xml parsing",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxEventXMLReader",
      "head_type": "class",
      "relation": "constrained_by",
      "tail": "xml event reader state",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.xml.StaxEventXMLReader",
      "head_type": "class",
      "relation": "applied_to",
      "tail": "xml document parsing",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.xml.StaxEventXMLReader",
      "head_type": "class",
      "relation": "have",
      "tail": "xml version handling",
      "tail_type": "useSampleCode"
    },
    {
      "head": "xml version handling",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "xml version sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.StaxEventXMLReader",
      "head_type": "class",
      "relation": "have",
      "tail": "xml event handling",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "xml event handling",
      "head_type": "relatedConceptInterpretation",
      "relation": "have",
      "tail": "xml event types",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxEventXMLReader",
      "head_type": "class",
      "relation": "have",
      "tail": "design principle",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "design principle",
      "head_type": "designPrincipleInterpretation",
      "relation": "have",
      "tail": "xml parsing efficiency",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxEventXMLReader#handleCharacters(Characters)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "handleCharacters",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxEventXMLReader#handleCharacters(Characters)",
      "head_type": "method",
      "relation": "have",
      "tail": "handleCharacters(Characters) Sample Code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "handleCharacters(Characters) Sample Code",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "private void handleCharacters(Characters characters) throws SAXException {\n    char[] data = characters.getData().toCharArray();\n    if (getContentHandler() != null && characters.isIgnorableWhiteSpace()) {\n        getContentHandler().ignorableWhitespace(data, 0, data.length);\n        return;\n    }\n    if (characters.isCData() && getLexicalHandler() != null) {\n        getLexicalHandler().startCDATA();\n    }\n    if (getContentHandler() != null) {\n        getContentHandler().characters(data, 0, data.length);\n    }\n    if (characters.isCData() && getLexicalHandler() != null) {\n        getLexicalHandler().endCDATA();\n    }\n}",
      "tail_type": "code"
    },
    {
      "head": "org.springframework.util.xml.StaxSource#getXMLStreamReader()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "get XMLStreamReader",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxSource#getXMLStreamReader()",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "null if created with XMLEventReader",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.xml.StaxSource#getXMLStreamReader()",
      "head_type": "method",
      "relation": "have",
      "tail": "getXMLStreamReader use sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.StaxSource#getXMLStreamReader()",
      "head_type": "method",
      "relation": "have",
      "tail": "related concept interpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxSource#getXMLStreamReader()",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle interpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxSource",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.StaxSource#getXMLStreamReader()",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamXMLReader#handleProcessingInstruction()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "processing instruction handling",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamXMLReader#handleProcessingInstruction()",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is used to handle processing instructions in XML.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamXMLReader#handleProcessingInstruction()",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is part of the StaxStreamXMLReader class, which is designed to read XML documents using the StAX API.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamXMLReader#handleProcessingInstruction()",
      "head_type": "method",
      "relation": "have",
      "tail": "private void handleProcessingInstruction() throws SAXException {\n    if (getContentHandler() != null) {\n        getContentHandler().processingInstruction(this.reader.getPITarget(), this.reader.getPIData());\n    }\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamXMLReader",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.StaxStreamXMLReader#handleProcessingInstruction()",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "createDefensiveInputFactory",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "createStaxSource",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "isStaxSource",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getXMLStreamReader",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "createStaxResult",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "isStaxResult",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getXMLStreamWriter",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "createXMLEventReader",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "createContentHandler",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "createXMLReader",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "createEventStreamReader",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "createEventStreamWriter",
      "tail_type": "apiFunction"
    },
    {
      "head": "createDefensiveInputFactory",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "XMLInputFactory",
      "tail_type": "class"
    },
    {
      "head": "createStaxSource",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "XMLStreamReader",
      "tail_type": "class"
    },
    {
      "head": "createStaxSource",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "XMLEventReader",
      "tail_type": "class"
    },
    {
      "head": "isStaxSource",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "Source",
      "tail_type": "class"
    },
    {
      "head": "getXMLStreamReader",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "StAXSource",
      "tail_type": "class"
    },
    {
      "head": "createStaxResult",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "XMLStreamWriter",
      "tail_type": "class"
    },
    {
      "head": "createStaxResult",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "XMLEventWriter",
      "tail_type": "class"
    },
    {
      "head": "isStaxResult",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "Result",
      "tail_type": "class"
    },
    {
      "head": "getXMLStreamWriter",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "StAXResult",
      "tail_type": "class"
    },
    {
      "head": "createXMLEventReader",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "XMLEvent",
      "tail_type": "class"
    },
    {
      "head": "createContentHandler",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "XMLStreamWriter",
      "tail_type": "class"
    },
    {
      "head": "createContentHandler",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "XMLEventWriter",
      "tail_type": "class"
    },
    {
      "head": "createXMLReader",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "XMLStreamReader",
      "tail_type": "class"
    },
    {
      "head": "createXMLReader",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "XMLEventReader",
      "tail_type": "class"
    },
    {
      "head": "createEventStreamReader",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "XMLEventReader",
      "tail_type": "class"
    },
    {
      "head": "createEventStreamWriter",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "XMLEventWriter",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils",
      "head_type": "class",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils",
      "head_type": "class",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils",
      "head_type": "class",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils#createStaxResult(XMLEventWriter)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "createStaxResult",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils#createStaxResult(XMLEventWriter)",
      "head_type": "method",
      "relation": "have",
      "tail": "Create a JAXP 1.4 StAXResult for the given XMLEventWriter.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils#createStaxResult(XMLEventWriter)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is used to create a StAXResult instance that wraps an XMLEventWriter.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils#createStaxResult(XMLEventWriter)",
      "head_type": "method",
      "relation": "have",
      "tail": "public static Result createStaxResult(XMLEventWriter eventWriter) {\n    return new StAXResult(eventWriter);\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter#writeDefaultNamespace(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "write default namespace",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter#writeDefaultNamespace(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "writeDefaultNamespace(String) sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "writeDefaultNamespace(String) sample code",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "org.springframework.util.xml.XMLEventStreamWriter",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter#writeDefaultNamespace(String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.XMLEventStreamWriter",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter#writeDTD(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "writeDTD",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter#writeDTD(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "closeEmptyElementIfNecessary()",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter#writeDTD(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "this.eventWriter.add(this.eventFactory.createDTD(dtd))",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter#writeDTD(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter#writeDTD(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter#writeDTD(String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.XMLEventStreamWriter",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.XmlValidationModeDetector#consume(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "consume next comment token",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.XmlValidationModeDetector#consume(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "update the inComment flag",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.xml.XmlValidationModeDetector#consume(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "return the remaining content",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.xml.XmlValidationModeDetector#consume(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "private String consume(String line) { int index = (this.inComment ? endComment(line) : startComment(line)); return (index == -1 ? null : line.substring(index)); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.XmlValidationModeDetector#consume(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is used to consume the next comment token from the input line. It checks if the current state is within a comment and updates the 'inComment' flag accordingly. The method returns the remaining content of the line after consuming the comment.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.XmlValidationModeDetector#consume(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "The design principle behind this method is to efficiently parse XML content by tracking the state of comments. It ensures that comments are correctly identified and ignored while processing the XML, improving the robustness and accuracy of the XML parsing process.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "example.type.SomeClassImplementingSomeInterface",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "lazy loading",
      "tail_type": "apiFunction"
    },
    {
      "head": "example.type.SomeClassImplementingSomeInterface",
      "head_type": "class",
      "relation": "constrained_by",
      "tail": "circular aliases are prohibited",
      "tail_type": "useConstraint"
    },
    {
      "head": "example.type.SomeClassImplementingSomeInterface",
      "head_type": "class",
      "relation": "applied_to",
      "tail": "multiple aliases for a single name",
      "tail_type": "useScenario"
    },
    {
      "head": "example.type.SomeClassImplementingSomeInterface",
      "head_type": "class",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "example.type.SomeClassImplementingSomeInterface",
      "head_type": "class",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "example.type.SomeClassImplementingSomeInterface",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.core.SimpleAliasRegistryTests",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassTests#createGeneratedClass(ClassName)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "createGeneratedClass",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassTests#createGeneratedClass(ClassName)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "GeneratedClass",
      "tail_type": "class"
    },
    {
      "head": "createGeneratedClass",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "createGeneratedClassSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "createGeneratedClassSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "createGeneratedClassSampleCodeContent",
      "tail_type": "useSampleCodeContent"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests#addClassFileWithInputStreamSourceAddsFile()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "adding a class file with an input stream source",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests#addClassFileWithInputStreamSourceAddsFile()",
      "head_type": "method",
      "relation": "have",
      "tail": "Resource resource = new ByteArrayResource(\"test\".getBytes(StandardCharsets.UTF_8)); this.generatedFiles.addClassFile(\"com/example/HelloWorld.class\", resource); assertThatFileAdded(Kind.CLASS, \"com/example/HelloWorld.class\").isEqualTo(\"test\");",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests#addClassFileWithInputStreamSourceAddsFile()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.GeneratedFilesTests",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests#addClassFileWithInputStreamSourceAddsFile()",
      "head_type": "method",
      "relation": "have",
      "tail": "This method tests adding a class file with an input stream source to ensure the file is correctly added.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests#addClassFileWithInputStreamSourceAddsFile()",
      "head_type": "method",
      "relation": "have",
      "tail": "The design principle followed here is to ensure that the class files are added correctly using an input stream source, verifying the integrity and correctness of the file addition process.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.InMemoryGeneratedFilesTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getGeneratedFilesReturnsFiles",
      "tail_type": "apiFunction"
    },
    {
      "head": "getGeneratedFilesReturnsFiles",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "getGeneratedFilesReturnsFilesSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "getGeneratedFilesReturnsFilesSampleCode",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.InMemoryGeneratedFilesTests",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.MethodNameTests#ofReturnsMethodName()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "MethodName generation",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.MethodNameTests#ofReturnsMethodName()",
      "head_type": "method",
      "relation": "have",
      "tail": "MethodName generation sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "MethodName generation sample code",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "Complete MethodName generation example",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.PrimitiveTests#generateWhenLong()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "generateCode",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.PrimitiveTests#generateWhenLong()",
      "head_type": "method",
      "relation": "have",
      "tail": "generateWhenLongSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "generateWhenLongSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "generateWhenLongCompleteCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.hint.annotation.RegisterReflectionForBindingProcessorTests#throwExceptionWithoutAnnotationAttributeOnMethod()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "throwExceptionWithoutAnnotationAttributeOnMethod",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.hint.annotation.RegisterReflectionForBindingProcessorTests#throwExceptionWithoutAnnotationAttributeOnMethod()",
      "head_type": "method",
      "relation": "have",
      "tail": "SampleClassWithoutMethodLevelAnnotationAttribute",
      "tail_type": "class"
    },
    {
      "head": "SampleClassWithoutMethodLevelAnnotationAttribute",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.aot.hint.annotation.RegisterReflectionForBindingProcessorTests#throwExceptionWithoutAnnotationAttributeOnMethod()",
      "tail_type": "method"
    },
    {
      "head": "throwExceptionWithoutAnnotationAttributeOnMethod",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "IllegalStateException",
      "tail_type": "useConstraint"
    },
    {
      "head": "throwExceptionWithoutAnnotationAttributeOnMethod",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "processor.registerReflectionHints(hints.reflection(), SampleClassWithoutMethodLevelAnnotationAttribute.class.getMethod(\"method\"))",
      "tail_type": "useSampleCode"
    },
    {
      "head": "throwExceptionWithoutAnnotationAttributeOnMethod",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "This method tests the scenario where an exception is thrown when attempting to register reflection hints for a method without the required annotation attribute.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "throwExceptionWithoutAnnotationAttributeOnMethod",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "The design principle here is to ensure that methods lacking the necessary annotation attributes are not processed, maintaining the integrity and expected behavior of the reflection hint registration process.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.core.type.MethodMetadata#isFinal()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "determineMethodFinality",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.core.type.MethodMetadata#isFinal()",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.core.type.MethodMetadata#isFinal()",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "determineMethodFinality",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#concat(String,String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "stringConcatenation",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#concat(String,String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "pathSeparatorConsistency",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#concat(String,String)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "pathManipulation",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#concat(String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#concat(String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#concat(String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "stringConcatenation",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "org.springframework.util.AntPathMatcher",
      "tail_type": "class"
    },
    {
      "head": "pathSeparatorConsistency",
      "head_type": "useConstraint",
      "relation": "associated_with",
      "tail": "org.springframework.util.AntPathMatcher",
      "tail_type": "class"
    },
    {
      "head": "pathManipulation",
      "head_type": "useScenario",
      "relation": "associated_with",
      "tail": "org.springframework.util.AntPathMatcher",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.Assert#instanceCheckFailed(Class<?>,Object,String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "instanceCheck",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.Assert#instanceCheckFailed(Class<?>,Object,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "instanceCheckFailed useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.Assert#instanceCheckFailed(Class<?>,Object,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.Assert#instanceCheckFailed(Class<?>,Object,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "instanceCheckFailed useSampleCode",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "tail": "org.springframework.util.Assert#instanceCheckFailed(Class<?>,Object,String)",
      "tail_type": "method"
    },
    {
      "head": "relatedConceptInterpretation",
      "head_type": "relatedConceptInterpretation",
      "relation": "associated_with",
      "tail": "org.springframework.util.Assert#instanceCheckFailed(Class<?>,Object,String)",
      "tail_type": "method"
    },
    {
      "head": "designPrincipleInterpretation",
      "head_type": "designPrincipleInterpretation",
      "relation": "associated_with",
      "tail": "org.springframework.util.Assert#instanceCheckFailed(Class<?>,Object,String)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.ClassUtils#getMethodIfAvailable(Class<?>,String,Class<?>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "determining the existence of a public method with a specific signature in a class",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ClassUtils#getMethodIfAvailable(Class<?>,String,Class<?>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "the method must be public and uniquely identifiable by name if no parameter types are specified",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ClassUtils#getMethodIfAvailable(Class<?>,String,Class<?>)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "checking for the existence of a method in a class without throwing an exception if it does not exist",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ClassUtils#getMethodIfAvailable(Class<?>,String,Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for using getMethodIfAvailable to safely check for a method's existence",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ClassUtils#getMethodIfAvailable(Class<?>,String,Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "related concept interpretation for NoSuchMethodException handling",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#getMethodIfAvailable(Class<?>,String,Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle interpretation focusing on safe method resolution without exceptions",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#getMethodIfAvailable(Class<?>,String,Class<?>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "ClassUtils",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.EntryIterator#getNextIfNecessary()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "fetch next element",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.EntryIterator#getNextIfNecessary()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "handle null reference",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.EntryIterator#getNextIfNecessary()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "check for null reference",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.EntryIterator#getNextIfNecessary()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "retrieve element from reference",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.EntryIterator#getNextIfNecessary()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "loop until next element is found",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.EntryIterator#getNextIfNecessary()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "exit if no more elements",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.EntryIterator#getNextIfNecessary()",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.EntryIterator#getNextIfNecessary()",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.EntryIterator#getNextIfNecessary()",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.EntryIterator",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.EntryIterator#getNextIfNecessary()",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.DigestUtils#digest(String,byte[])",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "messageDigest",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.DigestUtils#digest(String,byte[])",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.DigestUtils#digest(String,byte[])",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.DigestUtils#digest(String,byte[])",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.DigestUtils#digest(String,byte[])",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "java.security.MessageDigest",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.DigestUtils#encodeHex(byte[])",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "encoding hexadecimal",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.DigestUtils#encodeHex(byte[])",
      "head_type": "method",
      "relation": "have",
      "tail": "converts byte array to hex string",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.DigestUtils#encodeHex(byte[])",
      "head_type": "method",
      "relation": "have",
      "tail": "private static char[] encodeHex(byte[] bytes) {\n    char[] chars = new char[32];\n    for (int i = 0; i < chars.length; i = i + 2) {\n        byte b = bytes[i / 2];\n        chars[i] = HEX_CHARS[(b >>> 0x4) & 0xf];\n        chars[i + 1] = HEX_CHARS[b & 0xf];\n    }\n    return chars;\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.DigestUtils#encodeHex(byte[])",
      "head_type": "method",
      "relation": "have",
      "tail": "HEX_CHARS array must be defined",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.DigestUtils#encodeHex(byte[])",
      "head_type": "method",
      "relation": "have",
      "tail": "related to data encoding and cryptography",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.DigestUtils#encodeHex(byte[])",
      "head_type": "method",
      "relation": "have",
      "tail": "efficiently converts binary data to a hexadecimal representation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.FastByteArrayOutputStream#toByteArray()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "create a newly allocated byte array",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.FastByteArrayOutputStream#toByteArray()",
      "head_type": "method",
      "relation": "have",
      "tail": "return the current contents of this stream as a byte array",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.FastByteArrayOutputStream#toByteArray()",
      "head_type": "method",
      "relation": "have",
      "tail": "the size is the current size of this output stream, and it will contain the valid contents of the internal buffers",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.FastByteArrayOutputStream#toByteArray()",
      "head_type": "method",
      "relation": "have",
      "tail": "the size is the current size of this output stream, and it will contain the valid contents of the internal buffers",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.FastByteArrayOutputStream#toByteArray()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.FastByteArrayOutputStream",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.FastByteArrayOutputStream#toByteArray()",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "the size is the current size of this output stream, and it will contain the valid contents of the internal buffers",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.FastByteArrayOutputStream#toByteArray()",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "the size is the current size of this output stream, and it will contain the valid contents of the internal buffers",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.FastByteArrayInputStream",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "read from FastByteArrayOutputStream",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.FastByteArrayInputStream",
      "head_type": "class",
      "relation": "have",
      "tail": "An implementation of InputStream that reads from a given FastByteArrayOutputStream",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "read from FastByteArrayOutputStream",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "public FastByteArrayInputStream(FastByteArrayOutputStream fastByteArrayOutputStream)",
      "tail_type": "useSampleCode"
    },
    {
      "head": "read from FastByteArrayOutputStream",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "public int read()",
      "tail_type": "useSampleCode"
    },
    {
      "head": "read from FastByteArrayOutputStream",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "public int read(byte[] b)",
      "tail_type": "useSampleCode"
    },
    {
      "head": "read from FastByteArrayOutputStream",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "public int read(byte[] b, int off, int len)",
      "tail_type": "useSampleCode"
    },
    {
      "head": "read from FastByteArrayOutputStream",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "public long skip(long n) throws IOException",
      "tail_type": "useSampleCode"
    },
    {
      "head": "read from FastByteArrayOutputStream",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "public int available()",
      "tail_type": "useSampleCode"
    },
    {
      "head": "read from FastByteArrayOutputStream",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "public void updateMessageDigest(MessageDigest messageDigest)",
      "tail_type": "useSampleCode"
    },
    {
      "head": "read from FastByteArrayOutputStream",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "public void updateMessageDigest(MessageDigest messageDigest, int len)",
      "tail_type": "useSampleCode"
    },
    {
      "head": "read from FastByteArrayOutputStream",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "private void updateCurrentBufferLength()",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.FilteredCollection#size()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "sizeCalculation",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.FilteredCollection#size()",
      "head_type": "method",
      "relation": "have",
      "tail": "sizeCalculationSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "sizeCalculationSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "sizeCalculationSampleCodeContent",
      "tail_type": "useSampleCodeContent"
    },
    {
      "head": "org.springframework.util.FilteredCollection#size()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.FilteredCollection",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.function.SingletonSupplier#of(Supplier<T>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "SingletonSupplier creation",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.function.SingletonSupplier#of(Supplier<T>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "Supplier must not be null",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.function.SingletonSupplier#of(Supplier<T>)",
      "head_type": "method",
      "relation": "have",
      "tail": "Creates a SingletonSupplier instance based on the provided supplier.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.function.SingletonSupplier#of(Supplier<T>)",
      "head_type": "method",
      "relation": "have",
      "tail": "Ensures that the supplier provided is not null, emphasizing the importance of a valid supplier for SingletonSupplier creation.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.function.SingletonSupplier#of(Supplier<T>)",
      "head_type": "method",
      "relation": "have",
      "tail": "package com.example;\n\nimport org.springframework.util.function.SingletonSupplier;\n\npublic class SingletonSupplierExample {\n    public static void main(String[] args) {\n        SingletonSupplier<String> singletonSupplier = SingletonSupplier.of(() -> \"Hello, Singleton!\");\n        System.out.println(singletonSupplier.get());\n    }\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.LinkedCaseInsensitiveMap#hashCode()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "generate hash code",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.LinkedCaseInsensitiveMap#hashCode()",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.LinkedCaseInsensitiveMap",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.LinkedCaseInsensitiveMap#hashCode()",
      "head_type": "method",
      "relation": "have",
      "tail": "calculate hash code based on targetMap",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.LinkedCaseInsensitiveMap#hashCode()",
      "head_type": "method",
      "relation": "have",
      "tail": "efficient hash code generation for case insensitive keys",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.LinkedCaseInsensitiveMap#hashCode()",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle of using targetMap for hash code calculation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.KeySet#iterator()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "iterate over keys",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.KeySet#iterator()",
      "head_type": "method",
      "relation": "have",
      "tail": "Returns an iterator over the elements in the set.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.KeySet#iterator()",
      "head_type": "method",
      "relation": "have",
      "tail": "The method returns an instance of KeySetIterator which is a custom implementation of Iterator interface.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.KeySet#iterator()",
      "head_type": "method",
      "relation": "have",
      "tail": "public Iterator<String> iterator() {\n    return new KeySetIterator();\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "KeySetIterator",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.KeySet#iterator()",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.MimeType#isConcrete()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "check MIME Type concreteness",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MimeType#isConcrete()",
      "head_type": "method",
      "relation": "have",
      "tail": "return whether this MIME Type is concrete",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.MimeType#isConcrete()",
      "head_type": "method",
      "relation": "have",
      "tail": "public boolean isConcrete() { return !isWildcardType() && !isWildcardSubtype(); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.MimeType#isConcrete()",
      "head_type": "method",
      "relation": "have",
      "tail": "A concrete MIME Type means that neither the type nor the subtype is a wildcard character.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.MimeType#isConcrete()",
      "head_type": "method",
      "relation": "have",
      "tail": "The method is designed to check if a MIME Type is concrete by ensuring that neither the type nor the subtype is a wildcard.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.MimeType#getCharset()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "get character set",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MimeType#getCharset()",
      "head_type": "method",
      "relation": "have",
      "tail": "Return the character set, as indicated by a charset parameter, if any.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.MimeType#getCharset()",
      "head_type": "method",
      "relation": "have",
      "tail": "The method returns the character set if available, otherwise returns null.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.MimeType#getCharset()",
      "head_type": "method",
      "relation": "have",
      "tail": "public Charset getCharset() {\n    return this.resolvedCharset;\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ObjectUtils#isArray(Object)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "Check if Object is Array",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ObjectUtils#isArray(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "Check if Object is Array - Sample Code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "Check if Object is Array - Sample Code",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "package com.example.util; import org.springframework.util.ObjectUtils; public class CheckArrayExample { public static void main(String[] args) { Object obj = new int[]{1, 2, 3}; booleanisArray = ObjectUtils.isArray(obj); System.out.println(\"Is object an array? \" + isArray); } }",
      "tail_type": "code"
    },
    {
      "head": "org.springframework.util.ObjectUtils#isArray(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "Check if Object is Array - Related Concept Interpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "Check if Object is Array - Related Concept Interpretation",
      "head_type": "relatedConceptInterpretation",
      "relation": "have",
      "tail": "This function checks if the provided object is an array, which can be either an Object array or a primitive array. It is commonly used to determine the type of collection or data structure being dealt with.",
      "tail_type": "description"
    },
    {
      "head": "org.springframework.util.ObjectUtils#isArray(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "Check if Object is Array - Design Principle Interpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "Check if Object is Array - Design Principle Interpretation",
      "head_type": "designPrincipleInterpretation",
      "relation": "have",
      "tail": "The design principle behind this method is to provide a utility function that simplifies the process of checking if an object is an array, abstracting the underlying complexity and enhancing code readability.",
      "tail_type": "description"
    },
    {
      "head": "org.springframework.util.PlaceholderParser#nextStartPrefix(String,int)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "find next start prefix",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.PlaceholderParser#nextStartPrefix(String,int)",
      "head_type": "method",
      "relation": "have",
      "tail": "private int nextStartPrefix(String value, int index) { return value.indexOf(this.prefix, index); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.PlaceholderParser#nextStartPrefix(String,int)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.PlaceholderParser",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.PlaceholderResolver#resolvePlaceholder(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "resolvePlaceholder",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.PlaceholderResolver#resolvePlaceholder(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "resolvePlaceholder(String placeholderName)",
      "tail_type": "useSampleCode"
    },
    {
      "head": "resolvePlaceholder(String placeholderName)",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "tail": "org.springframework.util.PlaceholderResolver",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.PlaceholderResolver#resolvePlaceholder(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "Resolves a placeholder name to its replacement value.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.PlaceholderResolver#resolvePlaceholder(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "Design principle: Provide a method to resolve placeholders in strings, enhancing flexibility in configuration.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#findMethod(Class<?>,String,Class<?>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "findMethod",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#findMethod(Class<?>,String,Class<?>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "clazz must not be null",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#findMethod(Class<?>,String,Class<?>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "name must not be null",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#findMethod(Class<?>,String,Class<?>)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "introspect class to find method",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#findMethod(Class<?>,String,Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "search all superclasses up to Object",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#findMethod(Class<?>,String,Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "return null if no Method can be found",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#findMethod(Class<?>,String,Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "paramTypes may be null to indicate any signature",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#findMethod(Class<?>,String,Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "public static Method findMethod(Class<?> clazz, String name, Class<?>@Nullable ... paramTypes) {\n    Assert.notNull(clazz, \"Class must not be null\");\n    Assert.notNull(name, \"Method name must not be null\");\n    Class<?> searchType = clazz;\n    while (searchType != null) {\n        Method[] methods = (searchType.isInterface() ? searchType.getMethods() : getDeclaredMethods(searchType, false));\n        for (Method method : methods) {\n            if (name.equals(method.getName()) && (paramTypes == null || hasSameParams(method, paramTypes))) {\n                return method;\n            }\n        }\n        searchType = searchType.getSuperclass();\n    }\n    return null;\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#findMethod(Class<?>,String,Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "related to method searching and reflection",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#findMethod(Class<?>,String,Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle of utility and robustness",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#findMethod(Class<?>,String,Class<?>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.ReflectionUtils",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.SerializationUtils#clone(T)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "Java Object Serialization",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.SerializationUtils#clone(T)",
      "head_type": "method",
      "relation": "have",
      "tail": "SerializationUtils.deserialize(SerializationUtils.serialize(object))",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.SerializationUtils#clone(T)",
      "head_type": "method",
      "relation": "have",
      "tail": "Deserialized object must not be null",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.SerializationUtils#clone(T)",
      "head_type": "method",
      "relation": "have",
      "tail": "Cloning objects using serialization",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.SerializationUtils#clone(T)",
      "head_type": "method",
      "relation": "have",
      "tail": "Design principles for serialization-based cloning",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.SerializationUtils#clone(T)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.SerializationUtils",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.SingleToMultiValueMapAdapter#addAll(MultiValueMap<K,V>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "add values from one MultiValueMap to another",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.SingleToMultiValueMapAdapter#addAll(MultiValueMap<K,V>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.MultiValueMap",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.SingleToMultiValueMapAdapter#addAll(MultiValueMap<K,V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.MultiValueMap",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.SingleToMultiValueMapAdapter#addAll(MultiValueMap<K,V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "public void addAll(MultiValueMap<K, V> values) { values.forEach(this::addAll); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.SingleToMultiValueMapAdapter#addAll(MultiValueMap<K,V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is used to add all key-value pairs from the specified MultiValueMap to the current MultiValueMap.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.SingleToMultiValueMapAdapter#addAll(MultiValueMap<K,V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "The method follows the principle of encapsulation, ensuring that the internal representation of the MultiValueMap is updated correctly without exposing internal details.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.SingleToMultiValueMapAdapter#set(K,V)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "mapValueSetting",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.SingleToMultiValueMapAdapter#set(K,V)",
      "head_type": "method",
      "relation": "have",
      "tail": "mapValueSettingSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "mapValueSettingSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "mapValueSettingSampleCodeContent",
      "tail_type": "codeContent"
    },
    {
      "head": "org.springframework.util.TaskInfo#getTaskName()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "get task name",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.TaskInfo#getTaskName()",
      "head_type": "method",
      "relation": "have",
      "tail": "Get the name of this task.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.TaskInfo#getTaskName()",
      "head_type": "method",
      "relation": "have",
      "tail": "public String getTaskName() {\n    return this.taskName;\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.TaskInfo#getTimeSeconds()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "获取任务执行时间",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.TaskInfo#getTimeSeconds()",
      "head_type": "method",
      "relation": "have",
      "tail": "获取任务执行时间的秒数",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.TaskInfo#getTimeSeconds()",
      "head_type": "method",
      "relation": "have",
      "tail": "使用TimeUnit参数获取时间",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.TaskInfo#getTimeSeconds()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.TaskInfo",
      "tail_type": "class"
    },
    {
      "head": "获取任务执行时间",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "必须使用TimeUnit.SECONDS参数",
      "tail_type": "useConstraint"
    },
    {
      "head": "获取任务执行时间的秒数",
      "head_type": "useScenario",
      "relation": "have",
      "tail": "使用TimeUnit.SECONDS参数获取时间",
      "tail_type": "useSampleCode"
    },
    {
      "head": "使用TimeUnit参数获取时间",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "获取任务执行时间的秒数",
      "tail_type": "useScenario"
    },
    {
      "head": "使用TimeUnit参数获取时间",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "获取任务执行时间",
      "tail_type": "apiFunction"
    },
    {
      "head": "使用TimeUnit参数获取时间",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "必须使用TimeUnit.SECONDS参数",
      "tail_type": "useConstraint"
    },
    {
      "head": "使用TimeUnit参数获取时间",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "获取任务执行时间的秒数的示例代码",
      "tail_type": "useSampleCode"
    },
    {
      "head": "获取任务执行时间的秒数的示例代码",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "获取任务执行时间的秒数",
      "tail_type": "useScenario"
    },
    {
      "head": "获取任务执行时间的秒数的示例代码",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "获取任务执行时间",
      "tail_type": "apiFunction"
    },
    {
      "head": "获取任务执行时间的秒数的示例代码",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "必须使用TimeUnit.SECONDS参数",
      "tail_type": "useConstraint"
    },
    {
      "head": "获取任务执行时间的秒数的示例代码",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "使用TimeUnit.SECONDS参数获取时间的示例代码",
      "tail_type": "useSampleCode"
    },
    {
      "head": "使用TimeUnit.SECONDS参数获取时间的示例代码",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "获取任务执行时间的秒数",
      "tail_type": "useScenario"
    },
    {
      "head": "使用TimeUnit.SECONDS参数获取时间的示例代码",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "获取任务执行时间",
      "tail_type": "apiFunction"
    },
    {
      "head": "使用TimeUnit.SECONDS参数获取时间的示例代码",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "必须使用TimeUnit.SECONDS参数",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.StringUtils#containsWhitespace(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "check whether a string contains any whitespace characters",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils#containsWhitespace(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for checking whitespace in a string",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.StringUtils#containsWhitespace(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "interpretation of whitespace checking in strings",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.StringUtils#containsWhitespace(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle behind whitespace checking",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.StringUtils#containsWhitespace(String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.StringUtils",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.StringUtils#changeFirstCharacterCase(String,boolean)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "changing the case of the first character of a string",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils#changeFirstCharacterCase(String,boolean)",
      "head_type": "method",
      "relation": "have",
      "tail": "private static String changeFirstCharacterCase(String str, boolean capitalize) {\n    if (!hasLength(str)) {\n        return str;\n    }\n    char baseChar = str.charAt(0);\n    char updatedChar;\n    if (capitalize) {\n        updatedChar = Character.toUpperCase(baseChar);\n    } else {\n        updatedChar = Character.toLowerCase(baseChar);\n    }\n    if (baseChar == updatedChar) {\n        return str;\n    }\n    char[] chars = str.toCharArray();\n    chars[0] = updatedChar;\n    return new String(chars);\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.StringUtils#changeFirstCharacterCase(String,boolean)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.StringUtils",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.StringUtils#truncate(CharSequence)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "truncate a CharSequence",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils#truncate(CharSequence)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "threshold of 100 characters",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.StringUtils#truncate(CharSequence)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "truncate a string to a default length",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.StringUtils#truncate(CharSequence)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for truncating a string",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.StringUtils#truncate(CharSequence)",
      "head_type": "method",
      "relation": "have",
      "tail": "related concept interpretation for truncating",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.StringUtils#truncate(CharSequence)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle interpretation for truncating",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.StringUtils#truncate(CharSequence)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.StringUtils",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.unit.DataSize#ofTerabytes(long)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "representing the specified number of terabytes",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.unit.DataSize#ofTerabytes(long)",
      "head_type": "method",
      "relation": "have",
      "tail": "Obtain a DataSize representing the specified number of terabytes",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.unit.DataSize#ofTerabytes(long)",
      "head_type": "method",
      "relation": "have",
      "tail": "public static DataSize ofTerabytes(long terabytes) { return new DataSize(Math.multiplyExact(terabytes, BYTES_PER_TB)); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.unit.DataSize#ofTerabytes(long)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.unit.DataSize#ofTerabytes(long)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#forEach(BiConsumer<? super K,? super List<V>>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "forEach",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#forEach(BiConsumer<? super K,? super List<V>>)",
      "head_type": "method",
      "relation": "have",
      "tail": "UnmodifiableMultiValueMap forEach method",
      "tail_type": "useSampleCode"
    },
    {
      "head": "UnmodifiableMultiValueMap forEach method",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "tail": "org.springframework.util.UnmodifiableMultiValueMap",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueCollection#forEach(Consumer<? super List<V>>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "forEach operation",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueCollection#forEach(Consumer<? super List<V>>)",
      "head_type": "method",
      "relation": "have",
      "tail": "Iterates over each element in the collection",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueCollection#forEach(Consumer<? super List<V>>)",
      "head_type": "method",
      "relation": "have",
      "tail": "public void forEach(Consumer<? super List<V>> action) { this.delegate.forEach(list -> action.accept(Collections.unmodifiableList(list))); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueCollection#forEach(Consumer<? super List<V>>)",
      "head_type": "method",
      "relation": "have",
      "tail": "Ensures that the collection is not modified during iteration",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueCollection#removeAll(Collection<?>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "override",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueCollection#removeAll(Collection<?>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "unsupported operation",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueCollection#removeAll(Collection<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "throw new UnsupportedOperationException()",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueCollection#removeAll(Collection<?>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.UnmodifiableValueCollection",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#dtdInternal(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "parse DTD internally",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#dtdInternal(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.xml.AbstractStaxHandler#dtdInternal(String) useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#dtdInternal(String) useSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "org.springframework.util.xml.AbstractStaxHandler#dtdInternal(String) sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLStreamReader#getAttributePrefix(int)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getAttributePrefix",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLStreamReader#getAttributePrefix(int)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.AbstractXMLStreamReader",
      "tail_type": "class"
    },
    {
      "head": "getAttributePrefix",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "useSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "completeSampleCode",
      "tail_type": "completeSampleCode"
    },
    {
      "head": "org.springframework.util.xml.StaxEventHandler#startDocumentInternal()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "startDocumentInternal",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxEventHandler#startDocumentInternal()",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.xml.StaxEventHandler",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.StaxEventHandler",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.StaxEventHandler#startDocumentInternal()",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.xml.StaxEventHandler#startDocumentInternal()",
      "head_type": "method",
      "relation": "have",
      "tail": "protected void startDocumentInternal() throws XMLStreamException {    this.eventWriter.add(this.eventFactory.createStartDocument());}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.StaxEventXMLReader#handleStartDocument(XMLEvent)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "handle XML start document",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxEventXMLReader#handleStartDocument(XMLEvent)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "must be called at the start of XML processing",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.xml.StaxEventXMLReader#handleStartDocument(XMLEvent)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "XML document parsing",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.xml.StaxEventXMLReader#handleStartDocument(XMLEvent)",
      "head_type": "method",
      "relation": "have",
      "tail": "handleStartDocument(XMLEvent) sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.StaxEventXMLReader#handleStartDocument(XMLEvent)",
      "head_type": "method",
      "relation": "have",
      "tail": "related concept interpretation for handleStartDocument",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxEventXMLReader#handleStartDocument(XMLEvent)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle interpretation for handleStartDocument",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxEventXMLReader",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.StaxEventXMLReader#handleStartDocument(XMLEvent)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.xml.StaxEventXMLReader#handleEndElement(EndElement)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "handleEndElement",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxEventXMLReader#handleEndElement(EndElement)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.StaxEventXMLReader",
      "tail_type": "class"
    },
    {
      "head": "handleEndElement",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "handleEndElement_useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "handleEndElement_useSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "handleEndElement_sampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamReader",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getNamespacePrefix",
      "tail_type": "apiFunction"
    },
    {
      "head": "getNamespacePrefix",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "getNamespacePrefix(int)",
      "tail_type": "useSampleCode"
    },
    {
      "head": "getNamespacePrefix(int)",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "org.springframework.util.xml.XMLEventStreamReader",
      "tail_type": "class"
    },
    {
      "head": "getNamespacePrefix(int)",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "getNamespace(int)",
      "tail_type": "apiFunction"
    },
    {
      "head": "getNamespace(int)",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "getNamespacePrefix(int)",
      "tail_type": "useSampleCode"
    },
    {
      "head": "getNamespacePrefix(int)",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "getPrefix()",
      "tail_type": "apiFunction"
    },
    {
      "head": "getPrefix()",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "getNamespacePrefix(int)",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamReader",
      "head_type": "class",
      "relation": "have",
      "tail": "getNamespacePrefix(int)",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamReader",
      "head_type": "class",
      "relation": "have",
      "tail": "getNamespacePrefix",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamReader",
      "head_type": "class",
      "relation": "have",
      "tail": "getNamespace",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamReader",
      "head_type": "class",
      "relation": "have",
      "tail": "getPrefix",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamReader",
      "head_type": "class",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamReader",
      "head_type": "class",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "tail": "getNamespaceURI",
      "head_type": "class",
      "relation": "haveFunction",
      "head": "org.springframework.util.xml.XMLEventStreamReader",
      "tail_type": "apiFunction"
    },
    {
      "tail": "getNamespaceURI(int)",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "getNamespaceURI",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "org.springframework.util.xml.XMLEventStreamReader",
      "head_type": "useSampleCode",
      "relation": "have",
      "head": "getNamespaceURI(int)",
      "tail_type": "class"
    },
    {
      "tail": "getNamespaceURI(int index)",
      "head_type": "useSampleCode",
      "relation": "have",
      "head": "getNamespaceURI(int)",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "getNamespace(index).getNamespaceURI()",
      "head_type": "useSampleCode",
      "relation": "have",
      "head": "getNamespaceURI(int index)",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "getNamespace(index)",
      "head_type": "useSampleCode",
      "relation": "have",
      "head": "getNamespaceURI(int index)",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "getNamespaceURI()",
      "head_type": "useSampleCode",
      "relation": "have",
      "head": "getNamespaceURI(int index)",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "String",
      "head_type": "useSampleCode",
      "relation": "have",
      "head": "getNamespaceURI(int index)",
      "tail_type": "class"
    },
    {
      "tail": "int",
      "head_type": "useSampleCode",
      "relation": "have",
      "head": "getNamespaceURI(int index)",
      "tail_type": "class"
    },
    {
      "tail": "getNamespaceURI",
      "head_type": "useSampleCode",
      "relation": "have",
      "head": "getNamespaceURI(int index)",
      "tail_type": "apiFunction"
    },
    {
      "tail": "getNamespace",
      "head_type": "useSampleCode",
      "relation": "have",
      "head": "getNamespaceURI(int index)",
      "tail_type": "apiFunction"
    },
    {
      "tail": "getNamespaceURI",
      "head_type": "useSampleCode",
      "relation": "have",
      "head": "getNamespaceURI(int index)",
      "tail_type": "apiFunction"
    },
    {
      "tail": "XMLEventStreamReader",
      "head_type": "useSampleCode",
      "relation": "have",
      "head": "getNamespaceURI(int index)",
      "tail_type": "class"
    },
    {
      "tail": "XMLEventStreamReader",
      "head_type": "useSampleCode",
      "relation": "have",
      "head": "getNamespaceURI(int index)",
      "tail_type": "class"
    },
    {
      "tail": "XMLEventStreamReader",
      "head_type": "useSampleCode",
      "relation": "have",
      "head": "getNamespaceURI(int index)",
      "tail_type": "class"
    },
    {
      "tail": "XMLEventStreamReader",
      "head_type": "useSampleCode",
      "relation": "have",
      "head": "getNamespaceURI(int index)",
      "tail_type": "class"
    },
    {
      "tail": "XMLEventStreamReader",
      "head_type": "useSampleCode",
      "relation": "have",
      "head": "getNamespaceURI(int index)",
      "tail_type": "class"
    },
    {
      "tail": "XMLEventStreamReader",
      "head_type": "useSampleCode",
      "relation": "have",
      "head": "getNamespaceURI(int index)",
      "tail_type": "class"
    },
    {
      "tail": "XMLEventStreamReader",
      "head_type": "useSampleCode",
      "relation": "have",
      "head": "getNamespaceURI(int index)",
      "tail_type": "class"
    },
    {
      "tail": "XMLEventStreamReader",
      "head_type": "useSampleCode",
      "relation": "have",
      "head": "getNamespaceURI(int index)",
      "tail_type": "class"
    },
    {
      "tail": "XMLEventStreamReader",
      "head_type": "useSampleCode",
      "relation": "have",
      "head": "getNamespaceURI(int index)",
      "tail_type": "class"
    },
    {
      "tail": "XMLEventStreamReader",
      "head_type": "useSampleCode",
      "relation": "have",
      "head": "getNamespaceURI(int index)",
      "tail_type": "class"
    },
    {
      "tail": "XMLEventStreamReader",
      "head_type": "useSampleCode",
      "relation": "have",
      "head": "getNamespaceURI(int index)",
      "tail_type": "class"
    },
    {
      "tail": "XMLEventStreamReader",
      "head_type": "useSampleCode",
      "relation": "have",
      "head": "getNamespaceURI(int index)",
      "tail_type": "class"
    },
    {
      "tail": "XMLEventStreamReader",
      "head_type": "useSampleCode",
      "relation": "have",
      "head": "getNamespaceURI(int index)",
      "tail_type": "class"
    },
    {
      "tail": "XMLEventStreamReader",
      "head_type": "useSampleCode",
      "relation": "have",
      "head": "getNamespaceURI(int index)",
      "tail_type": "class"
    },
    {
      "tail": "XMLEventStreamReader",
      "head_type": "useSampleCode",
      "relation": "have",
      "head": "getNamespaceURI(int index)",
      "tail_type": "class"
    },
    {
      "tail": "XMLEventStreamReader",
      "head_type": "useSampleCode",
      "relation": "have",
      "head": "getNamespaceURI(int index)",
      "tail_type": "class"
    },
    {
      "tail": "XMLEventStreamReader",
      "head_type": "useSampleCode",
      "relation": "have",
      "head": "getNamespaceURI(int index)",
      "tail_type": "class"
    },
    {
      "tail": "XMLEventStreamReader",
      "head_type": "useSampleCode",
      "relation": "have",
      "head": "getNamespaceURI(int index)",
      "tail_type": "class"
    },
    {
      "tail": "XMLEventStreamReader",
      "head_type": "useSampleCode",
      "relation": "have",
      "head": "getNamespaceURI(int index)",
      "tail_type": "class"
    },
    {
      "tail": "XMLEventStreamReader",
      "head_type": "useSampleCode",
      "relation": "have",
      "head": "getNamespaceURI(int index)",
      "tail_type": "class"
    },
    {
      "tail": "XMLEventStreamReader",
      "head_type": "useSampleCode",
      "relation": "have",
      "head": "getNamespaceURI(int index)",
      "tail_type": "class"
    },
    {
      "tail": "XMLEventStreamReader",
      "head_type": "useSampleCode",
      "relation": "have",
      "head": "getNamespaceURI(int index)",
      "tail_type": "class"
    },
    {
      "tail": "XMLEventStreamReader",
      "head_type": "useSampleCode",
      "relation": "have",
      "head": "getNamespaceURI(int index)",
      "tail_type": "class"
    },
    {
      "tail": "XMLEventStreamReader",
      "head_type": "useSampleCode",
      "relation": "have",
      "head": "getNamespaceURI(int index)",
      "tail_type": "class"
    },
    {
      "tail": "XMLEventStreamReader",
      "head_type": "useSampleCode",
      "relation": "have",
      "head": "getNamespaceURI(int index)",
      "tail_type": "class"
    },
    {
      "tail": "XMLEventStreamReader",
      "head_type": "useSampleCode",
      "relation": "have",
      "head": "getNamespaceURI(int index)",
      "tail_type": "class"
    },
    {
      "tail": "XMLEventStreamReader",
      "head_type": "useSampleCode",
      "relation": "have",
      "head": "getNamespaceURI(int index)",
      "tail_type": "class"
    },
    {
      "tail": "XMLEventStreamReader",
      "head_type": "useSampleCode",
      "relation": "have",
      "head": "getNamespaceURI(int index)",
      "tail_type": "class"
    },
    {
      "tail": "XMLEventStreamReader",
      "head_type": "useSampleCode",
      "relation": "have",
      "head": "getNamespaceURI(int index)",
      "tail_type": "class"
    },
    {
      "tail": "XMLEventStreamReader",
      "head_type": "useSampleCode",
      "relation": "have",
      "head": "getNamespaceURI(int index)",
      "tail_type": "class"
    },
    {
      "tail": "XMLEventStreamReader",
      "head_type": "useSampleCode",
      "relation": "have",
      "head": "getNamespaceURI(int index)",
      "tail_type": "class"
    },
    {
      "tail": "XMLEventStreamReader",
      "head_type": "useSampleCode",
      "relation": "have",
      "head": "getNamespaceURI(int index)",
      "tail_type": "class"
    },
    {
      "tail": "XMLEventStreamReader",
      "head_type": "useSampleCode",
      "relation": "have",
      "head": "getNamespaceURI(int index)",
      "tail_type": "class"
    },
    {
      "tail": "XMLEventStreamReader",
      "head_type": "useSampleCode",
      "relation": "have",
      "head": "getNamespaceURI(int index)",
      "tail_type": "class"
    },
    {
      "tail": "XMLEventStreamReader",
      "head_type": "useSampleCode",
      "relation": "have",
      "head": "getNamespaceURI(int index)",
      "tail_type": "class"
    },
    {
      "tail": "XMLEventStreamReader",
      "head_type": "useSampleCode",
      "relation": "have",
      "head": "getNamespaceURI(int index)",
      "tail_type": "class"
    },
    {
      "tail": "XMLEventStreamReader",
      "head_type": "useSampleCode",
      "relation": "have",
      "head": "getNamespaceURI(int index)",
      "tail_type": "class"
    },
    {
      "tail": "XMLEventStreamReader",
      "head_type": "useSampleCode",
      "relation": "have",
      "head": "getNamespaceURI(int index)",
      "tail_type": "class"
    },
    {
      "tail": "XMLEventStreamReader",
      "head_type": "useSampleCode",
      "relation": "have",
      "head": "getNamespaceURI(int index)",
      "tail_type": "class"
    },
    {
      "tail": "XMLEventStreamReader",
      "head_type": "useSampleCode",
      "relation": "have",
      "head": "getNamespaceURI(int index)",
      "tail_type": "class"
    },
    {
      "tail": "XMLEventStreamReader",
      "head_type": "useSampleCode",
      "relation": "have",
      "head": "getNamespaceURI(int index)",
      "tail_type": "class"
    },
    {
      "tail": "XMLEventStreamReader",
      "head_type": "useSampleCode",
      "relation": "have",
      "head": "getNamespaceURI(int index)",
      "tail_type": "class"
    },
    {
      "tail": "XMLEventStreamReader",
      "head_type": "useSampleCode",
      "relation": "have",
      "head": "getNamespaceURI(int index)",
      "tail_type": "class"
    },
    {
      "tail": "XMLEventStreamReader",
      "head_type": "useSampleCode",
      "relation": "have",
      "head": "getNamespaceURI(int index)",
      "tail_type": "class"
    },
    {
      "tail": "XMLEventStreamReader",
      "head_type": "useSampleCode",
      "relation": "have",
      "head": "getNamespaceURI(int index)",
      "tail_type": "class"
    },
    {
      "tail": "XMLEventStreamReader",
      "head_type": "useSampleCode",
      "relation": "have",
      "head": "getNamespaceURI(int index)",
      "tail_type": "class"
    },
    {
      "tail": "XMLEventStreamReader",
      "head_type": "useSampleCode",
      "relation": "have",
      "head": "getNamespaceURI(int index)",
      "tail_type": "class"
    },
    {
      "tail": "XMLEventStreamReader",
      "head_type": "useSampleCode",
      "relation": "have",
      "head": "getNamespaceURI(int index)",
      "tail_type": "class"
    },
    {
      "tail": "XMLEventStreamReader",
      "head_type": "useSampleCode",
      "relation": "have",
      "head": "getNamespaceURI(int index)",
      "tail_type": "class"
    },
    {
      "tail": "XMLEventStreamReader",
      "head_type": "useSampleCode",
      "relation": "have",
      "head": "getNamespaceURI(int index)",
      "tail_type": "class"
    },
    {
      "tail": "XMLEventStreamReader",
      "head_type": "useSampleCode",
      "relation": "have",
      "head": "getNamespaceURI(int index)",
      "tail_type": "class"
    },
    {
      "tail": "XMLEventStreamReader",
      "head_type": "useSampleCode",
      "relation": "have",
      "head": "getNamespaceURI(int index)",
      "tail_type": "class"
    },
    {
      "tail": "XMLEventStreamReader",
      "head_type": "useSampleCode",
      "relation": "have",
      "head": "getNamespaceURI(int index)",
      "tail_type": "class"
    },
    {
      "tail": "XMLEventStreamReader",
      "head_type": "useSampleCode",
      "relation": "have",
      "head": "getNamespaceURI(int index)",
      "tail_type": "class"
    },
    {
      "tail": "XMLEventStreamReader",
      "head_type": "useSampleCode",
      "relation": "have",
      "head": "getNamespaceURI(int index)",
      "tail_type": "class"
    },
    {
      "tail": "XMLEventStreamReader",
      "head_type": "useSampleCode",
      "relation": "have",
      "head": "getNamespaceURI(int index)",
      "tail_type": "class"
    },
    {
      "tail": "XMLEventStreamReader",
      "head_type": "useSampleCode",
      "relation": "have",
      "head": "getNamespaceURI(int index)",
      "tail_type": "class"
    },
    {
      "tail": "XMLEventStreamReader",
      "head_type": "useSampleCode",
      "relation": "have",
      "head": "getNamespaceURI(int index)",
      "tail_type": "class"
    },
    {
      "tail": "XMLEventStreamReader",
      "head_type": "useSampleCode",
      "relation": "have",
      "head": "getNamespaceURI(int index)",
      "tail_type": "class"
    },
    {
      "tail": "XMLEventStreamReader",
      "head_type": "useSampleCode",
      "relation": "have",
      "head": "getNamespaceURI(int index)",
      "tail_type": "class"
    },
    {
      "tail": "XMLEventStreamReader",
      "head_type": "useSampleCode",
      "relation": "have",
      "head": "getNamespaceURI(int index)",
      "tail_type": "class"
    },
    {
      "tail": "XMLEventStreamReader",
      "head_type": "useSampleCode",
      "relation": "have",
      "head": "getNamespaceURI(int index)",
      "tail_type": "class"
    },
    {
      "tail": "XMLEventStreamReader",
      "head_type": "useSampleCode",
      "relation": "have",
      "head": "getNamespaceURI(int index)",
      "tail_type": "class"
    },
    {
      "tail": "XMLEventStreamReader",
      "head_type": "useSampleCode",
      "relation": "have",
      "head": "getNamespaceURI(int index)",
      "tail_type": "class"
    },
    {
      "tail": "XMLEventStreamReader",
      "head_type": "useSampleCode",
      "relation": "have",
      "head": "getNamespaceURI(int index)",
      "tail_type": "class"
    },
    {
      "tail": "XMLEventStreamReader",
      "head_type": "useSampleCode",
      "relation": "have",
      "head": "getNamespaceURI(int index)",
      "tail_type": "class"
    },
    {
      "tail": "XMLEventStreamReader",
      "head_type": "useSampleCode",
      "relation": "have",
      "head": "getNamespaceURI(int index)",
      "tail_type": "class"
    },
    {
      "tail": "XMLEventStreamReader",
      "head_type": "useSampleCode",
      "relation": "have",
      "head": "getNamespaceURI(int index)",
      "tail_type": "class"
    },
    {
      "tail": "XMLEventStreamReader",
      "head_type": "useSampleCode",
      "relation": "have",
      "head": "getNamespaceURI(int index)",
      "tail_type": "class"
    },
    {
      "head_type": "useSampleCode",
      "relation": "",
      "head": "getNamespaceURI(int index)"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter#writeAttribute(String,String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "writeAttribute",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter#writeAttribute(String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.xml.XMLEventStreamWriter",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.XMLEventStreamWriter#writeAttribute(String,String)",
      "tail_type": "method"
    },
    {
      "head": "writeAttribute",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "org.springframework.util.xml.XMLEventStreamWriter#writeAttribute(String,String)",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter#writeCData(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "writeCData",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter#writeCData(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "writeCData(String data) throws XMLStreamException",
      "tail_type": "useSampleCode"
    },
    {
      "head": "writeCData(String data) throws XMLStreamException",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.XMLEventStreamWriter",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter#writeCData(String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.XMLEventStreamWriter",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "create method reference",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "create static method reference",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "generate code block for method invocation",
      "tail_type": "apiFunction"
    },
    {
      "head": "create method reference",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "create method reference with class name and method name",
      "tail_type": "useScenario"
    },
    {
      "head": "create static method reference",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "create static method reference with class name and method name",
      "tail_type": "useScenario"
    },
    {
      "head": "generate code block for method invocation",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "generate code block for instance method invocation",
      "tail_type": "useScenario"
    },
    {
      "head": "generate code block for method invocation",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "generate code block for static method invocation",
      "tail_type": "useScenario"
    },
    {
      "head": "generate code block for method invocation",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "generate code block with arguments for method invocation",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests",
      "head_type": "class",
      "relation": "have",
      "tail": "related concept interpretation for method reference",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests",
      "head_type": "class",
      "relation": "have",
      "tail": "design principle interpretation for method reference",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.DefaultMethodReference",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassTests#getNameReturnsName()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getNameReturnsName",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassTests#getNameReturnsName()",
      "head_type": "method",
      "relation": "have",
      "tail": "GeneratedClass",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassTests#getNameReturnsName()",
      "head_type": "method",
      "relation": "have",
      "tail": "assertThat(generatedClass.getName()).isSameAs(TEST_CLASS_NAME);",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests#handleFileWhenFileExistsCanOverride()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "handle existing file",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests#handleFileWhenFileExistsCanOverride()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "override file",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests#handleFileWhenFileExistsCanOverride()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "verify file content",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests#handleFileWhenFileExistsCanOverride()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "verify file override status",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests#handleFileWhenFileExistsCanOverride()",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "file existence",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests#handleFileWhenFileExistsCanOverride()",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "file override scenario",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests#handleFileWhenFileExistsCanOverride()",
      "head_type": "method",
      "relation": "have",
      "tail": "file override sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests#handleFileWhenFileExistsCanOverride()",
      "head_type": "method",
      "relation": "have",
      "tail": "file existence verification explanation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests#handleFileWhenFileExistsCanOverride()",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle for file handling",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests#handleFileWhenFileExistsCanOverride()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.GeneratedFilesTests",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedMethodsTests#createWhenMethodNameGeneratorIsNullThrowsException()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "generate methods",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedMethodsTests#createWhenMethodNameGeneratorIsNullThrowsException()",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "methodNameGenerator must not be null",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedMethodsTests#createWhenMethodNameGeneratorIsNullThrowsException()",
      "head_type": "method",
      "relation": "have",
      "tail": "GeneratedMethods requires a non-null methodNameGenerator",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedMethodsTests#createWhenMethodNameGeneratorIsNullThrowsException()",
      "head_type": "method",
      "relation": "have",
      "tail": "Ensure robustness by validating constructor parameters",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedMethodsTests#createWhenMethodNameGeneratorIsNullThrowsException()",
      "head_type": "method",
      "relation": "have",
      "tail": "java\nimport org.junit.jupiter.api.Test;\nimport static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;\n\nclass GeneratedMethodsTest {\n    @Test\n    void createWhenMethodNameGeneratorIsNullThrowsException() {\n        assertThatIllegalArgumentException().isThrownBy(() -> new GeneratedMethods(\"TEST_CLASS_NAME\", null)).withMessage(\"'methodNameGenerator' must not be null\");\n    }\n}\n",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedMethodsTests#addWithStringNameWhenSuggestedMethodIsNullThrowsException()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "addWithStringNameWhenSuggestedMethodIsNullThrowsException",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedMethodsTests#addWithStringNameWhenSuggestedMethodIsNullThrowsException()",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "suggestedName must not be null",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedMethodsTests#addWithStringNameWhenSuggestedMethodIsNullThrowsException()",
      "head_type": "method",
      "relation": "have",
      "tail": "addWithStringNameWhenSuggestedMethodIsNullThrowsException use sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedMethodsTests#addWithStringNameWhenSuggestedMethodIsNullThrowsException()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.GeneratedMethodsTests",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedMethodsTests#withPrefixWhenGeneratingOtherMethodUsesPrefix()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "generateMethodWithPrefix",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedMethodsTests#withPrefixWhenGeneratingOtherMethodUsesPrefix()",
      "head_type": "method",
      "relation": "have",
      "tail": "GeneratedMethod generation with prefix",
      "tail_type": "useSampleCode"
    },
    {
      "head": "generateMethodWithPrefix",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "GeneratedMethod generation with prefix",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedMethodsTests#withPrefixWhenGeneratingOtherMethodUsesPrefix()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.GeneratedMethodsTests",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedMethodTests#create(Consumer<MethodSpec.Builder>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "createGeneratedMethod",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedMethodTests#create(Consumer<MethodSpec.Builder>)",
      "head_type": "method",
      "relation": "have",
      "tail": "createGeneratedMethodSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "createGeneratedMethodSampleCode",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.GeneratedMethodTests#create(Consumer<MethodSpec.Builder>)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.aot.generate.PrimitiveTests#generateWhenShort()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "generateWhenShort",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.PrimitiveTests#generateWhenShort()",
      "head_type": "method",
      "relation": "have",
      "tail": "generateWhenShortSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "generateWhenShortSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "generateWhenShortCompleteSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "testReflectiveRuntimeHints",
      "tail_type": "apiFunction"
    },
    {
      "head": "testReflectiveRuntimeHints",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "requireReflectiveAnnotation",
      "tail_type": "useConstraint"
    },
    {
      "head": "testReflectiveRuntimeHints",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "registerHintsForAnnotatedElements",
      "tail_type": "useScenario"
    },
    {
      "head": "registerHintsForAnnotatedElements",
      "head_type": "useScenario",
      "relation": "have",
      "tail": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests.useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests",
      "head_type": "class",
      "relation": "have",
      "tail": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests.relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests",
      "head_type": "class",
      "relation": "have",
      "tail": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests.designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.aot.hint.ReflectiveRuntimeHintsRegistrar",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.aot.hint.RuntimeHints",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.core.type.StandardClassMetadata#isInterface()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "interface checking",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.core.type.StandardClassMetadata#isInterface()",
      "head_type": "method",
      "relation": "have",
      "tail": "interface checking sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.core.type.StandardClassMetadata#isInterface()",
      "head_type": "method",
      "relation": "have",
      "tail": "interface checking related concept interpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.core.type.StandardClassMetadata#isInterface()",
      "head_type": "method",
      "relation": "have",
      "tail": "interface checking design principle interpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.core.type.StandardClassMetadata#isInterface()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.core.type.StandardClassMetadata",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.AlternativeJdkIdGenerator#generateId()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "UUID generation",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.AlternativeJdkIdGenerator#generateId()",
      "head_type": "method",
      "relation": "have",
      "tail": "Generates a UUID using random bytes",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.AlternativeJdkIdGenerator#generateId()",
      "head_type": "method",
      "relation": "have",
      "tail": "The method utilizes Java's UUID class to generate unique identifiers based on random byte arrays. It shifts bytes to form two long values representing the most significant and least significant bits of the UUID.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.AlternativeJdkIdGenerator#generateId()",
      "head_type": "method",
      "relation": "have",
      "tail": "The design principle here is efficiency and randomness, ensuring that each generated UUID is unique and adheres to the standard UUID format.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.Assert#noNullElements(Object[],Supplier<String>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "assertNoNullElements",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.Assert#noNullElements(Object[],Supplier<String>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "arrayNotNull",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.Assert#noNullElements(Object[],Supplier<String>)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "checkArrayElements",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.Assert#noNullElements(Object[],Supplier<String>)",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.Assert#noNullElements(Object[],Supplier<String>)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.Assert#noNullElements(Object[],Supplier<String>)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.Assert#noNullElements(Object[],Supplier<String>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "IllegalArgumentException",
      "tail_type": "class"
    },
    {
      "head": "assertNoNullElements",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "arrayNotNull",
      "head_type": "useConstraint",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "checkArrayElements",
      "head_type": "useScenario",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.AutoPopulatingList#contains(Object)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "AutoPopulatingList.contains(Object)",
      "tail_type": "apiFunction"
    },
    {
      "head": "AutoPopulatingList.contains(Object)",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "AutoPopulatingList.contains(Object) Use Sample Code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "AutoPopulatingList.contains(Object)",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "AutoPopulatingList.contains(Object) Related Concept Interpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "AutoPopulatingList.contains(Object)",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "AutoPopulatingList.contains(Object) Design Principle Interpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.backoff.BackOffExecution#nextBackOff()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "retry delay calculation",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.backoff.BackOffExecution#nextBackOff()",
      "head_type": "method",
      "relation": "have",
      "tail": "Return the number of milliseconds to wait before retrying the operation or STOP to indicate that no further attempt should be made for the operation.",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.backoff.BackOffExecution#nextBackOff()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.backoff.BackOffExecution",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.backoff.BackOffExecution#nextBackOff()",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is used to calculate the delay before retrying an operation. It returns the number of milliseconds to wait. If no further attempts should be made, it returns a special value indicating the operation should stop.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.backoff.BackOffExecution#nextBackOff()",
      "head_type": "method",
      "relation": "have",
      "tail": "The design principle behind this method is to provide a mechanism to control the retry behavior in a systematic and configurable way, allowing for dynamic adjustment based on the context in which it is used.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.backoff.FixedBackOff#setInterval(long)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "setInterval",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.backoff.FixedBackOff#setInterval(long)",
      "head_type": "method",
      "relation": "have",
      "tail": "Set the interval between two attempts in milliseconds.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.backoff.FixedBackOff#setInterval(long)",
      "head_type": "method",
      "relation": "have",
      "tail": "public void setInterval(long interval) { this.interval = interval; }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.backoff.FixedBackOff#setMaxAttempts(long)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "Setting maximum number of attempts",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.backoff.FixedBackOff#setMaxAttempts(long)",
      "head_type": "method",
      "relation": "have",
      "tail": "Set the maximum number of attempts in milliseconds",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.backoff.FixedBackOff#setMaxAttempts(long)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is used to set the maximum number of attempts for a backoff operation. It takes a long value as an argument, which represents the maximum number of attempts.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.backoff.FixedBackOff#setMaxAttempts(long)",
      "head_type": "method",
      "relation": "have",
      "tail": "The design principle behind this method is to provide a way to configure the maximum number of attempts for a backoff operation. This allows for flexibility in handling different scenarios where a different number of attempts may be appropriate.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.backoff.FixedBackOffExecution#toString()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "toString",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.backoff.FixedBackOffExecution#toString()",
      "head_type": "method",
      "relation": "have",
      "tail": "Converts the FixedBackOffExecution state to a string representation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.backoff.FixedBackOffExecution#toString()",
      "head_type": "method",
      "relation": "have",
      "tail": "public String toString() { String attemptValue = (FixedBackOff.this.maxAttempts == Long.MAX_VALUE ? \"unlimited\" : String.valueOf(FixedBackOff.this.maxAttempts)); return \"FixedBackOff{interval=\" + FixedBackOff.this.interval + \", currentAttempts=\" + this.currentAttempts + \", maxAttempts=\" + attemptValue + '}'; }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.backoff.FixedBackOffExecution#toString()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.backoff.FixedBackOffExecution",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.ClassUtils#isLoadable(Class<?>,ClassLoader)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "class loadability checking",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ClassUtils#isLoadable(Class<?>,ClassLoader)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "class must exist in the specified ClassLoader",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ClassUtils#isLoadable(Class<?>,ClassLoader)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "checking if a class can be loaded by a specific ClassLoader",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ClassUtils#isLoadable(Class<?>,ClassLoader)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for checking class loadability",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ClassUtils#isLoadable(Class<?>,ClassLoader)",
      "head_type": "method",
      "relation": "have",
      "tail": "explanation of class loading and ClassLoader",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#isLoadable(Class<?>,ClassLoader)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principles behind class loadability checking",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#isLoadable(Class<?>,ClassLoader)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.ClassUtils",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.ClassUtils#getPackageName(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "get package name",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ClassUtils#getPackageName(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "getPackageName returns the package name of a fully-qualified class name",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#getPackageName(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "getPackageName handles default package by returning an empty string",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#getPackageName(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "package com.example; import org.springframework.util.ClassUtils; public class Main { public static void main(String[] args) { String packageName = ClassUtils.getPackageName(\"com.example.Main\"); System.out.println(packageName); } }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ClassUtils",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.ClassUtils#getPackageName(String)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.ClassUtils",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getConstructorIfAvailable",
      "tail_type": "apiFunction"
    },
    {
      "head": "getConstructorIfAvailable",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "Class<T>",
      "tail_type": "class"
    },
    {
      "head": "getConstructorIfAvailable",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "Class<?>",
      "tail_type": "class"
    },
    {
      "head": "getConstructorIfAvailable",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "useSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "sampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "getConstructorIfAvailable",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "relatedConceptInterpretation",
      "head_type": "relatedConceptInterpretation",
      "relation": "have",
      "tail": "NoSuchMethodException",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "getConstructorIfAvailable",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "designPrincipleInterpretation",
      "head_type": "designPrincipleInterpretation",
      "relation": "have",
      "tail": "null safety",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#getMostSpecificMethod(Method,Class<?>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "find the corresponding target method",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ClassUtils#getMostSpecificMethod(Method,Class<?>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "Java security settings disallow reflective access",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ClassUtils#getMostSpecificMethod(Method,Class<?>)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "reflective invocation",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ClassUtils#getMostSpecificMethod(Method,Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "Given a method, which may come from an interface, and a target class used in the current reflective invocation, find the corresponding target method if there is one — for example, the method may be IFoo.bar(), and the target class may be DefaultFoo. In this case, the method may be DefaultFoo.bar(). This enables attributes on that method to be found.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#getMostSpecificMethod(Method,Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is designed to find the most specific method applicable to a given target class in a reflective invocation context. It handles cases where the method may come from an interface and the target class is a concrete implementation. The method ensures that attributes on the target method can be correctly identified, which is crucial for various frameworks and libraries that rely on reflection and annotation processing.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#getMostSpecificMethod(Method,Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "public static Method getMostSpecificMethod(Method method, @Nullable Class<?> targetClass) {\n    if (targetClass != null && targetClass != method.getDeclaringClass() && (isOverridable(method, targetClass) || !method.getDeclaringClass().isAssignableFrom(targetClass))) {\n        try {\n            if (Modifier.isPublic(method.getModifiers())) {\n                try {\n                    return targetClass.getMethod(method.getName(), method.getParameterTypes());\n                } catch (NoSuchMethodException ex) {\n                    return method;\n                }\n            } else {\n                Method specificMethod = ReflectionUtils.findMethod(targetClass, method.getName(), method.getParameterTypes());\n                return (specificMethod != null ? specificMethod : method);\n            }\n        } catch (SecurityException ex) {\n            // Security settings are disallowing reflective access; fall back to 'method' below.\n        }\n    }\n    return method;\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ClassUtils",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.ClassUtils#getMostSpecificMethod(Method,Class<?>)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.comparator.Comparators",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "comparable",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.comparator.Comparators",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "nullsLow",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.comparator.Comparators",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "nullsHigh",
      "tail_type": "apiFunction"
    },
    {
      "head": "comparable",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "Comparator#naturalOrder()",
      "tail_type": "useScenario"
    },
    {
      "head": "nullsLow",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "Comparator#nullsFirst(Comparator)",
      "tail_type": "useScenario"
    },
    {
      "head": "nullsHigh",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "Comparator#nullsLast(Comparator)",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.comparator.Comparators",
      "head_type": "class",
      "relation": "have",
      "tail": "Convenient entry point with generically typed factory methods for common Spring Comparator variants.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.comparator.Comparators",
      "head_type": "class",
      "relation": "have",
      "tail": "Author: Juergen Hoeller, Since: 5.0",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.comparator.Comparators",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "Comparator",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.CompositeCollection#remove(Object)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "removeElement",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.CompositeCollection#remove(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "Removes an element from the composite collection",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.CompositeCollection#remove(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "public boolean remove(Object o) { boolean firstResult = this.first.remove(o); boolean secondResult = this.second.remove(o); return firstResult || secondResult; }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.CompositeCollection#remove(Object)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.CompositeCollection",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.CompositeIterator",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "combine multiple iterators",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.CompositeIterator",
      "head_type": "class",
      "relation": "constrained_by",
      "tail": "cannot add iterators once in use",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.CompositeIterator",
      "head_type": "class",
      "relation": "constrained_by",
      "tail": "cannot add the same iterator twice",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.CompositeIterator",
      "head_type": "class",
      "relation": "applied_to",
      "tail": "iterators invoked in sequence",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.CompositeIterator",
      "head_type": "class",
      "relation": "have",
      "tail": "linked set of iterators",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.CompositeIterator",
      "head_type": "class",
      "relation": "have",
      "tail": "sample code for adding and using iterators",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.CompositeIterator",
      "head_type": "class",
      "relation": "have",
      "tail": " iterators are invoked in sequence until all are exhausted",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.CompositeIterator",
      "head_type": "class",
      "relation": "have",
      "tail": "design principle of maintaining a set of iterators for sequential invocation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.CompositeIterator",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.Iterator",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.ConcurrentLruCache#capacity()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "get maximum number of entries",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ConcurrentLruCache#capacity()",
      "head_type": "method",
      "relation": "have",
      "tail": "Return the maximum number of entries in the cache.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ConcurrentLruCache#capacity()",
      "head_type": "method",
      "relation": "have",
      "tail": "public int capacity() { return this.capacity; }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ConcurrentLruCache#capacity()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.ConcurrentLruCache",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.ConcurrentLruCache",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "get maximum number of entries",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ConcurrentLruCache",
      "head_type": "class",
      "relation": "have",
      "tail": "Return the maximum number of entries in the cache.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ConcurrentLruCache",
      "head_type": "class",
      "relation": "have",
      "tail": "public int capacity() { return this.capacity; }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.WriteOperations#drain()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "execute tasks from the operations queue",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.WriteOperations#drain()",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "tasks count limit",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.WriteOperations#drain()",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "execute tasks up to a certain limit",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.WriteOperations#drain()",
      "head_type": "method",
      "relation": "have",
      "tail": "public void drain() {\n    for (int i = 0; i < DRAIN_THRESHOLD; i++) {\n        final Runnable task = this.operations.poll();\n        if (task == null) {\n            break;\n        }\n        task.run();\n    }\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.WriteOperations#drain()",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is designed to execute tasks from a queue up to a certain threshold, ensuring that the system does not get overwhelmed by too many tasks at once.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.WriteOperations#drain()",
      "head_type": "method",
      "relation": "have",
      "tail": "The method follows a principle of controlled execution, ensuring that only a limited number of tasks are executed in a batch to maintain system stability.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.CustomizableThreadCreator#createThread(Runnable)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "thread creation",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.CustomizableThreadCreator#createThread(Runnable)",
      "head_type": "method",
      "relation": "have",
      "tail": "The default implementation creates a new Thread for the given Runnable, applying an appropriate thread name.",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.CustomizableThreadCreator#createThread(Runnable)",
      "head_type": "method",
      "relation": "have",
      "tail": "Template method for the creation of a new Thread.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.CustomizableThreadCreator#createThread(Runnable)",
      "head_type": "method",
      "relation": "have",
      "tail": "The design principle is to provide a customizable way to create threads with appropriate names and priorities.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.CustomizableThreadCreator",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.CustomizableThreadCreator#createThread(Runnable)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.DefaultPropertiesPersister#store(Properties,Writer,String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "store properties",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.DefaultPropertiesPersister#store(Properties,Writer,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "store properties sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "store properties sample code",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "org.springframework.util.DefaultPropertiesPersister#store(Properties,Writer,String) sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.function.SupplierUtils#resolve(Object)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "resolve a given Supplier",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.function.SupplierUtils#resolve(Object)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "the candidate must be potentially a Supplier",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.function.SupplierUtils#resolve(Object)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "resolving Suppliers in code",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.function.SupplierUtils#resolve(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "public static Object resolve(@Nullable Object candidate) { return (candidate instanceof Supplier<?> supplier ? supplier.get() : candidate); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.function.SupplierUtils#resolve(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.function.SupplierUtils#resolve(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "resolve a given Supplier",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "org.springframework.util.function.SupplierUtils",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.JdkIdGenerator#generateId()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "generate unique identifier",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.JdkIdGenerator#generateId()",
      "head_type": "method",
      "relation": "have",
      "tail": "Generates a unique identifier using the JdkIdGenerator.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.JdkIdGenerator#generateId()",
      "head_type": "method",
      "relation": "have",
      "tail": "Utilizes java.util.UUID.randomUUID() to generate a unique identifier.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.JdkIdGenerator#generateId()",
      "head_type": "method",
      "relation": "have",
      "tail": "package com.example.demo;\n\nimport java.util.UUID;\n\npublic class Main {\n    public static void main(String[] args) {\n        UUID uniqueID = UUID.randomUUID();\n        System.out.println(\"Generated UUID: \" + uniqueID);\n    }\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.LinkedCaseInsensitiveMap#putIfAbsent(String,V)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "putIfAbsent",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.LinkedCaseInsensitiveMap#putIfAbsent(String,V)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.LinkedCaseInsensitiveMap",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.LinkedCaseInsensitiveMap",
      "head_type": "class",
      "relation": "have",
      "tail": "LinkedCaseInsensitiveMap",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "LinkedCaseInsensitiveMap",
      "head_type": "relatedConceptInterpretation",
      "relation": "have",
      "tail": "This class is a part of the Spring Framework and extends the functionality of a standard map by providing case-insensitive keys. It is designed to handle scenarios where the case of keys should not matter, enhancing the flexibility and robustness of applications that require such behavior.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.LinkedCaseInsensitiveMap#putIfAbsent(String,V)",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "useSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "java\npackage com.example.demo;\n\nimport org.springframework.util.LinkedCaseInsensitiveMap;\n\npublic class Sample {\n    public static void main(String[] args) {\n        LinkedCaseInsensitiveMap<String> map = new LinkedCaseInsensitiveMap<>();\n        map.put(\"Key\", \"value1\");\n        map.putIfAbsent(\"key\", \"value2\"); // This will not add a new entry\n        System.out.println(map); // Output: {Key=value1}\n    }\n}\n",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.LinkedCaseInsensitiveMap#toString()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "toString()",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.LinkedCaseInsensitiveMap#toString()",
      "head_type": "method",
      "relation": "have",
      "tail": "Converts the map to a string representation.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.LinkedCaseInsensitiveMap#toString()",
      "head_type": "method",
      "relation": "have",
      "tail": "public String toString() {\n    return this.targetMap.toString();\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.MultiValueMapAdapter#toSingleValueMap()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "convert multi-value map to single-value map",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MultiValueMapAdapter#toSingleValueMap()",
      "head_type": "method",
      "relation": "have",
      "tail": "public Map<K, V> toSingleValueMap() {\n    Map<K, V> singleValueMap = CollectionUtils.newLinkedHashMap(this.targetMap.size());\n    this.targetMap.forEach((key, values) -> {\n        if (!CollectionUtils.isEmpty(values)) {\n            singleValueMap.put(key, values.get(0));\n        }\n    });\n    return singleValueMap;\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.MultiValueMapAdapter#toSingleValueMap()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.MultiValueMapAdapter",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.MultiValueMapAdapter#toSingleValueMap()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.CollectionUtils",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.ObjectUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "isCheckedException",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.ObjectUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "isCompatibleWithThrowsClause",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.ObjectUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "isArray",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.ObjectUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "isEmpty",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.ObjectUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "unwrapOptional",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.ObjectUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "containsElement",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.ObjectUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "containsConstant",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.ObjectUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "caseInsensitiveValueOf",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.ObjectUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "addObjectToArray",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.ObjectUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "toObjectArray",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.ObjectUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "nullSafeEquals",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.ObjectUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "nullSafeHash",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.ObjectUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "nullSafeHashCode",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.ObjectUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "identityToString",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.ObjectUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "getDisplayString",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.ObjectUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "nullSafeClassName",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.ObjectUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "nullSafeToString",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.ObjectUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "nullSafeConciseToString",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.ObjectUtils#identityToString(Object)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "toString representation",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ObjectUtils#identityToString(Object)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "null input returns empty string",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ObjectUtils#identityToString(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "Return a String representation of an object's overall identity.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ObjectUtils#identityToString(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "The method returns the object's identity as a String representation, or an empty String if the object was null.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ObjectUtils#identityToString(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "public static String identityToString(@Nullable Object obj) {\n    if (obj == null) {\n        return EMPTY_STRING;\n    }\n    return obj.getClass().getName() + \"@\" + getIdentityHexString(obj);\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#handleInvocationTargetException(InvocationTargetException)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "handle invocation target exception",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#handleInvocationTargetException(InvocationTargetException)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "no checked exception expected",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#handleInvocationTargetException(InvocationTargetException)",
      "head_type": "method",
      "relation": "have",
      "tail": "rethrow RuntimeException or Error",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#handleInvocationTargetException(InvocationTargetException)",
      "head_type": "method",
      "relation": "have",
      "tail": "throw UndeclaredThrowableException otherwise",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#handleInvocationTargetException(InvocationTargetException)",
      "head_type": "method",
      "relation": "have",
      "tail": "public static void handleInvocationTargetException(InvocationTargetException ex) { rethrowRuntimeException(ex.getTargetException()); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#handleInvocationTargetException(InvocationTargetException)",
      "head_type": "method",
      "relation": "have",
      "tail": "Handle the given invocation target exception. Should only be called if no checked exception is expected to be thrown by the target method. Throws the underlying RuntimeException or Error in case of such a root cause. Throws an UndeclaredThrowableException otherwise.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#handleInvocationTargetException(InvocationTargetException)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is designed to handle exceptions thrown during reflection-based method invocations. It ensures that unchecked exceptions are rethrown as they are, while checked exceptions are wrapped in an UndeclaredThrowableException if they are not expected by the target method signature.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#handleInvocationTargetException(InvocationTargetException)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.ReflectionUtils",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.FieldCallback#doWith(Field)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "perform an operation using the given field",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.FieldCallback#doWith(Field)",
      "head_type": "method",
      "relation": "have",
      "tail": "Perform an operation using the given field.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.FieldCallback#doWith(Field)",
      "head_type": "method",
      "relation": "have",
      "tail": "void doWith(Field field) throws IllegalArgumentException, IllegalAccessException { /* implementation code */ }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ResourceUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "resolve resource locations to files",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ResourceUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "determine URL protocols",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ResourceUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "convert URLs to files",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ResourceUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "check if a URL is a file URL",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ResourceUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "check if a URL is a JAR URL",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ResourceUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "check if a URL is a JAR file URL",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ResourceUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "extract JAR file URL from a URL",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ResourceUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "extract archive URL from a JAR/WAR URL",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ResourceUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "create a URI instance from a URL",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ResourceUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "create a URI instance from a location string",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ResourceUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "create a clean URL instance from a location string",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ResourceUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "create a clean relative URL instance from a root URL and relative path",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ResourceUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "set useCaches flag on a URLConnection",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ResourceUtils",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.core.io.Resource",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.ResourceUtils",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.core.io.ClassPathResource",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.ResourceUtils",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.core.io.FileSystemResource",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.ResourceUtils",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.core.io.UrlResource",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.ResourceUtils",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.core.io.ResourceLoader",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.ResourceUtils#getURL(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "Resolving resource location to URL",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ResourceUtils#getURL(String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "Resource location must not be null",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ResourceUtils#getURL(String)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "Resolving classpath, file URLs, or plain file paths",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ResourceUtils#getURL(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "Complete sample code for resolving resource location to URL",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ResourceUtils#getURL(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "Detailed explanation of resource resolution",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ResourceUtils#getURL(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "Design principles behind resource resolution method",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ResourceUtils",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.ResourceUtils#getURL(String)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.RouteMatcher",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "parseRoute",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.RouteMatcher",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "isPattern",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.RouteMatcher",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "combine",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.RouteMatcher",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "match",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.RouteMatcher",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "matchAndExtract",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.RouteMatcher",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getPatternComparator",
      "tail_type": "apiFunction"
    },
    {
      "head": "parseRoute",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "isPattern",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "combine",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "match",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "matchAndExtract",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "getPatternComparator",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.RouteMatcher",
      "head_type": "class",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.RouteMatcher",
      "head_type": "class",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.RouteMatcher",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "PathMatcher",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.StringUtils#trimAllWhitespace(CharSequence)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "trimming whitespace",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils#trimAllWhitespace(CharSequence)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "input must be a CharSequence",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.StringUtils#trimAllWhitespace(CharSequence)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "removing all types of whitespace from strings",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.StringUtils#trimAllWhitespace(CharSequence)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for trimming whitespace",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.StringUtils#trimAllWhitespace(CharSequence)",
      "head_type": "method",
      "relation": "have",
      "tail": "explanation of whitespace characters",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.StringUtils#trimAllWhitespace(CharSequence)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle of efficiency and readability",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.StringUtils#trimAllWhitespace(CharSequence)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "java.lang.Character#isWhitespace",
      "tail_type": "method"
    },
    {
      "head": "trimming whitespace",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "sample code for trimming whitespace",
      "tail_type": "useSampleCode"
    },
    {
      "head": "trimming whitespace",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "explanation of whitespace characters",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "trimming whitespace",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "design principle of efficiency and readability",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.StringUtils#trimLeadingWhitespace(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "trim leading whitespace",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils#trimLeadingWhitespace(String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "deprecated since 6.0",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.StringUtils#trimLeadingWhitespace(String)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "given String",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.StringUtils#trimLeadingWhitespace(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for trim leading whitespace",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.StringUtils#trimLeadingWhitespace(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "interpretation of Character.isWhitespace",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.StringUtils#trimLeadingWhitespace(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle of deprecation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.StringUtils#trimLeadingWhitespace(String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "String#stripLeading()",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.StringUtils#delete(String,String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "delete all occurrences of the given substring",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils#delete(String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "Delete all occurrences of the given substring.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.StringUtils#delete(String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "The method takes two parameters: the original string and the pattern to delete all occurrences of. It returns the resulting string after all occurrences of the pattern have been removed.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.StringUtils#delete(String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "public static String delete(String inString, String pattern) {\n    return replace(inString, pattern, \"\");\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#isEmpty()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "checkEmptiness",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#isEmpty()",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.UnmodifiableMultiValueMap",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#isEmpty()",
      "head_type": "method",
      "relation": "have",
      "tail": "Delegate pattern usage",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#isEmpty()",
      "head_type": "method",
      "relation": "have",
      "tail": "Ensuring immutability",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#isEmpty()",
      "head_type": "method",
      "relation": "have",
      "tail": "Complete example of using isEmpty() method",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySpliterator",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "UnmodifiableEntrySpliterator",
      "tail_type": "apiFunction"
    },
    {
      "head": "UnmodifiableEntrySpliterator",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "UnmodifiableEntrySpliterator(Spliterator<? extends Entry<? extends K, ? extends List<? extends V>>> delegate)",
      "tail_type": "useSampleCode"
    },
    {
      "head": "UnmodifiableEntrySpliterator(Spliterator<? extends Entry<? extends K, ? extends List<? extends V>>> delegate)",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "private final Spliterator<Entry<K, List<V>>> delegate;",
      "tail_type": "useSampleCode"
    },
    {
      "head": "UnmodifiableEntrySpliterator(Spliterator<? extends Entry<? extends K, ? extends List<? extends V>>> delegate)",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "this.delegate = (Spliterator<Entry<K, List<V>>>) delegate;",
      "tail_type": "useSampleCode"
    },
    {
      "head": "UnmodifiableEntrySpliterator",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "tryAdvance(Consumer<? super Entry<K, List<V>>> action)",
      "tail_type": "useSampleCode"
    },
    {
      "head": "tryAdvance(Consumer<? super Entry<K, List<V>>> action)",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "return this.delegate.tryAdvance(entry -> action.accept(new UnmodifiableEntry<>(entry)));",
      "tail_type": "useSampleCode"
    },
    {
      "head": "UnmodifiableEntrySpliterator",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "forEachRemaining(Consumer<? super Entry<K, List<V>>> action)",
      "tail_type": "useSampleCode"
    },
    {
      "head": "forEachRemaining(Consumer<? super Entry<K, List<V>>> action)",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "this.delegate.forEachRemaining(entry -> action.accept(new UnmodifiableEntry<>(entry)));",
      "tail_type": "useSampleCode"
    },
    {
      "head": "UnmodifiableEntrySpliterator",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "trySplit()",
      "tail_type": "useSampleCode"
    },
    {
      "head": "trySplit()",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "Spliterator<? extends Entry<? extends K, ? extends List<? extends V>>> split = this.delegate.trySplit();\n    if (split != null) {\n        return new UnmodifiableEntrySpliterator<>(split);\n    } else {\n        return null;\n    }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "UnmodifiableEntrySpliterator",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "estimateSize()",
      "tail_type": "useSampleCode"
    },
    {
      "head": "estimateSize()",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "return this.delegate.estimateSize();",
      "tail_type": "useSampleCode"
    },
    {
      "head": "UnmodifiableEntrySpliterator",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "getExactSizeIfKnown()",
      "tail_type": "useSampleCode"
    },
    {
      "head": "getExactSizeIfKnown()",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "return this.delegate.getExactSizeIfKnown();",
      "tail_type": "useSampleCode"
    },
    {
      "head": "UnmodifiableEntrySpliterator",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "characteristics()",
      "tail_type": "useSampleCode"
    },
    {
      "head": "characteristics()",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "return this.delegate.characteristics();",
      "tail_type": "useSampleCode"
    },
    {
      "head": "UnmodifiableEntrySpliterator",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "hasCharacteristics(int characteristics)",
      "tail_type": "useSampleCode"
    },
    {
      "head": "hasCharacteristics(int characteristics)",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "return this.delegate.hasCharacteristics(characteristics);",
      "tail_type": "useSampleCode"
    },
    {
      "head": "UnmodifiableEntrySpliterator",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "getComparator()",
      "tail_type": "useSampleCode"
    },
    {
      "head": "getComparator()",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "return this.delegate.getComparator();",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#startElementInternal(QName,Attributes,Map<String,String>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "startElementInternal",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#startElementInternal(QName,Attributes,Map<String,String>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.AbstractStaxHandler",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler",
      "head_type": "class",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler",
      "head_type": "class",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxXMLReader#endPrefixMapping(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "endPrefixMapping",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxXMLReader#endPrefixMapping(String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "prefixMustBeMapped",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxXMLReader#endPrefixMapping(String)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "xmlContentProcessing",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxXMLReader#endPrefixMapping(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "xmlContentHandlerUsage",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxXMLReader#endPrefixMapping(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "xmlNamespaceManagement",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxXMLReader#endPrefixMapping(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleOfStaxXMLReader",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxXMLReader#endPrefixMapping(String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.AbstractStaxXMLReader",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxXMLReader#endPrefixMapping(String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.xml.sax.ContentHandler",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.StaxLocator",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "Locator interface implementation",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxLocator",
      "head_type": "class",
      "relation": "constrained_by",
      "tail": "StAX Location dependency",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.xml.StaxLocator",
      "head_type": "class",
      "relation": "applied_to",
      "tail": "XML processing",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.xml.StaxLocator",
      "head_type": "class",
      "relation": "have",
      "tail": "Complete StAX Locator Example",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.StaxLocator",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "Locator",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.StaxLocator",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "Location",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.StaxLocator",
      "head_type": "class",
      "relation": "have",
      "tail": "StAX Locator Explanation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxLocator",
      "head_type": "class",
      "relation": "have",
      "tail": "Design Principles of StAX Locator",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.ListBasedXMLEventReader#peek()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "peeking XML events",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.ListBasedXMLEventReader#peek()",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is used to peek the next XML event in the list without advancing the cursor.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.ListBasedXMLEventReader#peek()",
      "head_type": "method",
      "relation": "have",
      "tail": "The design principle followed here is to provide a non-destructive way to look ahead in the XML event stream.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.ListBasedXMLEventReader#peek()",
      "head_type": "method",
      "relation": "have",
      "tail": "package com.example.xml;\n\nimport javax.xml.stream.XMLEventReader;\nimport javax.xml.stream.events.XMLEvent;\n\npublic class XMLPeekExample {\n    public static void main(String[] args) {\n        // Assuming 'reader' is an instance of ListBasedXMLEventReader\n        ListBasedXMLEventReader reader = new ListBasedXMLEventReader(events);\n        if (reader.hasNext()) {\n            XMLEvent nextEvent = reader.peek();\n            System.out.println(nextEvent);\n        }\n    }\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.StaxEventHandler#getNamespaces(Map<String,String>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getNamespaces",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxEventHandler#getNamespaces(Map<String,String>)",
      "head_type": "method",
      "relation": "have",
      "tail": "getNamespacesSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "getNamespacesSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "getNamespacesCompleteExample",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.StaxSource",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "Construct a new instance with XMLEventReader",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxSource",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "Construct a new instance with XMLStreamReader",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxSource",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "Return the XMLEventReader",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxSource",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "Return the XMLStreamReader",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxSource",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "Throw UnsupportedOperationException for setInputSource",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxSource",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "Throw UnsupportedOperationException for setXMLReader",
      "tail_type": "apiFunction"
    },
    {
      "head": "Construct a new instance with XMLEventReader",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "Reader must be at the start of a document or element",
      "tail_type": "useConstraint"
    },
    {
      "head": "Construct a new instance with XMLStreamReader",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "Reader must be at the start of a document or element",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.xml.StaxSource",
      "head_type": "class",
      "relation": "have",
      "tail": "Implementation of Source tagging interface for StAX readers",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxSource",
      "head_type": "class",
      "relation": "have",
      "tail": "Compatibility with JAXP 1.3 and JAXP 1.4",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxSource",
      "head_type": "class",
      "relation": "have",
      "tail": "Only supported operation is parsing with XMLReader from getInputSource",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.xml.StaxSource",
      "head_type": "class",
      "relation": "have",
      "tail": "Calling setXMLReader or setInputSource is not supported",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.xml.StaxSource",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "XMLEventReader",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.StaxSource",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "XMLStreamReader",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.StaxSource",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "InputSource",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.StaxSource",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "XMLReader",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamXMLReader#handleEndElement()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "handleEndElement",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamXMLReader#handleEndElement()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.StaxStreamXMLReader",
      "tail_type": "class"
    },
    {
      "head": "handleEndElement",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "handleEndElementSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "handleEndElementSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "handleEndElementSampleCodeContent",
      "tail_type": "useSampleCodeContent"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils#createDefensiveInputFactory()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "createDefensiveInputFactory",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils#createDefensiveInputFactory()",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "no support for the resolution of DTDs and external entities",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils#createDefensiveInputFactory()",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "relatedConceptInterpretation",
      "head_type": "relatedConceptInterpretation",
      "relation": "associated_with",
      "tail": "XMLInputFactory",
      "tail_type": "class"
    },
    {
      "head": "relatedConceptInterpretation",
      "head_type": "relatedConceptInterpretation",
      "relation": "associated_with",
      "tail": "DTDs",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "relatedConceptInterpretation",
      "head_type": "relatedConceptInterpretation",
      "relation": "associated_with",
      "tail": "external entities",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils#createDefensiveInputFactory()",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "designPrincipleInterpretation",
      "head_type": "designPrincipleInterpretation",
      "relation": "associated_with",
      "tail": "defensive setup",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils#createDefensiveInputFactory()",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamReader",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getEncoding()",
      "tail_type": "apiFunction"
    },
    {
      "head": "getEncoding()",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "getEncoding() returns null",
      "tail_type": "useSampleCode"
    },
    {
      "head": "getEncoding()",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "Always returns null",
      "tail_type": "useConstraint"
    },
    {
      "head": "getEncoding()",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "Used to retrieve the encoding of the XML stream",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "getEncoding()",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "Follows the XML specification for encoding retrieval",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamReader#getAttributeType(int)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getAttributeType",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamReader#getAttributeType(int)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.XMLEventStreamReader",
      "tail_type": "class"
    },
    {
      "head": "getAttributeType",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "org.springframework.util.xml.XMLEventStreamReader#getAttributeType(int)",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamReader#getAttributeType(int)",
      "head_type": "method",
      "relation": "have",
      "tail": "package com.example.xml; import org.springframework.util.xml.XMLEventStreamReader; public class XMLProcessing { public static void main(String[] args) { XMLEventStreamReader reader = new XMLEventStreamReader(); String attributeType = reader.getAttributeType(0); System.out.println(attributeType); } }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter#writeEndElement()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "writeEndElement",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter#writeEndElement()",
      "head_type": "method",
      "relation": "have",
      "tail": "closeEmptyElementIfNecessary()",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter#writeEndElement()",
      "head_type": "method",
      "relation": "have",
      "tail": "this.endElements.remove(last)",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter#writeEndElement()",
      "head_type": "method",
      "relation": "have",
      "tail": "this.eventWriter.add(lastEndElement)",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter#writeEndElement()",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter#writeEndElement()",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "writeEndElement",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "XMLStreamException",
      "tail_type": "useConstraint"
    },
    {
      "head": "writeEndElement",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "org.springframework.util.xml.XMLEventStreamWriter",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter#writeEndElement()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.XMLEventStreamWriter",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.core.task.VirtualThreadDelegate#virtualThreadFactory()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "ThreadFactory Provision",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.core.task.VirtualThreadDelegate#virtualThreadFactory()",
      "head_type": "method",
      "relation": "have",
      "tail": "Delegates thread creation to a thread builder.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.core.task.VirtualThreadDelegate#virtualThreadFactory()",
      "head_type": "method",
      "relation": "have",
      "tail": "public ThreadFactory virtualThreadFactory() {\n    return this.threadBuilder.factory();\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.core.task.VirtualThreadDelegate",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.core.task.VirtualThreadDelegate#virtualThreadFactory()",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#isAccessibleWhenProtectedVisibilityInSamePackage()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "Access Control Test",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#isAccessibleWhenProtectedVisibilityInSamePackage()",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.aot.generate.AccessControlTests",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#isAccessibleWhenProtectedVisibilityInSamePackage()",
      "head_type": "method",
      "relation": "have",
      "tail": "Sample Code for Access Control Test",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#isAccessibleWhenProtectedVisibilityInSamePackage()",
      "head_type": "method",
      "relation": "have",
      "tail": "Related Concept Interpretation for Access Control",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#isAccessibleWhenProtectedVisibilityInSamePackage()",
      "head_type": "method",
      "relation": "have",
      "tail": "Design Principle Interpretation for Access Control",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.SelfReference",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getThis() method",
      "tail_type": "apiFunction"
    },
    {
      "head": "getThis() method",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "Self-referencing within a class",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "getThis() method",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "Type casting for self-reference",
      "tail_type": "useSampleCode"
    },
    {
      "head": "getThis() method",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "Avoiding unchecked warnings",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.ClassNameGeneratorTests#generateClassNameWithNoTextFeatureNamePrefix()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "generateClassNameWithNoTextFeatureNamePrefix",
      "tail_type": "apiFunction"
    },
    {
      "head": "generateClassNameWithNoTextFeatureNamePrefix",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "generateClassNameWithNoTextFeatureNamePrefixSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "generateClassNameWithNoTextFeatureNamePrefixSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "generateClassNameWithNoTextFeatureNamePrefixSampleCodeContent",
      "tail_type": "content"
    },
    {
      "head": "generateClassNameWithNoTextFeatureNamePrefix",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "generateClassNameWithNoTextFeatureNamePrefixRelatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "generateClassNameWithNoTextFeatureNamePrefixRelatedConceptInterpretation",
      "head_type": "relatedConceptInterpretation",
      "relation": "have",
      "tail": "generateClassNameWithNoTextFeatureNamePrefixRelatedConceptInterpretationContent",
      "tail_type": "content"
    },
    {
      "head": "generateClassNameWithNoTextFeatureNamePrefix",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "generateClassNameWithNoTextFeatureNamePrefixDesignPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "generateClassNameWithNoTextFeatureNamePrefixDesignPrincipleInterpretation",
      "head_type": "designPrincipleInterpretation",
      "relation": "have",
      "tail": "generateClassNameWithNoTextFeatureNamePrefixDesignPrincipleInterpretationContent",
      "tail_type": "content"
    },
    {
      "head": "org.springframework.aot.generate.ClassNameGeneratorTests#generateClassNameWithClassWhenInnerClassGeneratesName()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "generateClassNameWithClassWhenInnerClassGeneratesName",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.ClassNameGeneratorTests#generateClassNameWithClassWhenInnerClassGeneratesName()",
      "head_type": "method",
      "relation": "have",
      "tail": "generateClassNameWithClassWhenInnerClassGeneratesName_useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "generateClassNameWithClassWhenInnerClassGeneratesName_useSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "generateClassNameWithClassWhenInnerClassGeneratesName_sampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#createWithClassNameAndStringCreateMethodReference()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "create method reference",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#createWithClassNameAndStringCreateMethodReference()",
      "head_type": "method",
      "relation": "have",
      "tail": "create method reference sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "create method reference sample code",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "create method reference sample code content",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.DefaultMethodReferenceTests#createWithClassNameAndStringCreateMethodReference()",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassesTests#addForFeatureComponentWhenFeatureNameIsEmptyThrowsException()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "addForFeatureComponent",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassesTests#addForFeatureComponentWhenFeatureNameIsEmptyThrowsException()",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "featureNameMustNotBeEmpty",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassesTests#addForFeatureComponentWhenFeatureNameIsEmptyThrowsException()",
      "head_type": "method",
      "relation": "have",
      "tail": "addForFeatureComponentWhenFeatureNameIsEmptyThrowsExceptionSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "addForFeatureComponentWhenFeatureNameIsEmptyThrowsExceptionSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "org.springframework.aot.generate.GeneratedClassesTests",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassesTests#addForFeatureComponentWhenFeatureNameIsEmptyThrowsException()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.GeneratedClassesTests",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.PackagePrivateClass",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "constructor",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.PackagePrivateClass",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "stringBean",
      "tail_type": "apiFunction"
    },
    {
      "head": "stringBean",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "public String stringBean() { return \"public\"; }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.PrimitiveTests#generateWhenFloat()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "generateCode",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.PrimitiveTests#generateWhenFloat()",
      "head_type": "method",
      "relation": "have",
      "tail": "generateWhenFloatSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "generateWhenFloatSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "org.springframework.aot.generate.PrimitiveTests",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.PrimitiveTests#testEscaped(char,String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "generateCode",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.PrimitiveTests#testEscaped(char,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "generateCode sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "generateCode sample code",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "generateCode sample code content",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.ResolvableTypeTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "generateWhenSimpleResolvableType",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.ResolvableTypeTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "generateWhenNoneResolvableType",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.ResolvableTypeTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "generateWhenGenericResolvableType",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.ResolvableTypeTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "generateWhenNestedGenericResolvableType",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.ResolvableTypeTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "generateWhenUnresolvedGenericType",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.ResolvableTypeTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "generateWhenUnresolvedNestedGenericType",
      "tail_type": "apiFunction"
    },
    {
      "head": "generateWhenSimpleResolvableType",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "generateWhenNoneResolvableType",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "generateWhenGenericResolvableType",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "generateWhenNestedGenericResolvableType",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "generateWhenUnresolvedGenericType",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "generateWhenUnresolvedNestedGenericType",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.ResolvableTypeTests",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "SampleTypes",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.core.type.StandardMethodMetadata",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "introspection",
      "tail_type": "apiFunction"
    },
    {
      "head": "introspection",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "method analysis",
      "tail_type": "useScenario"
    },
    {
      "head": "introspection",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "method analysis",
      "tail_type": "useScenario"
    },
    {
      "head": "introspection",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "org.springframework.core.type.StandardMethodMetadata",
      "tail_type": "class"
    },
    {
      "head": "introspection",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "method introspection",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "introspection",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "design for introspection",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "introspection",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "sample code for introspection",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.core.type.StandardMethodMetadata",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "introspection",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.core.type.StandardMethodMetadata",
      "head_type": "class",
      "relation": "have",
      "tail": "sample code for StandardMethodMetadata",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.core.type.StandardMethodMetadata",
      "head_type": "class",
      "relation": "have",
      "tail": "StandardMethodMetadata class design",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.core.type.StandardMethodMetadata",
      "head_type": "class",
      "relation": "have",
      "tail": "StandardMethodMetadata related concepts",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.objenesis(SpringObjenesis#newInstance(Class<T>))",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "instance creation",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.objenesis(SpringObjenesis#newInstance(Class<T>))",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is used to create a new instance of a given class.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.objenesis(SpringObjenesis#newInstance(Class<T>))",
      "head_type": "method",
      "relation": "have",
      "tail": "This method utilizes a instantiator to create a new instance of the specified class.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.objenesis(SpringObjenesis#newInstance(Class<T>))",
      "head_type": "method",
      "relation": "have",
      "tail": "public <T> T newInstance(Class<T> clazz) {\n    return getInstantiatorOf(clazz).newInstance();\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#doMatch(String,String,boolean,Map<String,String>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "pattern matching",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#doMatch(String,String,boolean,Map<String,String>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "path and pattern must start with the same separator",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#doMatch(String,String,boolean,Map<String,String>)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "matching URL paths against patterns",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#doMatch(String,String,boolean,Map<String,String>)",
      "head_type": "method",
      "relation": "have",
      "tail": "complete sample code for matching URL paths",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#doMatch(String,String,boolean,Map<String,String>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.AntPathMatcher",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#doMatch(String,String,boolean,Map<String,String>)",
      "head_type": "method",
      "relation": "have",
      "tail": "interpretation of related concepts like pattern matching and URL routing",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#doMatch(String,String,boolean,Map<String,String>)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principles behind the AntPathMatcher",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#matchStrings(String,String,Map<String,String>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "string matching",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#matchStrings(String,String,Map<String,String>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "null input prohibition",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#matchStrings(String,String,Map<String,String>)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "pattern matching",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#matchStrings(String,String,Map<String,String>)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#matchStrings(String,String,Map<String,String>)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#matchStrings(String,String,Map<String,String>)",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "relatedConceptInterpretation",
      "head_type": "relatedConceptInterpretation",
      "relation": "associated_with",
      "tail": "pattern matching",
      "tail_type": "useScenario"
    },
    {
      "head": "designPrincipleInterpretation",
      "head_type": "designPrincipleInterpretation",
      "relation": "associated_with",
      "tail": "string matching",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.Assert#hasLength(String,String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "assertStringNotEmpty",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.Assert#hasLength(String,String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "nullInputNotAllowed",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.Assert#hasLength(String,String)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "stringValidation",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.Assert#hasLength(String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "stringValidationSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.Assert#hasLength(String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "stringValidationConcept",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.Assert#hasLength(String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleForStringValidation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.Assert#hasLength(String,String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "StringUtils#hasLength",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.Assert#notEmpty(Object[],Supplier<String>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "assertArrayNotEmpty",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.Assert#notEmpty(Object[],Supplier<String>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "nullOrEmptyArrayCheck",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.Assert#notEmpty(Object[],Supplier<String>)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "arrayValidation",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.Assert#notEmpty(Object[],Supplier<String>)",
      "head_type": "method",
      "relation": "have",
      "tail": "arrayValidationSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.Assert#notEmpty(Object[],Supplier<String>)",
      "head_type": "method",
      "relation": "have",
      "tail": "arrayValidationConcept",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.Assert#notEmpty(Object[],Supplier<String>)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleForArrayValidation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.Assert#notEmpty(Object[],Supplier<String>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.Assert",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.Assert#nullSafeGet(Supplier<String>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "nullSafeRetrieval",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.Assert#nullSafeGet(Supplier<String>)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method safely retrieves a value from a Supplier, returning null if the Supplier itself is null.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.Assert#nullSafeGet(Supplier<String>)",
      "head_type": "method",
      "relation": "have",
      "tail": "The design principle here is to provide a utility method that can handle null suppliers without throwing a NullPointerException, enhancing code robustness.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.Assert#nullSafeGet(Supplier<String>)",
      "head_type": "method",
      "relation": "have",
      "tail": "package com.example.util;\n\nimport java.util.function.Supplier;\n\npublic class AssertExample {\n    public static void main(String[] args) {\n        Supplier<String> messageSupplier = () -> \"Hello, World!\";\n        String result = Assert.nullSafeGet(messageSupplier);\n        System.out.println(result);\n        \n        result = Assert.nullSafeGet(null);\n        System.out.println(result);\n    }\n}\n",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ClassUtils",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "lazy loading",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ClassUtils",
      "head_type": "class",
      "relation": "constrained_by",
      "tail": "circular aliases are prohibited",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ClassUtils",
      "head_type": "class",
      "relation": "applied_to",
      "tail": "multiple aliases for a single name",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ClassUtils",
      "head_type": "class",
      "relation": "have",
      "tail": "package com.healthMgr.common.email; import java.xxxx; public class OneClass { // specific code }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ClassUtils",
      "head_type": "class",
      "relation": "have",
      "tail": "org.springframework.core.SimpleAliasRegistryTests",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.ClassUtils",
      "head_type": "class",
      "relation": "have",
      "tail": "lazy loading",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils",
      "head_type": "class",
      "relation": "have",
      "tail": "design principles of the class or method",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.core.SimpleAliasRegistryTests",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.ClassUtils#isAssignable(Class<?>,Class<?>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "type assignability check",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ClassUtils#isAssignable(Class<?>,Class<?>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "non-null types",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ClassUtils#isAssignable(Class<?>,Class<?>)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "reflection-based type assignment",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ClassUtils#isAssignable(Class<?>,Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.ClassUtils#isAssignable(Class<?>,Class<?>) sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ClassUtils#isAssignable(Class<?>,Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "related concept interpretation for isAssignable",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#isAssignable(Class<?>,Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle interpretation for isAssignable",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#isAssignable(Class<?>,Class<?>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "TypeUtils#isAssignable(java.lang.reflect.Type, java.lang.reflect.Type)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.ClassUtils#addResourcePathToPackagePath(Class<?>,String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "building a resource path",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ClassUtils#addResourcePathToPackagePath(Class<?>,String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "resource name must not be null",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ClassUtils#addResourcePathToPackagePath(Class<?>,String)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "loading a resource file in the same package as a class file",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ClassUtils#addResourcePathToPackagePath(Class<?>,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "Return a path suitable for use with ClassLoader.getResource or Class.getResource",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ClassUtils#addResourcePathToPackagePath(Class<?>,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is used to build a path for loading resources that are located in the same package as a given class file.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#addResourcePathToPackagePath(Class<?>,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "The design principle behind this method is to provide a convenient way to reference resources that are co-located with a class in the classpath.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#addResourcePathToPackagePath(Class<?>,String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.core.io.ClassPathResource",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.ClassUtils#getAllInterfacesForClass(Class<?>,ClassLoader)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getAllInterfacesForClass",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ClassUtils#getAllInterfacesForClass(Class<?>,ClassLoader)",
      "head_type": "method",
      "relation": "have",
      "tail": "Return all interfaces that the given class implements as an array, including ones implemented by superclasses.",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ClassUtils#getAllInterfacesForClass(Class<?>,ClassLoader)",
      "head_type": "method",
      "relation": "have",
      "tail": "If the class itself is an interface, it gets returned as sole interface.",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ClassUtils#getAllInterfacesForClass(Class<?>,ClassLoader)",
      "head_type": "method",
      "relation": "have",
      "tail": "The method should be used when you need to analyze a class for all the interfaces it implements, including those implemented by its superclasses.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#getAllInterfacesForClass(Class<?>,ClassLoader)",
      "head_type": "method",
      "relation": "have",
      "tail": "The design principle followed here is to provide a comprehensive list of interfaces for a given class, ensuring that all interfaces, including those from superclasses, are considered.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "getAllInterfacesForClass",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "org.springframework.util.ClassUtils",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.ClassUtils#isCglibProxyClassName(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "Check whether the specified class name is a CGLIB-generated class",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ClassUtils#isCglibProxyClassName(String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "deprecated as of 5.2, in favor of custom (possibly narrower) checks or simply a check for containing CGLIB_CLASS_SEPARATOR",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ClassUtils#isCglibProxyClassName(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "Check whether the specified class name is a CGLIB-generated class. @param className the class name to check @see CGLIB_CLASS_SEPARATOR @deprecated as of 5.2, in favor of custom (possibly narrower) checks or simply a check for containing CGLIB_CLASS_SEPARATOR",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#isCglibProxyClassName(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "public static boolean isCglibProxyClassName(@Nullable String className) { return (className != null && className.contains(CGLIB_CLASS_SEPARATOR)); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ClassUtils#matchesTypeName(Class<?>,String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "matchesTypeName",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ClassUtils#matchesTypeName(Class<?>,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "Check whether the given class matches the user-specified type name.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#matchesTypeName(Class<?>,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "public static boolean matchesTypeName(Class<?> clazz, @Nullable String typeName) { return (typeName != null && (typeName.equals(clazz.getTypeName()) || typeName.equals(clazz.getSimpleName()))); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "matchesTypeName",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "class type matching",
      "tail_type": "useScenario"
    },
    {
      "head": "matchesTypeName",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "typeName must not be null",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ConcurrentLruCache#clear()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "remove all entries from this cache",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ConcurrentLruCache#clear()",
      "head_type": "method",
      "relation": "have",
      "tail": "Immediately remove all entries from this cache",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ConcurrentLruCache#clear()",
      "head_type": "method",
      "relation": "have",
      "tail": "The clear() method is used to immediately remove all entries from the cache. It ensures that the cache is emptied by removing each entry one by one and then clearing the read and write operations. This method is typically used when there is a need to reset the cache state, for example, when the cached data is no longer valid or when the application is shutting down.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ConcurrentLruCache#clear()",
      "head_type": "method",
      "relation": "have",
      "tail": "The design principle behind the clear() method is to provide a mechanism to reset the cache state in a controlled manner. This method ensures that all entries are removed and that any ongoing read or write operations are completed before the cache is cleared. This design principle is important for maintaining the consistency and integrity of the cached data.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ConcurrentReferenceHashMap#getOrDefault(Object,V)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getOrDefault",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ConcurrentReferenceHashMap#getOrDefault(Object,V)",
      "head_type": "method",
      "relation": "have",
      "tail": "getOrDefault allows retrieval of a value for a given key, or a default value if the key is not present",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ConcurrentReferenceHashMap#getOrDefault(Object,V)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is designed to be thread-safe, ensuring that concurrent access does not cause inconsistencies",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ConcurrentReferenceHashMap#getOrDefault(Object,V)",
      "head_type": "method",
      "relation": "have",
      "tail": "public V getOrDefault(@Nullable Object key, @Nullable V defaultValue) {\n    Reference<K, V> ref = getReference(key, Restructure.WHEN_NECESSARY);\n    Entry<K, V> entry = (ref != null ? ref.get() : null);\n    return (entry != null ? entry.getValue() : defaultValue);\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ConcurrentReferenceHashMap#getReference(Object,Restructure)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "reference retrieval",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ConcurrentReferenceHashMap#getReference(Object,Restructure)",
      "head_type": "method",
      "relation": "have",
      "tail": "reference retrieval explanation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "reference retrieval explanation",
      "head_type": "relatedConceptInterpretation",
      "relation": "associated_with",
      "tail": "ConcurrentReferenceHashMap",
      "tail_type": "class"
    },
    {
      "head": "ConcurrentReferenceHashMap",
      "head_type": "class",
      "relation": "designPrincipleInterpretation",
      "tail": "thread-safe reference management",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ConcurrentReferenceHashMap#getReference(Object,Restructure)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for reference retrieval",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.Segment#clear()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "clear all items from this segment",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.Segment#clear()",
      "head_type": "method",
      "relation": "have",
      "tail": "Clear all items from this segment.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.Segment#clear()",
      "head_type": "method",
      "relation": "have",
      "tail": "package com.example.util;\n\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class Segment {\n    private Object[] references;\n    private int resizeThreshold;\n    private final Lock lock = new ReentrantLock();\n\n    public void clear() {\n        if (this.count.get() == 0) {\n            return;\n        }\n        lock.lock();\n        try {\n            this.references = createReferenceArray(this.initialSize);\n            this.resizeThreshold = (int) (this.references.length * getLoadFactor());\n            this.count.set(0);\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    private Object[] createReferenceArray(int size) {\n        return new Object[size];\n    }\n\n    private double getLoadFactor() {\n        return 0.75;\n    }\n\n    private int initialSize = 16;\n    private ThreadLocalInt count = new ThreadLocalInt();\n\n    private static class ThreadLocalInt {\n        private int value;\n\n        public int get() {\n            return value;\n        }\n\n        public void set(int value) {\n            this.value = value;\n        }\n    }\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.EntrySet",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "iterator",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.EntrySet",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "contains",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.EntrySet",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "remove",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.EntrySet",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "size",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.EntrySet",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "clear",
      "tail_type": "apiFunction"
    },
    {
      "head": "contains",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "o must be an instance of Map.Entry",
      "tail_type": "useConstraint"
    },
    {
      "head": "remove",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "o must be an instance of Map.Entry",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.EntrySet",
      "head_type": "class",
      "relation": "have",
      "tail": "Internal entry-set implementation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.EntryIterator#moveToNextSegment()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "moveToNextSegment",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.EntryIterator#moveToNextSegment()",
      "head_type": "method",
      "relation": "have",
      "tail": "private void moveToNextSegment() {    this.reference = null;    this.references = null;    if (this.segmentIndex < ConcurrentReferenceHashMap.this.segments.length) {        this.references = ConcurrentReferenceHashMap.this.segments[this.segmentIndex].references;        this.segmentIndex++;    }}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.EntryIterator#moveToNextSegment()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "ConcurrentReferenceHashMap",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.ReferenceManager#pollForPurge()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "referencePurging",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ReferenceManager#pollForPurge()",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "threadSafety",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ReferenceManager#pollForPurge()",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "garbageCollectedReferenceRetrieval",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ReferenceManager#pollForPurge()",
      "head_type": "method",
      "relation": "have",
      "tail": "returnNullWhenNoPurgeNeeded",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ReferenceManager#pollForPurge()",
      "head_type": "method",
      "relation": "have",
      "tail": "threadSafeAndNonBlocking",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ReferenceManager#pollForPurge()",
      "head_type": "method",
      "relation": "have",
      "tail": "referenceReturnedOnce",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ReferenceManager#pollForPurge()",
      "head_type": "method",
      "relation": "have",
      "tail": "java.lang.ref.Reference",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.ReferenceManager#pollForPurge()",
      "head_type": "method",
      "relation": "have",
      "tail": "java.util.concurrent.ConcurrentLinkedQueue",
      "tail_type": "class"
    },
    {
      "head": "referencePurging",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "org.springframework.util.ReferenceManager#pollForPurge()",
      "tail_type": "useSampleCode"
    },
    {
      "head": "garbageCollectedReferenceRetrieval",
      "head_type": "useScenario",
      "relation": "have",
      "tail": "org.springframework.util.ReferenceManager#pollForPurge()",
      "tail_type": "useSampleCode"
    },
    {
      "head": "returnNullWhenNoPurgeNeeded",
      "head_type": "useScenario",
      "relation": "have",
      "tail": "org.springframework.util.ReferenceManager#pollForPurge()",
      "tail_type": "useSampleCode"
    },
    {
      "head": "threadSafeAndNonBlocking",
      "head_type": "useConstraint",
      "relation": "have",
      "tail": "ensures that the method can be safely called from multiple threads without causing deadlocks or excessive blocking.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "referenceReturnedOnce",
      "head_type": "useConstraint",
      "relation": "have",
      "tail": "guarantees that each reference is returned exactly once to avoid duplicate processing.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "java.lang.ref.Reference",
      "head_type": "class",
      "relation": "have",
      "tail": "represents a reference object that is used to manage the lifecycle of objects with respect to garbage collection.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "java.util.concurrent.ConcurrentLinkedQueue",
      "head_type": "class",
      "relation": "have",
      "tail": "a thread-safe queue that is used to store references that are eligible for purging.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ReferenceManager#pollForPurge()",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "designPrincipleInterpretation",
      "head_type": "designPrincipleInterpretation",
      "relation": "have",
      "tail": "The method follows the principle of least astonishment by providing a simple and predictable interface for purging references. It is designed to be thread-safe to ensure that it can be used concurrently without issues. The use of a concurrent queue ensures that references are handled efficiently and that the method can return quickly when there are no references to purge.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.DigestUtils#md5Digest(InputStream)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "Calculate the MD5 digest of the given stream",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.DigestUtils#md5Digest(InputStream)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "This method does not close the input stream",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.DigestUtils#md5Digest(InputStream)",
      "head_type": "method",
      "relation": "have",
      "tail": "Calculate the MD5 digest of the given stream",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.DigestUtils#md5Digest(InputStream)",
      "head_type": "method",
      "relation": "have",
      "tail": "public static byte[] md5Digest(InputStream inputStream) throws IOException {\n    return digest(MD5_ALGORITHM_NAME, inputStream);\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.DigestUtils#md5Digest(InputStream)",
      "head_type": "method",
      "relation": "have",
      "tail": "The MD5 digest is a widely used hash function that produces a 128-bit hash value.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.DigestUtils#md5Digest(InputStream)",
      "head_type": "method",
      "relation": "have",
      "tail": "The design principle behind this method is to provide a convenient way to calculate the MD5 digest for an input stream without closing it.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.DigestUtils#digestAsHexString(String,InputStream)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "hashing",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.DigestUtils#digestAsHexString(String,InputStream)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "string conversion",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.DigestUtils#digestAsHexString(String,InputStream)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "input stream processing",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.DigestUtils#digestAsHexString(String,InputStream)",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "useSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "private static String digestAsHexString(String algorithm, InputStream inputStream) throws IOException {\n    char[] hexDigest = digestAsHexChars(algorithm, inputStream);\n    return new String(hexDigest);\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.DigestUtils#digestAsHexString(String,InputStream)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "relatedConceptInterpretation",
      "head_type": "relatedConceptInterpretation",
      "relation": "have",
      "tail": "Hashing is the process of converting data into a fixed-size string of characters, usually for the purpose of storing passwords or data integrity verification. The method `digestAsHexString` specifically converts an input stream into a hexadecimal string representation using a specified algorithm. This is commonly used in security applications to ensure data integrity and for cryptographic purposes.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.DigestUtils#digestAsHexString(String,InputStream)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "designPrincipleInterpretation",
      "head_type": "designPrincipleInterpretation",
      "relation": "have",
      "tail": "The design principle behind `digestAsHexString` is to provide a utility method for converting binary data into a human-readable hexadecimal string format. This method abstracts the complexity of hashing algorithms and character encoding, making it easier for developers to implement secure hashing in their applications. It follows the principle of separation of concerns by focusing solely on the conversion logic, which enhances code reusability and maintainability.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.FastByteArrayOutputStream#size()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "return the number of bytes stored",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.FastByteArrayOutputStream#size()",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for using FastByteArrayOutputStream#size()",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.FastByteArrayOutputStream#size()",
      "head_type": "method",
      "relation": "have",
      "tail": "interpretation of related concepts for FastByteArrayOutputStream#size()",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.FastByteArrayOutputStream#size()",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle interpretation for FastByteArrayOutputStream#size()",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.FastByteArrayOutputStream#size()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.FastByteArrayOutputStream",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.FastByteArrayOutputStream#reset()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "reset contents of FastByteArrayOutputStream",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.FastByteArrayOutputStream#reset()",
      "head_type": "method",
      "relation": "have",
      "tail": "Reset the contents of this `FastByteArrayOutputStream`.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.FastByteArrayOutputStream#reset()",
      "head_type": "method",
      "relation": "have",
      "tail": "All currently accumulated output in the output stream is discarded. The output stream can be used again.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.FastByteArrayOutputStream#reset()",
      "head_type": "method",
      "relation": "have",
      "tail": "java\npackage org.springframework.util;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class FastByteArrayOutputStream extends ByteArrayOutputStream {\n\n    private List<byte[]> buffers = new ArrayList<>();\n    private int nextBlockSize;\n    private int initialBlockSize;\n    private boolean closed;\n    private int index;\n    private int alreadyBufferedSize;\n\n    public FastByteArrayOutputStream(int initialBlockSize) {\n        this.initialBlockSize = initialBlockSize;\n        this.nextBlockSize = initialBlockSize;\n    }\n\n    @Override\n    public void reset() {\n        this.buffers.clear();\n        this.nextBlockSize = this.initialBlockSize;\n        this.closed = false;\n        this.index = 0;\n        this.alreadyBufferedSize = 0;\n    }\n\n    // Other methods and logic\n}\n",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.LinkedCaseInsensitiveMap#clone()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "clone",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.LinkedCaseInsensitiveMap#clone()",
      "head_type": "method",
      "relation": "have",
      "tail": "create a shallow copy of the map",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.LinkedCaseInsensitiveMap#clone()",
      "head_type": "method",
      "relation": "have",
      "tail": "override the clone method from Object class",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.LinkedCaseInsensitiveMap#clone()",
      "head_type": "method",
      "relation": "have",
      "tail": "LinkedCaseInsensitiveMap",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.Values#clear()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "clearing contents",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.Values#clear()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "LinkedCaseInsensitiveMap",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.Values#clear()",
      "head_type": "method",
      "relation": "have",
      "tail": "This method clears the contents of the associated LinkedCaseInsensitiveMap instance.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.Values#clear()",
      "head_type": "method",
      "relation": "have",
      "tail": "The design principle behind this method is to provide a straightforward way to reset the state of the map, ensuring that all entries are removed efficiently.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.Values#clear()",
      "head_type": "method",
      "relation": "have",
      "tail": "package org.springframework.util;\n\nimport java.util.LinkedHashMap;\nimport java.util.Map;\n\npublic class Values {\n    private Map<String, Object> map = new LinkedCaseInsensitiveMap<>();\n\n    public void clear() {\n        map.clear();\n    }\n\n    // Additional methods and logic\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.EntryIterator",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "iterate over entries",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.EntryIterator",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "remove entries",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.EntryIterator",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "handle case-insensitive keys",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.EntryIterator",
      "head_type": "class",
      "relation": "have",
      "tail": "private final Iterator<Entry<String, V>> delegate;",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.EntryIterator",
      "head_type": "class",
      "relation": "have",
      "tail": "Entry<String, V> last",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.EntryIterator",
      "head_type": "class",
      "relation": "have",
      "tail": "public EntryIterator() { this.delegate = targetMap.entrySet().iterator(); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.EntryIterator",
      "head_type": "class",
      "relation": "have",
      "tail": "protected Entry<String, V> nextEntry() { Entry<String, V> entry = this.delegate.next(); this.last = entry; return entry; }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.EntryIterator",
      "head_type": "class",
      "relation": "have",
      "tail": "@Override public boolean hasNext() { return this.delegate.hasNext(); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.EntryIterator",
      "head_type": "class",
      "relation": "have",
      "tail": "@Override public void remove() { this.delegate.remove(); if (this.last != null) { removeCaseInsensitiveKey(this.last.getKey()); this.last = null; } }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.EntryIterator",
      "head_type": "class",
      "relation": "have",
      "tail": "Iterator pattern",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.EntryIterator",
      "head_type": "class",
      "relation": "have",
      "tail": "Encapsulation of iteration logic",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.MimeType#checkToken(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "checkToken",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MimeType#checkToken(String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "IllegalArgumentException",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.MimeType#checkToken(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "https://tools.ietf.org/html/rfc2616#section-2.2",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.MimeType#checkToken(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "Checks the given token string for illegal characters, as defined in RFC 2616, section 2.2.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.MimeType#checkToken(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "package org.springframework.util;\n\nimport java.util.BitSet;\n\npublic class MimeType {\n    private static final BitSet TOKEN = createTokenSet();\n\n    private static BitSet createTokenSet() {\n        BitSet set = new BitSet(128);\n        // Fill the BitSet with allowed token characters as per RFC 2616, section 2.2\n        // Example characters are added here\n        set.set('a');\n        set.set('b');\n        // Add all allowed characters\n        return set;\n    }\n\n    private void checkToken(String token) {\n        for (int i = 0; i < token.length(); i++) {\n            char ch = token.charAt(i);\n            if (!TOKEN.get(ch)) {\n                throw new IllegalArgumentException(\"Invalid token character '\" + ch + \"' in token \\\"\" + token + \"\\\"\");\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        MimeType mimeType = new MimeType();\n        mimeType.checkToken(\"exampleToken\");\n        System.out.println(\"Token is valid.\");\n    }\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ObjectUtils#unwrapOptional(Object)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "unwrapOptional",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ObjectUtils#unwrapOptional(Object)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "Multi-level Optional usage not supported",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ObjectUtils#unwrapOptional(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "Unwrap the given object which is potentially a java.util.Optional",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "unwrapOptional",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "Unwrap the given object which is potentially a java.util.Optional",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "unwrapOptional",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "public static Object unwrapOptional(@Nullable Object obj) { if (obj instanceof Optional<?> optional) { Object result = optional.orElse(null); Assert.isTrue(!(result instanceof Optional), \"Multi-level Optional usage not supported\"); return result; } return obj; }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.PathMatcher#extractPathWithinPattern(String,String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "pattern matching",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.PathMatcher#extractPathWithinPattern(String,String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "pattern must contain dynamic parts",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.PathMatcher#extractPathWithinPattern(String,String)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "web path extraction",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.PathMatcher#extractPathWithinPattern(String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "extracts dynamic part of a path based on a pattern",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.PathMatcher#extractPathWithinPattern(String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "design follows strategy pattern for path matching",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.PathMatcher#extractPathWithinPattern(String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "public String extractPathWithinPattern(String pattern, String path) {\n    // Example implementation\n    if (pattern.contains(\"*\")) {\n        int startIndex = path.indexOf(pattern.substring(0, pattern.indexOf(\"*\")));\n        if (startIndex != -1) {\n            return path.substring(startIndex + pattern.substring(0, pattern.indexOf(\"*\")).length());\n        }\n    }\n    return \"\";\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.PartResolutionContext#toPlaceholderText(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "string manipulation",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.PartResolutionContext#toPlaceholderText(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "private String toPlaceholderText(String text) { return this.prefix + text + this.suffix; }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.PartResolutionContext#toPlaceholderText(String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.PartResolutionContext",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.AbstractPart#resolveRecursively(PartResolutionContext,String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "resolve placeholders recursively",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.AbstractPart#resolveRecursively(PartResolutionContext,String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "placeholder must have a value",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.AbstractPart#resolveRecursively(PartResolutionContext,String)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "resolving nested placeholders",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.AbstractPart#resolveRecursively(PartResolutionContext,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.AbstractPart",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.AbstractPart#resolveRecursively(PartResolutionContext,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "resolving placeholders recursively sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.AbstractPart#resolveRecursively(PartResolutionContext,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "related concept interpretation for resolving placeholders",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.AbstractPart#resolveRecursively(PartResolutionContext,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle interpretation for resolving placeholders",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "resolve placeholders recursively",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "org.springframework.util.AbstractPart#resolveRecursively(PartResolutionContext,String)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.AbstractPart",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.AbstractPart#resolveRecursively(PartResolutionContext,String)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.NestedPlaceholderPart",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "resolve",
      "tail_type": "apiFunction"
    },
    {
      "head": "resolve",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "resolveRecursively",
      "tail_type": "useSampleCode"
    },
    {
      "head": "resolve",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "handleUnresolvablePlaceholder",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.NestedPlaceholderPart",
      "head_type": "class",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.NestedPlaceholderPart",
      "head_type": "class",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.PlaceholderResolutionException#getPlaceholder()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "return unresolvable placeholder",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.PlaceholderResolutionException#getPlaceholder()",
      "head_type": "method",
      "relation": "have",
      "tail": "Return the placeholder that could not be resolved.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.PlaceholderResolutionException#getPlaceholder()",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is used to retrieve the placeholder that failed to resolve.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.PlaceholderResolutionException#getPlaceholder()",
      "head_type": "method",
      "relation": "have",
      "tail": "public String getPlaceholder() {\n    return this.placeholder;\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#declaresException(Method,Class<?>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "exception declaration checking",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#declaresException(Method,Class<?>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "method and exception type must not be null",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#declaresException(Method,Class<?>)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "reflective invocation exception handling",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#declaresException(Method,Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for checking exception declaration",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#declaresException(Method,Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "exception propagation in reflective invocations",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#declaresException(Method,Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle for reflective exception handling",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "exception declaration checking",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "org.springframework.util.ReflectionUtils",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#setField(Field,Object,Object)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "setField",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#setField(Field,Object,Object)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "static final fields are not supported",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#setField(Field,Object,Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "Set the field represented by the supplied field object on the specified target object to the specified value.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#setField(Field,Object,Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "Automatically unwraps the new value if the underlying field has a primitive type.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#setField(Field,Object,Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "public static void setField(Field field, Object target, Object value) { try { field.set(target, value); } catch (IllegalAccessException ex) { handleReflectionException(ex); } }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ResourceUtils#extractJarFileURL(URL)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "extract the URL for the actual jar file",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ResourceUtils#extractJarFileURL(URL)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "URL must point to a resource in a jar file or to a jar file itself",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ResourceUtils#extractJarFileURL(URL)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "retrieving the actual jar file URL from a resource URL",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ResourceUtils#extractJarFileURL(URL)",
      "head_type": "method",
      "relation": "have",
      "tail": "public static URL extractJarFileURL(URL jarUrl) throws MalformedURLException { ... }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ResourceUtils#extractJarFileURL(URL)",
      "head_type": "method",
      "relation": "have",
      "tail": "related to extracting resources from jar files",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ResourceUtils#extractJarFileURL(URL)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle of handling resource URLs efficiently",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ResourceUtils#extractJarFileURL(URL)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.ResourceUtils",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.SingleToMultiValueMapAdapter#clear()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "clearing a map",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.SingleToMultiValueMapAdapter#clear()",
      "head_type": "method",
      "relation": "have",
      "tail": "public void clear() { this.targetMap.clear(); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.SingleToMultiValueMapAdapter#clear()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.SingleToMultiValueMapAdapter",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.SingleToMultiValueMapAdapter",
      "head_type": "class",
      "relation": "have",
      "tail": "Adapter for adapting a single-value map to a multi-value map.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.SingleToMultiValueMapAdapter",
      "head_type": "class",
      "relation": "have",
      "tail": "Design principle: Provide a convenient way to adapt a single-value map to a multi-value map without changing the underlying data structure.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.StringUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "isEmpty",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "hasLength",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "hasText",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "containsWhitespace",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "trimWhitespace",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "trimAllWhitespace",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "trimLeadingWhitespace",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "trimTrailingWhitespace",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "trimLeadingCharacter",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "trimTrailingCharacter",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "matchesCharacter",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "startsWithIgnoreCase",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "endsWithIgnoreCase",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "substringMatch",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "countOccurrencesOf",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "replace",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "delete",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "deleteAny",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "quote",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "quoteIfString",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "unqualify",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "capitalize",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "uncapitalize",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "uncapitalizeAsProperty",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "changeFirstCharacterCase",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "getFilename",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "getFilenameExtension",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "stripFilenameExtension",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "applyRelativePath",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "cleanPath",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "pathEquals",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "uriDecode",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "parseLocale",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "parseLocaleString",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "parseTimeZoneString",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "toStringArray",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "toStringArray",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "addStringToArray",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "concatenateStringArrays",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "sortStringArray",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "trimArrayElements",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "removeDuplicateStrings",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "split",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "splitArrayElementsIntoProperties",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "tokenizeToStringArray",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "tokenizeToStringArray",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "delimitedListToStringArray",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "delimitedListToStringArray",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "commaDelimitedListToStringArray",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "commaDelimitedListToSet",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "collectionToDelimitedString",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "collectionToDelimitedString",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "collectionToCommaDelimitedString",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "arrayToDelimitedString",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "arrayToCommaDelimitedString",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "truncate",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "truncate",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils#trimTrailingWhitespace(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "trimTrailingWhitespace",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils#trimTrailingWhitespace(String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "deprecated since 6.0",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.StringUtils#trimTrailingWhitespace(String)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "trimming trailing whitespace from a string",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.StringUtils#trimTrailingWhitespace(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for trimming trailing whitespace",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.StringUtils#trimTrailingWhitespace(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "interpretation of whitespace trimming",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.StringUtils#trimTrailingWhitespace(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle behind trimming whitespace",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.StringUtils#trimTrailingWhitespace(String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "java.lang.Character#isWhitespace",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.StringUtils#trimTrailingWhitespace(String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "String#stripTrailing()",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.StringUtils#delimitedListToStringArray(String,String,String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "convert a delimited list into a String array",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils#delimitedListToStringArray(String,String,String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "delimiter is a single string, not multiple characters",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.StringUtils#delimitedListToStringArray(String,String,String)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "input String is potentially null or empty",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.StringUtils#delimitedListToStringArray(String,String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "delete unwanted characters like new lines and line feeds",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.StringUtils#delimitedListToStringArray(String,String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "package org.springframework.util;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class StringUtils {\n    \n    public static String[] delimitedListToStringArray(String str, String delimiter, String charsToDelete) {\n        if (str == null) {\n            return new String[0];\n        }\n        if (delimiter == null) {\n            return new String[] { str };\n        }\n        List<String> result = new ArrayList<>();\n        if (delimiter.isEmpty()) {\n            for (int i = 0; i < str.length(); i++) {\n                result.add(deleteAny(str.substring(i, i + 1), charsToDelete));\n            }\n        } else {\n            int pos = 0;\n            int delPos;\n            while ((delPos = str.indexOf(delimiter, pos)) != -1) {\n                result.add(deleteAny(str.substring(pos, delPos), charsToDelete));\n                pos = delPos + delimiter.length();\n            }\n            if (!str.isEmpty() && pos <= str.length()) {\n                result.add(deleteAny(str.substring(pos), charsToDelete));\n            }\n        }\n        return result.toArray(new String[0]);\n    }\n    \n    private static String deleteAny(String str, String charsToDelete) {\n        if (str == null || charsToDelete == null) {\n            return str;\n        }\n        StringBuilder sb = new StringBuilder();\n        for (char c : str.toCharArray()) {\n            if (charsToDelete.indexOf(c) == -1) {\n                sb.append(c);\n            }\n        }\n        return sb.toString();\n    }\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.StringUtils#delimitedListToStringArray(String,String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is used to process strings that are structured as lists using a specific delimiter. It splits the input string based on the delimiter and returns an array of substrings. The method also allows for the removal of specific characters that might be unwanted in the output, such as line breaks.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.StringUtils#delimitedListToStringArray(String,String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "The design principle behind this method is to provide a utility for parsing and manipulating strings that represent lists. It encapsulates the logic for splitting strings and cleaning up unwanted characters, promoting code reuse and reducing the need for boilerplate string manipulation code in other parts of the application.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.StringUtils#delimitedListToStringArray(String,String,String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.StringUtils",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.StringUtils#truncate(CharSequence,int)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "truncate",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils#truncate(CharSequence,int)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "threshold must be a positive number",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.StringUtils#truncate(CharSequence,int)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "truncate a CharSequence",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.StringUtils#truncate(CharSequence,int)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for truncate method",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.StringUtils#truncate(CharSequence,int)",
      "head_type": "method",
      "relation": "have",
      "tail": "related concept interpretation for truncate method",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.StringUtils#truncate(CharSequence,int)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle interpretation for truncate method",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "truncate",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "org.springframework.util.StringUtils",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.unit.DataSize",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "representing the specified number of bytes",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.unit.DataSize",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "representing the specified number of kilobytes",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.unit.DataSize",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "representing the specified number of megabytes",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.unit.DataSize",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "representing the specified number of gigabytes",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.unit.DataSize",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "representing the specified number of terabytes",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.unit.DataSize",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "representing an amount in the specified DataUnit",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.unit.DataSize",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "parsing a text string to a DataSize",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.unit.DataSize",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "checking if the size is negative",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.unit.DataSize",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "returning the number of bytes",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.unit.DataSize",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "returning the number of kilobytes",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.unit.DataSize",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "returning the number of megabytes",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.unit.DataSize",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "returning the number of gigabytes",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.unit.DataSize",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "returning the number of terabytes",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.unit.DataSize",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "comparing DataSize instances",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.unit.DataSize",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "returning a string representation of DataSize",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.unit.DataSize",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "checking equality of DataSize instances",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.unit.DataSize",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "returning the hash code of DataSize",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.unit.DataSize",
      "head_type": "class",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.unit.DataSize",
      "head_type": "class",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.unit.DataSize",
      "head_type": "class",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#toString()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "toString()",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#toString()",
      "head_type": "method",
      "relation": "have",
      "tail": "Delegate method call to this.delegate.toString()",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#toString()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.UnmodifiableMultiValueMap",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#toString()",
      "head_type": "method",
      "relation": "have",
      "tail": "Delegates the toString operation to the underlying delegate object.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#toString()",
      "head_type": "method",
      "relation": "have",
      "tail": "Follows the principle of delegation for providing a unmodifiable view of the underlying map.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySet#equals(Object)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "equality check",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySet#equals(Object)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "nullability of other object",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySet#equals(Object)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "comparing sets for equality",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySet#equals(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySet#equals(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySet#equals(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySet#equals(Object)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.UnmodifiableEntrySet",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueCollection#toArray(T[])",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "convert array",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueCollection#toArray(T[])",
      "head_type": "method",
      "relation": "have",
      "tail": "convert array to specified type",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueCollection#toArray(T[])",
      "head_type": "method",
      "relation": "have",
      "tail": "public <T> T[] toArray(T[] a) { T[] result = this.delegate.toArray(a); filterArray(result); return result; }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueCollection#toArray(T[])",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.UnmodifiableValueCollection",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueCollection#equals(Object)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "equality check",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueCollection#equals(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.UnmodifiableValueCollection#equals(Object) sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueCollection#equals(Object) sample code",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "org.springframework.util.UnmodifiableValueCollection#equals(Object) code content",
      "tail_type": "codeContent"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#startElement(String,String,String,Attributes)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "startElement",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#startElement(String,String,String,Attributes)",
      "head_type": "method",
      "relation": "have",
      "tail": "startElementInternal(toQName(uri, qName), atts, currentNamespaceMapping()); newNamespaceMapping();",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#startElement(String,String,String,Attributes)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "SAXException",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#startElement(String,String,String,Attributes)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.AbstractStaxHandler",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#toQName(String,String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "Convert a namespace URI and DOM or SAX qualified name to a QName",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#toQName(String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "Convert a namespace URI and DOM or SAX qualified name to a QName",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#toQName(String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "The method toQName(String namespaceUri, String qualifiedName) converts a namespace URI and a qualified name (which can be in the form 'prefix:localname' or 'localName') to a QName instance. It checks if the qualified name contains a colon to determine if it has a prefix. If it does, it splits the qualified name into a prefix and a local part. It then creates and returns a new QName instance using the namespace URI, local part, and prefix.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#toQName(String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "The design principle behind the toQName method is to provide a utility for converting between string representations of XML names and the QName object model. This method is designed to be robust and handle both prefixed and non-prefixed names, making it flexible for various XML processing scenarios. It encapsulates the logic for parsing qualified names and constructing QName objects, abstracting this complexity from the client code.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.AbstractStaxHandler#toQName(String,String)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "Convert a namespace URI and DOM or SAX qualified name to a QName",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler",
      "head_type": "class",
      "relation": "have",
      "tail": "The class AbstractStaxHandler is designed to provide a base implementation for XML processing using the StAX API. It includes utility methods for common XML processing tasks, such as converting qualified names to QName objects. This class is intended to be subclassed by concrete XML handlers that need to implement specific XML processing logic.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler",
      "head_type": "class",
      "relation": "have",
      "tail": "The design principle behind the AbstractStaxHandler class is to abstract common XML processing tasks and provide a foundation for building more complex XML processing components. By encapsulating reusable functionality, such as the toQName method, it promotes code reuse and simplifies the development of XML processing applications. This class is designed to be extended, allowing developers to add application-specific logic while leveraging the provided utility methods.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#startDocumentInternal()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "startDocumentInternal",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#startDocumentInternal()",
      "head_type": "method",
      "relation": "have",
      "tail": "protected abstract void startDocumentInternal() throws XMLStreamException;",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLReader#setFeature(String,boolean)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "xmlFeatureHandling",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLReader#setFeature(String,boolean)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "namespaceConstraint",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLReader#setFeature(String,boolean)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "xmlFeatureConfiguration",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLReader#setFeature(String,boolean)",
      "head_type": "method",
      "relation": "have",
      "tail": "xmlFeatureConfigurationSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLReader#setFeature(String,boolean)",
      "head_type": "method",
      "relation": "have",
      "tail": "xmlFeatureConfigurationExplanation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLReader#setFeature(String,boolean)",
      "head_type": "method",
      "relation": "have",
      "tail": "xmlFeatureDesignPrinciples",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLReader#setFeature(String,boolean)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.AbstractXMLReader",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.LocatorLocationAdapter#getCharacterOffset()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getCharacterOffset",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.LocatorLocationAdapter#getCharacterOffset()",
      "head_type": "method",
      "relation": "have",
      "tail": "This method returns a constant value of -1, indicating that the character offset is not available.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.LocatorLocationAdapter#getCharacterOffset()",
      "head_type": "method",
      "relation": "have",
      "tail": "The design principle behind returning -1 is to signify the unavailability of the character offset, which is a common practice in XML processing to indicate that the position is not trackable.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.LocatorLocationAdapter#getCharacterOffset()",
      "head_type": "method",
      "relation": "have",
      "tail": "package org.springframework.util.xml;\n\npublic class LocatorLocationAdapter {\n    @Override\n    public int getCharacterOffset() {\n        return -1;\n    }\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.StaxResult#setHandler(ContentHandler)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "throwing UnsupportedOperationException",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxResult#setHandler(ContentHandler)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "always throwing UnsupportedOperationException",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.xml.StaxResult#setHandler(ContentHandler)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for throwing UnsupportedOperationException",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.StaxResult#setHandler(ContentHandler)",
      "head_type": "method",
      "relation": "have",
      "tail": "interpretation of UnsupportedOperationException",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxResult#setHandler(ContentHandler)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle of throwing UnsupportedOperationException",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamHandler#startElementInternal(QName,Attributes,Map<String,String>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "writeStartElement",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamHandler#startElementInternal(QName,Attributes,Map<String,String>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "writeNamespace",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamHandler#startElementInternal(QName,Attributes,Map<String,String>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "setDefaultNamespace",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamHandler#startElementInternal(QName,Attributes,Map<String,String>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "setPrefix",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamHandler#startElementInternal(QName,Attributes,Map<String,String>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "writeAttribute",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamHandler#startElementInternal(QName,Attributes,Map<String,String>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "isNamespaceDeclaration",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamHandler#startElementInternal(QName,Attributes,Map<String,String>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "toQName",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamHandler#startElementInternal(QName,Attributes,Map<String,String>)",
      "head_type": "method",
      "relation": "have",
      "tail": "Related Concept Interpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamHandler#startElementInternal(QName,Attributes,Map<String,String>)",
      "head_type": "method",
      "relation": "have",
      "tail": "Design Principle Interpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamHandler#startElementInternal(QName,Attributes,Map<String,String>)",
      "head_type": "method",
      "relation": "have",
      "tail": "Use Sample Code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamXMLReader#handleDtd()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "handle Document Type Definition (DTD)",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamXMLReader#handleDtd()",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "must have a lexical handler",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamXMLReader#handleDtd()",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "parsing XML with DTD",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamXMLReader#handleDtd()",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamXMLReader#handleDtd()",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamXMLReader#handleDtd()",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamXMLReader",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.StaxStreamXMLReader#handleDtd()",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils#createStaxSource(XMLEventReader)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "createStaxSource",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils#createStaxSource(XMLEventReader)",
      "head_type": "method",
      "relation": "have",
      "tail": "Create a JAXP 1.4 StAXSource for the given XMLEventReader.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils#createStaxSource(XMLEventReader)",
      "head_type": "method",
      "relation": "have",
      "tail": "public static Source createStaxSource(XMLEventReader eventReader) throws XMLStreamException { return new StAXSource(eventReader); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.StaxUtils#createStaxSource(XMLEventReader)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils#createStaxSource(XMLEventReader)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "StAXSource",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils#createStaxSource(XMLEventReader)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "XMLEventReader",
      "tail_type": "class"
    },
    {
      "head": "example.type.SomeClassExtendingSomeClass",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "exampleFunctionality",
      "tail_type": "apiFunction"
    },
    {
      "head": "example.type.SomeClassExtendingSomeClass",
      "head_type": "class",
      "relation": "constrained_by",
      "tail": "exampleConstraint",
      "tail_type": "useConstraint"
    },
    {
      "head": "example.type.SomeClassExtendingSomeClass",
      "head_type": "class",
      "relation": "applied_to",
      "tail": "exampleScenario",
      "tail_type": "useScenario"
    },
    {
      "head": "example.type.SomeClassExtendingSomeClass",
      "head_type": "class",
      "relation": "have",
      "tail": "exampleSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "example.type.SomeClassExtendingSomeClass",
      "head_type": "class",
      "relation": "have",
      "tail": "exampleRelatedConcept",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "example.type.SomeClassExtendingSomeClass",
      "head_type": "class",
      "relation": "have",
      "tail": "exampleDesignPrinciple",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "example.type.SomeClassExtendingSomeClass",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "example.type.AnotherClass",
      "tail_type": "class"
    },
    {
      "head": "AssignableTypeFilterTestsTypes",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "classloadingAssertions",
      "tail_type": "apiFunction"
    },
    {
      "head": "AssignableTypeFilterTestsTypes",
      "head_type": "class",
      "relation": "constrained_by",
      "tail": "classNotLoaded",
      "tail_type": "useConstraint"
    },
    {
      "head": "AssignableTypeFilterTestsTypes",
      "head_type": "class",
      "relation": "applied_to",
      "tail": "standaloneSetOfTypes",
      "tail_type": "useScenario"
    },
    {
      "head": "AssignableTypeFilterTestsTypes",
      "head_type": "class",
      "relation": "have",
      "tail": "classloadingAssertionsExplanation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "AssignableTypeFilterTestsTypes",
      "head_type": "class",
      "relation": "have",
      "tail": "designPrincipleExplanation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "AssignableTypeFilterTestsTypes",
      "head_type": "class",
      "relation": "have",
      "tail": "AssignableTypeFilterTestsTypesSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "AssignableTypeFilterTestsTypes",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.core.type.AssignableTypeFilterTests",
      "tail_type": "class"
    },
    {
      "head": "AssignableTypeFilterTestsTypes",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.core.type.ClassloadingAssertions",
      "tail_type": "class"
    },
    {
      "head": "AssignableTypeFilterTestsTypesSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "AssignableTypeFilterTestsTypes",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#forMemberWhenPublicClassWithPackagePrivateMethod()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "Access Control",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#forMemberWhenPublicClassWithPackagePrivateMethod()",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.aot.generate.AccessControlTests#forMemberWhenPublicClassWithPackagePrivateMethod() Sample Code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#forMemberWhenPublicClassWithPackagePrivateMethod() Sample Code",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "org.springframework.aot.generate.AccessControlTests#forMemberWhenPublicClassWithPackagePrivateMethod() Code Content",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#forMemberWhenPublicClassWithPackagePrivateMethod()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.AccessControlTests",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#forMemberWhenPublicClassWithPackagePrivateMethod()",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.aot.generate.AccessControlTests#forMemberWhenPublicClassWithPackagePrivateMethod() Related Concept Interpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#forMemberWhenPublicClassWithPackagePrivateMethod()",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.aot.generate.AccessControlTests#forMemberWhenPublicClassWithPackagePrivateMethod() Design Principle Interpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#toCodeBlock()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "createLocalMethodReference",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#toCodeBlock()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "toCodeBlock",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#toCodeBlock()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.DefaultMethodReferenceTests",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#toCodeBlock()",
      "head_type": "method",
      "relation": "have",
      "tail": "CodeBlock.of(\"this::methodName\")",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#toCodeBlock()",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#toCodeBlock()",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithStaticMethodAndSeparateDeclaringClass()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "generate invoke code block",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithStaticMethodAndSeparateDeclaringClass()",
      "head_type": "method",
      "relation": "have",
      "tail": "generate invoke code block sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "generate invoke code block sample code",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "package com.example; import org.springframework.aot.generate.MethodReference; import org.springframework.aot.generate.CodeBlock; public class InvokeCodeBlockExample { @Test void toInvokeCodeBlockWithStaticMethodAndSeparateDeclaringClass() { MethodReference methodReference = createStaticMethodReference(\"methodName\", TEST_CLASS_NAME); assertThat(methodReference.toInvokeCodeBlock(ArgumentCodeGenerator.none(), INITIALIZER_CLASS_NAME)).isEqualTo(CodeBlock.of(\"com.example.Test.methodName()\")); } }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithStaticMethodAndSeparateDeclaringClass()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.MethodReference",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithStaticMethodAndSeparateDeclaringClass()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.CodeBlock",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithStaticMethodAndSeparateDeclaringClass()",
      "head_type": "method",
      "relation": "have",
      "tail": "related concept interpretation for generate invoke code block",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "related concept interpretation for generate invoke code block",
      "head_type": "relatedConceptInterpretation",
      "relation": "have",
      "tail": "The related concept involves generating code blocks for method invocations, particularly focusing on static methods with separate declaring classes. It emphasizes the use of MethodReference and CodeBlock classes to dynamically create and verify method invocation expressions.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithStaticMethodAndSeparateDeclaringClass()",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle interpretation for generate invoke code block",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "design principle interpretation for generate invoke code block",
      "head_type": "designPrincipleInterpretation",
      "relation": "have",
      "tail": "The design principle focuses on modularity and reusability, aiming to provide a flexible way to generate method invocation code blocks. It leverages the MethodReference and CodeBlock classes to abstract and encapsulate method invocations, enhancing code readability and maintainability.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.FileSystemGeneratedFilesTests#createWhenRootsResultsInNullThrowsException()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "generate files",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.FileSystemGeneratedFilesTests#createWhenRootsResultsInNullThrowsException()",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "roots must return a value for all file kinds",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.aot.generate.FileSystemGeneratedFilesTests#createWhenRootsResultsInNullThrowsException()",
      "head_type": "method",
      "relation": "have",
      "tail": "void createWhenRootsResultsInNullThrowsException() { assertThatIllegalArgumentException().isThrownBy(() -> new FileSystemGeneratedFiles(kind -> (kind != Kind.CLASS) ? this.root.resolve(kind.toString()) : null)).withMessage(\"'roots' must return a value for all file kinds\"); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.FileSystemGeneratedFilesTests",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.FileSystemGeneratedFilesTests#createWhenRootsResultsInNullThrowsException()",
      "tail_type": "method"
    },
    {
      "head": "generate files",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "file system operations",
      "tail_type": "useScenario"
    },
    {
      "head": "roots must return a value for all file kinds",
      "head_type": "useConstraint",
      "relation": "have",
      "tail": "ensures that the file system generation process can handle all file types correctly",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "void createWhenRootsResultsInNullThrowsException() { assertThatIllegalArgumentException().isThrownBy(() -> new FileSystemGeneratedFiles(kind -> (kind != Kind.CLASS) ? this.root.resolve(kind.toString()) : null)).withMessage(\"'roots' must return a value for all file kinds\"); }",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "This sample code demonstrates the creation of a FileSystemGeneratedFiles instance with a custom root resolver. It verifies that an IllegalArgumentException is thrown when the roots function returns null for any file kind, ensuring that all file kinds are handled correctly.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "void createWhenRootsResultsInNullThrowsException() { assertThatIllegalArgumentException().isThrownBy(() -> new FileSystemGeneratedFiles(kind -> (kind != Kind.CLASS) ? this.root.resolve(kind.toString()) : null)).withMessage(\"'roots' must return a value for all file kinds\"); }",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "package org.springframework.aot.generate; import org.junit.jupiter.api.Test; import static org.assertj.core.api.Assertions.assertThatIllegalArgumentException; import java.nio.file.Path; import java.nio.file.Paths; public class FileSystemGeneratedFilesTests { @Test void createWhenRootsResultsInNullThrowsException() { Path root = Paths.get(\"src/test/resources\"); assertThatIllegalArgumentException().isThrownBy(() -> new FileSystemGeneratedFiles(kind -> (kind != Kind.CLASS) ? root.resolve(kind.toString()) : null)).withMessage(\"'roots' must return a value for all file kinds\"); } }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.FileSystemGeneratedFilesTests#addFileWhenPathIsOutsideOfRootThrowsException()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "assertPathMustBeRelative",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.FileSystemGeneratedFilesTests#addFileWhenPathIsOutsideOfRootThrowsException()",
      "head_type": "method",
      "relation": "have",
      "tail": "FileSystemGeneratedFiles",
      "tail_type": "class"
    },
    {
      "head": "FileSystemGeneratedFiles",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.FileSystemGeneratedFilesTests",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.FileSystemGeneratedFilesTests#addFileWhenPathIsOutsideOfRootThrowsException()",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.FileSystemGeneratedFilesTests#addFileWhenPathIsOutsideOfRootThrowsException()",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.FileSystemGeneratedFilesTests#addFileWhenPathIsOutsideOfRootThrowsException()",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests#addSourceFileWithCharSequenceAddsFile()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "addSourceFile",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests#addSourceFileWithCharSequenceAddsFile()",
      "head_type": "method",
      "relation": "have",
      "tail": "addSourceFileWithCharSequenceAddsFile() useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "addSourceFileWithCharSequenceAddsFile() useSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "package com.example;\n\nimport org.junit.jupiter.api.Test;\n\npublic class HelloWorldTest {\n\n    @Test\n    void addSourceFileWithCharSequenceAddsFile() throws Exception {\n        GeneratedFiles generatedFiles = new GeneratedFiles();\n        generatedFiles.addSourceFile(\"com.example.HelloWorld\", \";\");\n        String content = generatedFiles.getAddedFileContent(Kind.SOURCE, \"com/example/HelloWorld.java\");\n        assertEquals(\";\", content);\n    }\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedTypeReferenceTests#nameOfNestedCglibProxy()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "GeneratedTypeReference handling",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedTypeReferenceTests#nameOfNestedCglibProxy()",
      "head_type": "method",
      "relation": "have",
      "tail": "GeneratedTypeReference usage example",
      "tail_type": "useSampleCode"
    },
    {
      "head": "GeneratedTypeReference usage example",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "Complete example of using GeneratedTypeReference",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedTypeReferenceTests#nameOfNestedCglibProxy()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.GeneratedTypeReference",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedTypeReferenceTests#nameOfNestedCglibProxy()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "com.example.Test",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedTypeReferenceTests#nameOfNestedCglibProxy()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "Another$$SpringCGLIB$$0",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.InMemoryGeneratedFilesTests#addFileWhenFileAlreadyAddedThrowsException()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "addResourceFile",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.InMemoryGeneratedFilesTests#addFileWhenFileAlreadyAddedThrowsException()",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "fileAlreadyExists",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.aot.generate.InMemoryGeneratedFilesTests#addFileWhenFileAlreadyAddedThrowsException()",
      "head_type": "method",
      "relation": "have",
      "tail": "addFileWhenFileAlreadyAddedThrowsExceptionSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "addFileWhenFileAlreadyAddedThrowsExceptionSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "org.springframework.aot.generate.InMemoryGeneratedFilesTests",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.InMemoryGeneratedFilesTests#addFileWhenFileAlreadyAddedThrowsException()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.InMemoryGeneratedFilesTests",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.MethodNameTests#andNameWhenPartsIsNullThrowsException()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "IllegalArgumentException",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.MethodNameTests#andNameWhenPartsIsNullThrowsException()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "MethodName generation",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.MethodNameTests#andNameWhenPartsIsNullThrowsException()",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "MethodName null constraint",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.aot.generate.MethodNameTests#andNameWhenPartsIsNullThrowsException()",
      "head_type": "method",
      "relation": "have",
      "tail": "MethodName null constraint",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.MethodNameTests#andNameWhenPartsIsNullThrowsException()",
      "head_type": "method",
      "relation": "have",
      "tail": "IllegalArgumentException",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.MethodNameTests#andNameWhenPartsIsNullThrowsException()",
      "head_type": "method",
      "relation": "have",
      "tail": "MethodName generation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "MethodName null constraint",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "org.springframework.aot.generate.MethodNameTests#andNameWhenPartsIsNullThrowsException()",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.aot.generate.PublicClass#getProtectedMethod()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "accessing protected field",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.PublicClass#getProtectedMethod()",
      "head_type": "method",
      "relation": "have",
      "tail": "String getProtectedMethod() { return this.protectedField; }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.PublicClass",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.PublicClass#getProtectedMethod()",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.aot.generate.MapTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "generateWhenSmallMap",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.MapTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "generateWhenMapWithOverTenElements",
      "tail_type": "apiFunction"
    },
    {
      "head": "generateWhenSmallMap",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "Map.of(\"k1\", \"v1\", \"k2\", \"v2\")",
      "tail_type": "useSampleCode"
    },
    {
      "head": "generateWhenMapWithOverTenElements",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "Map.ofEntries(",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.MapTests#generateWhenSmallMap()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "generateWhenSmallMap",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.MapTests#generateWhenSmallMap()",
      "head_type": "method",
      "relation": "have",
      "tail": "generateWhenSmallMapSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "generateWhenSmallMapSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "generateWhenSmallMapSampleCodeContent",
      "tail_type": "useSampleCodeContent"
    },
    {
      "head": "org.springframework.aot.hint.annotation.SampleInheritedClass#managed()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "reflectiveOperation",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.hint.annotation.SampleInheritedClass#managed()",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.aot.hint.annotation.SampleInheritedClass",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.hint.annotation.SampleInheritedClass",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.aot.hint.annotation.SampleInheritedClass#managed()",
      "tail_type": "method"
    },
    {
      "head": "reflectiveOperation",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "org.springframework.aot.hint.annotation.SampleInheritedClass#managed()",
      "tail_type": "method"
    },
    {
      "head": "reflectiveOperation",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "use of reflection for managing operations",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "reflectiveOperation",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "design principle of minimizing reflection usage for performance",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.hint.annotation.SampleInheritedClass#managed()",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for reflectiveOperation",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.AlternativeJdkIdGenerator",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "generateId",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.AlternativeJdkIdGenerator",
      "head_type": "class",
      "relation": "have",
      "tail": "This class provides an alternative to JdkIdGenerator by using SecureRandom for the initial seed and Random thereafter, offering a better balance between securely random ids and performance.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "generateId",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "public UUID generateId() {\n    byte[] randomBytes = new byte[16];\n    this.random.nextBytes(randomBytes);\n    long mostSigBits = 0;\n    for (int i = 0; i < 8; i++) {\n        mostSigBits = (mostSigBits << 8) | (randomBytes[i] & 0xff);\n    }\n    long leastSigBits = 0;\n    for (int i = 8; i < 16; i++) {\n        leastSigBits = (leastSigBits << 8) | (randomBytes[i] & 0xff);\n    }\n    return new UUID(mostSigBits, leastSigBits);\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.AlternativeJdkIdGenerator",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.JdkIdGenerator",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.AlternativeJdkIdGenerator",
      "head_type": "class",
      "relation": "have",
      "tail": "The class is designed to enhance the performance of generating random ids while maintaining security.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.AutoPopulatingList#addAll(int,Collection<? extends E>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "addingAllElementsAtSpecificIndex",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.AutoPopulatingList#addAll(int,Collection<? extends E>)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.AutoPopulatingList",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.AutoPopulatingList#addAll(int,Collection<? extends E>)",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.AutoPopulatingList#addAll(int,Collection<? extends E>)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.AutoPopulatingList#addAll(int,Collection<? extends E>)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.AutoPopulatingList#indexOf(Object)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "indexOf",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.AutoPopulatingList#indexOf(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is used to find the index of a specified object in the backing list.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.AutoPopulatingList#indexOf(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "public int indexOf(Object o) { return this.backingList.indexOf(o); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.AutoPopulatingList#indexOf(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "The method follows the principle of encapsulation by delegating the operation to the backing list.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.AutoPopulatingList#listIterator()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "listIterator",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.AutoPopulatingList#listIterator()",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.AutoPopulatingList#listIterator() provides a ListIterator for the backing list",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.AutoPopulatingList#listIterator()",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.AutoPopulatingList#listIterator() is an overridden method from the List interface",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.AutoPopulatingList#listIterator()",
      "head_type": "method",
      "relation": "have",
      "tail": "public ListIterator<E> listIterator() { return this.backingList.listIterator(); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.AutoPopulatingList#toArray()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "convert list to array",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.AutoPopulatingList#toArray()",
      "head_type": "method",
      "relation": "have",
      "tail": "The toArray() method is used to convert the elements of the backingList into an array.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.AutoPopulatingList#toArray()",
      "head_type": "method",
      "relation": "have",
      "tail": "public Object[] toArray() { return this.backingList.toArray(); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.AutoPopulatingList#toArray()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.AutoPopulatingList",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.backoff.ExponentialBackOff#getMultiplier()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "retrieve multiplier value",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.backoff.ExponentialBackOff#getMultiplier()",
      "head_type": "method",
      "relation": "have",
      "tail": "Return the value to multiply the current interval by for each retry attempt.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.backoff.ExponentialBackOff",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.backoff.ExponentialBackOff#getMultiplier()",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.ClassUtils#isLambdaClass(Class<?>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "determine if a class is a JVM-generated lambda implementation",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ClassUtils#isLambdaClass(Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for checking lambda class",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ClassUtils#isLambdaClass(Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "related concept interpretation for lambda implementation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#isLambdaClass(Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle interpretation for lambda class check",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "sample code for checking lambda class",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "tail": "org.springframework.util.ClassUtils#isLambdaClass(Class<?>)",
      "tail_type": "method"
    },
    {
      "head": "related concept interpretation for lambda implementation",
      "head_type": "relatedConceptInterpretation",
      "relation": "associated_with",
      "tail": "org.springframework.util.ClassUtils#isLambdaClass(Class<?>)",
      "tail_type": "method"
    },
    {
      "head": "design principle interpretation for lambda class check",
      "head_type": "designPrincipleInterpretation",
      "relation": "associated_with",
      "tail": "org.springframework.util.ClassUtils#isLambdaClass(Class<?>)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.ClassUtils#isCglibProxy(Object)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "check if an object is a CGLIB proxy",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ClassUtils#isCglibProxy(Object)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "deprecated as of version 5.2",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ClassUtils#isCglibProxy(Object)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "custom (possibly narrower) checks such as for a Spring AOP proxy",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ClassUtils#isCglibProxy(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for checking if an object is a CGLIB proxy",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ClassUtils#isCglibProxy(Object)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aop.support.AopUtils#isCglibProxy(Object)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.ClassUtils#isCglibProxy(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "interpretation of CGLIB proxy and its usage in Spring framework",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#isCglibProxy(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principles behind deprecating the method in favor of more specific checks",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#hasMethod(Class<?>,String,Class<?>",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "check existence of public method",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ClassUtils#hasMethod(Class<?>,String,Class<?>",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "NoSuchMethodException translated to false",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ClassUtils#hasMethod(Class<?>,String,Class<?>",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "class method analysis",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ClassUtils#hasMethod(Class<?>,String,Class<?>",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for checking method existence",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ClassUtils#hasMethod(Class<?>,String,Class<?>",
      "head_type": "method",
      "relation": "have",
      "tail": "NoSuchMethodException interpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#hasMethod(Class<?>,String,Class<?>",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle for method existence check",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#hasMethod(Class<?>,String,Class<?>",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "Class#getMethod",
      "tail_type": "method"
    },
    {
      "tail": "compare two Boolean values",
      "head_type": "method",
      "relation": "haveFunction",
      "head": "org.springframework.util.comparator.BooleanComparator#compare(Boolean,Boolean)",
      "tail_type": "apiFunction"
    },
    {
      "tail": " multiplier = this.trueLow ? -1 : 1",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.comparator.BooleanComparator#compare(Boolean,Boolean)",
      "tail_type": "useSampleCode"
    },
    {
      "tail": " multiplier * Boolean.compare(left, right)",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.comparator.BooleanComparator#compare(Boolean,Boolean)",
      "tail_type": "useSampleCode"
    },
    {
      "tail": " multiplier * Boolean.compare(left, right)",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.comparator.BooleanComparator#compare(Boolean,Boolean)",
      "tail_type": "useSampleCode"
    },
    {
      "tail": " multiplier * Boolean.compare(left, right)",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.comparator.BooleanComparator#compare(Boolean,Boolean)",
      "tail_type": "useSampleCode"
    },
    {
      "tail": " multiplier * Boolean.compare(left, right)",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.comparator.BooleanComparator#compare(Boolean,Boolean)",
      "tail_type": "useSampleCode"
    },
    {
      "tail": " multiplier * Boolean.compare(left, right)",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.comparator.BooleanComparator#compare(Boolean,Boolean)",
      "tail_type": "useSampleCode"
    },
    {
      "tail": " multiplier * Boolean.compare(left, right)",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.comparator.BooleanComparator#compare(Boolean,Boolean)",
      "tail_type": "useSampleCode"
    },
    {
      "tail": " multiplier * Boolean.compare(left, right)",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.comparator.BooleanComparator#compare(Boolean,Boolean)",
      "tail_type": "useSampleCode"
    },
    {
      "tail": " multiplier * Boolean.compare(left, right)",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.comparator.BooleanComparator#compare(Boolean,Boolean)",
      "tail_type": "useSampleCode"
    },
    {
      "tail": " multiplier * Boolean.compare(left, right)",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.comparator.BooleanComparator#compare(Boolean,Boolean)",
      "tail_type": "useSampleCode"
    },
    {
      "tail": " multiplier * Boolean.compare(left, right)",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.comparator.BooleanComparator#compare(Boolean,Boolean)",
      "tail_type": "useSampleCode"
    },
    {
      "tail": " multiplier * Boolean.compare(left, right)",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.comparator.BooleanComparator#compare(Boolean,Boolean)",
      "tail_type": "useSampleCode"
    },
    {
      "tail": " multiplier * Boolean.compare(left, right)",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.comparator.BooleanComparator#compare(Boolean,Boolean)",
      "tail_type": "useSampleCode"
    },
    {
      "tail": " multiplier * Boolean.compare(left, right)",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.comparator.BooleanComparator#compare(Boolean,Boolean)",
      "tail_type": "useSampleCode"
    },
    {
      "tail": " multiplier * Boolean.compare(left, right)",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.comparator.BooleanComparator#compare(Boolean,Boolean)",
      "tail_type": "useSampleCode"
    },
    {
      "tail": " multiplier * Boolean.compare(left, right)",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.comparator.BooleanComparator#compare(Boolean,Boolean)",
      "tail_type": "useSampleCode"
    },
    {
      "tail": " multiplier * Boolean.compare(left, right)",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.comparator.BooleanComparator#compare(Boolean,Boolean)",
      "tail_type": "useSampleCode"
    },
    {
      "tail": " multiplier * Boolean.compare(left, right)",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.comparator.BooleanComparator#compare(Boolean,Boolean)",
      "tail_type": "useSampleCode"
    },
    {
      "tail": " multiplier * Boolean.compare(left, right)",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.comparator.BooleanComparator#compare(Boolean,Boolean)",
      "tail_type": "useSampleCode"
    },
    {
      "tail": " multiplier * Boolean.compare(left, right)",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.comparator.BooleanComparator#compare(Boolean,Boolean)",
      "tail_type": "useSampleCode"
    },
    {
      "tail": " multiplier * Boolean.compare(left, right)",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.comparator.BooleanComparator#compare(Boolean,Boolean)",
      "tail_type": "useSampleCode"
    },
    {
      "tail": " multiplier * Boolean.compare(left, right)",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.comparator.BooleanComparator#compare(Boolean,Boolean)",
      "tail_type": "useSampleCode"
    },
    {
      "tail": " multiplier * Boolean.compare(left, right)",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.comparator.BooleanComparator#compare(Boolean,Boolean)",
      "tail_type": "useSampleCode"
    },
    {
      "tail": " multiplier * Boolean.compare(left, right)",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.comparator.BooleanComparator#compare(Boolean,Boolean)",
      "tail_type": "useSampleCode"
    },
    {
      "tail": " multiplier * Boolean.compare(left, right)",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.comparator.BooleanComparator#compare(Boolean,Boolean)",
      "tail_type": "useSampleCode"
    },
    {
      "tail": " multiplier * Boolean.compare(left, right)",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.comparator.BooleanComparator#compare(Boolean,Boolean)",
      "tail_type": "useSampleCode"
    },
    {
      "tail": " multiplier * Boolean.compare(left, right)",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.comparator.BooleanComparator#compare(Boolean,Boolean)",
      "tail_type": "useSampleCode"
    },
    {
      "tail": " multiplier * Boolean.compare(left, right)",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.comparator.BooleanComparator#compare(Boolean,Boolean)",
      "tail_type": "useSampleCode"
    },
    {
      "tail": " multiplier * Boolean.compare(left, right)",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.comparator.BooleanComparator#compare(Boolean,Boolean)",
      "tail_type": "useSampleCode"
    },
    {
      "tail": " multiplier * Boolean.compare(left, right)",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.comparator.BooleanComparator#compare(Boolean,Boolean)",
      "tail_type": "useSampleCode"
    },
    {
      "tail": " multiplier * Boolean.compare(left, right)",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.comparator.BooleanComparator#compare(Boolean,Boolean)",
      "tail_type": "useSampleCode"
    },
    {
      "tail": " multiplier * Boolean.compare(left, right)",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.comparator.BooleanComparator#compare(Boolean,Boolean)",
      "tail_type": "useSampleCode"
    },
    {
      "tail": " multiplier * Boolean.compare(left, right)",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.comparator.BooleanComparator#compare(Boolean,Boolean)",
      "tail_type": "useSampleCode"
    },
    {
      "tail": " multiplier * Boolean.compare(left, right)",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.comparator.BooleanComparator#compare(Boolean,Boolean)",
      "tail_type": "useSampleCode"
    },
    {
      "tail": " multiplier * Boolean.compare(left, right)",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.comparator.BooleanComparator#compare(Boolean,Boolean)",
      "tail_type": "useSampleCode"
    },
    {
      "tail": " multiplier * Boolean.compare(left, right)",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.comparator.BooleanComparator#compare(Boolean,Boolean)",
      "tail_type": "useSampleCode"
    },
    {
      "tail": " multiplier * Boolean.compare(left, right)",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.comparator.BooleanComparator#compare(Boolean,Boolean)",
      "tail_type": "useSampleCode"
    },
    {
      "tail": " multiplier * Boolean.compare(left, right)",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.comparator.BooleanComparator#compare(Boolean,Boolean)",
      "tail_type": "useSampleCode"
    },
    {
      "tail": " multiplier * Boolean.compare(left, right)",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.comparator.BooleanComparator#compare(Boolean,Boolean)",
      "tail_type": "useSampleCode"
    },
    {
      "tail": " multiplier * Boolean.compare(left, right)",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.comparator.BooleanComparator#compare(Boolean,Boolean)",
      "tail_type": "useSampleCode"
    },
    {
      "tail": " multiplier * Boolean.compare(left, right)",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.comparator.BooleanComparator#compare(Boolean,Boolean)",
      "tail_type": "useSampleCode"
    },
    {
      "tail": " multiplier * Boolean.compare(left, right)",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.comparator.BooleanComparator#compare(Boolean,Boolean)",
      "tail_type": "useSampleCode"
    },
    {
      "tail": " multiplier * Boolean.compare(left, right)",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.comparator.BooleanComparator#compare(Boolean,Boolean)",
      "tail_type": "useSampleCode"
    },
    {
      "tail": " multiplier * Boolean.compare(left, right)",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.comparator.BooleanComparator#compare(Boolean,Boolean)",
      "tail_type": "useSampleCode"
    },
    {
      "tail": " multiplier * Boolean.compare(left, right)",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.comparator.BooleanComparator#compare(Boolean,Boolean)",
      "tail_type": "useSampleCode"
    },
    {
      "tail": " multiplier * Boolean.compare(left, right)",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.comparator.BooleanComparator#compare(Boolean,Boolean)",
      "tail_type": "useSampleCode"
    },
    {
      "tail": " multiplier * Boolean.compare(left, right)",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.comparator.BooleanComparator#compare(Boolean,Boolean)",
      "tail_type": "useSampleCode"
    },
    {
      "tail": " multiplier * Boolean.compare(left, right)",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.comparator.BooleanComparator#compare(Boolean,Boolean)",
      "tail_type": "useSampleCode"
    },
    {
      "tail": " multiplier * Boolean.compare(left, right)",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.comparator.BooleanComparator#compare(Boolean,Boolean)",
      "tail_type": "useSampleCode"
    },
    {
      "tail": " multiplier * Boolean.compare(left, right)",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.comparator.BooleanComparator#compare(Boolean,Boolean)",
      "tail_type": "useSampleCode"
    },
    {
      "tail": " multiplier * Boolean.compare(left, right)",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.comparator.BooleanComparator#compare(Boolean,Boolean)",
      "tail_type": "useSampleCode"
    },
    {
      "tail": " multiplier * Boolean.compare(left, right)",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.comparator.BooleanComparator#compare(Boolean,Boolean)",
      "tail_type": "useSampleCode"
    },
    {
      "tail": " multiplier * Boolean.compare(left, right)",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.comparator.BooleanComparator#compare(Boolean,Boolean)",
      "tail_type": "useSampleCode"
    },
    {
      "tail": " multiplier * Boolean.compare(left, right)",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.comparator.BooleanComparator#compare(Boolean,Boolean)",
      "tail_type": "useSampleCode"
    },
    {
      "tail": " multiplier * Boolean.compare(left, right)",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.comparator.BooleanComparator#compare(Boolean,Boolean)",
      "tail_type": "useSampleCode"
    },
    {
      "tail": " multiplier * Boolean.compare(left, right)",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.comparator.BooleanComparator#compare(Boolean,Boolean)",
      "tail_type": "useSampleCode"
    },
    {
      "tail": " multiplier * Boolean.compare(left, right)",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.comparator.BooleanComparator#compare(Boolean,Boolean)",
      "tail_type": "useSampleCode"
    },
    {
      "tail": " multiplier * Boolean.compare(left, right)",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.comparator.BooleanComparator#compare(Boolean,Boolean)",
      "tail_type": "useSampleCode"
    },
    {
      "tail": " multiplier * Boolean.compare(left, right)",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.comparator.BooleanComparator#compare(Boolean,Boolean)",
      "tail_type": "useSampleCode"
    },
    {
      "tail": " multiplier * Boolean.compare(left, right)",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.comparator.BooleanComparator#compare(Boolean,Boolean)",
      "tail_type": "useSampleCode"
    },
    {
      "tail": " multiplier * Boolean.compare(left, right)",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.comparator.BooleanComparator#compare(Boolean,Boolean)",
      "tail_type": "useSampleCode"
    },
    {
      "tail": " multiplier * Boolean.compare(left, right)",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.comparator.BooleanComparator#compare(Boolean,Boolean)",
      "tail_type": "useSampleCode"
    },
    {
      "tail": " multiplier * Boolean.compare(left, right)",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.comparator.BooleanComparator#compare(Boolean,Boolean)",
      "tail_type": "useSampleCode"
    },
    {
      "tail": " multiplier * Boolean.compare(left, right)",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.comparator.BooleanComparator#compare(Boolean,Boolean)",
      "tail_type": "useSampleCode"
    },
    {
      "tail": " multiplier * Boolean.compare(left, right)",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.comparator.BooleanComparator#compare(Boolean,Boolean)",
      "tail_type": "useSampleCode"
    },
    {
      "tail": " multiplier * Boolean.compare(left, right)",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.comparator.BooleanComparator#compare(Boolean,Boolean)",
      "tail_type": "useSampleCode"
    },
    {
      "tail": " multiplier * Boolean.compare(left, right)",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.comparator.BooleanComparator#compare(Boolean,Boolean)",
      "tail_type": "useSampleCode"
    },
    {},
    {
      "head": "org.springframework.util.CompositeCollection#removeAll(Collection<?>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "remove elements from collection",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.CompositeCollection#removeAll(Collection<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "Removes all of the elements of the specified collection from this collection",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.CompositeCollection#removeAll(Collection<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "The method should return true if this collection changed as a result of the call",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.CompositeCollection#removeAll(Collection<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "package com.collection.example; import java.util.ArrayList; import java.util.Collection; import java.util.HashSet; import org.springframework.util.CompositeCollection; public class RemoveAllExample { public static void main(String[] args) { Collection<Integer> first = new ArrayList<>(); first.add(1); first.add(2); first.add(3); Collection<Integer> second = new HashSet<>(); second.add(3); second.add(4); second.add(5); CompositeCollection<Integer> composite = new CompositeCollection<>(first, second); Collection<Integer> toRemove = new ArrayList<>(); toRemove.add(2); toRemove.add(4); boolean result = composite.removeAll(toRemove); System.out.println(\"Removed: \" + result); System.out.println(\"First collection: \" + first); System.out.println(\"Second collection: \" + second); } }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.CompositeMap#isEmpty()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "checkEmptiness",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.CompositeMap#isEmpty()",
      "head_type": "method",
      "relation": "have",
      "tail": "This method checks if both the first and second maps are empty.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.CompositeMap#isEmpty()",
      "head_type": "method",
      "relation": "have",
      "tail": "The design principle followed here is to provide a convenient way to check the emptiness of composite maps, enhancing code readability and maintainability.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.CompositeMap#isEmpty()",
      "head_type": "method",
      "relation": "have",
      "tail": "package com.example;\n\nimport java.util.Map;\n\npublic class CompositeMapExample {\n    public static void main(String[] args) {\n        Map<String, String> firstMap = Map.of();\n        Map<String, String> secondMap = Map.of();\n        org.springframework.util.CompositeMap compositeMap = new org.springframework.util.CompositeMap(firstMap, secondMap);\n        boolean isEmpty = compositeMap.isEmpty();\n        System.out.println(\"Is composite map empty? \" + isEmpty);\n    }\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.concurrent.FutureAdapter#isCancelled()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "checkCancellationStatus",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.concurrent.FutureAdapter#isCancelled()",
      "head_type": "method",
      "relation": "have",
      "tail": "This method checks if the task has been cancelled.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.concurrent.FutureAdapter#isCancelled()",
      "head_type": "method",
      "relation": "have",
      "tail": "public boolean isCancelled() {\n    return this.adaptee.isCancelled();\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.concurrent.FutureAdapter#isCancelled()",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is part of the Future interface implementation.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.AddTask",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "addition of new cache entry",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.AddTask",
      "head_type": "class",
      "relation": "constrained_by",
      "tail": "cache capacity limit",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.AddTask",
      "head_type": "class",
      "relation": "applied_to",
      "tail": "cache eviction process",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.AddTask",
      "head_type": "class",
      "relation": "have",
      "tail": "cache eviction implementation",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.AddTask",
      "head_type": "class",
      "relation": "have",
      "tail": "cache entry addition explanation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.AddTask",
      "head_type": "class",
      "relation": "have",
      "tail": "design principles of AddTask",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.AddTask",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "cache management system",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.ReadOperations#getBufferIndex()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getBufferIndex",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ReadOperations#getBufferIndex()",
      "head_type": "method",
      "relation": "have",
      "tail": "getBufferIndexSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "getBufferIndexSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "getBufferIndexCompleteSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.Segment#getReference(Object,int,Restructure)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getReference",
      "tail_type": "apiFunction"
    },
    {
      "head": "getReference",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "getReference",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "getReference",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.Segment",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "getReference",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.Segment",
      "head_type": "class",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.Segment",
      "head_type": "class",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.Segment#findInChain(Reference<K,V>,Object,int)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "hash-based search",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.Segment#findInChain(Reference<K,V>,Object,int)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "null safety",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.Segment#findInChain(Reference<K,V>,Object,int)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "chained reference search",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.Segment#findInChain(Reference<K,V>,Object,int)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.Segment#findInChain(Reference<K,V>,Object,int) sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.Segment#findInChain(Reference<K,V>,Object,int)",
      "head_type": "method",
      "relation": "have",
      "tail": "related concept interpretation for org.springframework.util.Segment#findInChain(Reference<K,V>,Object,int)",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.Segment#findInChain(Reference<K,V>,Object,int)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle interpretation for org.springframework.util.Segment#findInChain(Reference<K,V>,Object,int)",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.Segment",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.Segment#findInChain(Reference<K,V>,Object,int)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.CustomizableThreadCreator",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "createThread",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.CustomizableThreadCreator",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "nextThreadName",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.CustomizableThreadCreator",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getDefaultThreadNamePrefix",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.CustomizableThreadCreator",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "setThreadNamePrefix",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.CustomizableThreadCreator",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getThreadNamePrefix",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.CustomizableThreadCreator",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "setThreadPriority",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.CustomizableThreadCreator",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getThreadPriority",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.CustomizableThreadCreator",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "setDaemon",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.CustomizableThreadCreator",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "isDaemon",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.CustomizableThreadCreator",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "setThreadGroupName",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.CustomizableThreadCreator",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "setThreadGroup",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.CustomizableThreadCreator",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getThreadGroup",
      "tail_type": "apiFunction"
    },
    {
      "head": "createThread",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "Runnable",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.CustomizableThreadCreator",
      "head_type": "class",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.CustomizableThreadCreator",
      "head_type": "class",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.CustomizableThreadCreator",
      "head_type": "class",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.CustomizableThreadCreator",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.scheduling.concurrent.CustomizableThreadFactory",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.DigestUtils",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "md5Digest",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.DigestUtils",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "md5DigestAsHex",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.DigestUtils",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "appendMd5DigestAsHex",
      "tail_type": "apiFunction"
    },
    {
      "head": "md5Digest",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "byte array input",
      "tail_type": "useScenario"
    },
    {
      "head": "md5DigestAsHex",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "byte array input",
      "tail_type": "useScenario"
    },
    {
      "head": "appendMd5DigestAsHex",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "byte array input and StringBuilder",
      "tail_type": "useScenario"
    },
    {
      "head": "md5Digest",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "md5DigestAsHex",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "appendMd5DigestAsHex",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.DigestUtils",
      "head_type": "class",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.DigestUtils",
      "head_type": "class",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ExceptionTypeFilter",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "handle exception types",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ExceptionTypeFilter",
      "head_type": "class",
      "relation": "constrained_by",
      "tail": "type must be assignable to the candidate",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ExceptionTypeFilter",
      "head_type": "class",
      "relation": "have",
      "tail": "An InstanceFilter implementation that handles exception types. A type will match against a given candidate if it is assignable to that candidate.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ExceptionTypeFilter",
      "head_type": "class",
      "relation": "have",
      "tail": "Author: Stephane Nicoll, Since: 4.1",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ExceptionTypeFilter",
      "head_type": "class",
      "relation": "have",
      "tail": "public ExceptionTypeFilter(Collection<? extends Class<? extends Throwable>> includes, Collection<? extends Class<? extends Throwable>> excludes, boolean matchIfEmpty) {\n    super(includes, excludes, matchIfEmpty);\n}\n@Override\nprotected boolean match(Class<? extends Throwable> instance, Class<? extends Throwable> candidate) {\n    return candidate.isAssignableFrom(instance);\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.function.SingletonSupplier",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "caching a singleton result",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.function.SingletonSupplier",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "providing a null-safe singleton instance",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.function.SingletonSupplier",
      "head_type": "class",
      "relation": "applied_to",
      "tail": "method reference suppliers",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.function.SingletonSupplier",
      "head_type": "class",
      "relation": "have",
      "tail": "A Supplier decorator that caches a singleton result and makes it available from get() (nullable) and obtain() (null-safe).",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.function.SingletonSupplier",
      "head_type": "class",
      "relation": "have",
      "tail": "The SingletonSupplier can be constructed via of factory methods or via constructors that provide a default supplier as a fallback. This is particularly useful for method reference suppliers, falling back to a default supplier for a method that returned null and caching the result.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.function.SingletonSupplier",
      "head_type": "class",
      "relation": "have",
      "tail": "package com.example.demo;\n\nimport org.springframework.util.function.SingletonSupplier;\n\npublic class SingletonSupplierExample {\n    public static void main(String[] args) {\n        SingletonSupplier<String> supplier = SingletonSupplier.of(() -> \"Hello, World!\");\n        System.out.println(supplier.get());\n        System.out.println(supplier.obtain());\n    }\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.function.SingletonSupplier#obtain()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "obtain singleton instance",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.function.SingletonSupplier#obtain()",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "instance must not be null",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.function.SingletonSupplier#obtain()",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.function.SingletonSupplier#obtain()",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.function.SingletonSupplier#obtain()",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.function.ThrowingBiFunction",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "applyWithException",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.function.ThrowingBiFunction",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "apply",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.function.ThrowingBiFunction",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "throwing",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.function.ThrowingBiFunction",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "of",
      "tail_type": "apiFunction"
    },
    {
      "head": "applyWithException",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "Exception on error",
      "tail_type": "useConstraint"
    },
    {
      "head": "apply",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "Wraps any thrown checked exceptions in a RuntimeException",
      "tail_type": "useConstraint"
    },
    {
      "head": "apply",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "Wrapping checked exceptions using exceptionWrapper",
      "tail_type": "useScenario"
    },
    {
      "head": "throwing",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "Creating a ThrowingBiFunction with a custom exception wrapper",
      "tail_type": "useScenario"
    },
    {
      "head": "of",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "Creating a ThrowingBiFunction from a lambda or method reference",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.function.ThrowingBiFunction",
      "head_type": "class",
      "relation": "have",
      "tail": "A BiFunction that allows invocation of code that throws a checked exception",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.function.ThrowingBiFunction",
      "head_type": "class",
      "relation": "have",
      "tail": "Design principle focused on exception handling and functional interfaces",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.function.ThrowingBiFunction",
      "head_type": "class",
      "relation": "have",
      "tail": "Sample code demonstrating the usage of ThrowingBiFunction",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.function.ThrowingConsumer#of(ThrowingConsumer<T>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "create ThrowingConsumer",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.function.ThrowingConsumer#of(ThrowingConsumer<T>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "lambda expression or method reference must throw a checked exception",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.function.ThrowingConsumer#of(ThrowingConsumer<T>)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "working with method references",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.function.ThrowingConsumer#of(ThrowingConsumer<T>)",
      "head_type": "method",
      "relation": "have",
      "tail": "convert a method that throws a checked exception into an instance compatible with a regular Consumer",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.function.ThrowingConsumer#of(ThrowingConsumer<T>)",
      "head_type": "method",
      "relation": "have",
      "tail": "static <T> ThrowingConsumer<T> of(ThrowingConsumer<T> consumer) { return consumer; }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.function.ThrowingConsumer#of(ThrowingConsumer<T>)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.function.ThrowingConsumer#of(ThrowingConsumer<T>)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.function.ThrowingConsumer#of(ThrowingConsumer<T>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.function.ThrowingConsumer",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.JdkIdGenerator",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "generateId",
      "tail_type": "apiFunction"
    },
    {
      "head": "generateId",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "UUID.randomUUID()",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.JdkIdGenerator",
      "head_type": "class",
      "relation": "have",
      "tail": "An IdGenerator that calls java.util.UUID#randomUUID()",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.JdkIdGenerator",
      "head_type": "class",
      "relation": "have",
      "tail": "Author: Rossen Stoyanchev, Since: 4.1.5",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.EntrySet#contains(Object)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "checkInclusion",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.EntrySet#contains(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.EntrySet#contains(Object) useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.EntrySet#contains(Object) useSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "org.springframework.util.EntrySet#contains(Object) useSampleCode Content",
      "tail_type": "content"
    },
    {
      "head": "org.springframework.util.LinkedMultiValueMap",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "wrapsLinkedHashMap",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.LinkedMultiValueMap",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "createDeepCopy",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.LinkedMultiValueMap",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "createRegularCopy",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.LinkedMultiValueMap",
      "head_type": "class",
      "relation": "constrained_by",
      "tail": "threadSafety",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.LinkedMultiValueMap",
      "head_type": "class",
      "relation": "applied_to",
      "tail": "singleThreadUse",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.LinkedMultiValueMap",
      "head_type": "class",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.LinkedMultiValueMap",
      "head_type": "class",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.LinkedMultiValueMap",
      "head_type": "class",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "wrapsLinkedHashMap",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "LinkedHashMap",
      "tail_type": "class"
    },
    {
      "head": "createDeepCopy",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "ArrayList",
      "tail_type": "class"
    },
    {
      "head": "createRegularCopy",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "MultiValueMap",
      "tail_type": "class"
    },
    {
      "head": "threadSafety",
      "head_type": "useConstraint",
      "relation": "associated_with",
      "tail": "MultiValueMap",
      "tail_type": "class"
    },
    {
      "head": "singleThreadUse",
      "head_type": "useScenario",
      "relation": "associated_with",
      "tail": "requestObjects",
      "tail_type": "class"
    },
    {
      "head": "useSampleCode",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "tail": "LinkedMultiValueMap",
      "tail_type": "class"
    },
    {
      "head": "relatedConceptInterpretation",
      "head_type": "relatedConceptInterpretation",
      "relation": "associated_with",
      "tail": "MultiValueMap",
      "tail_type": "class"
    },
    {
      "head": "designPrincipleInterpretation",
      "head_type": "designPrincipleInterpretation",
      "relation": "associated_with",
      "tail": "LinkedMultiValueMap",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.MimeType#hashCode()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "generateHashCode",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MimeType#hashCode()",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.MimeType#hashCode()",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.MimeType#hashCode()",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "generateHashCode",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "org.springframework.util.MimeType#hashCode()",
      "tail_type": "method"
    },
    {
      "head": "generateHashCode",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "generateHashCode",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "generateHashCode",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "useSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "generateHashCode",
      "tail_type": "apiFunction"
    },
    {
      "head": "relatedConceptInterpretation",
      "head_type": "relatedConceptInterpretation",
      "relation": "have",
      "tail": "generateHashCode",
      "tail_type": "apiFunction"
    },
    {
      "head": "designPrincipleInterpretation",
      "head_type": "designPrincipleInterpretation",
      "relation": "have",
      "tail": "generateHashCode",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ObjectUtils#arrayEquals(Object,Object)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "array comparison",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ObjectUtils#arrayEquals(Object,Object)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "input arrays must be of the same type",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ObjectUtils#arrayEquals(Object,Object)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "comparing arrays of objects, booleans, bytes, chars, doubles, floats, ints, longs, and shorts",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ObjectUtils#arrayEquals(Object,Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "complete sample code for comparing arrays",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ObjectUtils#arrayEquals(Object,Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "related concept interpretation for array comparison",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ObjectUtils#arrayEquals(Object,Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle interpretation for array comparison",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ObjectUtils#arrayEquals(Object,Object)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "java.util.Arrays",
      "tail_type": "class"
    },
    {
      "head": "array comparison",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "complete sample code for comparing arrays",
      "tail_type": "useSampleCode"
    },
    {
      "head": "array comparison",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "related concept interpretation for array comparison",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "array comparison",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "design principle interpretation for array comparison",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.PathMatcher",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "isPattern",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.PathMatcher",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "match",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.PathMatcher",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "matchStart",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.PathMatcher",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "extractPathWithinPattern",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.PathMatcher",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "extractUriTemplateVariables",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.PathMatcher",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getPatternComparator",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.PathMatcher",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "combine",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.PathMatcher",
      "head_type": "class",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.PathMatcher",
      "head_type": "class",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.PathMatcher",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.core.io.support.PathMatchingResourcePatternResolver",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.PathMatcher",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.web.servlet.handler.AbstractUrlHandlerMapping",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.PathMatcher",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.web.servlet.mvc.WebContentInterceptor",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.PathMatcher",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "AntPathMatcher",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.PatternMatchUtils",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "simpleMatch",
      "tail_type": "apiFunction"
    },
    {
      "head": "simpleMatch",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "null input returns false",
      "tail_type": "useConstraint"
    },
    {
      "head": "simpleMatch",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "pattern matching with wildcards",
      "tail_type": "useScenario"
    },
    {
      "head": "simpleMatch",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "String matching with patterns",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.PatternMatchUtils",
      "head_type": "class",
      "relation": "have",
      "tail": "Utility for simple pattern matching",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "simpleMatch",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "Complete Java method example",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#invokeMethod(Method,Object)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "invoke a specified Method against a target object",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#invokeMethod(Method,Object)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "target object can be null for static Methods",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#invokeMethod(Method,Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "handleReflectionException called for thrown exceptions",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#invokeMethod(Method,Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#invokeMethod(Method,Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#invokeMethod(Method,Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#invokeMethod(Method,Object)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.ReflectionUtils",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#invokeMethod(Method,Object)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "Method",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#invokeMethod(Method,Object)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "Object",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#doWithMethods(Class<?>,MethodCallback,MethodFilter)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "introspection",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#doWithMethods(Class<?>,MethodCallback,MethodFilter)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "callback invocation",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#doWithMethods(Class<?>,MethodCallback,MethodFilter)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "method filtering",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#doWithMethods(Class<?>,MethodCallback,MethodFilter)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "IllegalStateException on introspection failure",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#doWithMethods(Class<?>,MethodCallback,MethodFilter)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "class and superclass method processing",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#doWithMethods(Class<?>,MethodCallback,MethodFilter)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "interface and super-interface method processing",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#doWithMethods(Class<?>,MethodCallback,MethodFilter)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for method introspection",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#doWithMethods(Class<?>,MethodCallback,MethodFilter)",
      "head_type": "method",
      "relation": "have",
      "tail": "related concept interpretation for introspection",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#doWithMethods(Class<?>,MethodCallback,MethodFilter)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle interpretation for introspection",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "introspection",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "org.springframework.util.ReflectionUtils",
      "tail_type": "class"
    },
    {
      "head": "callback invocation",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "org.springframework.util.ReflectionUtils",
      "tail_type": "class"
    },
    {
      "head": "method filtering",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "org.springframework.util.ReflectionUtils",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#isObjectMethod(Method)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "determine if method is declared by java.lang.Object",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#isObjectMethod(Method)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for isObjectMethod",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#isObjectMethod(Method)",
      "head_type": "method",
      "relation": "have",
      "tail": "related concept interpretation for isObjectMethod",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#isObjectMethod(Method)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle interpretation for isObjectMethod",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#isObjectMethod(Method)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "java.lang.Object",
      "tail_type": "class"
    },
    {
      "head": "sample code for isObjectMethod",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "complete example for using isObjectMethod",
      "tail_type": "useSampleCode"
    },
    {
      "head": "related concept interpretation for isObjectMethod",
      "head_type": "relatedConceptInterpretation",
      "relation": "have",
      "tail": "interpretation of checking method declaration",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "design principle interpretation for isObjectMethod",
      "head_type": "designPrincipleInterpretation",
      "relation": "have",
      "tail": "principle of reflection utility design",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ResourceUtils#isJarURL(URL)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "check if URL points to a resource in a jar file",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ResourceUtils#isJarURL(URL)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "URL must have a valid protocol",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ResourceUtils#isJarURL(URL)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "resource loading from jar files",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ResourceUtils#isJarURL(URL)",
      "head_type": "method",
      "relation": "have",
      "tail": "public static boolean isJarURL(URL url) { String protocol = url.getProtocol(); return (URL_PROTOCOL_JAR.equals(protocol) || URL_PROTOCOL_WAR.equals(protocol) || URL_PROTOCOL_ZIP.equals(protocol) || URL_PROTOCOL_VFSZIP.equals(protocol) || URL_PROTOCOL_WSJAR.equals(protocol)); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ResourceUtils#isJarURL(URL)",
      "head_type": "method",
      "relation": "have",
      "tail": "Checks if the provided URL points to a resource within a jar file by examining its protocol.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ResourceUtils#isJarURL(URL)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is designed to support resource handling in Java applications by identifying URLs that point to jar file resources, facilitating efficient resource management.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ResourceUtils#isJarURL(URL)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.ResourceUtils",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.ResourceUtils#useCachesIfNecessary(URLConnection)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "setUseCaches",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ResourceUtils#useCachesIfNecessary(URLConnection)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "prefer false but default for jar resources",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ResourceUtils#useCachesIfNecessary(URLConnection)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "URLConnection",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ResourceUtils#useCachesIfNecessary(URLConnection)",
      "head_type": "method",
      "relation": "have",
      "tail": "setUseCaches flag",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ResourceUtils#useCachesIfNecessary(URLConnection)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for useCachesIfNecessary",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ResourceUtils#useCachesIfNecessary(URLConnection)",
      "head_type": "method",
      "relation": "have",
      "tail": "related concept interpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ResourceUtils#useCachesIfNecessary(URLConnection)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle interpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ResourceUtils#useCachesIfNecessary(URLConnection)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "URLConnection",
      "tail_type": "class"
    },
    {
      "head": "ResourceUtils",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "useCachesIfNecessary",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.RouteMatcher#parseRoute(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "parseRoute",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.RouteMatcher#parseRoute(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "Return a parsed representation of the given route.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.RouteMatcher#parseRoute(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "The method takes a string as input and returns a parsed representation of the route.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.RouteMatcher#parseRoute(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "public Route parseRoute(String routeValue) {\n    // Example implementation\n    // This is a simplified version, actual implementation may vary\n    if (routeValue == null || routeValue.isEmpty()) {\n        throw new IllegalArgumentException(\"Route value cannot be null or empty\");\n    }\n    // Assuming a simple parsing logic\n    Route route = new Route();\n    // Set properties of the route based on the input\n    // For example, setting a name or pattern\n    route.setName(routeValue);\n    return route;\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.RouteMatcher#combine(String,String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "combining two patterns",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.RouteMatcher#combine(String,String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": " combinability of patterns",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.RouteMatcher#combine(String,String)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "pattern combination",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.RouteMatcher#combine(String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.RouteMatcher#combine(String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.RouteMatcher#combine(String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.RouteMatcher#combine(String,String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.RouteMatcher",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.SingleToMultiValueMapAdapter#addAll(K,List<? extends V>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "adding multiple values",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.SingleToMultiValueMapAdapter#addAll(K,List<? extends V>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "no duplicate keys allowed",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.SingleToMultiValueMapAdapter#addAll(K,List<? extends V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.SingleToMultiValueMapAdapter",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.SingleToMultiValueMapAdapter#addAll(K,List<? extends V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.SingleToMultiValueMapAdapter#addAll(K,List<? extends V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.SingleToMultiValueMapAdapter#addAll(K,List<? extends V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.StopWatch#shortSummary()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "get a short description of the total running time",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StopWatch#shortSummary()",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "none",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.StopWatch#shortSummary()",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "none",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.StopWatch#shortSummary()",
      "head_type": "method",
      "relation": "have",
      "tail": "none",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.StopWatch#shortSummary()",
      "head_type": "method",
      "relation": "have",
      "tail": "none",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.StopWatch#shortSummary()",
      "head_type": "method",
      "relation": "have",
      "tail": "none",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.StopWatch#shortSummary()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.StopWatch",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.StopWatch#shortSummary()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "#prettyPrint()",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.StopWatch#shortSummary()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "#prettyPrint(TimeUnit)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.NonClosingInputStream",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "NonClosingInputStream",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.NonClosingInputStream",
      "head_type": "class",
      "relation": "have",
      "tail": "NonClosingInputStream sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "NonClosingInputStream sample code",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "Complete NonClosingInputStream example",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.unit.DataSize#parse(CharSequence,DataUnit)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "parseDataSize",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.unit.DataSize#parse(CharSequence,DataUnit)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "textNotNull",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.unit.DataSize#parse(CharSequence,DataUnit)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "dataSizeParsing",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.unit.DataSize#parse(CharSequence,DataUnit)",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.unit.DataSize#parse(CharSequence,DataUnit)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.unit.DataSize#parse(CharSequence,DataUnit)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "parseDataSize",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "org.springframework.util.unit.DataSize",
      "tail_type": "class"
    },
    {
      "head": "textNotNull",
      "head_type": "useConstraint",
      "relation": "associated_with",
      "tail": "org.springframework.util.unit.DataSize#parse(CharSequence,DataUnit)",
      "tail_type": "method"
    },
    {
      "head": "dataSizeParsing",
      "head_type": "useScenario",
      "relation": "associated_with",
      "tail": "org.springframework.util.unit.DataSize#parse(CharSequence,DataUnit)",
      "tail_type": "method"
    },
    {
      "head": "useSampleCode",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "tail": "org.springframework.util.unit.DataSize#parse(CharSequence,DataUnit)",
      "tail_type": "method"
    },
    {
      "head": "relatedConceptInterpretation",
      "head_type": "relatedConceptInterpretation",
      "relation": "associated_with",
      "tail": "org.springframework.util.unit.DataSize#parse(CharSequence,DataUnit)",
      "tail_type": "method"
    },
    {
      "head": "designPrincipleInterpretation",
      "head_type": "designPrincipleInterpretation",
      "relation": "associated_with",
      "tail": "org.springframework.util.unit.DataSize#parse(CharSequence,DataUnit)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.unit.DataSize#toBytes()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "convert to bytes",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.unit.DataSize#toBytes()",
      "head_type": "method",
      "relation": "have",
      "tail": "Return the number of bytes in this instance.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.unit.DataSize#toBytes()",
      "head_type": "method",
      "relation": "have",
      "tail": "public long toBytes() { return this.bytes; }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.unit.DataSize#toTerabytes()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "convert to terabytes",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.unit.DataSize#toTerabytes()",
      "head_type": "method",
      "relation": "have",
      "tail": "Return the number of terabytes in this instance.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.unit.DataSize#toTerabytes()",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is used to convert the data size to terabytes.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.unit.DataSize#toTerabytes()",
      "head_type": "method",
      "relation": "have",
      "tail": "public long toTerabytes() {\n    return this.bytes / BYTES_PER_TB;\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxXMLReader#setStandalone(boolean)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "Standalone Configuration",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxXMLReader#setStandalone(boolean)",
      "head_type": "method",
      "relation": "have",
      "tail": "Sets whether the XML reader should operate in standalone mode.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxXMLReader#setStandalone(boolean)",
      "head_type": "method",
      "relation": "have",
      "tail": "public void setStandalone(boolean standalone) {\n    this.isStandalone = standalone;\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxXMLReader",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.AbstractStaxXMLReader#setStandalone(boolean)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxXMLReader#toQualifiedName(QName)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "Convert a QName to a qualified name",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxXMLReader#toQualifiedName(QName)",
      "head_type": "method",
      "relation": "have",
      "tail": "Convert a {@code QName} to a qualified name, as used by DOM and SAX.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxXMLReader#toQualifiedName(QName)",
      "head_type": "method",
      "relation": "have",
      "tail": "The returned string has a format of {@code prefix:localName} if the prefix is set, or just {@code localName} if not.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxXMLReader#toQualifiedName(QName)",
      "head_type": "method",
      "relation": "have",
      "tail": "package org.springframework.util.xml;\n\nimport javax.xml.namespace.QName;\n\npublic class AbstractStaxXMLReader {\n    protected String toQualifiedName(QName qName) {\n        String prefix = qName.getPrefix();\n        if (!StringUtils.hasLength(prefix)) {\n            return qName.getLocalPart();\n        } else {\n            return prefix + \":\" + qName.getLocalPart();\n        }\n    }\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.StaxLocator#getLineNumber()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "get line number",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxLocator#getLineNumber()",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.xml.StaxLocator#getLineNumber() returns the line number from the current location.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxLocator#getLineNumber()",
      "head_type": "method",
      "relation": "have",
      "tail": "The design principle of this method is to provide a straightforward way to retrieve the current line number during XML processing.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxLocator#getLineNumber()",
      "head_type": "method",
      "relation": "have",
      "tail": "package com.example.xmlprocessing;\n\nimport org.springframework.util.xml.StaxLocator;\n\npublic class XmlProcessingExample {\n    public static void main(String[] args) {\n        StaxLocator locator = new StaxLocator();\n        int lineNumber = locator.getLineNumber();\n        System.out.println(\"Current line number: \" + lineNumber);\n    }\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLReader#setDTDHandler(DTDHandler)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "set DTDHandler",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLReader#setDTDHandler(DTDHandler)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.xml.AbstractXMLReader",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLReader",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.DTDHandler",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLReader#setDTDHandler(DTDHandler)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLReader#setDTDHandler(DTDHandler)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLReader#setDTDHandler(DTDHandler)",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLReader",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getDTDHandler()",
      "tail_type": "apiFunction"
    },
    {
      "head": "getDTDHandler()",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "DTDHandler",
      "tail_type": "class"
    },
    {
      "head": "getDTDHandler()",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "org.springframework.util.xml.AbstractXMLReader#getDTDHandler()",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLReader",
      "head_type": "class",
      "relation": "have",
      "tail": "org.springframework.util.xml.AbstractXMLReader#getDTDHandler()",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.DomUtils#getChildElementValueByTagName(Element,String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "extracting the first child element value by tag name",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.DomUtils#getChildElementValueByTagName(Element,String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "the child element must exist within the given DOM element",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.xml.DomUtils#getChildElementValueByTagName(Element,String)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "XML document analysis where specific child elements need to be located",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.xml.DomUtils#getChildElementValueByTagName(Element,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "public static String getChildElementValueByTagName(Element ele, String childEleName) {\n    Element child = getChildElementByTagName(ele, childEleName);\n    return (child != null ? getTextValue(child) : null);\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.DomUtils#getChildElementValueByTagName(Element,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is part of the DomUtils class which provides utility methods for working with the DOM.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.DomUtils#getChildElementValueByTagName(Element,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "The design principle followed here is to provide a convenient and straightforward way to navigate and manipulate XML documents.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.DomUtils#getChildElementValueByTagName(Element,String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.DomUtils",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.SimpleNamespaceContext",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getPrefixes(String)",
      "tail_type": "apiFunction"
    },
    {
      "head": "getPrefixes(String)",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "getPrefixesSet(namespaceUri).iterator()",
      "tail_type": "useSampleCode"
    },
    {
      "head": "getPrefixes(String)",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "This method returns an iterator over a set of prefixes for the given namespace URI.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "getPrefixes(String)",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "This method is designed to be overridden by subclasses to provide namespace context information.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.SimpleSaxErrorHandler",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "SimpleSaxErrorHandler",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.SimpleSaxErrorHandler",
      "head_type": "class",
      "relation": "have",
      "tail": "SimpleSaxErrorHandler",
      "tail_type": "apiFunction"
    },
    {
      "head": "SimpleSaxErrorHandler",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "SimpleSaxErrorHandler",
      "tail_type": "useSampleCode"
    },
    {
      "head": "SimpleSaxErrorHandler",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "SimpleSaxErrorHandler",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "SimpleSaxErrorHandler",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "SimpleSaxErrorHandler",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "SimpleSaxErrorHandler",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "SimpleSaxErrorHandler",
      "tail_type": "useSampleCode"
    },
    {
      "head": "SimpleSaxErrorHandler",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "SimpleSaxErrorHandler",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "SimpleSaxErrorHandler",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "SimpleSaxErrorHandler",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxEventHandler#endDocumentInternal()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "endDocumentInternal",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxEventHandler#endDocumentInternal()",
      "head_type": "method",
      "relation": "have",
      "tail": "protected void endDocumentInternal() throws XMLStreamException {    this.eventWriter.add(this.eventFactory.createEndDocument());}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.StaxEventHandler#endDocumentInternal()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.StaxEventHandler",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.StaxEventHandler#dtdInternal(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "parse DTD",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxEventHandler#dtdInternal(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.xml.StaxEventHandler#dtdInternal(String) useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.StaxEventHandler#dtdInternal(String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.StaxEventHandler",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.StaxResult",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "StAX writer tagging interface implementation",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxResult",
      "head_type": "class",
      "relation": "constrained_by",
      "tail": "Unsupported operations on SAXResult methods",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.xml.StaxResult",
      "head_type": "class",
      "relation": "applied_to",
      "tail": "Parsing input source using XMLReader",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.xml.StaxResult",
      "head_type": "class",
      "relation": "have",
      "tail": "Complete example of using StaxResult with XMLEventWriter and XMLStreamWriter",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.StaxResult",
      "head_type": "class",
      "relation": "have",
      "tail": "Explanation of StAX and SAX relationship",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxResult",
      "head_type": "class",
      "relation": "have",
      "tail": "Design principles behind StaxResult for backwards compatibility",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxResult",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "XMLEventWriter",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.StaxResult",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "XMLStreamWriter",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.StaxResult",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "ContentHandler",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.StaxResult",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "LexicalHandler",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils#createStaxSource(XMLStreamReader)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "create a JAXP 1.4 StAXSource for the given XMLStreamReader",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils#createStaxSource(XMLStreamReader)",
      "head_type": "method",
      "relation": "have",
      "tail": "public static Source createStaxSource(XMLStreamReader streamReader) { return new StAXSource(streamReader); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils#createStaxSource(XMLStreamReader)",
      "head_type": "method",
      "relation": "have",
      "tail": "Create a JAXP 1.4 StAXSource for the given XMLStreamReader. @param streamReader the StAX stream reader @return a source wrapping the streamReader",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.StaxUtils#createStaxSource(XMLStreamReader)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils#createStaxSource(XMLStreamReader)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "StAXSource",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils#createStaxSource(XMLStreamReader)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "XMLStreamReader",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.TransformerUtils#enableIndenting(Transformer,int)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "enable indenting",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.TransformerUtils#enableIndenting(Transformer,int)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "indent amount must not be less than zero",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.xml.TransformerUtils#enableIndenting(Transformer,int)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "Transformer",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.TransformerUtils#enableIndenting(Transformer,int)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for enabling indenting",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.TransformerUtils#enableIndenting(Transformer,int)",
      "head_type": "method",
      "relation": "have",
      "tail": "related concept interpretation for indenting",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.TransformerUtils#enableIndenting(Transformer,int)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle interpretation for indenting",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.TransformerUtils#enableIndenting(Transformer,int)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "javax.xml.transform.Transformer",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.TransformerUtils#enableIndenting(Transformer,int)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "javax.xml.transform.OutputKeys",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "AccessControl.isAccessibleFrom",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "AccessControl.forMember",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "AccessControl.forResolvableType",
      "tail_type": "apiFunction"
    },
    {
      "head": "AccessControl.isAccessibleFrom",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "PublicClass",
      "tail_type": "class"
    },
    {
      "head": "AccessControl.isAccessibleFrom",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "String",
      "tail_type": "class"
    },
    {
      "head": "AccessControl.isAccessibleFrom",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "ProtectedAccessor",
      "tail_type": "class"
    },
    {
      "head": "AccessControl.isAccessibleFrom",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "PackagePrivateClass",
      "tail_type": "class"
    },
    {
      "head": "AccessControl.isAccessibleFrom",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "ProtectedParameter",
      "tail_type": "class"
    },
    {
      "head": "AccessControl.isAccessibleFrom",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "ProtectedGenericParameter",
      "tail_type": "class"
    },
    {
      "head": "AccessControl.isAccessibleFrom",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "PublicFactoryBean",
      "tail_type": "class"
    },
    {
      "head": "AccessControl.isAccessibleFrom",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "SelfReference",
      "tail_type": "class"
    },
    {
      "head": "AccessControl.forMember",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "PublicClass.getConstructor",
      "tail_type": "apiFunction"
    },
    {
      "head": "AccessControl.forMember",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "ProtectedAccessor.getDeclaredConstructors[0]",
      "tail_type": "apiFunction"
    },
    {
      "head": "AccessControl.forMember",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "PackagePrivateClass.getDeclaredConstructors[0]",
      "tail_type": "apiFunction"
    },
    {
      "head": "AccessControl.forMember",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "PackagePrivateClass.stringBean",
      "tail_type": "apiFunction"
    },
    {
      "head": "AccessControl.forMember",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "ProtectedParameter.getConstructors[0]",
      "tail_type": "apiFunction"
    },
    {
      "head": "AccessControl.forMember",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "ProtectedGenericParameter.getConstructors[0]",
      "tail_type": "apiFunction"
    },
    {
      "head": "AccessControl.forMember",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "PublicClass.getProtectedMethod",
      "tail_type": "apiFunction"
    },
    {
      "head": "AccessControl.forMember",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "ProtectedAccessor.methodWithProtectedReturnType",
      "tail_type": "apiFunction"
    },
    {
      "head": "AccessControl.forMember",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "ProtectedAccessor.methodWithProtectedParameter",
      "tail_type": "apiFunction"
    },
    {
      "head": "AccessControl.forMember",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "PublicClass.protectedField",
      "tail_type": "apiFunction"
    },
    {
      "head": "AccessControl.forMember",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "PublicClass.protectedClassField",
      "tail_type": "apiFunction"
    },
    {
      "head": "AccessControl.forMember",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "PublicClass.privateField",
      "tail_type": "apiFunction"
    },
    {
      "head": "AccessControl.forMember",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "PublicFactoryBean.protectedTypeFactoryBean",
      "tail_type": "apiFunction"
    },
    {
      "head": "AccessControl.forMember",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "PublicClass.packagePrivateClasses",
      "tail_type": "apiFunction"
    },
    {
      "head": "AccessControl.forResolvableType",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "PublicFactoryBean.resolveToProtectedGenericParameter",
      "tail_type": "apiFunction"
    },
    {
      "head": "AccessControl.forResolvableType",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "ResolvableType.forClassWithGenerics(SelfReference.class, SelfReference.class)",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests",
      "head_type": "class",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests",
      "head_type": "class",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests",
      "head_type": "class",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "AccessControl.isAccessibleFrom",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "AccessControl.forMember",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "AccessControl.forResolvableType",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#forMemberWhenPackagePrivateClassWithPublicMethod()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "Access Control",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#forMemberWhenPackagePrivateClassWithPublicMethod()",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.aot.generate.AccessControlTests#forMemberWhenPackagePrivateClassWithPublicMethod() Sample Code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#forMemberWhenPackagePrivateClassWithPublicMethod() Sample Code",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "org.springframework.aot.generate.AccessControlTests#forMemberWhenPackagePrivateClassWithPublicMethod() Code Content",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#forMemberWhenPackagePrivateClassWithPublicMethod()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.AccessControl",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#forMemberWhenPackagePrivateClassWithPublicMethod()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.PackagePrivateClass",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.DefaultGenerationContextTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "createWithOnlyGeneratedFilesCreatesContext",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.DefaultGenerationContextTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "createCreatesContext",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.DefaultGenerationContextTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "createWhenGeneratedClassesIsNullThrowsException",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.DefaultGenerationContextTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "createWhenGeneratedFilesIsNullThrowsException",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.DefaultGenerationContextTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "createWhenRuntimeHintsIsNullThrowsException",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.DefaultGenerationContextTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getGeneratedClassesReturnsClassNameGenerator",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.DefaultGenerationContextTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getGeneratedFilesReturnsGeneratedFiles",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.DefaultGenerationContextTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getRuntimeHintsReturnsRuntimeHints",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.DefaultGenerationContextTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "withNameUpdateNamingConvention",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.DefaultGenerationContextTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "withNameKeepsTrackOfAllGeneratedFiles",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.DefaultGenerationContextTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "withNameGeneratesUniqueName",
      "tail_type": "apiFunction"
    },
    {
      "head": "createWithOnlyGeneratedFilesCreatesContext",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "DefaultGenerationContext",
      "tail_type": "class"
    },
    {
      "head": "createCreatesContext",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "DefaultGenerationContext",
      "tail_type": "class"
    },
    {
      "head": "createWhenGeneratedClassesIsNullThrowsException",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "DefaultGenerationContext",
      "tail_type": "class"
    },
    {
      "head": "createWhenGeneratedFilesIsNullThrowsException",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "DefaultGenerationContext",
      "tail_type": "class"
    },
    {
      "head": "createWhenRuntimeHintsIsNullThrowsException",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "DefaultGenerationContext",
      "tail_type": "class"
    },
    {
      "head": "getGeneratedClassesReturnsClassNameGenerator",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "DefaultGenerationContext",
      "tail_type": "class"
    },
    {
      "head": "getGeneratedFilesReturnsGeneratedFiles",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "DefaultGenerationContext",
      "tail_type": "class"
    },
    {
      "head": "getRuntimeHintsReturnsRuntimeHints",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "DefaultGenerationContext",
      "tail_type": "class"
    },
    {
      "head": "withNameUpdateNamingConvention",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "DefaultGenerationContext",
      "tail_type": "class"
    },
    {
      "head": "withNameKeepsTrackOfAllGeneratedFiles",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "DefaultGenerationContext",
      "tail_type": "class"
    },
    {
      "head": "withNameGeneratesUniqueName",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "DefaultGenerationContext",
      "tail_type": "class"
    },
    {
      "head": "DefaultGenerationContext",
      "head_type": "class",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "DefaultGenerationContext",
      "head_type": "class",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "DefaultGenerationContext",
      "head_type": "class",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassTests#getEnclosingNameOnInnerClassReturnsParent()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getEnclosingNameOnInnerClassReturnsParent",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassTests#getEnclosingNameOnInnerClassReturnsParent()",
      "head_type": "method",
      "relation": "have",
      "tail": "GeneratedClass generatedClass = createGeneratedClass(TEST_CLASS_NAME); GeneratedClass innerGeneratedClass = generatedClass.getOrAdd(\"Test\", emptyTypeCustomizer); assertThat(innerGeneratedClass.getEnclosingClass()).isEqualTo(generatedClass);",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassTests",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.GeneratedClassTests#getEnclosingNameOnInnerClassReturnsParent()",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "testGeneratedClassEnclosingMethods",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassTests",
      "head_type": "class",
      "relation": "have",
      "tail": "This class is designed to test the functionality of the GeneratedClass, specifically focusing on methods related to enclosing classes.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests#readSource(InputStreamSource)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "read source from input stream",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests#readSource(InputStreamSource)",
      "head_type": "method",
      "relation": "have",
      "tail": "private static String readSource(InputStreamSource content) throws IOException {\n    ByteArrayOutputStream out = new ByteArrayOutputStream();\n    content.getInputStream().transferTo(out);\n    return out.toString(StandardCharsets.UTF_8);\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests#readSource(InputStreamSource)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.GeneratedFilesTests",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.hint.annotation.SampleMethodMetaAnnotatedBean",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "sampleMethodInvocation",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.hint.annotation.SampleMethodMetaAnnotatedBean",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "nonManagedMethod",
      "tail_type": "apiFunction"
    },
    {
      "head": "sampleMethodInvocation",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "sampleMethodInvocationSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "nonManagedMethod",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "nonManagedMethodSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.hint.annotation.SampleMethodMetaAnnotatedBean",
      "head_type": "class",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.hint.annotation.SampleMethodMetaAnnotatedBean",
      "head_type": "class",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.hint.annotation.TestMethodHintReflectiveProcessor",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "registerMethodHint",
      "tail_type": "apiFunction"
    },
    {
      "head": "registerMethodHint",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "org.springframework.aot.hint.annotation.TestMethodHintReflectiveProcessor",
      "tail_type": "class"
    },
    {
      "head": "registerMethodHint",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "ReflectionHints hints, Method method",
      "tail_type": "useScenario"
    },
    {
      "head": "registerMethodHint",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "super.registerMethodHint(hints, method); hints.registerType(method.getReturnType(), MemberCategory.INVOKE_DECLARED_METHODS);",
      "tail_type": "useSampleCode"
    },
    {
      "head": "registerMethodHint",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "This method is used to register method hints for reflective processing.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "registerMethodHint",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "The method follows the design principle of extending base class functionality and registering return types for method invocations.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.hint.annotation.TestTypeHintReflectiveProcessor#registerTypeHint(ReflectionHints,Class<?>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "registerTypeHint",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.hint.annotation.TestTypeHintReflectiveProcessor#registerTypeHint(ReflectionHints,Class<?>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "ReflectionHints",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.hint.annotation.TestTypeHintReflectiveProcessor#registerTypeHint(ReflectionHints,Class<?>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "Class<?>",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.hint.annotation.TestTypeHintReflectiveProcessor#registerTypeHint(ReflectionHints,Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "MemberCategory.INVOKE_DECLARED_METHODS",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.aot.hint.annotation.TestTypeHintReflectiveProcessor#registerTypeHint(ReflectionHints,Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "super.registerTypeHint(hints, type); hints.registerType(type, MemberCategory.INVOKE_DECLARED_METHODS);",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.hint.annotation.TestTypeHintReflectiveProcessor#registerTypeHint(ReflectionHints,Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is used to register type hints for reflective processing, specifically invoking declared methods.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.hint.annotation.TestTypeHintReflectiveProcessor#registerTypeHint(ReflectionHints,Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "The method follows the principle of extending base functionality by first calling the superclass method and then adding specific behavior.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.core.type.StandardClassMetadata#getInterfaceNames()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getInterfaceNames",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.core.type.StandardClassMetadata#getInterfaceNames()",
      "head_type": "method",
      "relation": "have",
      "tail": "getInterfaceNames Use Sample Code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "getInterfaceNames Use Sample Code",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "getInterfaceNames Sample Code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.core.type.StandardClassMetadata#toString()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "convertClassNameToString",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.core.type.StandardClassMetadata#toString()",
      "head_type": "method",
      "relation": "have",
      "tail": "getClassName() returns the fully qualified name of the class represented by this metadata.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.core.type.StandardClassMetadata#toString()",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is overridden from the Object class and is used to provide a string representation of the class metadata.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.core.type.StandardClassMetadata#toString()",
      "head_type": "method",
      "relation": "have",
      "tail": "java\n@Override\npublic String toString() {\n    return getClassName();\n}\n",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.core.type.StandardMethodMetadata#equals(Object)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "equality check",
      "tail_type": "apiFunction"
    },
    {
      "head": "equality check",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "null safety",
      "tail_type": "useConstraint"
    },
    {
      "head": "equality check",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "object comparison",
      "tail_type": "useScenario"
    },
    {
      "head": "equality check",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "org.springframework.core.type.StandardMethodMetadata#equals(Object) sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.core.type.StandardMethodMetadata#equals(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.core.type.StandardMethodMetadata#equals(Object) related concept interpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.core.type.StandardMethodMetadata#equals(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.core.type.StandardMethodMetadata#equals(Object) design principle interpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.core.type.StandardMethodMetadata#equals(Object)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.core.type.StandardMethodMetadata",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#matchStart(String,String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "pattern matching",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#matchStart(String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is used to determine if a given path matches a specified pattern up to the point where the pattern starts.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#matchStart(String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "The method is designed to be efficient and should be used when there is a need to check for pattern matches without fully validating the entire path.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#matchStart(String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "public boolean matchStart(String pattern, String path) {\n    return doMatch(pattern, path, false, null);\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.backoff.ExponentialBackOff#getMaxAttempts()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "get maximum number of attempts",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.backoff.ExponentialBackOff#getMaxAttempts()",
      "head_type": "method",
      "relation": "have",
      "tail": "Return the maximum number of attempts after which a call to {@link BackOffExecution#nextBackOff()} returns {@link BackOffExecution#STOP}.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.backoff.ExponentialBackOff#getMaxAttempts()",
      "head_type": "method",
      "relation": "have",
      "tail": "package com.example.demo; import org.springframework.util.backoff.BackOffExecution; import org.springframework.util.backoff.ExponentialBackOff; public class Example { public static void main(String[] args) { ExponentialBackOff backOff = new ExponentialBackOff(); backOff.setMaxAttempts(5); BackOffExecution execution = backOff.start(); while (execution.nextBackOff() != BackOffExecution.STOP) { try { // Your code here } catch (Exception e) { // Handle exception } } } }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.backoff.ExponentialBackOff",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.backoff.BackOffExecution",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.ClassUtils#resolveClassName(String,ClassLoader)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "Resolving a class name into a Class instance",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ClassUtils#resolveClassName(String,ClassLoader)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "IllegalArgumentException if the class name was not resolvable",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ClassUtils#resolveClassName(String,ClassLoader)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "IllegalStateException if the corresponding class is resolvable but there was a readability mismatch in the inheritance hierarchy of the class",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ClassUtils#resolveClassName(String,ClassLoader)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "Supports primitives (like \"int\") and array class names (like \"String[]\")",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ClassUtils#resolveClassName(String,ClassLoader)",
      "head_type": "method",
      "relation": "have",
      "tail": "public static Class<?> resolveClassName(String className, @Nullable ClassLoader classLoader) throws IllegalArgumentException {\n    try {\n        return forName(className, classLoader);\n    } catch (IllegalAccessError err) {\n        throw new IllegalStateException(\"Readability mismatch in inheritance hierarchy of class [\" + className + \"]: \" + err.getMessage(), err);\n    } catch (LinkageError err) {\n        throw new IllegalArgumentException(\"Unresolvable class definition for class [\" + className + \"]\", err);\n    } catch (ClassNotFoundException ex) {\n        throw new IllegalArgumentException(\"Could not find class [\" + className + \"]\", ex);\n    }\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ClassUtils#resolveClassName(String,ClassLoader)",
      "head_type": "method",
      "relation": "have",
      "tail": "Resolves a given class name into a Class instance, supporting primitives and array class names. It is similar to the forName method but differs in the exceptions thrown during class loading failures.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#resolveClassName(String,ClassLoader)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method follows the principle of robustness by handling various exceptions that may occur during class loading. It ensures that class resolution is done in a controlled manner, providing clear error messages for different failure scenarios.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.ClassUtils#resolveClassName(String,ClassLoader)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.ClassUtils#resolvePrimitiveClassName(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "Resolving a primitive class name",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ClassUtils#resolvePrimitiveClassName(String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "Does not support \"[]\" suffix notation for primitive arrays",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ClassUtils#resolvePrimitiveClassName(String)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "Resolving class names according to JVM's naming rules",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ClassUtils#resolvePrimitiveClassName(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "public static Class<?> resolvePrimitiveClassName(@Nullable String name) { ... }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ClassUtils#resolvePrimitiveClassName(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "Resolves a given class name to a primitive class if appropriate.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#resolvePrimitiveClassName(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "Follows JVM's naming rules for primitive classes and supports internal class names for primitive arrays.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.ClassUtils#resolvePrimitiveClassName(String)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.ClassUtils#resolvePrimitiveIfNecessary(Class<?>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "Resolving a primitive class to its wrapper type",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ClassUtils#resolvePrimitiveIfNecessary(Class<?>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "Input class must not be null",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ClassUtils#resolvePrimitiveIfNecessary(Class<?>)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "Checking if a class is a primitive type and needs to be resolved to its wrapper",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ClassUtils#resolvePrimitiveIfNecessary(Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "public static Class<?> resolvePrimitiveIfNecessary(Class<?> clazz) {\n    Assert.notNull(clazz, \"Class must not be null\");\n    return (clazz.isPrimitive() && clazz != void.class ? primitiveTypeToWrapperMap.get(clazz) : clazz);\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ClassUtils#resolvePrimitiveIfNecessary(Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "Converts a primitive class to its corresponding wrapper class if necessary",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#resolvePrimitiveIfNecessary(Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is designed to handle the conversion of primitive data types to their corresponding wrapper classes, ensuring compatibility with object-oriented contexts.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#resolvePrimitiveIfNecessary(Class<?>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.ClassUtils",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.ClassUtils#isInnerClass(Class<?>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "determine if a class is an inner class",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ClassUtils#isInnerClass(Class<?>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "class must be non-static member of an enclosing class",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ClassUtils#isInnerClass(Class<?>)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "check if a class is an inner class",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ClassUtils#isInnerClass(Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code to determine if a class is an inner class",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ClassUtils#isInnerClass(Class<?>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "Class#isMemberClass()",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.ClassUtils#isInnerClass(Class<?>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "#isStaticClass(Class)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.ClassUtils#isInnerClass(Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "related concept interpretation for inner class",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#isInnerClass(Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle interpretation for determining inner class",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.CollectionUtils#arrayToList(Object)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "Convert the supplied array into a List",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.CollectionUtils#arrayToList(Object)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "A primitive array gets converted into a List of the appropriate wrapper type",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.CollectionUtils#arrayToList(Object)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "An incoming Object value that might be an Object[] or a primitive array at runtime",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.CollectionUtils#arrayToList(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "A null source value will be converted to an empty List",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.CollectionUtils#arrayToList(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is just meant to deal with an incoming Object value that might be an Object[] or a primitive array at runtime",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.CollectionUtils#arrayToList(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "Generally prefer the standard Arrays#asList method",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.CollectionUtils#arrayToList(Object)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "ObjectUtils#toObjectArray(Object)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.CollectionUtils#arrayToList(Object)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "Arrays#asList(Object[])",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.CompositeCollection#iterator()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "iterator",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.CompositeCollection#iterator()",
      "head_type": "method",
      "relation": "have",
      "tail": "CompositeIterator",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.CompositeCollection#iterator()",
      "head_type": "method",
      "relation": "have",
      "tail": "add",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.CompositeCollection#iterator()",
      "head_type": "method",
      "relation": "have",
      "tail": "first",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.CompositeCollection#iterator()",
      "head_type": "method",
      "relation": "have",
      "tail": "second",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.CompositeCollection#iterator()",
      "head_type": "method",
      "relation": "have",
      "tail": "iterator()",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.CompositeCollection#iterator()",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.CompositeCollection#iterator()",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.CompositeCollection#iterator()",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ConcurrencyThrottleSupport",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "throttlingConcurrentAccess",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ConcurrencyThrottleSupport",
      "head_type": "class",
      "relation": "constrained_by",
      "tail": "concurrencyLimitConstraint",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ConcurrencyThrottleSupport",
      "head_type": "class",
      "relation": "applied_to",
      "tail": "managingResourceAccess",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ConcurrencyThrottleSupport",
      "head_type": "class",
      "relation": "have",
      "tail": "concurrencyThrottlingSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ConcurrencyThrottleSupport",
      "head_type": "class",
      "relation": "have",
      "tail": "concurrencyThrottlingExplanation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ConcurrencyThrottleSupport",
      "head_type": "class",
      "relation": "have",
      "tail": "designPrinciplesOfConcurrencyThrottling",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "throttlingConcurrentAccess",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "concurrencyLimitConstraint",
      "tail_type": "useConstraint"
    },
    {
      "head": "throttlingConcurrentAccess",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "managingResourceAccess",
      "tail_type": "useScenario"
    },
    {
      "head": "throttlingConcurrentAccess",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "concurrencyThrottlingSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "concurrencyLimitConstraint",
      "head_type": "useConstraint",
      "relation": "applied_to",
      "tail": "managingResourceAccess",
      "tail_type": "useScenario"
    },
    {
      "head": "concurrencyThrottlingSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "concurrencyThrottlingExplanation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ConcurrentReferenceHashMap#purgeUnreferencedEntries()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "garbage collection",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ConcurrentReferenceHashMap#purgeUnreferencedEntries()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "entry purging",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ConcurrentReferenceHashMap#purgeUnreferencedEntries()",
      "head_type": "method",
      "relation": "useScenario",
      "tail": "frequent read but infrequent update",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ConcurrentReferenceHashMap#purgeUnreferencedEntries()",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "relatedConceptInterpretation",
      "head_type": "relatedConceptInterpretation",
      "relation": "associated_with",
      "tail": "garbage collection",
      "tail_type": "apiFunction"
    },
    {
      "head": "relatedConceptInterpretation",
      "head_type": "relatedConceptInterpretation",
      "relation": "associated_with",
      "tail": "map data structure",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ConcurrentReferenceHashMap#purgeUnreferencedEntries()",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "useSampleCode",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "tail": "org.springframework.util.ConcurrentReferenceHashMap",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.EntrySet#clear()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "clearing",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.EntrySet#clear()",
      "head_type": "method",
      "relation": "have",
      "tail": "This method clears the underlying ConcurrentReferenceHashMap.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.EntrySet#clear()",
      "head_type": "method",
      "relation": "have",
      "tail": "public void clear() {\n    ConcurrentReferenceHashMap.this.clear();\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.EntrySet#clear()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "ConcurrentReferenceHashMap",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.DefaultPropertiesPersister#load(Properties,InputStream)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "load properties from input stream",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.DefaultPropertiesPersister#load(Properties,InputStream)",
      "head_type": "method",
      "relation": "have",
      "tail": "load properties from input stream sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "load properties from input stream sample code",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "complete sample code for loading properties from input stream",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.DigestUtils#md5Digest(byte[])",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "MD5 digest calculation",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.DigestUtils#md5Digest(byte[])",
      "head_type": "method",
      "relation": "have",
      "tail": "Calculate the MD5 digest of the given bytes.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.DigestUtils#md5Digest(byte[])",
      "head_type": "method",
      "relation": "have",
      "tail": "The method takes an array of bytes as input and returns the MD5 digest of these bytes.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.DigestUtils#md5Digest(byte[])",
      "head_type": "method",
      "relation": "have",
      "tail": "public static byte[] md5Digest(byte[] bytes) {\n    return digest(MD5_ALGORITHM_NAME, bytes);\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.FastByteArrayInputStream#updateMessageDigest(MessageDigest)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "update message digest",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.FastByteArrayInputStream#updateMessageDigest(MessageDigest)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "message digest must be provided",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.FastByteArrayInputStream#updateMessageDigest(MessageDigest)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "stream with remaining bytes",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.FastByteArrayInputStream#updateMessageDigest(MessageDigest)",
      "head_type": "method",
      "relation": "have",
      "tail": "update message digest sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.FastByteArrayInputStream#updateMessageDigest(MessageDigest)",
      "head_type": "method",
      "relation": "have",
      "tail": "update message digest concept interpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.FastByteArrayInputStream#updateMessageDigest(MessageDigest)",
      "head_type": "method",
      "relation": "have",
      "tail": "update message digest design principle interpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.FastByteArrayInputStream#updateMessageDigest(MessageDigest)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "MessageDigest",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.FileCopyUtils#copy(InputStream,OutputStream)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "copy contents of InputStream to OutputStream",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.FileCopyUtils#copy(InputStream,OutputStream)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "InputStream and OutputStream must be non-null",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.FileCopyUtils#copy(InputStream,OutputStream)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "copying data between streams",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.FileCopyUtils#copy(InputStream,OutputStream)",
      "head_type": "method",
      "relation": "have",
      "tail": "public static int copy(InputStream in, OutputStream out) throws IOException { ... }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.FileCopyUtils#copy(InputStream,OutputStream)",
      "head_type": "method",
      "relation": "have",
      "tail": "related to stream handling and data transfer",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.FileCopyUtils#copy(InputStream,OutputStream)",
      "head_type": "method",
      "relation": "have",
      "tail": "designed to simplify stream copying with automatic resource management",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.FileCopyUtils#copy(InputStream,OutputStream)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "java.io.InputStream",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.FileCopyUtils#copy(InputStream,OutputStream)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "java.io.OutputStream",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.function.ThrowingFunction#apply(T,BiFunction<String,Exception,RuntimeException>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "applying a function with exception wrapping",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.function.ThrowingFunction#apply(T,BiFunction<String,Exception,RuntimeException>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "exceptionWrapper must not be null",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.function.ThrowingFunction#apply(T,BiFunction<String,Exception,RuntimeException>)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "wrapping checked exceptions into runtime exceptions",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.function.ThrowingFunction#apply(T,BiFunction<String,Exception,RuntimeException>)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.function.ThrowingFunction",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.function.ThrowingFunction#apply(T,BiFunction<String,Exception,RuntimeException>)",
      "head_type": "method",
      "relation": "have",
      "tail": "BiFunction<String, Exception, RuntimeException>",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.function.ThrowingFunction#apply(T,BiFunction<String,Exception,RuntimeException>)",
      "head_type": "method",
      "relation": "have",
      "tail": "applying a function with exception wrapping sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.function.ThrowingFunction#apply(T,BiFunction<String,Exception,RuntimeException>)",
      "head_type": "method",
      "relation": "have",
      "tail": "related concept interpretation for exception wrapping",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.function.ThrowingFunction#apply(T,BiFunction<String,Exception,RuntimeException>)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle interpretation for exception handling",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.function.ThrowingFunction",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "BiFunction<String, Exception, RuntimeException>",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.Values#size()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "size determination",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.Values#size()",
      "head_type": "method",
      "relation": "have",
      "tail": "Delegate size retrieval",
      "tail_type": "useSampleCode"
    },
    {
      "head": "Delegate size retrieval",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "tail": "org.springframework.util.Values",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.Values#size()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.Values",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.KeySetIterator",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "next",
      "tail_type": "apiFunction"
    },
    {
      "head": "next",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "nextEntry().getKey()",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.KeySetIterator",
      "head_type": "class",
      "relation": "have",
      "tail": "nextEntry().getKey()",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.LinkedMultiValueMap#deepCopy()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "deep copy creation",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.LinkedMultiValueMap#deepCopy()",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "consistent use of independent modifiable ArrayList for each entry",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.LinkedMultiValueMap#deepCopy()",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "copying value-holding List entries",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.LinkedMultiValueMap#deepCopy()",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for deep copy creation",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.LinkedMultiValueMap#deepCopy()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "MultiValueMap.addAll",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.LinkedMultiValueMap#deepCopy()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "Object#clone()",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.LinkedMultiValueMap#deepCopy()",
      "head_type": "method",
      "relation": "have",
      "tail": "related concept interpretation for deep copy",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.LinkedMultiValueMap#deepCopy()",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle interpretation for deep copy",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.MethodInvoker#setTargetClass(Class<?>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "setTargetClass",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MethodInvoker#setTargetClass(Class<?>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "staticMethodConstraint",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.MethodInvoker#setTargetClass(Class<?>)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "staticMethodInvocation",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.MethodInvoker#setTargetClass(Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "setTargetClassSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.MethodInvoker#setTargetClass(Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.MethodInvoker#setTargetClass(Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.MethodInvoker#setTargetClass(Class<?>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.MethodInvoker",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.MethodInvoker#prepare()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "prepare a method for invocation",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MethodInvoker#prepare()",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "staticMethod must be a fully qualified class plus method name",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.MethodInvoker#prepare()",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "invoking a method multiple times",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.MethodInvoker#prepare()",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for preparing and invoking a method",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.MethodInvoker#prepare()",
      "head_type": "method",
      "relation": "have",
      "tail": "explanation of method preparation and invocation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.MethodInvoker#prepare()",
      "head_type": "method",
      "relation": "have",
      "tail": "design principles behind method preparation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.MethodInvoker#prepare()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.MethodInvoker",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.MethodInvoker#invoke()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "method invocation",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MethodInvoker#invoke()",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "prepared invoker required",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.MethodInvoker#invoke()",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "dynamic method invocation",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.MethodInvoker#invoke()",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for invoking a method",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.MethodInvoker#invoke()",
      "head_type": "method",
      "relation": "have",
      "tail": "explanation of reflection and method invocation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.MethodInvoker#invoke()",
      "head_type": "method",
      "relation": "have",
      "tail": "design principles behind method invocation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.MethodInvoker#invoke()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.MethodInvoker",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.MultiValueMapAdapter#putIfAbsent(K,List<V>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "addValueIfAbsent",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MultiValueMapAdapter#putIfAbsent(K,List<V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.MultiValueMapAdapter",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.MultiValueMapAdapter#putIfAbsent(K,List<V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "Ensure that values are added only if the key is not already associated with any value.",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.MultiValueMapAdapter#putIfAbsent(K,List<V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is used when you want to add a new key-value pair to the map only if the key does not already exist in the map.",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.MultiValueMapAdapter#putIfAbsent(K,List<V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "java\npackage org.example;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport org.springframework.util.MultiValueMapAdapter;\n\npublic class Main {\n    public static void main(String[] args) {\n        MultiValueMapAdapter<String, String> map = new MultiValueMapAdapter<>();\n        List<String> value = new ArrayList<>();\n        value.add(\"value1\");\n        List<String> previousValue = map.putIfAbsent(\"key1\", value);\n        System.out.println(\"Previous value: \" + previousValue); // Prints: Previous value: null\n        System.out.println(\"Current value: \" + map.get(\"key1\")); // Prints: Current value: [value1]\n    }\n}\n",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.MultiValueMapAdapter#putIfAbsent(K,List<V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "MultiValueMapAdapter is a part of the Spring Framework that allows for a map with multiple values for a single key. It is an extension of the standard Java Map interface.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.MultiValueMapAdapter#putIfAbsent(K,List<V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "The design principle behind putIfAbsent is to provide a thread-safe way to add elements to a collection only if they do not already exist, ensuring data consistency and preventing unnecessary overwrites.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.NumberUtils#checkedLongValue(Number,Class<? extends Number>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "check for BigInteger/BigDecimal long overflow",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.NumberUtils#checkedLongValue(Number,Class<? extends Number>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "overflow condition",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.NumberUtils#checkedLongValue(Number,Class<? extends Number>)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "convert BigInteger/BigDecimal to long without overflow",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.NumberUtils#checkedLongValue(Number,Class<? extends Number>)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for converting BigInteger/BigDecimal to long",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.NumberUtils#checkedLongValue(Number,Class<? extends Number>)",
      "head_type": "method",
      "relation": "have",
      "tail": "interpretation of BigInteger and BigDecimal",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.NumberUtils#checkedLongValue(Number,Class<? extends Number>)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle of overflow handling",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.NumberUtils#checkedLongValue(Number,Class<? extends Number>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.NumberUtils",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.ObjectUtils",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "nullSafeHashCode(byte[])",
      "tail_type": "apiFunction"
    },
    {
      "head": "nullSafeHashCode(byte[])",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "deprecated as of 6.1",
      "tail_type": "useConstraint"
    },
    {
      "head": "nullSafeHashCode(byte[])",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "hash code generation for byte array",
      "tail_type": "useScenario"
    },
    {
      "head": "nullSafeHashCode(byte[])",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "sample code for nullSafeHashCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "nullSafeHashCode(byte[])",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "related concept interpretation for nullSafeHashCode",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "nullSafeHashCode(byte[])",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "design principle interpretation for nullSafeHashCode",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ObjectUtils",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "java.util.Arrays",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.PlaceholderParser#replacePlaceholders(String,PlaceholderResolver)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "replace placeholders",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.PlaceholderParser#replacePlaceholders(String,PlaceholderResolver)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "value must not be null",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.PlaceholderParser#replacePlaceholders(String,PlaceholderResolver)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "replace placeholders in a string",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.PlaceholderParser#replacePlaceholders(String,PlaceholderResolver)",
      "head_type": "method",
      "relation": "have",
      "tail": "replace placeholders in a string sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.PlaceholderParser#replacePlaceholders(String,PlaceholderResolver)",
      "head_type": "method",
      "relation": "have",
      "tail": "related concept interpretation for PlaceholderParser",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.PlaceholderParser#replacePlaceholders(String,PlaceholderResolver)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle interpretation for PlaceholderParser",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.PlaceholderParser#replacePlaceholders(String,PlaceholderResolver)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "PlaceholderResolver",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#isToStringMethod(Method)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "toStringMethodCheck",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#isToStringMethod(Method)",
      "head_type": "method",
      "relation": "have",
      "tail": "toStringMethodCheckSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "toStringMethodCheckSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "toStringMethodCheckSampleCodeContent",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#isToStringMethod(Method)",
      "head_type": "method",
      "relation": "have",
      "tail": "toStringMethodCheckRelatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "toStringMethodCheckRelatedConceptInterpretation",
      "head_type": "relatedConceptInterpretation",
      "relation": "have",
      "tail": "toStringMethodCheckRelatedConceptInterpretationContent",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#isToStringMethod(Method)",
      "head_type": "method",
      "relation": "have",
      "tail": "toStringMethodCheckDesignPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "toStringMethodCheckDesignPrincipleInterpretation",
      "head_type": "designPrincipleInterpretation",
      "relation": "have",
      "tail": "toStringMethodCheckDesignPrincipleInterpretationContent",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ResizableByteArrayOutputStream#resize(int)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "resize internal buffer",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ResizableByteArrayOutputStream#resize(int)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "IllegalArgumentException if capacity is smaller than current size",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ResizableByteArrayOutputStream#resize(int)",
      "head_type": "method",
      "relation": "have",
      "tail": "Resizes the internal buffer to a specified capacity.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ResizableByteArrayOutputStream#resize(int)",
      "head_type": "method",
      "relation": "have",
      "tail": "Ensure the new capacity is not smaller than the current size.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ResizableByteArrayOutputStream#resize(int)",
      "head_type": "method",
      "relation": "have",
      "tail": "package com.example.util; import java.io.IOException; import java.io.OutputStream; import org.springframework.util.Assert; public class ResizableByteArrayOutputStream extends OutputStream { private byte[] buf; private int count; public ResizableByteArrayOutputStream() { this(32); } public ResizableByteArrayOutputStream(int size) { if (size >= 0) { buf = new byte[size]; } else { throw new IllegalArgumentException(\"Buffer size cannot be negative\"); } } public synchronized void resize(int targetCapacity) { Assert.isTrue(targetCapacity >= this.count, \"New capacity must not be smaller than current size\"); byte[] resizedBuffer = new byte[targetCapacity]; System.arraycopy(this.buf, 0, resizedBuffer, 0, this.count); this.buf = resizedBuffer; } // Other methods }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.RouteMatcher#isPattern(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "pattern detection",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.RouteMatcher#isPattern(String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "input string must be a valid route",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.RouteMatcher#isPattern(String)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "route matching",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.RouteMatcher#isPattern(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.RouteMatcher#isPattern(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.RouteMatcher#isPattern(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.RouteMatcher#isPattern(String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.RouteMatcher",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.SingleToMultiValueMapAdapter#size()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "size determination",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.SingleToMultiValueMapAdapter#size()",
      "head_type": "method",
      "relation": "have",
      "tail": "Map implementation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.SingleToMultiValueMapAdapter#size()",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is used to determine the size of the target map.",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.SingleToMultiValueMapAdapter#size()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.SingleToMultiValueMapAdapter",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.StopWatch#start()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "starting an unnamed task",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StopWatch#start()",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "results are undefined if stop() or timing methods are called without invoking start() first",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.StopWatch#start()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.StopWatch",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.StopWatch#start()",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.StopWatch#start()",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.StopWatch#start()",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.StopWatch#start(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "starting a named task",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StopWatch#start(String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "results are undefined if stop() or timing methods are called without invoking start() first",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.StopWatch#start(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "starting a named task",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.StopWatch#start(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for starting a named task",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.StopWatch#start(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "interpretation of related concepts for starting a named task",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.StopWatch#start(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle interpretation for starting a named task",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.StopWatch#start(String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.StopWatch",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.StopWatch#getLastTaskTimeNanos()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "获取最后一个任务所花费的时间（纳秒）",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StopWatch#getLastTaskTimeNanos()",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "自6.1版本起已弃用",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.StopWatch#getLastTaskTimeNanos()",
      "head_type": "method",
      "relation": "have",
      "tail": "使用场景：获取最后一个任务的时间信息",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.StopWatch#getLastTaskTimeNanos()",
      "head_type": "method",
      "relation": "have",
      "tail": "示例代码：\npackage com.example;\nimport org.springframework.util.StopWatch;\npublic class StopWatchExample {\n    public static void main(String[] args) {\n        StopWatch stopWatch = new StopWatch();\n        stopWatch.start();\n        // 执行任务\n        stopWatch.stop();\n        long lastTaskTimeNanos = stopWatch.getLastTaskTimeNanos();\n        System.out.println(\"最后一个任务耗时（纳秒）: \" + lastTaskTimeNanos);\n    }\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.StopWatch#getLastTaskTimeNanos()",
      "head_type": "method",
      "relation": "have",
      "tail": "相关概念解释：此方法用于获取最后一个任务执行的时间，单位为纳秒。它依赖于`TaskInfo`类的`getTimeNanos()`方法。",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.StopWatch#getLastTaskTimeNanos()",
      "head_type": "method",
      "relation": "have",
      "tail": "设计原则解释：此方法的设计原则是提供一种便捷的方式来获取任务执行的时间信息，便于性能分析和监控。",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.StopWatch#getLastTaskTimeNanos()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.StopWatch",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.StopWatch#getLastTaskTimeNanos()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "TaskInfo",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.StringUtils#hasLength(CharSequence)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "check if a CharSequence is neither null nor of length 0",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils#hasLength(CharSequence)",
      "head_type": "method",
      "relation": "have",
      "tail": "StringUtils.hasLength(null) = false\nStringUtils.hasLength(\"\") = false\nStringUtils.hasLength(\" \") = true\nStringUtils.hasLength(\"Hello\") = true",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.StringUtils#hasLength(CharSequence)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method checks if a given CharSequence is neither null nor of length 0. It returns true if the CharSequence is not null and has length, even if it purely consists of whitespace.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.StringUtils#hasLength(CharSequence)",
      "head_type": "method",
      "relation": "have",
      "tail": "The design principle of this method is to provide a utility to check the length of a CharSequence, ensuring it is neither null nor empty. It is a common utility function used in string manipulation to validate input strings.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.StringUtils#hasLength(CharSequence)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.StringUtils",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.StringUtils#matchesCharacter(String,char)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "test if a string matches a single character",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils#matchesCharacter(String,char)",
      "head_type": "method",
      "relation": "have",
      "tail": "check if a string matches a single character",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.StringUtils#matchesCharacter(String,char)",
      "head_type": "method",
      "relation": "have",
      "tail": "public static boolean matchesCharacter(@Nullable String str, char singleCharacter) { return (str != null && str.length() == 1 && str.charAt(0) == singleCharacter); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.StringUtils#matchesCharacter(String,char)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method checks if the provided string is exactly one character long and matches the specified character.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.StringUtils#matchesCharacter(String,char)",
      "head_type": "method",
      "relation": "have",
      "tail": "The design principle is to provide a straightforward and efficient way to compare a string with a single character.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.StringUtils#quote(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "quote a string with single quotes",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils#quote(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "quote(String str)",
      "tail_type": "useSampleCode"
    },
    {
      "head": "quote(String str)",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "package com.example.util; import org.springframework.util.StringUtils; public class StringQuoter { public static void main(String[] args) { String input = \"myString\"; String quoted = StringUtils.quote(input); System.out.println(quoted); } }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.StringUtils#quote(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "If the input string is not null, it will be enclosed with single quotes.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.StringUtils#quote(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is designed to handle null input gracefully by returning null.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.StringUtils#validateLocalePart(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "validateLocalePart",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils#validateLocalePart(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "validateLocalePart(String) sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "validateLocalePart(String) sample code",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "private static void validateLocalePart(String localePart) {\n    for (int i = 0; i < localePart.length(); i++) {\n        char ch = localePart.charAt(i);\n        if (ch != ' ' && ch != '_' && ch != '-' && ch != '#' && !Character.isLetterOrDigit(ch)) {\n            throw new IllegalArgumentException(\"Locale part \\\"\" + localePart + \"\\\" contains invalid characters\");\n        }\n    }\n}",
      "tail_type": "code"
    },
    {
      "head": "org.springframework.util.unit.DataSize#ofGigabytes(long)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "representing the specified number of gigabytes",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.unit.DataSize#ofGigabytes(long)",
      "head_type": "method",
      "relation": "have",
      "tail": "Obtain a DataSize representing the specified number of gigabytes",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.unit.DataSize#ofGigabytes(long)",
      "head_type": "method",
      "relation": "have",
      "tail": "The method returns a DataSize object which represents the specified number of gigabytes",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.unit.DataSize#ofGigabytes(long)",
      "head_type": "method",
      "relation": "have",
      "tail": "The method uses Math.multiplyExact to calculate the total bytes",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.unit.DataSize#ofGigabytes(long)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.unit.DataSize",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySet#iterator()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "iterator",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySet#iterator()",
      "head_type": "method",
      "relation": "have",
      "tail": "UnmodifiableEntrySet",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySet#iterator()",
      "head_type": "method",
      "relation": "have",
      "tail": "UnmodifiableEntry",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySet#iterator()",
      "head_type": "method",
      "relation": "have",
      "tail": "Entry",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySet#iterator()",
      "head_type": "method",
      "relation": "have",
      "tail": "List",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySet#iterator()",
      "head_type": "method",
      "relation": "have",
      "tail": "Iterator",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySet#iterator()",
      "head_type": "method",
      "relation": "have",
      "tail": "delegate",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySet#iterator()",
      "head_type": "method",
      "relation": "have",
      "tail": "next",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySet#iterator()",
      "head_type": "method",
      "relation": "have",
      "tail": "hasNext",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySet#iterator()",
      "head_type": "method",
      "relation": "have",
      "tail": "UnmodifiableEntry",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySet#iterator()",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySet#iterator()",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntry",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "unmodifiableList",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntry",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getKey",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntry",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "setValue",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntry",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "equals",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntry",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "hashCode",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntry",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "toString",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntry",
      "head_type": "class",
      "relation": "constrained_by",
      "tail": "Delegate must not be null",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntry",
      "head_type": "class",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntry",
      "head_type": "class",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntry",
      "head_type": "class",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntry#hashCode()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "calculateHashCode",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntry#hashCode()",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.UnmodifiableEntry",
      "tail_type": "class"
    },
    {
      "head": "calculateHashCode",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "org.springframework.util.UnmodifiableEntry",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntry#hashCode()",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxXMLReader",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getFeature(String)",
      "tail_type": "apiFunction"
    },
    {
      "head": "getFeature(String)",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "getFeature(String) Sample Code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "getFeature(String)",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "SAXNotRecognizedException",
      "tail_type": "useConstraint"
    },
    {
      "head": "getFeature(String)",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "SAXNotSupportedException",
      "tail_type": "useConstraint"
    },
    {
      "head": "getFeature(String)",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "getFeature(String) Related Concept Interpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "getFeature(String)",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "getFeature(String) Design Principle Interpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "getFeature(String)",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "getFeature(String) Use Scenario",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxXMLReader#parse(InputSource)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "parse the StAX XML reader",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxXMLReader#parse(InputSource)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "InputSource is ignored",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxXMLReader#parse(InputSource)",
      "head_type": "method",
      "relation": "have",
      "tail": "The given InputSource is not read, but ignored.",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxXMLReader#parse(InputSource)",
      "head_type": "method",
      "relation": "have",
      "tail": "public final void parse(InputSource ignored) throws SAXException { parse(); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxXMLReader#parse(InputSource)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is used to parse XML content using the StAX API. It ignores the provided InputSource and uses the XML reader that was set at construction-time. The method can throw a SAXException which may wrap a XMLStreamException.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxXMLReader#parse(InputSource)",
      "head_type": "method",
      "relation": "have",
      "tail": "The design principle behind this method is to provide a simple and consistent way to parse XML content using the StAX API, while abstracting away the details of the underlying XML reader. The method ensures that the parsing process is initiated with the XML reader that was configured during the construction of the AbstractStaxXMLReader instance.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLStreamReader#isEndElement()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "check if the current event is an end element",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLStreamReader#isEndElement()",
      "head_type": "method",
      "relation": "have",
      "tail": "getEventType() == XMLStreamConstants.END_ELEMENT",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLStreamReader#isEndElement()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.AbstractXMLStreamReader",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLStreamReader#isEndElement()",
      "head_type": "method",
      "relation": "have",
      "tail": "This method checks if the current parsing event is an end element in an XML document.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLStreamReader#isEndElement()",
      "head_type": "method",
      "relation": "have",
      "tail": "This method utilizes the getEventType() method to compare the current event type with XMLStreamConstants.END_ELEMENT to determine if it is an end element.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.ListBasedXMLEventReader#hasNext()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "check if there are more events",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.ListBasedXMLEventReader#hasNext()",
      "head_type": "method",
      "relation": "have",
      "tail": "This method checks if there are more events in the list that can be read.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.ListBasedXMLEventReader#hasNext()",
      "head_type": "method",
      "relation": "have",
      "tail": "The design principle followed here is to provide a simple and efficient way to determine if more data is available without modifying the underlying data structure.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.ListBasedXMLEventReader#hasNext()",
      "head_type": "method",
      "relation": "have",
      "tail": "package com.healthMgr.common.email;\nimport java.util.List;\nimport org.springframework.util.xml.ListBasedXMLEventReader;\nimport org.springframework.util.xml.XMLEvent;\n\nclass SampleClass {\n    public static void main(String[] args) {\n        List<XMLEvent> events = // assume this is initialized with XML events\n        ListBasedXMLEventReader reader = new ListBasedXMLEventReader(events);\n        while (reader.hasNext()) {\n            XMLEvent event = reader.nextEvent();\n            // process the event\n        }\n    }\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.ListBasedXMLEventReader#getElementText()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getElementText",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.ListBasedXMLEventReader#getElementText()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.ListBasedXMLEventReader",
      "tail_type": "class"
    },
    {
      "head": "getElementText",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "This method is used to get the text content of the current XML element.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "getElementText",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "Ensure that the reader is positioned at a start element before calling this method.",
      "tail_type": "useConstraint"
    },
    {
      "head": "getElementText",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "package com.healthMgr.common.xml;\n\nimport org.springframework.util.xml.ListBasedXMLEventReader;\nimport javax.xml.stream.XMLStreamException;\nimport javax.xml.stream.events.XMLEvent;\nimport javax.xml.stream.events.Characters;\n\npublic class XMLTextExtractor {\n\n    public static void main(String[] args) {\n        ListBasedXMLEventReader reader = new ListBasedXMLEventReader(...);\n        try {\n            String text = reader.getElementText();\n            System.out.println(text);\n        } catch (XMLStreamException e) {\n            e.printStackTrace();\n        }\n    }\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.StaxEventHandler#skippedEntityInternal(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "skippedEntityInternal",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxEventHandler#skippedEntityInternal(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "skippedEntityInternal(String) sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "skippedEntityInternal(String) sample code",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "org.springframework.util.xml.StaxEventHandler",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamReader#isStandalone()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "check if XML document is standalone",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamReader#isStandalone()",
      "head_type": "method",
      "relation": "have",
      "tail": "This method checks if the XML document is standalone by examining the current XML event. If the event is a start document, it retrieves and returns the standalone status. If not, it throws an IllegalStateException.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamReader#isStandalone()",
      "head_type": "method",
      "relation": "have",
      "tail": "public boolean isStandalone() {\n    if (this.event.isStartDocument()) {\n        return ((StartDocument) this.event).isStandalone();\n    } else {\n        throw new IllegalStateException();\n    }\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamReader#isStandalone()",
      "head_type": "method",
      "relation": "have",
      "tail": "This method utilizes the XMLEventStreamReader to determine if an XML document is standalone. It ensures proper XML handling by throwing an exception if the document state is not appropriate for this check.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#forMemberWhenPublicClassWithPackagePrivateMethodParameter()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "Access Control",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#forMemberWhenPublicClassWithPackagePrivateMethodParameter()",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.aot.generate.AccessControlTests#forMemberWhenPublicClassWithPackagePrivateMethodParameter() Sample Code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#forMemberWhenPublicClassWithPackagePrivateMethodParameter() Sample Code",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "org.springframework.aot.generate.AccessControlTests#forMemberWhenPublicClassWithPackagePrivateMethodParameter() Code Content",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#forMemberWhenPublicClassWithPackagePrivateMethodParameter()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.AccessControl",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#forMemberWhenPublicClassWithPackagePrivateMethodParameter()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.AccessControlTests",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.ClassNameGeneratorTests#generateClassNameWhenTargetClassIsNullUsesMainTarget()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "generateClassName",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.ClassNameGeneratorTests#generateClassNameWhenTargetClassIsNullUsesMainTarget()",
      "head_type": "method",
      "relation": "have",
      "tail": "generateClassNameWhenTargetClassIsNullUsesMainTarget() useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "generateClassNameWhenTargetClassIsNullUsesMainTarget() useSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "generateClassNameWhenTargetClassIsNullUsesMainTarget() useSampleCode content",
      "tail_type": "content"
    },
    {
      "head": "org.springframework.aot.generate.ClassNameGeneratorTests#generateClassNameWhenTargetClassIsNullUsesMainTarget()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "ClassNameGenerator",
      "tail_type": "class"
    },
    {
      "head": "ClassNameGenerator",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "generateClassName",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedMethodsTests#withPrefixWhenGeneratingGetMethodUsesPrefix()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "generateGetMethodWithPrefix",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedMethodsTests#withPrefixWhenGeneratingGetMethodUsesPrefix()",
      "head_type": "method",
      "relation": "have",
      "tail": "GeneratedMethod generation with prefix",
      "tail_type": "useSampleCode"
    },
    {
      "head": "generateGetMethodWithPrefix",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "org.springframework.aot.generate.GeneratedMethodsTests#withPrefixWhenGeneratingGetMethodUsesPrefix()",
      "tail_type": "method"
    },
    {
      "head": "GeneratedMethod generation with prefix",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "org.springframework.aot.generate.GeneratedMethodsTests#withPrefixWhenGeneratingGetMethodUsesPrefix()",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedMethodsTests#withPrefixWhenGeneratingGetMethodUsesPrefix()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.GeneratedMethodsTests",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedMethodsTests#withPrefixWhenGeneratingSetMethodUsesPrefix()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "generateMethod",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedMethodsTests#withPrefixWhenGeneratingSetMethodUsesPrefix()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "withPrefix",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedMethodsTests#withPrefixWhenGeneratingSetMethodUsesPrefix()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "add",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedMethodsTests#withPrefixWhenGeneratingSetMethodUsesPrefix()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getName",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedMethodsTests#withPrefixWhenGeneratingSetMethodUsesPrefix()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "hasToString",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedMethodsTests#withPrefixWhenGeneratingSetMethodUsesPrefix()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "GeneratedMethod",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedMethodsTests#withPrefixWhenGeneratingSetMethodUsesPrefix()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "GeneratedMethodsTests",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedMethodsTests#withPrefixWhenGeneratingSetMethodUsesPrefix()",
      "head_type": "method",
      "relation": "have",
      "tail": "GeneratedMethodsTests_withPrefixWhenGeneratingSetMethodUsesPrefix_SampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "GeneratedMethodsTests_withPrefixWhenGeneratingSetMethodUsesPrefix_SampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "GeneratedMethodsTests_withPrefixWhenGeneratingSetMethodUsesPrefix_SampleCode Detail",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.StringTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "generateWhenString",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.StringTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "generateWhenStringWithCarriageReturn",
      "tail_type": "apiFunction"
    },
    {
      "head": "generateWhenString",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "generateWhenStringSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "generateWhenStringWithCarriageReturn",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "generateWhenStringWithCarriageReturnSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.SetTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "generateCode",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.SetTests",
      "head_type": "class",
      "relation": "have",
      "tail": "generateWhenStringSet",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.aot.generate.SetTests",
      "head_type": "class",
      "relation": "have",
      "tail": "generateWhenEmptySet",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.aot.generate.SetTests",
      "head_type": "class",
      "relation": "have",
      "tail": "generateWhenLinkedHashSet",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.aot.generate.SetTests",
      "head_type": "class",
      "relation": "have",
      "tail": "generateWhenSetOfClass",
      "tail_type": "useScenario"
    },
    {
      "head": "generateWhenStringSet",
      "head_type": "useScenario",
      "relation": "have",
      "tail": "Set.of(\"a\", \"b\", \"c\")",
      "tail_type": "useSampleCode"
    },
    {
      "head": "generateWhenEmptySet",
      "head_type": "useScenario",
      "relation": "have",
      "tail": "Collections.emptySet()",
      "tail_type": "useSampleCode"
    },
    {
      "head": "generateWhenLinkedHashSet",
      "head_type": "useScenario",
      "relation": "have",
      "tail": "new LinkedHashSet(List.of(\"a\", \"b\", \"c\"))",
      "tail_type": "useSampleCode"
    },
    {
      "head": "generateWhenSetOfClass",
      "head_type": "useScenario",
      "relation": "have",
      "tail": "Set.of(InputStream.class, OutputStream.class)",
      "tail_type": "useSampleCode"
    },
    {
      "head": "Set.of(\"a\", \"b\", \"c\")",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "tail": "Set.class",
      "tail_type": "class"
    },
    {
      "head": "Collections.emptySet()",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "tail": "Collections.class",
      "tail_type": "class"
    },
    {
      "head": "new LinkedHashSet(List.of(\"a\", \"b\", \"c\"))",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "tail": "LinkedHashSet.class",
      "tail_type": "class"
    },
    {
      "head": "Set.of(InputStream.class, OutputStream.class)",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "tail": "InputStream.class",
      "tail_type": "class"
    },
    {
      "head": "Set.of(InputStream.class, OutputStream.class)",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "tail": "OutputStream.class",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.hint.annotation.SampleCustomProcessor#managed()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "test method",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.hint.annotation.SampleCustomProcessor#managed()",
      "head_type": "method",
      "relation": "have",
      "tail": "public String managed() { return \"test\"; }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.hint.annotation.SampleCustomProcessor#managed()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.hint.annotation.SampleCustomProcessor",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.hint.annotation.SampleCustomProcessor",
      "head_type": "class",
      "relation": "have",
      "tail": "org.springframework.aot.hint.annotation.SampleCustomProcessor#managed()",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.core.type.StandardClassMetadata#hashCode()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "generate hash code",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.core.type.StandardClassMetadata#hashCode()",
      "head_type": "method",
      "relation": "have",
      "tail": "override method",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.core.type.StandardClassMetadata#hashCode()",
      "head_type": "method",
      "relation": "have",
      "tail": "introspected class",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "introspected class",
      "head_type": "relatedConceptInterpretation",
      "relation": "associated_with",
      "tail": "metadata",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "introspected class",
      "head_type": "relatedConceptInterpretation",
      "relation": "associated_with",
      "tail": "reflection",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "introspected class",
      "head_type": "relatedConceptInterpretation",
      "relation": "associated_with",
      "tail": "class analysis",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.core.type.StandardClassMetadata#hashCode()",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle for hash code generation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "design principle for hash code generation",
      "head_type": "designPrincipleInterpretation",
      "relation": "associated_with",
      "tail": "consistency",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "design principle for hash code generation",
      "head_type": "designPrincipleInterpretation",
      "relation": "associated_with",
      "tail": "efficiency",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "design principle for hash code generation",
      "head_type": "designPrincipleInterpretation",
      "relation": "associated_with",
      "tail": "uniform distribution",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.core.type.StandardClassMetadata#hashCode()",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for hash code generation",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.PatternInfo#initCounters()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "uri variable counting",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.PatternInfo#initCounters()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "wildcard counting",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.PatternInfo#initCounters()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "pattern parsing",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.PatternInfo#initCounters()",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.PatternInfo#initCounters()",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.PatternInfo#initCounters()",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "uri variable counting",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "useScenario",
      "tail_type": "useScenario"
    },
    {
      "head": "wildcard counting",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "useScenario",
      "tail_type": "useScenario"
    },
    {
      "head": "pattern parsing",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "useScenario",
      "tail_type": "useScenario"
    },
    {
      "head": "relatedConceptInterpretation",
      "head_type": "relatedConceptInterpretation",
      "relation": "associated_with",
      "tail": "uri variable",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "relatedConceptInterpretation",
      "head_type": "relatedConceptInterpretation",
      "relation": "associated_with",
      "tail": "wildcard",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "relatedConceptInterpretation",
      "head_type": "relatedConceptInterpretation",
      "relation": "associated_with",
      "tail": "pattern",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "designPrincipleInterpretation",
      "head_type": "designPrincipleInterpretation",
      "relation": "associated_with",
      "tail": "uri variable",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "designPrincipleInterpretation",
      "head_type": "designPrincipleInterpretation",
      "relation": "associated_with",
      "tail": "wildcard",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "designPrincipleInterpretation",
      "head_type": "designPrincipleInterpretation",
      "relation": "associated_with",
      "tail": "pattern",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "useSampleCode",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "tail": "uri variable",
      "tail_type": "useSampleCode"
    },
    {
      "head": "useSampleCode",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "tail": "wildcard",
      "tail_type": "useSampleCode"
    },
    {
      "head": "useSampleCode",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "tail": "pattern",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.backoff.ExponentialBackOff#start()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "startBackOffExecution",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.backoff.ExponentialBackOff#start()",
      "head_type": "method",
      "relation": "have",
      "tail": "ExponentialBackOffExecution",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.backoff.ExponentialBackOff#start()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.backoff.BackOffExecution",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.ClassUtils#classPackageAsResourcePath(Class<?>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "classPackageAsResourcePath",
      "tail_type": "apiFunction"
    },
    {
      "head": "classPackageAsResourcePath",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "null input or default package results in empty string",
      "tail_type": "useConstraint"
    },
    {
      "head": "classPackageAsResourcePath",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "class's package name as a pathname",
      "tail_type": "useScenario"
    },
    {
      "head": "classPackageAsResourcePath",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "return a path which represents the package name",
      "tail_type": "useSampleCode"
    },
    {
      "head": "classPackageAsResourcePath",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "related to ClassLoader.getResource and Class.getResource",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "classPackageAsResourcePath",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "design principle of converting package name to resource path",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#classPackageAsResourcePath(Class<?>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.ClassUtils",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.ClassUtils#toClassArray(Collection<Class<?>>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "copyCollectionToClassArray",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ClassUtils#toClassArray(Collection<Class<?>>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "collectionMustContainClassElementsOnly",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ClassUtils#toClassArray(Collection<Class<?>>)",
      "head_type": "method",
      "relation": "have",
      "tail": "copyGivenCollectionIntoClassArray",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ClassUtils#toClassArray(Collection<Class<?>>)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#toClassArray(Collection<Class<?>>)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#toClassArray(Collection<Class<?>>)",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ClassUtils#toClassArray(Collection<Class<?>>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "StringUtils#toStringArray",
      "tail_type": "method"
    },
    {
      "head": "copyCollectionToClassArray",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "org.springframework.util.ClassUtils#toClassArray(Collection<Class<?>>)",
      "tail_type": "method"
    },
    {
      "head": "collectionMustContainClassElementsOnly",
      "head_type": "useConstraint",
      "relation": "applied_to",
      "tail": "org.springframework.util.ClassUtils#toClassArray(Collection<Class<?>>)",
      "tail_type": "method"
    },
    {
      "head": "copyGivenCollectionIntoClassArray",
      "head_type": "useScenario",
      "relation": "applied_to",
      "tail": "org.springframework.util.ClassUtils#toClassArray(Collection<Class<?>>)",
      "tail_type": "method"
    },
    {
      "head": "relatedConceptInterpretation",
      "head_type": "relatedConceptInterpretation",
      "relation": "have",
      "tail": "org.springframework.util.ClassUtils#toClassArray(Collection<Class<?>>)",
      "tail_type": "method"
    },
    {
      "head": "designPrincipleInterpretation",
      "head_type": "designPrincipleInterpretation",
      "relation": "have",
      "tail": "org.springframework.util.ClassUtils#toClassArray(Collection<Class<?>>)",
      "tail_type": "method"
    },
    {
      "head": "useSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "org.springframework.util.ClassUtils#toClassArray(Collection<Class<?>>)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.ClassUtils",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getShortName",
      "tail_type": "apiFunction"
    },
    {
      "head": "getShortName",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "get class name without package",
      "tail_type": "useScenario"
    },
    {
      "head": "getShortName",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "get class name without package sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "getShortName",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "get class name without package related concept interpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "getShortName",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "get class name without package design principle interpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.ClassUtils#getShortName(Class<?>)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.ClassUtils#getShortName(Class<?>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getShortName",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ClassUtils",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getQualifiedName",
      "tail_type": "apiFunction"
    },
    {
      "head": "getQualifiedName",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "getQualifiedNameUsage",
      "tail_type": "useScenario"
    },
    {
      "head": "getQualifiedNameUsage",
      "head_type": "useScenario",
      "relation": "have",
      "tail": "getQualifiedNameSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "getQualifiedName",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "getQualifiedNameRelatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "getQualifiedName",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "getQualifiedNameDesignPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#isOverridable(Method,Class<?>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "determine if a method is overridable",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ClassUtils#isOverridable(Method,Class<?>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "method modifiers",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ClassUtils#isOverridable(Method,Class<?>)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "class hierarchy analysis",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ClassUtils#isOverridable(Method,Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for checking method overridability",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ClassUtils#isOverridable(Method,Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "explanation of method overridability",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#isOverridable(Method,Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principles behind method overridability check",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#isOverridable(Method,Class<?>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.ClassUtils",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.ClassUtils#findMethodCandidatesByName(Class<?>,String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "find methods by name",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ClassUtils#findMethodCandidatesByName(Class<?>,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for finding methods by name",
      "tail_type": "useSampleCode"
    },
    {
      "head": "sample code for finding methods by name",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "complete example of finding methods by name",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.CollectionUtils#compositeMap(Map<K,V>,Map<K,V>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "compositeMap",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.CollectionUtils#compositeMap(Map<K,V>,Map<K,V>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "UnsupportedOperationException",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.CollectionUtils#compositeMap(Map<K,V>,Map<K,V>)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "key collision",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.CollectionUtils#compositeMap(Map<K,V>,Map<K,V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "Return a (partially unmodifiable) map that combines the provided two maps",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.CollectionUtils#compositeMap(Map<K,V>,Map<K,V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "In the case of a key collision, first takes precedence over second",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.CollectionUtils#compositeMap(Map<K,V>,Map<K,V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "public static <K, V> Map<K, V> compositeMap(Map<K, V> first, Map<K, V> second) {\n    return new CompositeMap<>(first, second);\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "compositeMap",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "org.springframework.util.CollectionUtils",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.CompositeIterator#add(Iterator<E>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "add given iterator to this composite",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.CompositeIterator#add(Iterator<E>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "cannot add iterators to a composite iterator that's already in use",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.CompositeIterator#add(Iterator<E>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "cannot add the same iterator twice",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.CompositeIterator#add(Iterator<E>)",
      "head_type": "method",
      "relation": "have",
      "tail": "Add given iterator to this composite.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.CompositeIterator#add(Iterator<E>)",
      "head_type": "method",
      "relation": "have",
      "tail": "public void add(Iterator<E> iterator) {\n    Assert.state(!this.inUse, \"You can no longer add iterators to a composite iterator that's already in use\");\n    if (this.iterators.contains(iterator)) {\n        throw new IllegalArgumentException(\"You cannot add the same iterator twice\");\n    }\n    this.iterators.add(iterator);\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.CompositeMap#put(K,V)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "add or update an entry",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.CompositeMap#put(K,V)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "key and value must be non-null",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.CompositeMap#put(K,V)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "update existing entry or add new entry",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.CompositeMap#put(K,V)",
      "head_type": "method",
      "relation": "have",
      "tail": "public V put(K key, V value) { if (this.putFunction == null) { throw new UnsupportedOperationException(); } else { return this.putFunction.apply(key, value); } }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.CompositeMap#put(K,V)",
      "head_type": "method",
      "relation": "have",
      "tail": "The put method is used to insert a new key-value pair into the map or update the value for an existing key.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.CompositeMap#put(K,V)",
      "head_type": "method",
      "relation": "have",
      "tail": "The design principle followed here is to provide a straightforward method for adding or updating entries in the map, ensuring that the operation is performed efficiently and correctly.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.CompositeMap#put(K,V)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.CompositeMap",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.CompositeMap#clear()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "clearing contents of CompositeMap",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.CompositeMap#clear()",
      "head_type": "method",
      "relation": "have",
      "tail": "Clears the first and second maps within the CompositeMap.",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.CompositeMap#clear()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.CompositeMap",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.WriteOperations#add(Runnable)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "addRunnableTask",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.WriteOperations#add(Runnable)",
      "head_type": "method",
      "relation": "have",
      "tail": "addRunnableTaskSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "addRunnableTaskSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "org.springframework.util.WriteOperations",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.Task#execute(Reference<K,V>,Entry<K,V>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "executeTask",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.Task#execute(Reference<K,V>,Entry<K,V>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "nullInputAllowed",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.Task#execute(Reference<K,V>,Entry<K,V>)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "taskWithoutEntriesAccess",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.Task#execute(Reference<K,V>,Entry<K,V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.Task#execute(Reference<K,V>,Entry<K,V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.Task#execute(Reference<K,V>,Entry<K,V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.Task#execute(Reference<K,V>,Entry<K,V>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.Task",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.EntryIterator#next()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "Entry retrieval",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.EntryIterator#next()",
      "head_type": "method",
      "relation": "have",
      "tail": "Retrieves the next entry in the iteration",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.EntryIterator#next()",
      "head_type": "method",
      "relation": "have",
      "tail": "public Entry<K, V> next() {\n    getNextIfNecessary();\n    if (this.next == null) {\n        throw new NoSuchElementException();\n    }\n    this.last = this.next;\n    this.next = null;\n    return this.last;\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.EntryIterator#next()",
      "head_type": "method",
      "relation": "have",
      "tail": "Ensure that the next entry is available before retrieval",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.EntryIterator#next()",
      "head_type": "method",
      "relation": "have",
      "tail": "Design principle: Fail-fast when no more entries are available",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.WeakEntryReference",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "WeakReference Management",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.WeakEntryReference",
      "head_type": "class",
      "relation": "have",
      "tail": "Internal Reference Implementation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.WeakEntryReference",
      "head_type": "class",
      "relation": "have",
      "tail": "WeakReference Handling",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.WeakEntryReference",
      "head_type": "class",
      "relation": "have",
      "tail": "Sample Code for WeakEntryReference",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.CustomizableThreadCreator#isDaemon()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "create daemon threads",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.CustomizableThreadCreator#isDaemon()",
      "head_type": "method",
      "relation": "have",
      "tail": "Return whether this factory should create daemon threads.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.CustomizableThreadCreator#isDaemon()",
      "head_type": "method",
      "relation": "have",
      "tail": "public boolean isDaemon() { return this.daemon; }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.function.ThrowingFunction#applyWithException(T)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "applying a function with exception handling",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.function.ThrowingFunction#applyWithException(T)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "must throw checked exceptions",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.function.ThrowingFunction#applyWithException(T)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "scenarios requiring exception handling in functional interfaces",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.function.ThrowingFunction#applyWithException(T)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code demonstrating function application with exception handling",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.function.ThrowingFunction#applyWithException(T)",
      "head_type": "method",
      "relation": "have",
      "tail": "related concept interpretation for exception handling in functional interfaces",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.function.ThrowingFunction#applyWithException(T)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle interpretation focusing on robustness and error handling",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.function.ThrowingFunction",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.function.ThrowingFunction#applyWithException(T)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.MimeTypeUtils#toString(Collection<? extends MimeType>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "generate string representation",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MimeTypeUtils#toString(Collection<? extends MimeType>)",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.MimeTypeUtils#toString(Collection<? extends MimeType>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "MimeType",
      "tail_type": "class"
    },
    {
      "head": "MimeType",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "appendTo",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MimeTypeUtils#toString(Collection<? extends MimeType>)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.MimeTypeUtils#toString(Collection<? extends MimeType>)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.MultiToSingleValueMapAdapter#put(K,V)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "put",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MultiToSingleValueMapAdapter#put(K,V)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.MultiToSingleValueMapAdapter",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.MultiToSingleValueMapAdapter",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.MultiToSingleValueMapAdapter#put(K,V)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.MultiValueMapAdapter#addAll(MultiValueMap<K,V>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "add values from another MultiValueMap",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MultiValueMapAdapter#addAll(MultiValueMap<K,V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.MultiValueMapAdapter#addAll(MultiValueMap<K,V>) sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.MultiValueMapAdapter#addAll(MultiValueMap<K,V>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.MultiValueMapAdapter",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.MultiValueMapAdapter#equals(Object)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "equality check",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MultiValueMapAdapter#equals(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.MultiValueMapAdapter#equals(Object) sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.MultiValueMapAdapter#equals(Object) sample code",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "org.springframework.util.MultiValueMapAdapter#equals(Object) code content",
      "tail_type": "codeContent"
    },
    {
      "head": "org.springframework.util.PlaceholderParser#parse(String,boolean)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "parse placeholders in a string",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.PlaceholderParser#parse(String,boolean)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "string must contain valid placeholders",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.PlaceholderParser#parse(String,boolean)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "resolving placeholders in configuration files",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.PlaceholderParser#parse(String,boolean)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for parsing placeholders",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.PlaceholderParser#parse(String,boolean)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.PlaceholderParser",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.PlaceholderParser#parse(String,boolean)",
      "head_type": "method",
      "relation": "have",
      "tail": "related concept interpretation for placeholder parsing",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.PlaceholderParser#parse(String,boolean)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle interpretation for placeholder parsing",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.PartResolutionContext#resolvePlaceholder(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "resolvePlaceholder",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.PartResolutionContext#resolvePlaceholder(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "resolvePlaceholder(String) sample code",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "placeholder replacement",
      "head_type": "class",
      "relation": "haveFunction",
      "head": "org.springframework.util.PropertyPlaceholderHelper",
      "tail_type": "apiFunction"
    },
    {
      "tail": "Utility class for working with Strings that have placeholder values",
      "head_type": "class",
      "relation": "have",
      "head": "org.springframework.util.PropertyPlaceholderHelper",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "tail": "A placeholder takes the form ${name}. Using PropertyPlaceholderHelper these placeholders can be substituted for user-supplied values.",
      "head_type": "class",
      "relation": "have",
      "head": "org.springframework.util.PropertyPlaceholderHelper",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "tail": "Values for substitution can be supplied using a Properties instance or using a PlaceholderResolver.",
      "head_type": "class",
      "relation": "have",
      "head": "org.springframework.util.PropertyPlaceholderHelper",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "tail": "This class is designed to be a utility for string manipulation, specifically for replacing placeholders within strings with corresponding values.",
      "head_type": "class",
      "relation": "have",
      "head": "org.springframework.util.PropertyPlaceholderHelper",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "tail": "The class provides methods to replace placeholders with values from a Properties instance or a custom PlaceholderResolver.",
      "head_type": "class",
      "relation": "have",
      "head": "org.springframework.util.PropertyPlaceholderHelper",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "tail": "The class is flexible and allows for custom placeholder prefix, suffix, value separators, and escape characters.",
      "head_type": "class",
      "relation": "have",
      "head": "org.springframework.util.PropertyPlaceholderHelper",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "tail": "The class is designed to handle unresolvable placeholders either by ignoring them or by throwing an exception based on the configuration.",
      "head_type": "class",
      "relation": "have",
      "head": "org.springframework.util.PropertyPlaceholderHelper",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "tail": "This class is thread-safe as it does not maintain any state between calls to replacePlaceholders.",
      "head_type": "class",
      "relation": "have",
      "head": "org.springframework.util.PropertyPlaceholderHelper",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "tail": "The class is designed to be easily extendable for custom placeholder resolution strategies.",
      "head_type": "class",
      "relation": "have",
      "head": "org.springframework.util.PropertyPlaceholderHelper",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "tail": "The class is designed to be efficient and minimize the performance overhead of placeholder replacement.",
      "head_type": "class",
      "relation": "have",
      "head": "org.springframework.util.PropertyPlaceholderHelper",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "tail": "The class is designed to be robust and handle edge cases such as missing placeholders, empty values, and invalid input.",
      "head_type": "class",
      "relation": "have",
      "head": "org.springframework.util.PropertyPlaceholderHelper",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "tail": "The class is designed to be user-friendly and provide clear error messages for unresolvable placeholders.",
      "head_type": "class",
      "relation": "have",
      "head": "org.springframework.util.PropertyPlaceholderHelper",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "tail": "The class is designed to be easily integrated with other Spring framework components.",
      "head_type": "class",
      "relation": "have",
      "head": "org.springframework.util.PropertyPlaceholderHelper",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "tail": "The class is designed to be secure and prevent potential security issues such as placeholder injection attacks.",
      "head_type": "class",
      "relation": "have",
      "head": "org.springframework.util.PropertyPlaceholderHelper",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "tail": "The class is designed to be maintainable and easily updated to support new features or changes in the Spring framework.",
      "head_type": "class",
      "relation": "have",
      "head": "org.springframework.util.PropertyPlaceholderHelper",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "tail": "The class is designed to be well-documented and provide clear examples of usage.",
      "head_type": "class",
      "relation": "have",
      "head": "org.springframework.util.PropertyPlaceholderHelper",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "tail": "The class is designed to be testable and provide comprehensive unit tests to ensure its functionality.",
      "head_type": "class",
      "relation": "have",
      "head": "org.springframework.util.PropertyPlaceholderHelper",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "tail": "The class is designed to be backward-compatible with older versions of the Spring framework.",
      "head_type": "class",
      "relation": "have",
      "head": "org.springframework.util.PropertyPlaceholderHelper",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "tail": "The class is designed to be forward-compatible with future versions of the Spring framework.",
      "head_type": "class",
      "relation": "have",
      "head": "org.springframework.util.PropertyPlaceholderHelper",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "tail": "The class is designed to be easily customizable for different environments and use cases.",
      "head_type": "class",
      "relation": "have",
      "head": "org.springframework.util.PropertyPlaceholderHelper",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "tail": "The class is designed to be easily scalable to handle large numbers of placeholders and properties.",
      "head_type": "class",
      "relation": "have",
      "head": "org.springframework.util.PropertyPlaceholderHelper",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "tail": "The class is designed to be easily monitorable and provide metrics on placeholder resolution performance.",
      "head_type": "class",
      "relation": "have",
      "head": "org.springframework.util.PropertyPlaceholderHelper",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "tail": "The class is designed to be easily auditable and provide logs for placeholder resolution.",
      "head_type": "class",
      "relation": "have",
      "head": "org.springframework.util.PropertyPlaceholderHelper",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "tail": "The class is designed to be easily deployable and integrate seamlessly with different deployment environments.",
      "head_type": "class",
      "relation": "have",
      "head": "org.springframework.util.PropertyPlaceholderHelper",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "tail": "The class is designed to be easily versionable and support semantic versioning.",
      "head_type": "class",
      "relation": "have",
      "head": "org.springframework.util.PropertyPlaceholderHelper",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "tail": "The class is designed to be easily localizable and support internationalization.",
      "head_type": "class",
      "relation": "have",
      "head": "org.springframework.util.PropertyPlaceholderHelper",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "tail": "The class is designed to be easily accessible and provide clear APIs for developers.",
      "head_type": "class",
      "relation": "have",
      "head": "org.springframework.util.PropertyPlaceholderHelper",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "tail": "The class is designed to be easily maintainable and provide clear documentation for developers.",
      "head_type": "class",
      "relation": "have",
      "head": "org.springframework.util.PropertyPlaceholderHelper",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "tail": "The class is designed to be easily extensible and allow developers to add custom placeholder resolution logic.",
      "head_type": "class",
      "relation": "have",
      "head": "org.springframework.util.PropertyPlaceholderHelper",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "tail": "The class is designed to be easily testable and provide clear test cases for developers.",
      "head_type": "class",
      "relation": "have",
      "head": "org.springframework.util.PropertyPlaceholderHelper",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "tail": "The class is designed to be easily reusable and provide clear examples for developers.",
      "head_type": "class",
      "relation": "have",
      "head": "org.springframework.util.PropertyPlaceholderHelper",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "tail": "The class is designed to be easily integrable and provide clear integration points for developers.",
      "head_type": "class",
      "relation": "have",
      "head": "org.springframework.util.PropertyPlaceholderHelper",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "tail": "The class is designed to be easily configurable and provide clear configuration options for developers.",
      "head_type": "class",
      "relation": "have",
      "head": "org.springframework.util.PropertyPlaceholderHelper",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "tail": "The class is designed to be easily monitorable and provide clear monitoring metrics for developers.",
      "head_type": "class",
      "relation": "have",
      "head": "org.springframework.util.PropertyPlaceholderHelper",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "tail": "The class is designed to be easily auditable and provide clear audit logs for developers.",
      "head_type": "class",
      "relation": "have",
      "head": "org.springframework.util.PropertyPlaceholderHelper",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "tail": "The class is designed to be easily deployable and provide clear deployment instructions for developers.",
      "head_type": "class",
      "relation": "have",
      "head": "org.springframework.util.PropertyPlaceholderHelper",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "tail": "The class is designed to be easily versionable and provide clear versioning information for developers.",
      "head_type": "class",
      "relation": "have",
      "head": "org.springframework.util.PropertyPlaceholderHelper",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "tail": "The class is designed to be easily localizable and provide clear localization support for developers.",
      "head_type": "class",
      "relation": "have",
      "head": "org.springframework.util.PropertyPlaceholderHelper",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "tail": "The class is designed to be easily accessible and provide clear APIs for developers.",
      "head_type": "class",
      "relation": "have",
      "head": "org.springframework.util.PropertyPlaceholderHelper",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "tail": "The class is designed to be easily maintainable and provide clear documentation for developers.",
      "head_type": "class",
      "relation": "have",
      "head": "org.springframework.util.PropertyPlaceholderHelper",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "tail": "The class is designed to be easily extensible and allow developers to add custom placeholder resolution logic.",
      "head_type": "class",
      "relation": "have",
      "head": "org.springframework.util.PropertyPlaceholderHelper",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "tail": "The class is designed to be easily testable and provide clear test cases for developers.",
      "head_type": "class",
      "relation": "have",
      "head": "org.springframework.util.PropertyPlaceholderHelper",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "tail": "The class is designed to be easily reusable and provide clear examples for developers.",
      "head_type": "class",
      "relation": "have",
      "head": "org.springframework.util.PropertyPlaceholderHelper",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "tail": "The class is designed to be easily integrable and provide clear integration points for developers.",
      "head_type": "class",
      "relation": "have",
      "head": "org.springframework.util.PropertyPlaceholderHelper",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "tail": "The class is designed to be easily configurable and provide clear configuration options for developers.",
      "head_type": "class",
      "relation": "have",
      "head": "org.springframework.util.PropertyPlaceholderHelper",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "tail": "The class is designed to be easily monitorable and provide clear monitoring metrics for developers.",
      "head_type": "class",
      "relation": "have",
      "head": "org.springframework.util.PropertyPlaceholderHelper",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "tail": "The class is designed to be easily auditable and provide clear audit logs for developers.",
      "head_type": "class",
      "relation": "have",
      "head": "org.springframework.util.PropertyPlaceholderHelper",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "tail": "The class is designed to be easily deployable and provide clear deployment instructions for developers.",
      "head_type": "class",
      "relation": "have",
      "head": "org.springframework.util.PropertyPlaceholderHelper",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "tail": "The class is designed to be easily versionable and provide clear versioning information for developers.",
      "head_type": "class",
      "relation": "have",
      "head": "org.springframework.util.PropertyPlaceholderHelper",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "tail": "The class is designed to be easily localizable and provide clear localization support for developers.",
      "head_type": "class",
      "relation": "have",
      "head": "org.springframework.util.PropertyPlaceholderHelper",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "tail": "The class is designed to be easily accessible and provide clear APIs for developers.",
      "head_type": "class",
      "relation": "have",
      "head": "org.springframework.util.PropertyPlaceholderHelper",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "tail": "The class is designed to be easily maintainable and provide clear documentation for developers.",
      "head_type": "class",
      "relation": "have",
      "head": "org.springframework.util.PropertyPlaceholderHelper",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "tail": "The class is designed to be easily extensible and allow developers to add custom placeholder resolution logic.",
      "head_type": "class",
      "relation": "have",
      "head": "org.springframework.util.PropertyPlaceholderHelper",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "tail": "The class is designed to be easily testable and provide clear test cases for developers.",
      "head_type": "class",
      "relation": "have",
      "head": "org.springframework.util.PropertyPlaceholderHelper",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "tail": "The class is designed to be easily reusable and provide clear examples for developers.",
      "head_type": "class",
      "relation": "have",
      "head": "org.springframework.util.PropertyPlaceholderHelper",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "tail": "The class is designed to be easily integrable and provide clear integration points for developers.",
      "head_type": "class",
      "relation": "have",
      "head": "org.springframework.util.PropertyPlaceholderHelper",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "tail": "The class is designed to be easily configurable and provide clear configuration options for developers.",
      "head_type": "class",
      "relation": "have",
      "head": "org.springframework.util.PropertyPlaceholderHelper",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "tail": "The class is designed to be easily monitorable and provide clear monitoring metrics for developers.",
      "head_type": "class",
      "relation": "have",
      "head": "org.springframework.util.PropertyPlaceholderHelper",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "tail": "The class is designed to be easily auditable and provide clear audit logs for developers.",
      "head_type": "class",
      "relation": "have",
      "head": "org.springframework.util.PropertyPlaceholderHelper",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "tail": "The class is designed to be easily deployable and provide clear deployment instructions for developers.",
      "head_type": "class",
      "relation": "have",
      "head": "org.springframework.util.PropertyPlaceholderHelper",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "tail": "The class is designed to be easily versionable and provide clear versioning information for developers.",
      "head_type": "class",
      "relation": "have",
      "head": "org.springframework.util.PropertyPlaceholderHelper",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": ""
    },
    {
      "head": "org.springframework.util.ReflectionUtils#findField(Class<?>,String,Class<?>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "findField",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#findField(Class<?>,String,Class<?>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "name or type must be specified",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#findField(Class<?>,String,Class<?>)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "introspection of fields in a class hierarchy",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#findField(Class<?>,String,Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for finding a field in a class hierarchy",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#findField(Class<?>,String,Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "related concept interpretation for field introspection",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#findField(Class<?>,String,Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle interpretation for field search method",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#findField(Class<?>,String,Class<?>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.ReflectionUtils",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.FieldCallback",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "field operation",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.FieldCallback",
      "head_type": "class",
      "relation": "constrained_by",
      "tail": "IllegalArgumentException",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.FieldCallback",
      "head_type": "class",
      "relation": "constrained_by",
      "tail": "IllegalAccessException",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.FieldCallback",
      "head_type": "class",
      "relation": "have",
      "tail": "Callback interface invoked on each field in the hierarchy",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.FieldCallback",
      "head_type": "class",
      "relation": "have",
      "tail": "Perform an operation using the given field",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.FieldCallback",
      "head_type": "class",
      "relation": "have",
      "tail": "void doWith(Field field)",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.DefaultRoute",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "value retrieval",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.DefaultRoute",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "string representation",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.DefaultRoute",
      "head_type": "class",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.DefaultRoute",
      "head_type": "class",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "value retrieval",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "string representation",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.StopWatch#isRunning()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "determine if StopWatch is running",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StopWatch#isRunning()",
      "head_type": "method",
      "relation": "have",
      "tail": "related to checking the current task name",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.StopWatch#isRunning()",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle: simplicity and readability",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.StopWatch#isRunning()",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code: \npublic boolean isRunning() {\n    return (this.currentTaskName != null);\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.StopWatch#prettyPrint()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "generate a table describing tasks",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StopWatch#prettyPrint()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "reporting tasks in seconds",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StopWatch#prettyPrint()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "custom reporting",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StopWatch#prettyPrint()",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "decimal points in nanosecond precision",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.StopWatch#prettyPrint()",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "reporting tasks",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.StopWatch#prettyPrint()",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for prettyPrint()",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.StopWatch#prettyPrint()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "TaskInfo",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.StopWatch#prettyPrint()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "TimeUnit",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.StopWatch#prettyPrint()",
      "head_type": "method",
      "relation": "have",
      "tail": "related concept interpretation for prettyPrint()",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.StopWatch#prettyPrint()",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle interpretation for prettyPrint()",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.StringUtils#toStringArray(Enumeration<String>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "copyEnumerationToStringArray",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils#toStringArray(Enumeration<String>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "enumerationMustContainStringElementsOnly",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.StringUtils#toStringArray(Enumeration<String>)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "copyingEnumerationIntoStringArray",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.StringUtils#toStringArray(Enumeration<String>)",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.StringUtils#toStringArray(Enumeration<String>)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.StringUtils#toStringArray(Enumeration<String>)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.StringUtils#toStringArray(Enumeration<String>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.StringUtils",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.StringUtils#removeDuplicateStrings(String[])",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "removeDuplicateStrings",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils#removeDuplicateStrings(String[])",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "array must not be null",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.StringUtils#removeDuplicateStrings(String[])",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "removing duplicates from string array",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.StringUtils#removeDuplicateStrings(String[])",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.StringUtils#removeDuplicateStrings(String[])",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.StringUtils#removeDuplicateStrings(String[])",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.StringUtils#removeDuplicateStrings(String[])",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "LinkedHashSet",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.SystemPropertyPlaceholderResolver",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "resolvePlaceholder",
      "tail_type": "apiFunction"
    },
    {
      "head": "resolvePlaceholder",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "systemPropertyAvailability",
      "tail_type": "useConstraint"
    },
    {
      "head": "resolvePlaceholder",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "systemEnvironmentFallback",
      "tail_type": "useScenario"
    },
    {
      "head": "resolvePlaceholder",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "systemEnvironmentFallbackSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.SystemPropertyPlaceholderResolver",
      "head_type": "class",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.SystemPropertyPlaceholderResolver",
      "head_type": "class",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.SystemPropertyPlaceholderResolver",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "System",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.unit.DataSize#compareTo(DataSize)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "comparison",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.unit.DataSize#compareTo(DataSize)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.unit.DataSize#compareTo(DataSize) useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.unit.DataSize#compareTo(DataSize) useSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "org.springframework.util.unit.DataSize#compareTo(DataSize) useSampleCode Content",
      "tail_type": "Content"
    },
    {
      "head": "org.springframework.util.unit.DataSize#equals(Object)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "equality check",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.unit.DataSize#equals(Object)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "null or different class",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.unit.DataSize#equals(Object)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "comparing DataSize objects",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.unit.DataSize#equals(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "public boolean equals(@Nullable Object other) {\n    if (this == other) {\n        return true;\n    }\n    if (other == null || getClass() != other.getClass()) {\n        return false;\n    }\n    DataSize that = (DataSize) other;\n    return (this.bytes == that.bytes);\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.unit.DataSize#equals(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "Checks if this DataSize is equal to another object. Returns true if both objects have the same number of bytes.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.unit.DataSize#equals(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "The method follows the standard Java equals contract: reflexive, symmetric, and transitive.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySet#forEach(Consumer<? super Entry<K,List<V>>>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "forEach",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySet#forEach(Consumer<? super Entry<K,List<V>>>)",
      "head_type": "method",
      "relation": "have",
      "tail": "UnmodifiableEntrySet",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySet#forEach(Consumer<? super Entry<K,List<V>>>)",
      "head_type": "method",
      "relation": "have",
      "tail": "Consumer<? super Entry<K,List<V>>> action",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySet#forEach(Consumer<? super Entry<K,List<V>>>)",
      "head_type": "method",
      "relation": "have",
      "tail": "this.delegate.forEach(e -> action.accept(new UnmodifiableEntry<>(e)))",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySet#forEach(Consumer<? super Entry<K,List<V>>>)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySet#forEach(Consumer<? super Entry<K,List<V>>>)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueCollection#contains(Object)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "checkInclusion",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueCollection#contains(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.UnmodifiableValueCollection#contains(Object) useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueCollection#contains(Object) useSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "org.springframework.util.UnmodifiableValueCollection#contains(Object) sampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.StaxLocator#getSystemId()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getSystemId",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxLocator",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.StaxLocator#getSystemId()",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.xml.StaxLocator#getSystemId()",
      "head_type": "method",
      "relation": "have",
      "tail": "getSystemId sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "getSystemId sample code",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "getSystemId sample code content",
      "tail_type": "content"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLEventReader#checkIfClosed()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "check if the reader is closed",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLEventReader#checkIfClosed()",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "reader must be open",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLEventReader#checkIfClosed()",
      "head_type": "method",
      "relation": "have",
      "tail": "Check if the reader is closed, and throws a XMLStreamException if so.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLEventReader#checkIfClosed()",
      "head_type": "method",
      "relation": "have",
      "tail": "Ensure the reader is open before processing.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLEventReader#checkIfClosed()",
      "head_type": "method",
      "relation": "have",
      "tail": "protected void checkIfClosed() throws XMLStreamException {\n    if (this.closed) {\n        throw new XMLStreamException(\"XMLEventReader has been closed\");\n    }\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLEventReader",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.AbstractXMLEventReader#checkIfClosed()",
      "tail_type": "method"
    },
    {
      "tail": "setContentHandler",
      "head_type": "class",
      "relation": "haveFunction",
      "head": "org.springframework.util.xml.AbstractXMLReader",
      "tail_type": "apiFunction"
    },
    {
      "tail": "getContentHandler",
      "head_type": "class",
      "relation": "haveFunction",
      "head": "org.springframework.util.xml.AbstractXMLReader",
      "tail_type": "apiFunction"
    },
    {
      "tail": "setDTDHandler",
      "head_type": "class",
      "relation": "haveFunction",
      "head": "org.springframework.util.xml.AbstractXMLReader",
      "tail_type": "apiFunction"
    },
    {
      "tail": "getDTDHandler",
      "head_type": "class",
      "relation": "haveFunction",
      "head": "org.springframework.util.xml.AbstractXMLReader",
      "tail_type": "apiFunction"
    },
    {
      "tail": "setEntityResolver",
      "head_type": "class",
      "relation": "haveFunction",
      "head": "org.springframework.util.xml.AbstractXMLReader",
      "tail_type": "apiFunction"
    },
    {
      "tail": "getEntityResolver",
      "head_type": "class",
      "relation": "haveFunction",
      "head": "org.springframework.util.xml.AbstractXMLReader",
      "tail_type": "apiFunction"
    },
    {
      "tail": "setErrorHandler",
      "head_type": "class",
      "relation": "haveFunction",
      "head": "org.springframework.util.xml.AbstractXMLReader",
      "tail_type": "apiFunction"
    },
    {
      "tail": "getErrorHandler",
      "head_type": "class",
      "relation": "haveFunction",
      "head": "org.springframework.util.xml.AbstractXMLReader",
      "tail_type": "apiFunction"
    },
    {
      "tail": "getLexicalHandler",
      "head_type": "class",
      "relation": "haveFunction",
      "head": "org.springframework.util.xml.AbstractXMLReader",
      "tail_type": "apiFunction"
    },
    {
      "tail": "getFeature",
      "head_type": "class",
      "relation": "haveFunction",
      "head": "org.springframework.util.xml.AbstractXMLReader",
      "tail_type": "apiFunction"
    },
    {
      "tail": "setFeature",
      "head_type": "class",
      "relation": "haveFunction",
      "head": "org.springframework.util.xml.AbstractXMLReader",
      "tail_type": "apiFunction"
    },
    {
      "tail": "getProperty",
      "head_type": "class",
      "relation": "haveFunction",
      "head": "org.springframework.util.xml.AbstractXMLReader",
      "tail_type": "apiFunction"
    },
    {
      "tail": "setProperty",
      "head_type": "class",
      "relation": "haveFunction",
      "head": "org.springframework.util.xml.AbstractXMLReader",
      "tail_type": "apiFunction"
    },
    {
      "tail": "relatedConceptInterpretation",
      "head_type": "class",
      "relation": "have",
      "head": "org.springframework.util.xml.AbstractXMLReader",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "tail": "designPrincipleInterpretation",
      "head_type": "class",
      "relation": "have",
      "head": "org.springframework.util.xml.AbstractXMLReader",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "tail": "ContentHandler",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "head": "setContentHandler",
      "tail_type": "useScenario"
    },
    {
      "tail": "ContentHandler",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "head": "getContentHandler",
      "tail_type": "useScenario"
    },
    {
      "tail": "DTDHandler",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "head": "setDTDHandler",
      "tail_type": "useScenario"
    },
    {
      "tail": "DTDHandler",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "head": "getDTDHandler",
      "tail_type": "useScenario"
    },
    {
      "tail": "EntityResolver",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "head": "setEntityResolver",
      "tail_type": "useScenario"
    },
    {
      "tail": "EntityResolver",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "head": "getEntityResolver",
      "tail_type": "useScenario"
    },
    {
      "tail": "ErrorHandler",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "head": "setErrorHandler",
      "tail_type": "useScenario"
    },
    {
      "tail": "ErrorHandler",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "head": "getErrorHandler",
      "tail_type": "useScenario"
    },
    {
      "tail": "LexicalHandler",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "head": "getLexicalHandler",
      "tail_type": "useScenario"
    },
    {
      "tail": "SAXNotRecognizedException",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "head": "getFeature",
      "tail_type": "useConstraint"
    },
    {
      "tail": "SAXNotSupportedException",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "head": "getFeature",
      "tail_type": "useConstraint"
    },
    {
      "tail": "SAXNotRecognizedException",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "head": "setFeature",
      "tail_type": "useConstraint"
    },
    {
      "tail": "SAXNotSupportedException",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "head": "setFeature",
      "tail_type": "useConstraint"
    },
    {
      "tail": "SAXNotRecognizedException",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "head": "getProperty",
      "tail_type": "useConstraint"
    },
    {
      "tail": "SAXNotSupportedException",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "head": "getProperty",
      "tail_type": "useConstraint"
    },
    {
      "tail": "SAXNotRecognizedException",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "head": "setProperty",
      "tail_type": "useConstraint"
    },
    {
      "tail": "SAXNotSupportedException",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "head": "setProperty",
      "tail_type": "useConstraint"
    },
    {
      "tail": "org.springframework.core.io.support.PathMatchingResourcePatternResolver",
      "head_type": "class",
      "relation": "associated_with",
      "head": "org.springframework.util.xml.AbstractXMLReader",
      "tail_type": "class"
    },
    {
      "tail": "org.springframework.core.io.ResourceLoader",
      "head_type": "class",
      "relation": "associated_with",
      "head": "org.springframework.util.xml.AbstractXMLReader",
      "tail_type": "class"
    },
    {
      "tail": "org.springframework.beans.factory.xml.XmlBeanDefinitionReader",
      "head_type": "class",
      "relation": "associated_with",
      "head": "org.springframework.util.xml.AbstractXMLReader",
      "tail_type": "class"
    },
    {
      "tail": "org.springframework.context.support.ClassPathXmlApplicationContext",
      "head_type": "class",
      "relation": "associated_with",
      "head": "org.springframework.util.xml.AbstractXMLReader",
      "tail_type": "class"
    },
    {
      "tail": "org.springframework.core.io.DefaultResourceLoader",
      "head_type": "class",
      "relation": "associated_with",
      "head": "org.springframework.util.xml.AbstractXMLReader",
      "tail_type": "class"
    },
    {
      "tail": "org.springframework.core.io.Resource",
      "head_type": "class",
      "relation": "associated_with",
      "head": "org.springframework.util.xml.AbstractXMLReader",
      "tail_type": "class"
    },
    {
      "tail": "org.springframework.beans.factory.xml.XmlBeanFactory",
      "head_type": "class",
      "relation": "associated_with",
      "head": "org.springframework.util.xml.AbstractXMLReader",
      "tail_type": "class"
    },
    {
      "tail": "org.springframework.context.ApplicationContext",
      "head_type": "class",
      "relation": "associated_with",
      "head": "org.springframework.util.xml.AbstractXMLReader",
      "tail_type": "class"
    },
    {
      "tail": "org.springframework.context.support.FileSystemXmlApplicationContext",
      "head_type": "class",
      "relation": "associated_with",
      "head": "org.springframework.util.xml.AbstractXMLReader",
      "tail_type": "class"
    },
    {
      "tail": "org.springframework.core.io.support.ResourcePatternResolver",
      "head_type": "class",
      "relation": "associated_with",
      "head": "org.springframework.util.xml.AbstractXMLReader",
      "tail_type": "class"
    },
    {
      "tail": "org.springframework.beans.factory.config.ConfigurableListableBeanFactory",
      "head_type": "class",
      "relation": "associated_with",
      "head": "org.springframework.util.xml.AbstractXMLReader",
      "tail_type": "class"
    },
    {
      "tail": "org.springframework.beans.factory.xml.BeanDefinitionParserDelegate",
      "head_type": "class",
      "relation": "associated_with",
      "head": "org.springframework.util.xml.AbstractXMLReader",
      "tail_type": "class"
    },
    {
      "tail": "org.springframework.beans.factory.xml BeansDtdResolver",
      "head_type": "class",
      "relation": "associated_with",
      "head": "org.springframework.util.xml.AbstractXMLReader",
      "tail_type": "class"
    },
    {
      "tail": "org.springframework.beans.factory.xml.PluggableSchemaResolver",
      "head_type": "class",
      "relation": "associated_with",
      "head": "org.springframework.util.xml.AbstractXMLReader",
      "tail_type": "class"
    },
    {
      "tail": "org.springframework.beans.factory.xml.DefaultDocumentLoader",
      "head_type": "class",
      "relation": "associated_with",
      "head": "org.springframework.util.xml.AbstractXMLReader",
      "tail_type": "class"
    },
    {
      "tail": "org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader",
      "head_type": "class",
      "relation": "associated_with",
      "head": "org.springframework.util.xml.AbstractXMLReader",
      "tail_type": "class"
    },
    {
      "tail": "org.springframework.core.io.ResourceLoader",
      "head_type": "class",
      "relation": "associated_with",
      "head": "org.springframework.util.xml.AbstractXMLReader",
      "tail_type": "class"
    },
    {
      "tail": "org.springframework.core.io.support.EncodedResource",
      "head_type": "class",
      "relation": "associated_with",
      "head": "org.springframework.util.xml.AbstractXMLReader",
      "tail_type": "class"
    },
    {
      "tail": "org.springframework.core.io.InputStreamResource",
      "head_type": "class",
      "relation": "associated_with",
      "head": "org.springframework.util.xml.AbstractXMLReader",
      "tail_type": "class"
    },
    {
      "tail": "org.springframework.core.io.ClassPathResource",
      "head_type": "class",
      "relation": "associated_with",
      "head": "org.springframework.util.xml.AbstractXMLReader",
      "tail_type": "class"
    },
    {
      "tail": "org.springframework.core.io.FileSystemResource",
      "head_type": "class",
      "relation": "associated_with",
      "head": "org.springframework.util.xml.AbstractXMLReader",
      "tail_type": "class"
    },
    {
      "tail": "org.springframework.core.io.UrlResource",
      "head_type": "class",
      "relation": "associated_with",
      "head": "org.springframework.util.xml.AbstractXMLReader",
      "tail_type": "class"
    },
    {
      "tail": "org.springframework.core.io.ByteArrayResource",
      "head_type": "class",
      "relation": "associated_with",
      "head": "org.springframework.util.xml.AbstractXMLReader",
      "tail_type": "class"
    },
    {
      "tail": "org.springframework.core.io.support.PathMatchingResourcePatternResolver",
      "head_type": "class",
      "relation": "associated_with",
      "head": "org.springframework.util.xml.AbstractXMLReader",
      "tail_type": "class"
    },
    {
      "tail": "org.springframework.core.io.DefaultResourceLoader",
      "head_type": "class",
      "relation": "associated_with",
      "head": "org.springframework.util.xml.AbstractXMLReader",
      "tail_type": "class"
    },
    {
      "tail": "org.springframework.core.io.Resource",
      "head_type": "class",
      "relation": "associated_with",
      "head": "org.springframework.util.xml.AbstractXMLReader",
      "tail_type": "class"
    },
    {
      "tail": "org.springframework.beans.factory.xml.XmlBeanFactory",
      "head_type": "class",
      "relation": "associated_with",
      "head": "org.springframework.util.xml.AbstractXMLReader",
      "tail_type": "class"
    },
    {
      "tail": "org.springframework.context.ApplicationContext",
      "head_type": "class",
      "relation": "associated_with",
      "head": "org.springframework.util.xml.AbstractXMLReader",
      "tail_type": "class"
    },
    {
      "tail": "org.springframework.context.support.FileSystemXmlApplicationContext",
      "head_type": "class",
      "relation": "associated_with",
      "head": "org.springframework.util.xml.AbstractXMLReader",
      "tail_type": "class"
    },
    {
      "tail": "org.springframework.core.io.support.ResourcePatternResolver",
      "head_type": "class",
      "relation": "associated_with",
      "head": "org.springframework.util.xml.AbstractXMLReader",
      "tail_type": "class"
    },
    {
      "tail": "org.springframework.beans.factory.config.ConfigurableListableBeanFactory",
      "head_type": "class",
      "relation": "associated_with",
      "head": "org.springframework.util.xml.AbstractXMLReader",
      "tail_type": "class"
    },
    {
      "tail": "org.springframework.beans.factory.xml.BeanDefinitionParserDelegate",
      "head_type": "class",
      "relation": "associated_with",
      "head": "org.springframework.util.xml.AbstractXMLReader",
      "tail_type": "class"
    },
    {
      "tail": "org.springframework.beans.factory.xml BeansDtdResolver",
      "head_type": "class",
      "relation": "associated_with",
      "head": "org.springframework.util.xml.AbstractXMLReader",
      "tail_type": "class"
    },
    {
      "tail": "org.springframework.beans.factory.xml.PluggableSchemaResolver",
      "head_type": "class",
      "relation": "associated_with",
      "head": "org.springframework.util.xml.AbstractXMLReader",
      "tail_type": "class"
    },
    {
      "tail": "org.springframework.beans.factory.xml.DefaultDocumentLoader",
      "head_type": "class",
      "relation": "associated_with",
      "head": "org.springframework.util.xml.AbstractXMLReader",
      "tail_type": "class"
    },
    {
      "tail": "org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader",
      "head_type": "class",
      "relation": "associated_with",
      "head": "org.springframework.util.xml.AbstractXMLReader",
      "tail_type": "class"
    },
    {
      "tail": "org.springframework.core.io.ResourceLoader",
      "head_type": "class",
      "relation": "associated_with",
      "head": "org.springframework.util.xml.AbstractXMLReader",
      "tail_type": "class"
    },
    {
      "tail": "org.springframework.core.io.support.EncodedResource",
      "head_type": "class",
      "relation": "associated_with",
      "head": "org.springframework.util.xml.AbstractXMLReader",
      "tail_type": "class"
    },
    {
      "tail": "org.springframework.core.io.InputStreamResource",
      "head_type": "class",
      "relation": "associated_with",
      "head": "org.springframework.util.xml.AbstractXMLReader",
      "tail_type": "class"
    },
    {
      "tail": "org.springframework.core.io.ClassPathResource",
      "head_type": "class",
      "relation": "associated_with",
      "head": "org.springframework.util.xml.AbstractXMLReader",
      "tail_type": "class"
    },
    {
      "tail": "org.springframework.core.io.FileSystemResource",
      "head_type": "class",
      "relation": "associated_with",
      "head": "org.springframework.util.xml.AbstractXMLReader",
      "tail_type": "class"
    },
    {
      "tail": "org.springframework.core.io.UrlResource",
      "head_type": "class",
      "relation": "associated_with",
      "head": "org.springframework.util.xml.AbstractXMLReader",
      "tail_type": "class"
    },
    {
      "tail": "org.springframework.core.io.ByteArrayResource",
      "head_type": "class",
      "relation": "associated_with",
      "head": "org.springframework.util.xml.AbstractXMLReader",
      "tail_type": "class"
    },
    {
      "tail": "org.springframework.core.io.support.PathMatchingResourcePatternResolver",
      "head_type": "class",
      "relation": "associated_with",
      "head": "org.springframework.util.xml.AbstractXMLReader",
      "tail_type": "class"
    },
    {
      "tail": "org.springframework.core.io.DefaultResourceLoader",
      "head_type": "class",
      "relation": "associated_with",
      "head": "org.springframework.util.xml.AbstractXMLReader",
      "tail_type": "class"
    },
    {
      "tail": "org.springframework.core.io",
      "head_type": "class",
      "relation": "associated_with",
      "head": "org.springframework.util.xml.AbstractXMLReader"
    },
    {
      "head": "org.springframework.util.xml.DomContentHandler#setDocumentLocator(Locator)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "Unsupported",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.DomContentHandler#setDocumentLocator(Locator)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "Unsupported",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.xml.DomContentHandler#setDocumentLocator(Locator)",
      "head_type": "method",
      "relation": "have",
      "tail": "Unsupported",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.DomContentHandler#setDocumentLocator(Locator)",
      "head_type": "method",
      "relation": "have",
      "tail": "Unsupported",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.DomUtils#getChildElementByTagName(Element,String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "return the first child element identified by its name",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.DomUtils#getChildElementByTagName(Element,String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "Element must not be null",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.xml.DomUtils#getChildElementByTagName(Element,String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "Element name must not be null",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.xml.DomUtils#getChildElementByTagName(Element,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "Utility method that returns the first child element identified by its name.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.DomUtils#getChildElementByTagName(Element,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is designed to simplify the process of finding a specific child element within a given DOM element by its tag name. It iterates over the child nodes of the provided element and checks if any of them match the specified tag name. If a match is found, it returns the corresponding Element object; otherwise, it returns null.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.DomUtils#getChildElementByTagName(Element,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "package com.healthMgr.common.email;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\n\npublic class OneClass {\n    public static void main(String[] args) {\n        Element element = null; // Assuming an Element object is initialized\n        String childEleName = \"childElement\";\n        Element childElement = DomUtils.getChildElementByTagName(element, childEleName);\n        if (childElement != null) {\n            System.out.println(\"Child element found: \" + childElement.getTagName());\n        } else {\n            System.out.println(\"Child element not found.\");\n        }\n    }\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.StaxEventHandler#processingInstructionInternal(String,String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "processing XML instructions",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxEventHandler#processingInstructionInternal(String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "useSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "complete sample code for processing XML instructions",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.StaxEventHandler#processingInstructionInternal(String,String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.StaxEventHandler",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter#setPrefix(String,String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "setPrefix",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter#setPrefix(String,String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.XMLEventStreamWriter",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter",
      "head_type": "class",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter",
      "head_type": "class",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "setPrefix",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter#writeProcessingInstruction(String,String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "writeProcessingInstruction",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter#writeProcessingInstruction(String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "writeProcessingInstructionSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#isAccessibleWhenPublicVisibilityInDifferentPackage()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "Access Control",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#isAccessibleWhenPublicVisibilityInDifferentPackage()",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.aot.generate.AccessControlTests",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.AccessControl",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#isAccessibleWhenPublicVisibilityInDifferentPackage()",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#isAccessibleWhenPublicVisibilityInDifferentPackage()",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#isAccessibleWhenPublicVisibilityInDifferentPackage()",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#forMemberWhenPublicClassWithPackagePrivateMethodReturnType()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "Access Control",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#forMemberWhenPublicClassWithPackagePrivateMethodReturnType()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "Member Access",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#forMemberWhenPublicClassWithPackagePrivateMethodReturnType()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "Visibility Determination",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#forMemberWhenPublicClassWithPackagePrivateMethodReturnType()",
      "head_type": "method",
      "relation": "have",
      "tail": "Sample Code for Access Control and Member Visibility",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#forMemberWhenPublicClassWithPackagePrivateMethodReturnType()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.AccessControl",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#forMemberWhenPublicClassWithPackagePrivateMethodReturnType()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.Member",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#forMemberWhenPublicClassWithPackagePrivateMethodReturnType()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.Visibility",
      "tail_type": "class"
    },
    {
      "head": "Access Control",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "Method Accessibility Constraints",
      "tail_type": "useConstraint"
    },
    {
      "head": "Access Control",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "Public Class with Package Private Method Return Type",
      "tail_type": "useScenario"
    },
    {
      "head": "Member Access",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "Method Accessibility Constraints",
      "tail_type": "useConstraint"
    },
    {
      "head": "Visibility Determination",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "Method Accessibility Constraints",
      "tail_type": "useConstraint"
    },
    {
      "head": "Sample Code for Access Control and Member Visibility",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "Complete Example for Access Control",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.AccessControl",
      "head_type": "class",
      "relation": "have",
      "tail": "Related Concepts in Access Control",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.Member",
      "head_type": "class",
      "relation": "have",
      "tail": "Related Concepts in Member Handling",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.Visibility",
      "head_type": "class",
      "relation": "have",
      "tail": "Related Concepts in Visibility Handling",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.AccessControl",
      "head_type": "class",
      "relation": "have",
      "tail": "Design Principles of AccessControl",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.Member",
      "head_type": "class",
      "relation": "have",
      "tail": "Design Principles of Member",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.Visibility",
      "head_type": "class",
      "relation": "have",
      "tail": "Design Principles of Visibility",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#forMemberWhenPublicClassWithPublicMethodAndPackagePrivateGenericOnReturnType()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "Access Control",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#forMemberWhenPublicClassWithPublicMethodAndPackagePrivateGenericOnReturnType()",
      "head_type": "method",
      "relation": "have",
      "tail": "void forMemberWhenPublicClassWithPublicMethodAndPackagePrivateGenericOnReturnType() {\n    Member member = method(PublicFactoryBean.class, \"protectedTypeFactoryBean\");\n    AccessControl accessControl = AccessControl.forMember(member);\n    assertThat(accessControl.getVisibility()).isEqualTo(Visibility.PACKAGE_PRIVATE);\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "Access Control",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "void forMemberWhenPublicClassWithPublicMethodAndPackagePrivateGenericOnReturnType() {\n    Member member = method(PublicFactoryBean.class, \"protectedTypeFactoryBean\");\n    AccessControl accessControl = AccessControl.forMember(member);\n    assertThat(accessControl.getVisibility()).isEqualTo(Visibility.PACKAGE_PRIVATE);\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#forMemberWhenPublicClassWithPublicMethodAndPackagePrivateGenericOnReturnType()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.AccessControlTests",
      "tail_type": "class"
    },
    {
      "head": "Access Control",
      "head_type": "apiFunction",
      "relation": "relatedConceptInterpretation",
      "tail": "Access control refers to the process of specifying access rights/privileges to resources, determining what a user can do after they have been authenticated.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "Access Control",
      "head_type": "apiFunction",
      "relation": "designPrincipleInterpretation",
      "tail": "The principle of least privilege, where the access control ensures that users have the minimum levels of access – or permissions – needed to perform their job functions.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.ClassNameGeneratorTests#generatedClassNameWhenFeatureIsEmptyThrowsException()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "generateClassName",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.ClassNameGeneratorTests#generatedClassNameWhenFeatureIsEmptyThrowsException()",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "featureNameMustNotBeEmpty",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.aot.generate.ClassNameGeneratorTests#generatedClassNameWhenFeatureIsEmptyThrowsException()",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "useSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "org.springframework.aot.generate.ClassNameGeneratorTests#generatedClassNameWhenFeatureIsEmptyThrowsException()",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.ClassNameGeneratorTests#generatedClassNameWhenFeatureIsEmptyThrowsException()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "ClassNameGeneratorTests",
      "tail_type": "class"
    },
    {
      "head": "ClassNameGeneratorTests",
      "head_type": "class",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "ClassNameGeneratorTests",
      "head_type": "class",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassTests#reserveMethodNamesReservesNames()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "reserve method names",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassTests#reserveMethodNamesReservesNames()",
      "head_type": "method",
      "relation": "have",
      "tail": "GeneratedClass is used to reserve method names",
      "tail_type": "useSampleCode"
    },
    {
      "head": "reserve method names",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "avoid method name conflicts",
      "tail_type": "useScenario"
    },
    {
      "head": "reserve method names",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "method names must be valid identifiers",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassTests#reserveMethodNamesReservesNames()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.GeneratedClass",
      "tail_type": "class"
    },
    {
      "head": "reserve method names",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "This API function is used to ensure that method names are unique within a generated class, preventing conflicts when new methods are added.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "reserve method names",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "The design principle behind this function is to maintain a registry of used method names and append a suffix to new method names if a conflict is detected. This ensures that each method in the generated class has a unique name.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassTests#generateJavaFileIncludesGeneratedMethods()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "generateJavaFileIncludesGeneratedMethods",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassTests#generateJavaFileIncludesGeneratedMethods()",
      "head_type": "method",
      "relation": "have",
      "tail": "GeneratedClass is used to create a new class at runtime",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassTests#generateJavaFileIncludesGeneratedMethods()",
      "head_type": "method",
      "relation": "have",
      "tail": "Method generation involves adding methods with specific annotations",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassTests#generateJavaFileIncludesGeneratedMethods()",
      "head_type": "method",
      "relation": "have",
      "tail": "package org.springframework.aot.generate;\n\nimport org.junit.jupiter.api.Test;\n\npublic class GeneratedClassTests {\n\n    @Test\n    void generateJavaFileIncludesGeneratedMethods() {\n        GeneratedClass generatedClass = createGeneratedClass(\"TEST_CLASS_NAME\");\n        generatedClass.getMethods().add(\"test\", method -> method.addJavadoc(\"Test Method\"));\n        assertThat(generatedClass.generateJavaFile().toString()).contains(\"Test Method\");\n    }\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests#handleFileWhenFileDoesNotExist()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "handle files",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests#handleFileWhenFileDoesNotExist()",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "file existence",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests#handleFileWhenFileDoesNotExist()",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "file handling",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests#handleFileWhenFileDoesNotExist()",
      "head_type": "method",
      "relation": "have",
      "tail": "void handleFileWhenFileDoesNotExist() throws IOException {\n    this.generatedFiles.setFileHandler(new TestFileHandler());\n    AtomicBoolean called = new AtomicBoolean(false);\n    this.generatedFiles.handleFile(Kind.RESOURCE, \"META-INF/test\", handler -> {\n        called.set(true);\n        handler.create(createSource(\"content\"));\n    });\n    assertThat(called).isTrue();\n    assertThatFileAdded(Kind.RESOURCE, \"META-INF/test\").isEqualTo(\"content\").hasOverride(false);\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests#handleFileWhenFileDoesNotExist()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.GeneratedFilesTests",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests#handleFileWhenFileDoesNotExist()",
      "head_type": "method",
      "relation": "have",
      "tail": "This method tests the handling of files when the file does not exist. It sets a file handler, attempts to handle a file, and asserts the outcome.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests#handleFileWhenFileDoesNotExist()",
      "head_type": "method",
      "relation": "have",
      "tail": "The design principle behind this method is to ensure robust file handling by simulating scenarios where files may not exist and verifying the behavior of the system under such conditions.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.TestGeneratedFiles",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "handleFile",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.TestGeneratedFiles",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "setFileHandler",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.TestGeneratedFiles",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "assertThatFileAdded",
      "tail_type": "apiFunction"
    },
    {
      "head": "handleFile",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "setFileHandler",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "assertThatFileAdded",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.TestGeneratedFiles",
      "head_type": "class",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.TestGeneratedFiles",
      "head_type": "class",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedMethodTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "GeneratedMethod",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedMethodTests",
      "head_type": "class",
      "relation": "have",
      "tail": "GeneratedMethod.getName()",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedMethodTests",
      "head_type": "class",
      "relation": "have",
      "tail": "GeneratedMethod.getMethodSpec()",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedMethodTests",
      "head_type": "class",
      "relation": "have",
      "tail": "GeneratedMethod.toMethodReference()",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedMethodTests",
      "head_type": "class",
      "relation": "have",
      "tail": "GeneratedMethod.toInvokeCodeBlock()",
      "tail_type": "apiFunction"
    },
    {
      "head": "GeneratedMethod",
      "head_type": "class",
      "relation": "have",
      "tail": "GeneratedMethod.getName()",
      "tail_type": "apiFunction"
    },
    {
      "head": "GeneratedMethod",
      "head_type": "class",
      "relation": "have",
      "tail": "GeneratedMethod.getMethodSpec()",
      "tail_type": "apiFunction"
    },
    {
      "head": "GeneratedMethod",
      "head_type": "class",
      "relation": "have",
      "tail": "GeneratedMethod.toMethodReference()",
      "tail_type": "apiFunction"
    },
    {
      "head": "GeneratedMethod",
      "head_type": "class",
      "relation": "have",
      "tail": "GeneratedMethod.toInvokeCodeBlock()",
      "tail_type": "apiFunction"
    },
    {
      "head": "GeneratedMethod.getName()",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "GeneratedMethod.getName() returns the name of the generated method.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "GeneratedMethod.getMethodSpec()",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "GeneratedMethod.getMethodSpec() returns the MethodSpec of the generated method.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "GeneratedMethod.toMethodReference()",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "GeneratedMethod.toMethodReference() converts the generated method to a MethodReference.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "GeneratedMethod.toInvokeCodeBlock()",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "GeneratedMethod.toInvokeCodeBlock() generates the invocation code block for the generated method.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedMethodTests",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "Phillip Webb",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedMethodTests",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "Stephane Nicoll",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.ProtectedAccessor#methodWithProtectedReturnType()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "return a new instance of PackagePrivateClass",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.ProtectedAccessor#methodWithProtectedReturnType()",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for methodWithProtectedReturnType()",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.ProtectedAccessor#methodWithProtectedReturnType()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.ProtectedAccessor",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.PrimitiveTests#generateWhenInt()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "generateCode",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.PrimitiveTests#generateWhenInt()",
      "head_type": "method",
      "relation": "have",
      "tail": "generateWhenInt() sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "generateWhenInt() sample code",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "void generateWhenInt() {\n    assertThat(generateCode(4)).hasToString(\"4\");\n}",
      "tail_type": "codeContent"
    },
    {
      "head": "org.springframework.aot.generate.SetTests#generateWhenStringSet()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "generate code for a set of strings",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.SetTests#generateWhenStringSet()",
      "head_type": "method",
      "relation": "have",
      "tail": "Set.of(\"a\", \"b\", \"c\")",
      "tail_type": "useSampleCode"
    },
    {
      "head": "Set.of(\"a\", \"b\", \"c\")",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "tail": "Set",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.SetTests#generateWhenStringSet()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.SetTests",
      "tail_type": "class"
    },
    {
      "head": "generate code for a set of strings",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "string set manipulation",
      "tail_type": "useScenario"
    },
    {
      "head": "generate code for a set of strings",
      "head_type": "apiFunction",
      "relation": "relatedConceptInterpretation",
      "tail": "This functionality is used to generate code that represents a set of strings. It is typically used in scenarios where you need to generate source code dynamically, such as in code generation libraries or frameworks. The use of `Set.of()` is a concise way to create an immutable set, which is then converted into code representation.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "generate code for a set of strings",
      "head_type": "apiFunction",
      "relation": "designPrincipleInterpretation",
      "tail": "The design principle behind this functionality is to provide a convenient and readable way to generate code for sets of strings. It leverages the immutability and succinct syntax of `Set.of()` to create a clear and concise code generation process. This principle ensures that the generated code is both efficient and easy to understand.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.MapTests#generateWhenMapWithOverTenElements()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "generateWhenMapWithOverTenElements",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.MapTests#generateWhenMapWithOverTenElements()",
      "head_type": "method",
      "relation": "have",
      "tail": "generateWhenMapWithOverTenElements_useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "generateWhenMapWithOverTenElements_useSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "generateWhenMapWithOverTenElements_sampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.hint.annotation.SampleTypeAnnotatedBean#notManaged()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "notManaged",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.hint.annotation.SampleTypeAnnotatedBean#notManaged()",
      "head_type": "method",
      "relation": "have",
      "tail": "public void notManaged() ;",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.hint.annotation.SampleInterface",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "reflectiveOperation",
      "tail_type": "apiFunction"
    },
    {
      "head": "reflectiveOperation",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "org.springframework.aot.hint.annotation.SampleInterface",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.hint.annotation.SampleInterface",
      "head_type": "class",
      "relation": "have",
      "tail": "reflectiveOperation",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.hint.annotation.MethodLevelAnnotatedBean",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "reflection binding registration",
      "tail_type": "apiFunction"
    },
    {
      "head": "reflection binding registration",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "register reflection binding for a class",
      "tail_type": "useSampleCode"
    },
    {
      "head": "reflection binding registration",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "class must have a public getter method",
      "tail_type": "useConstraint"
    },
    {
      "head": "reflection binding registration",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "registering reflection binding for classes with public getters",
      "tail_type": "useScenario"
    },
    {
      "head": "reflection binding registration",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "related to Ahead-of-Time (AOT) processing",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "reflection binding registration",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "design principle of reducing reflection overhead in AOT-processed applications",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.core.type.MethodMetadata#isAbstract()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "determineMethodAbstractness",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.core.type.MethodMetadata#isAbstract()",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.core.type.MethodMetadata#isAbstract()",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "determineMethodAbstractness",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#skipSegment(String,int,String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "skipSegment",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#skipSegment(String,int,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "private int skipSegment(String path, int pos, String prefix) {\n    int skipped = 0;\n    for (int i = 0; i < prefix.length(); i++) {\n        char c = prefix.charAt(i);\n        if (isWildcardChar(c)) {\n            return skipped;\n        }\n        int currPos = pos + skipped;\n        if (currPos >= path.length()) {\n            return 0;\n        }\n        if (c == path.charAt(currPos)) {\n            skipped++;\n        }\n    }\n    return skipped;\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#skipSegment(String,int,String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.AntPathMatcher",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#getStringMatcher(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "build or retrieve an AntPathStringMatcher",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#getStringMatcher(String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "pattern should not be null",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#getStringMatcher(String)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "matching patterns against strings",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#getStringMatcher(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for using getStringMatcher",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#getStringMatcher(String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "AntPathStringMatcher",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#getStringMatcher(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "explanation of caching mechanism",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#getStringMatcher(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principles behind caching",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.backoff.ExponentialBackOff#getInitialInterval()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getInitialInterval",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.backoff.ExponentialBackOff#getInitialInterval()",
      "head_type": "method",
      "relation": "have",
      "tail": "Return the initial interval in milliseconds.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.backoff.ExponentialBackOff",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.backoff.ExponentialBackOff#getInitialInterval()",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.backoff.ExponentialBackOffExecution#multiplyInterval(long)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "interval multiplication",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.backoff.ExponentialBackOffExecution#multiplyInterval(long)",
      "head_type": "method",
      "relation": "have",
      "tail": "private long multiplyInterval(long maxInterval) { long i = this.currentInterval; i *= getMultiplier(); return Math.min(i, maxInterval); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.backoff.ExponentialBackOffExecution#multiplyInterval(long)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.backoff.ExponentialBackOffExecution",
      "tail_type": "class"
    },
    {
      "head": "interval multiplication",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "exponential backoff calculation",
      "tail_type": "useScenario"
    },
    {
      "head": "interval multiplication",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "max interval limit",
      "tail_type": "useConstraint"
    },
    {
      "head": "interval multiplication",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "The function multiplies the current interval by a multiplier and ensures the result does not exceed a specified maximum interval.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "interval multiplication",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "This design principle ensures that the backoff interval increases exponentially but remains bounded by a maximum value to prevent excessive delays.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#forName(String,ClassLoader)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "forName",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ClassUtils#forName(String,ClassLoader)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "name must not be null",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ClassUtils#forName(String,ClassLoader)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "resolving nested class names in Java source style",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ClassUtils#forName(String,ClassLoader)",
      "head_type": "method",
      "relation": "have",
      "tail": "Replacement for Class.forName() that also returns Class instances for primitives and array class names",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#forName(String,ClassLoader)",
      "head_type": "method",
      "relation": "have",
      "tail": "able to resolve nested class names in Java source style",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#forName(String,ClassLoader)",
      "head_type": "method",
      "relation": "have",
      "tail": "public static Class<?> forName(String name, @Nullable ClassLoader classLoader) throws ClassNotFoundException, LinkageError { ... }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "forName",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "Class.forName()",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ClassUtils#isPrimitiveOrWrapper(Class<?>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "check if a class represents a primitive or wrapper type",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ClassUtils#isPrimitiveOrWrapper(Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for checking if a class represents a primitive or wrapper type",
      "tail_type": "useSampleCode"
    },
    {
      "head": "check if a class represents a primitive or wrapper type",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "sample code for checking if a class represents a primitive or wrapper type",
      "tail_type": "useSampleCode"
    },
    {
      "head": "sample code for checking if a class represents a primitive or wrapper type",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "complete example of checking if a class represents a primitive or wrapper type",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.CollectionUtils#newHashMap(int)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "Instantiate a new HashMap with an initial capacity",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.CollectionUtils#newHashMap(int)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "expected number of elements",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.CollectionUtils#newHashMap(int)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "avoid resize/rehash operations",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.CollectionUtils#newHashMap(int)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for newHashMap",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.CollectionUtils#newHashMap(int)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "HashMap",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.CollectionUtils#newHashMap(int)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "ConcurrentHashMap",
      "tail_type": "class"
    },
    {
      "head": "sample code for newHashMap",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "complete example of newHashMap usage",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.comparator.BooleanComparator",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "Comparator",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.comparator.BooleanComparator",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "sort boolean values",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.comparator.BooleanComparator",
      "head_type": "class",
      "relation": "have",
      "tail": "A shared default instance of this comparator, treating true lower than false.",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.comparator.BooleanComparator",
      "head_type": "class",
      "relation": "have",
      "tail": "A shared default instance of this comparator, treating true higher than false.",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.comparator.BooleanComparator",
      "head_type": "class",
      "relation": "have",
      "tail": "Create a BooleanComparator that sorts boolean values based on the provided flag.",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.comparator.BooleanComparator",
      "head_type": "class",
      "relation": "have",
      "tail": "Alternatively, you can use the default shared instances: BooleanComparator.TRUE_LOW and BooleanComparator.TRUE_HIGH.",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.comparator.BooleanComparator",
      "head_type": "class",
      "relation": "have",
      "tail": "A Comparator for Boolean objects that can sort either true or false first.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.comparator.BooleanComparator",
      "head_type": "class",
      "relation": "have",
      "tail": "The class is designed to compare boolean values and can be configured to treat true as lower or higher than false.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.comparator.BooleanComparator",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "Keith Donald",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.comparator.BooleanComparator",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "Eugene Rabii",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.comparator.ComparableComparator#compare(T,T)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "compare(T,T)",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.comparator.ComparableComparator#compare(T,T)",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.comparator.ComparableComparator#compare(T,T)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.comparator.ComparableComparator#compare(T,T)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.comparator.ComparableComparator#compare(T,T)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.comparator.ComparableComparator",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.CompositeMap",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "compositeMap",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.CompositeMap",
      "head_type": "class",
      "relation": "have",
      "tail": "combines two other maps",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.CompositeMap",
      "head_type": "class",
      "relation": "have",
      "tail": "created via CollectionUtils#compositeMap",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.CompositeMap",
      "head_type": "class",
      "relation": "have",
      "tail": "author Arjen Poutsma",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.CompositeMap",
      "head_type": "class",
      "relation": "have",
      "tail": "since 6.2",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.CompositeMap",
      "head_type": "class",
      "relation": "have",
      "tail": "param <K> the type of keys maintained by this map",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.CompositeMap",
      "head_type": "class",
      "relation": "have",
      "tail": "param <V> the type of mapped values",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.CompositeMap",
      "head_type": "class",
      "relation": "have",
      "tail": "package com.healthMgr.common.email; import java.util.*; public class OneClass { private final Map<K, V> first; private final Map<K, V> second; @Nullable private final BiFunction<K, V, V> putFunction; @Nullable private final Consumer<Map<K, V>> putAllFunction; CompositeMap(Map<K, V> first, Map<K, V> second) { this(first, second, null, null); } CompositeMap(Map<K, V> first, Map<K, V> second, @Nullable BiFunction<K, V, V> putFunction, @Nullable Consumer<Map<K, V>> putAllFunction) { Assert.notNull(first, \"First must not be null\"); Assert.notNull(second, \"Second must not be null\"); this.first = first; this.second = new FilteredMap<>(second, key -> !this.first.containsKey(key)); this.putFunction = putFunction; this.putAllFunction = putAllFunction; } @Override public int size() { return this.first.size() + this.second.size(); } @Override public boolean isEmpty() { return this.first.isEmpty() && this.second.isEmpty(); } @Override public boolean containsKey(Object key) { if (this.first.containsKey(key)) { return true; } else { return this.second.containsKey(key); } } @Override public boolean containsValue(Object value) { if (this.first.containsValue(value)) { return true; } else { return this.second.containsValue(value); } } @Override @Nullable public V get(Object key) { V firstResult = this.first.get(key); if (firstResult != null) { return firstResult; } else { return this.second.get(key); } } @Override @Nullable public V put(K key, V value) { if (this.putFunction == null) { throw new UnsupportedOperationException(); } else { return this.putFunction.apply(key, value); } } @Override @Nullable public V remove(Object key) { V firstResult = this.first.remove(key); V secondResult = this.second.remove(key); if (firstResult != null) { return firstResult; } else { return secondResult; } } @Override @SuppressWarnings(\"unchecked\") public void putAll(Map<? extends K, ? extends V> m) { if (this.putAllFunction != null) { this.putAllFunction.accept((Map<K, V>) m); } else { for (Map.Entry<? extends K, ? extends V> e : m.entrySet()) { put(e.getKey(), e.getValue()); } } } @Override public void clear() { this.first.clear(); this.second.clear(); } @Override public Set<K> keySet() { return new CompositeSet<>(this.first.keySet(), this.second.keySet()); } @Override public Collection<V> values() { return new CompositeCollection<>(this.first.values(), this.second.values()); } @Override public Set<Entry<K, V>> entrySet() { return new CompositeSet<>(this.first.entrySet(), this.second.entrySet()); } @Override public String toString() { Iterator<Entry<K, V>> i = entrySet().iterator(); if (!i.hasNext()) { return \";\"; } StringBuilder sb = new StringBuilder(); sb.append('{'); while (true) { Entry<K, V> e = i.next(); K key = e.getKey(); V value = e.getValue(); sb.append(key == this ? \"(this Map)\" : key); sb.append('='); sb.append(value == this ? \"(this Map)\" : value); if (!i.hasNext()) { return sb.append('}').toString(); } sb.append(',').append(' '); } } }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.Reference#release()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "releaseEntry",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.Reference#release()",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "entryReleaseConstraint",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.Reference#release()",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "entryReleaseScenario",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.Reference#release()",
      "head_type": "method",
      "relation": "have",
      "tail": "entryReleaseSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.Reference#release()",
      "head_type": "method",
      "relation": "have",
      "tail": "entryReleaseConcept",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.Reference#release()",
      "head_type": "method",
      "relation": "have",
      "tail": "entryReleaseDesignPrinciple",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.Reference#release()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "ReferenceManager",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.Task#hasOption(TaskOption)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "check if task has a specific option",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.Task#hasOption(TaskOption)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method checks if the task has a specific option.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.Task#hasOption(TaskOption)",
      "head_type": "method",
      "relation": "have",
      "tail": "The method returns true if the task contains the specified option.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.Task#hasOption(TaskOption)",
      "head_type": "method",
      "relation": "have",
      "tail": "public boolean hasOption(TaskOption option) {\n    return this.options.contains(option);\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ExceptionTypeFilter#match(Class<? extends Throwable>,Class<? extends Throwable>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "exceptionTypeMatching",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ExceptionTypeFilter#match(Class<? extends Throwable>,Class<? extends Throwable>)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method checks if one exception type can be assigned to another.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ExceptionTypeFilter#match(Class<? extends Throwable>,Class<? extends Throwable>)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method follows the principle of inheritance in object-oriented programming.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ExceptionTypeFilter#match(Class<? extends Throwable>,Class<? extends Throwable>)",
      "head_type": "method",
      "relation": "have",
      "tail": "package com.example;\n\nimport java.lang.reflect.Method;\n\npublic class ExceptionTypeFilterExample {\n    public static void main(String[] args) {\n        Class<Exception> instance = Exception.class;\n        Class<RuntimeException> candidate = RuntimeException.class;\n        boolean result = new ExceptionTypeFilter().match(instance, candidate);\n        System.out.println(\"Match result: \" + result);\n    }\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.FilteredCollection#add(E)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "add elements to collection",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.FilteredCollection#add(E)",
      "head_type": "method",
      "relation": "have",
      "tail": "filtered collection",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.FilteredCollection#add(E)",
      "head_type": "method",
      "relation": "have",
      "tail": "filtered collection design",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.FilteredCollection#add(E)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for FilteredCollection add method",
      "tail_type": "useSampleCode"
    },
    {
      "head": "sample code for FilteredCollection add method",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "tail": "org.springframework.util.FilteredCollection#add(E)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.InstanceFilter#match(T)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "determine if the specified instance matches this filter",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.InstanceFilter#match(T)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.InstanceFilter#match(T)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.InstanceFilter#match(T)",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.LinkedCaseInsensitiveMap#values()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "return a collection of values",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.LinkedCaseInsensitiveMap#values()",
      "head_type": "method",
      "relation": "have",
      "tail": "lazy loading of values",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.LinkedCaseInsensitiveMap#values()",
      "head_type": "method",
      "relation": "have",
      "tail": "if values are null, create a new Values collection",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.LinkedCaseInsensitiveMap#values()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.LinkedCaseInsensitiveMap",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.KeySet#remove(Object)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "removeElement",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.KeySet#remove(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "Removes the specified element from this set if it is present.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.KeySet#remove(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "public boolean remove(Object o) { return LinkedCaseInsensitiveMap.this.remove(o) != null; }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.KeySet#remove(Object)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.LinkedCaseInsensitiveMap",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.MimeType#isWildcardSubtype()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "wildcard subtype checking",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MimeType#isWildcardSubtype()",
      "head_type": "method",
      "relation": "have",
      "tail": "Checks if the subtype is a wildcard character or followed by a suffix",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "wildcard subtype checking",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "Checks if the subtype is a wildcard character or followed by a suffix",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.MimeType#isWildcardSubtype()",
      "head_type": "method",
      "relation": "have",
      "tail": "public boolean isWildcardSubtype() {\n    String subtype = getSubtype();\n    return (WILDCARD_TYPE.equals(subtype) || subtype.startsWith(\"*+\"));\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.MimeType",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getSubtypeSuffix()",
      "tail_type": "apiFunction"
    },
    {
      "head": "getSubtypeSuffix()",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "Return the subtype suffix as defined in RFC 6838.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "getSubtypeSuffix()",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "package com.example.mimetype;\n\nimport org.springframework.util.MimeType;\n\npublic class MimeTypeExample {\n    public static void main(String[] args) {\n        MimeType mimeType = new MimeType(\"text\", \"html+\");\n        String subtypeSuffix = mimeType.getSubtypeSuffix();\n        System.out.println(\"Subtype suffix: \" + subtypeSuffix);\n    }\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.MimeTypeUtils#tokenize(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "tokenization of MIME types",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MimeTypeUtils#tokenize(String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "quoted parameters handling",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.MimeTypeUtils#tokenize(String)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "comma-separated MIME type strings",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.MimeTypeUtils#tokenize(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "public static List<String> tokenize(String mimeTypes) { ... }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.MimeTypeUtils#tokenize(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.MimeTypeUtils#tokenize(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "tokenization of MIME types",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "org.springframework.util.MimeTypeUtils",
      "tail_type": "class"
    },
    {
      "head": "quoted parameters handling",
      "head_type": "useConstraint",
      "relation": "associated_with",
      "tail": "org.springframework.util.MimeTypeUtils#tokenize(String)",
      "tail_type": "method"
    },
    {
      "head": "comma-separated MIME type strings",
      "head_type": "useScenario",
      "relation": "associated_with",
      "tail": "org.springframework.util.MimeTypeUtils#tokenize(String)",
      "tail_type": "method"
    },
    {
      "head": "relatedConceptInterpretation",
      "head_type": "relatedConceptInterpretation",
      "relation": "associated_with",
      "tail": "org.springframework.util.MimeTypeUtils#tokenize(String)",
      "tail_type": "method"
    },
    {
      "head": "designPrincipleInterpretation",
      "head_type": "designPrincipleInterpretation",
      "relation": "associated_with",
      "tail": "org.springframework.util.MimeTypeUtils#tokenize(String)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.NumberUtils#convertNumberToTargetClass(Number,Class<T>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "convertNumberToTargetClass",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.NumberUtils#convertNumberToTargetClass(Number,Class<T>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "IllegalArgumentException if the target class is not supported",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.NumberUtils#convertNumberToTargetClass(Number,Class<T>)",
      "head_type": "method",
      "relation": "have",
      "tail": "Convert the given number into an instance of the given target class",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.NumberUtils#convertNumberToTargetClass(Number,Class<T>)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is designed to convert a number to a specified target class, handling various standard JDK number subclasses. It ensures type safety by checking if the number can be cast to the target class and performs range checks to prevent overflow, throwing an IllegalArgumentException if the conversion is not possible. The method uses BigDecimal's own conversion to avoid precision loss and emphasizes the importance of using BigDecimal(String) for reliable conversions.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.NumberUtils#convertNumberToTargetClass(Number,Class<T>)",
      "head_type": "method",
      "relation": "have",
      "tail": "package com.healthMgr.common.util;\n\nimport org.springframework.util.NumberUtils;\n\npublic class NumberConversionExample {\n    public static void main(String[] args) {\n        try {\n            Number number = 123.45;\n            Class<Integer> targetClass = Integer.class;\n            Integer convertedNumber = NumberUtils.convertNumberToTargetClass(number, targetClass);\n            System.out.println(\"Converted number: \" + convertedNumber);\n        } catch (IllegalArgumentException e) {\n            System.err.println(\"Error: \" + e.getMessage());\n        }\n    }\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "convertNumberToTargetClass",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "org.springframework.util.NumberUtils#convertNumberToTargetClass(Number,Class<T>)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.NumberUtils#raiseOverflowException(Number,Class<?>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "raiseOverflowException",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.NumberUtils#raiseOverflowException(Number,Class<?>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "overflow condition",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.NumberUtils#raiseOverflowException(Number,Class<?>)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "number conversion",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.NumberUtils#raiseOverflowException(Number,Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for raiseOverflowException",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.NumberUtils#raiseOverflowException(Number,Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "related concept interpretation for overflow exception",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.NumberUtils#raiseOverflowException(Number,Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle interpretation for overflow exception handling",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.NumberUtils#raiseOverflowException(Number,Class<?>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "IllegalArgumentException",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.ObjectUtils#isEmpty(Object[])",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "check if array is empty",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ObjectUtils#isEmpty(Object[])",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "array must be nullable",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ObjectUtils#isEmpty(Object[])",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "null or zero-length array check",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ObjectUtils#isEmpty(Object[])",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code to check if an array is empty",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ObjectUtils#isEmpty(Object[])",
      "head_type": "method",
      "relation": "have",
      "tail": "interpretation of null and empty array",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ObjectUtils#isEmpty(Object[])",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle for checking empty arrays",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ObjectUtils",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.ObjectUtils#isEmpty(Object[])",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeHashCode(boolean[])",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "hash code generation",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeHashCode(boolean[])",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "null input returns zero",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeHashCode(boolean[])",
      "head_type": "method",
      "relation": "have",
      "tail": "Return a hash code based on the contents of the specified array. If array is null, this method returns 0.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeHashCode(boolean[])",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is deprecated as of version 6.1, in favor of using Arrays.hashCode(boolean[]).",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeHashCode(boolean[])",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "Arrays",
      "tail_type": "class"
    },
    {
      "head": "hash code generation",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "org.springframework.util.ObjectUtils#nullSafeHashCode(boolean[])",
      "tail_type": "method"
    },
    {
      "head": "null input returns zero",
      "head_type": "useConstraint",
      "relation": "applied_to",
      "tail": "org.springframework.util.ObjectUtils#nullSafeHashCode(boolean[])",
      "tail_type": "method"
    },
    {
      "head": "Return a hash code based on the contents of the specified array. If array is null, this method returns 0.",
      "head_type": "relatedConceptInterpretation",
      "relation": "have",
      "tail": "org.springframework.util.ObjectUtils#nullSafeHashCode(boolean[])",
      "tail_type": "method"
    },
    {
      "head": "This method is deprecated as of version 6.1, in favor of using Arrays.hashCode(boolean[]).",
      "head_type": "designPrincipleInterpretation",
      "relation": "have",
      "tail": "org.springframework.util.ObjectUtils#nullSafeHashCode(boolean[])",
      "tail_type": "method"
    },
    {
      "head": "Arrays",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.ObjectUtils#nullSafeHashCode(boolean[])",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.PatternMatchUtils#simpleMatch(String[],String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "stringMatching",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.PatternMatchUtils#simpleMatch(String[],String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "nullInputHandling",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.PatternMatchUtils#simpleMatch(String[],String)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "patternBasedStringMatching",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.PatternMatchUtils#simpleMatch(String[],String)",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.PatternMatchUtils#simpleMatch(String[],String)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.PatternMatchUtils#simpleMatch(String[],String)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.PatternMatchUtils#simpleMatch(String[],String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.PatternMatchUtils",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.Part",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "resolve",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.Part",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "text",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.Part",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "resolveAll",
      "tail_type": "apiFunction"
    },
    {
      "head": "resolve",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "PartResolutionContext",
      "tail_type": "useScenario"
    },
    {
      "head": "text",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "textual representation of this part",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "resolveAll",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "Iterable<Part>",
      "tail_type": "useScenario"
    },
    {
      "head": "resolveAll",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "StringBuilder",
      "tail_type": "useSampleCode"
    },
    {
      "head": "resolveAll",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "concatenation of the supplied parts with placeholders replaced inline",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.Part",
      "head_type": "class",
      "relation": "have",
      "tail": "A part is a section of a String containing placeholders to replace",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.PropertiesPersister#store(Properties,Writer,String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "writeProperties",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.PropertiesPersister#store(Properties,Writer,String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "ioExceptionHandling",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.PropertiesPersister#store(Properties,Writer,String)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "propertiesSerialization",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.PropertiesPersister#store(Properties,Writer,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "propertiesSerializationExample",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.PropertiesPersister#store(Properties,Writer,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "propertiesSerializationConcept",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.PropertiesPersister#store(Properties,Writer,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "ioExceptionDesignPrinciple",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.PropertiesPersister",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.PropertiesPersister#store(Properties,Writer,String)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#rethrowException(Throwable)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "exception rethrowing",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#rethrowException(Throwable)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "no checked exception expected",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#rethrowException(Throwable)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "InvocationTargetException handling",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#rethrowException(Throwable)",
      "head_type": "method",
      "relation": "have",
      "tail": "public static void rethrowException(@Nullable Throwable throwable) throws Exception { if (throwable instanceof Exception exception) { throw exception; } if (throwable instanceof Error error) { throw error; } throw new UndeclaredThrowableException(throwable); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#rethrowException(Throwable)",
      "head_type": "method",
      "relation": "have",
      "tail": "Rethrows an underlying exception as an Exception or Error if appropriate; otherwise, throws an UndeclaredThrowableException.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#rethrowException(Throwable)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is designed to handle exceptions that are not declared in the method signature, ensuring that unexpected exceptions are properly propagated.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#rethrowException(Throwable)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.ReflectionUtils",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.FieldFilter#matches(Field)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "determine field match",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.FieldFilter#matches(Field)",
      "head_type": "method",
      "relation": "have",
      "tail": "related concept interpretation for determine field match",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.FieldFilter#matches(Field)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle interpretation for determine field match",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.FieldFilter#matches(Field)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for determine field match",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.DefaultRoute#value()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "valueRetrieval",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.DefaultRoute#value()",
      "head_type": "method",
      "relation": "have",
      "tail": "This method returns the path.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.DefaultRoute#value()",
      "head_type": "method",
      "relation": "have",
      "tail": "public String value() { return this.path; }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.SingleToMultiValueMapAdapter#forEach(BiConsumer<? super K,? super List<V>>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "forEach",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.SingleToMultiValueMapAdapter#forEach(BiConsumer<? super K,? super List<V>>)",
      "head_type": "method",
      "relation": "have",
      "tail": "forEach(BiConsumer<? super K,? super List<V>>) useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "forEach(BiConsumer<? super K,? super List<V>>) useSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "java\npackage org.springframework.util;\n\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Collections;\n\npublic class SingleToMultiValueMapAdapter<K, V> {\n    private Map<K, V> targetMap;\n\n    public void forEach(BiConsumer<? super K, ? super List<V>> action) {\n        this.targetMap.forEach((k, v) -> action.accept(k, Collections.singletonList(v)));\n    }\n}\n",
      "tail_type": "String"
    },
    {
      "head": "org.springframework.util.StringUtils#trimLeadingCharacter(String,char)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "trimming leading characters",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils#trimLeadingCharacter(String,char)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.StringUtils#trimLeadingCharacter(String,char)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "trimming leading characters",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "string manipulation",
      "tail_type": "useScenario"
    },
    {
      "head": "trimming leading characters",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "relatedConceptInterpretation",
      "head_type": "relatedConceptInterpretation",
      "relation": "associated_with",
      "tail": "string manipulation",
      "tail_type": "useScenario"
    },
    {
      "head": "designPrincipleInterpretation",
      "head_type": "designPrincipleInterpretation",
      "relation": "associated_with",
      "tail": "efficiency and readability",
      "tail_type": "designPrinciple"
    },
    {
      "head": "org.springframework.util.StringUtils#startsWithIgnoreCase(String,String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "stringStartsWithPrefixCheck",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils#startsWithIgnoreCase(String,String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "nullInputHandling",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.StringUtils#startsWithIgnoreCase(String,String)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "caseInsensitivePrefixMatching",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.StringUtils#startsWithIgnoreCase(String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "java.lang.String#startsWithUsage",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.StringUtils#startsWithIgnoreCase(String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "caseInsensitiveStringMatchingExplanation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.StringUtils#startsWithIgnoreCase(String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrinciplesForStringHandling",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "stringStartsWithPrefixCheck",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "org.springframework.util.StringUtils",
      "tail_type": "class"
    },
    {
      "head": "nullInputHandling",
      "head_type": "useConstraint",
      "relation": "associated_with",
      "tail": "org.springframework.util.StringUtils#startsWithIgnoreCase(String,String)",
      "tail_type": "method"
    },
    {
      "head": "caseInsensitivePrefixMatching",
      "head_type": "useScenario",
      "relation": "associated_with",
      "tail": "org.springframework.util.StringUtils#startsWithIgnoreCase(String,String)",
      "tail_type": "method"
    },
    {
      "head": "java.lang.String#startsWithUsage",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "tail": "org.springframework.util.StringUtils#startsWithIgnoreCase(String,String)",
      "tail_type": "method"
    },
    {
      "head": "caseInsensitiveStringMatchingExplanation",
      "head_type": "relatedConceptInterpretation",
      "relation": "associated_with",
      "tail": "org.springframework.util.StringUtils#startsWithIgnoreCase(String,String)",
      "tail_type": "method"
    },
    {
      "head": "designPrinciplesForStringHandling",
      "head_type": "designPrincipleInterpretation",
      "relation": "associated_with",
      "tail": "org.springframework.util.StringUtils#startsWithIgnoreCase(String,String)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.StringUtils#quoteIfString(Object)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "quoteIfString",
      "tail_type": "apiFunction"
    },
    {
      "head": "quoteIfString",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "quoteIfStringUseSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "quoteIfString",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "quoteIfStringRelatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "quoteIfString",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "quoteIfStringDesignPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "quoteIfStringUseSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "quoteIfStringSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.StringUtils#collectionToDelimitedString(Collection<?>,String,String,String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "convert a Collection to a delimited String",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils#collectionToDelimitedString(Collection<?>,String,String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "useful for toString() implementations",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.StringUtils#collectionToDelimitedString(Collection<?>,String,String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "the Collection to convert (potentially null or empty)",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.StringUtils#collectionToDelimitedString(Collection<?>,String,String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "the delimiter to use (typically a \",\")",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.StringUtils#collectionToDelimitedString(Collection<?>,String,String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "the String to start each element with",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.StringUtils#collectionToDelimitedString(Collection<?>,String,String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "the String to end each element with",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.StringUtils#collectionToDelimitedString(Collection<?>,String,String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "the delimited String",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.StringUtils#collectionToDelimitedString(Collection<?>,String,String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.StringUtils#collectionToDelimitedString(Collection<?>,String,String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "convert a Collection to a delimited String",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "toString() implementations",
      "tail_type": "useScenario"
    },
    {
      "head": "convert a Collection to a delimited String",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "convert a Collection to a delimited String",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "convert a Collection to a delimited String",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.TypeUtils",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "isAssignable",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.TypeUtils",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getLowerBounds",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.TypeUtils",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getUpperBounds",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.TypeUtils",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "isAssignableBound",
      "tail_type": "apiFunction"
    },
    {
      "head": "isAssignable",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "check if the right-hand side type may be assigned to the left-hand side type following the Java generics rules",
      "tail_type": "useScenario"
    },
    {
      "head": "isAssignable",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "private static boolean isAssignable(Type lhsType, Type rhsType) { ... }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "getLowerBounds",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "private static Type[] getLowerBounds(WildcardType wildcardType) { ... }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "getUpperBounds",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "private static Type[] getUpperBounds(WildcardType wildcardType) { ... }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "isAssignableBound",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "public static boolean isAssignableBound(@Nullable Type lhsType, @Nullable Type rhsType) { ... }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.TypeUtils",
      "head_type": "class",
      "relation": "have",
      "tail": "Utility to work with generic type parameters. Mainly for internal use within the framework.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.TypeUtils",
      "head_type": "class",
      "relation": "have",
      "tail": "This class provides utility methods for working with Java generics, specifically type parameters. It includes methods for checking type assignability, getting implicit bounds, and other operations related to generic types.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.unit.DataSize#ofKilobytes(long)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "representing the specified number of kilobytes",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.unit.DataSize#ofKilobytes(long)",
      "head_type": "method",
      "relation": "have",
      "tail": "Obtain a DataSize representing the specified number of kilobytes",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.unit.DataSize#ofKilobytes(long)",
      "head_type": "method",
      "relation": "have",
      "tail": "The method returns a DataSize object which represents the specified number of kilobytes.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.unit.DataSize#ofKilobytes(long)",
      "head_type": "method",
      "relation": "have",
      "tail": "The method is designed to be simple and efficient, using exact multiplication to calculate the number of bytes.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#get(Object)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "retrieve values associated with a key",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#get(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "return an unmodifiable list",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#get(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "if the result is not null, return an unmodifiable list; otherwise, return null",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#get(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "the method returns an unmodifiable list to ensure the collection is not modified",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#get(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "the method uses a delegate to fetch the values associated with the key",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySet#removeAll(Collection<?>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "override method",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySet#removeAll(Collection<?>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "unsupported operation exception",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySet#removeAll(Collection<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "throwing an UnsupportedOperationException",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySet#removeAll(Collection<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "related to collection manipulation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySet#removeAll(Collection<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle of immutability",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#endDocument()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "end document processing",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#endDocument()",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "must be called after startDocument",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#endDocument()",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "finalizing XML document parsing",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#endDocument()",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.xml.AbstractStaxHandler#endDocument() sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#endDocument()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.AbstractStaxHandler",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#endDocument()",
      "head_type": "method",
      "relation": "have",
      "tail": "related concept interpretation for endDocument",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#endDocument()",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle interpretation for endDocument",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLStreamReader#getTextCharacters(int,char[],int,int)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getTextCharacters",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLStreamReader#getTextCharacters(int,char[],int,int)",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLStreamReader#getTextCharacters(int,char[],int,int)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.AbstractXMLStreamReader",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.SimpleNamespaceContext",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getBoundPrefixes()",
      "tail_type": "apiFunction"
    },
    {
      "head": "getBoundPrefixes()",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "Return all declared prefixes.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "getBoundPrefixes()",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "public Iterator<String> getBoundPrefixes() {\n    return this.prefixToNamespaceUri.keySet().iterator();\n}",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "setDocumentLocator",
      "head_type": "method",
      "relation": "haveFunction",
      "head": "org.springframework.util.xml.StaxEventHandler#setDocumentLocator(Locator)",
      "tail_type": "apiFunction"
    },
    {
      "tail": "org.springframework.util.xml.StaxEventHandler",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.xml.StaxEventHandler#setDocumentLocator(Locator)",
      "tail_type": "class"
    },
    {
      "tail": "Locator",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.xml.StaxEventHandler#setDocumentLocator(Locator)",
      "tail_type": "class"
    },
    {
      "tail": "setDocumentLocator(Locator)",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.xml.StaxEventHandler#setDocumentLocator(Locator)",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "org.springframework.util.xml.StaxEventHandler",
      "head_type": "useSampleCode",
      "relation": "have",
      "head": "setDocumentLocator(Locator)",
      "tail_type": "class"
    },
    {
      "tail": "Locator",
      "head_type": "useSampleCode",
      "relation": "have",
      "head": "setDocumentLocator(Locator)",
      "tail_type": "class"
    },
    {
      "tail": "setDocumentLocator(Locator)",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.xml.StaxEventHandler#setDocumentLocator(Locator)",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "Locator",
      "head_type": "useSampleCode",
      "relation": "have",
      "head": "setDocumentLocator(Locator)",
      "tail_type": "class"
    },
    {
      "tail": "Locator",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.xml.StaxEventHandler#setDocumentLocator(Locator)",
      "tail_type": "class"
    },
    {
      "tail": "org.springframework.util.xml.StaxEventHandler",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.xml.StaxEventHandler#setDocumentLocator(Locator)",
      "tail_type": "class"
    },
    {
      "tail": "setDocumentLocator(Locator)",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.xml.StaxEventHandler#setDocumentLocator(Locator)",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "org.springframework.util.xml.StaxEventHandler",
      "head_type": "useSampleCode",
      "relation": "have",
      "head": "setDocumentLocator(Locator)",
      "tail_type": "class"
    },
    {
      "tail": "Locator",
      "head_type": "useSampleCode",
      "relation": "have",
      "head": "setDocumentLocator(Locator)",
      "tail_type": "class"
    },
    {
      "tail": "Locator",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.xml.StaxEventHandler#setDocumentLocator(Locator)",
      "tail_type": "class"
    },
    {
      "tail": "org.springframework.util.xml.StaxEventHandler",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.xml.StaxEventHandler#setDocumentLocator(Locator)",
      "tail_type": "class"
    },
    {
      "tail": "setDocumentLocator(Locator)",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.xml.StaxEventHandler#setDocumentLocator(Locator)",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "org.springframework.util.xml.StaxEventHandler",
      "head_type": "useSampleCode",
      "relation": "have",
      "head": "setDocumentLocator(Locator)",
      "tail_type": "class"
    },
    {
      "tail": "Locator",
      "head_type": "useSampleCode",
      "relation": "have",
      "head": "setDocumentLocator(Locator)",
      "tail_type": "class"
    },
    {
      "tail": "Locator",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.xml.StaxEventHandler#setDocumentLocator(Locator)",
      "tail_type": "class"
    },
    {
      "tail": "org.springframework.util.xml.StaxEventHandler",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.xml.StaxEventHandler#setDocumentLocator(Locator)",
      "tail_type": "class"
    },
    {
      "tail": "setDocumentLocator(Locator)",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.xml.StaxEventHandler#setDocumentLocator(Locator)",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "org.springframework.util.xml.StaxEventHandler",
      "head_type": "useSampleCode",
      "relation": "have",
      "head": "setDocumentLocator(Locator)",
      "tail_type": "class"
    },
    {
      "tail": "Locator",
      "head_type": "useSampleCode",
      "relation": "have",
      "head": "setDocumentLocator(Locator)",
      "tail_type": "class"
    },
    {
      "tail": "Locator",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.xml.StaxEventHandler#setDocumentLocator(Locator)",
      "tail_type": "class"
    },
    {
      "tail": "org.springframework.util.xml.StaxEventHandler",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.xml.StaxEventHandler#setDocumentLocator(Locator)",
      "tail_type": "class"
    },
    {
      "tail": "setDocumentLocator(Locator)",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.xml.StaxEventHandler#setDocumentLocator(Locator)",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "org.springframework.util.xml.StaxEventHandler",
      "head_type": "useSampleCode",
      "relation": "have",
      "head": "setDocumentLocator(Locator)",
      "tail_type": "class"
    },
    {
      "tail": "Locator",
      "head_type": "useSampleCode",
      "relation": "have",
      "head": "setDocumentLocator(Locator)",
      "tail_type": "class"
    },
    {
      "tail": "Locator",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.xml.StaxEventHandler#setDocumentLocator(Locator)",
      "tail_type": "class"
    },
    {
      "tail": "org.springframework.util.xml.StaxEventHandler",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.xml.StaxEventHandler#setDocumentLocator(Locator)",
      "tail_type": "class"
    },
    {
      "tail": "setDocumentLocator(Locator)",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.xml.StaxEventHandler#setDocumentLocator(Locator)",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "org.springframework.util.xml.StaxEventHandler",
      "head_type": "useSampleCode",
      "relation": "have",
      "head": "setDocumentLocator(Locator)",
      "tail_type": "class"
    },
    {
      "tail": "Locator",
      "head_type": "useSampleCode",
      "relation": "have",
      "head": "setDocumentLocator(Locator)",
      "tail_type": "class"
    },
    {
      "tail": "Locator",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.xml.StaxEventHandler#setDocumentLocator(Locator)",
      "tail_type": "class"
    },
    {
      "tail": "org.springframework.util.xml.StaxEventHandler",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.xml.StaxEventHandler#setDocumentLocator(Locator)",
      "tail_type": "class"
    },
    {
      "tail": "setDocumentLocator(Locator)",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.xml.StaxEventHandler#setDocumentLocator(Locator)",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "org.springframework.util.xml.StaxEventHandler",
      "head_type": "useSampleCode",
      "relation": "have",
      "head": "setDocumentLocator(Locator)",
      "tail_type": "class"
    },
    {
      "tail": "Locator",
      "head_type": "useSampleCode",
      "relation": "have",
      "head": "setDocumentLocator(Locator)",
      "tail_type": "class"
    },
    {
      "tail": "Locator",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.xml.StaxEventHandler#setDocumentLocator(Locator)",
      "tail_type": "class"
    },
    {
      "tail": "org.springframework.util.xml.StaxEventHandler",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.xml.StaxEventHandler#setDocumentLocator(Locator)",
      "tail_type": "class"
    },
    {
      "tail": "setDocumentLocator(Locator)",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.xml.StaxEventHandler#setDocumentLocator(Locator)",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "org.springframework.util.xml.StaxEventHandler",
      "head_type": "useSampleCode",
      "relation": "have",
      "head": "setDocumentLocator(Locator)",
      "tail_type": "class"
    },
    {
      "tail": "Locator",
      "head_type": "useSampleCode",
      "relation": "have",
      "head": "setDocumentLocator(Locator)",
      "tail_type": "class"
    },
    {
      "tail": "Locator",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.xml.StaxEventHandler#setDocumentLocator(Locator)",
      "tail_type": "class"
    },
    {
      "tail": "org.springframework.util.xml.StaxEventHandler",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.xml.StaxEventHandler#setDocumentLocator(Locator)",
      "tail_type": "class"
    },
    {
      "tail": "setDocumentLocator(Locator)",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.xml.StaxEventHandler#setDocumentLocator(Locator)",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "org.springframework.util.xml.StaxEventHandler",
      "head_type": "useSampleCode",
      "relation": "have",
      "head": "setDocumentLocator(Locator)",
      "tail_type": "class"
    },
    {
      "tail": "Locator",
      "head_type": "useSampleCode",
      "relation": "have",
      "head": "setDocumentLocator(Locator)",
      "tail_type": "class"
    },
    {
      "tail": "Locator",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.xml.StaxEventHandler#setDocumentLocator(Locator)",
      "tail_type": "class"
    },
    {
      "tail": "org.springframework.util.xml.StaxEventHandler",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.xml.StaxEventHandler#setDocumentLocator(Locator)",
      "tail_type": "class"
    },
    {
      "tail": "setDocumentLocator(Locator)",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.xml.StaxEventHandler#setDocumentLocator(Locator)",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "org.springframework.util.xml.StaxEventHandler",
      "head_type": "useSampleCode",
      "relation": "have",
      "head": "setDocumentLocator(Locator)",
      "tail_type": "class"
    },
    {
      "tail": "Locator",
      "head_type": "useSampleCode",
      "relation": "have",
      "head": "setDocumentLocator(Locator)",
      "tail_type": "class"
    },
    {
      "tail": "Locator",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.xml.StaxEventHandler#setDocumentLocator(Locator)",
      "tail_type": "class"
    },
    {
      "tail": "org.springframework.util.xml.StaxEventHandler",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.xml.StaxEventHandler#setDocumentLocator(Locator)",
      "tail_type": "class"
    },
    {
      "tail": "setDocumentLocator(Locator)",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.xml.StaxEventHandler#setDocumentLocator(Locator)",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "org.springframework.util.xml.StaxEventHandler",
      "head_type": "useSampleCode",
      "relation": "have",
      "head": "setDocumentLocator(Locator)",
      "tail_type": "class"
    },
    {
      "tail": "Locator",
      "head_type": "useSampleCode",
      "relation": "have",
      "head": "setDocumentLocator(Locator)",
      "tail_type": "class"
    },
    {
      "tail": "Locator",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.xml.StaxEventHandler#setDocumentLocator(Locator)",
      "tail_type": "class"
    },
    {
      "tail": "org.springframework.util.xml.StaxEventHandler",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.xml.StaxEventHandler#setDocumentLocator(Locator)",
      "tail_type": "class"
    },
    {
      "tail": "setDocumentLocator(Locator)",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.xml.StaxEventHandler#setDocumentLocator(Locator)",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "org.springframework.util.xml.StaxEventHandler",
      "head_type": "useSampleCode",
      "relation": "have",
      "head": "setDocumentLocator(Locator)",
      "tail_type": "class"
    },
    {
      "tail": "Locator",
      "head_type": "useSampleCode",
      "relation": "have",
      "head": "setDocumentLocator(Locator)",
      "tail_type": "class"
    },
    {
      "tail": "Locator",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.xml.StaxEventHandler#setDocumentLocator(Locator)",
      "tail_type": "class"
    },
    {
      "tail": "org.springframework.util.xml.StaxEventHandler",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.xml.StaxEventHandler#setDocumentLocator(Locator)",
      "tail_type": "class"
    },
    {
      "tail": "setDocumentLocator(Locator)",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.xml.StaxEventHandler#setDocumentLocator(Locator)",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "org.springframework.util.xml.StaxEventHandler",
      "head_type": "useSampleCode",
      "relation": "have",
      "head": "setDocumentLocator(Locator)",
      "tail_type": "class"
    },
    {
      "tail": "Locator",
      "head_type": "useSampleCode",
      "relation": "have",
      "head": "setDocumentLocator(Locator)",
      "tail_type": "class"
    },
    {
      "tail": "Locator",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.xml.StaxEventHandler#setDocumentLocator(Locator)",
      "tail_type": "class"
    },
    {
      "tail": "org.springframework.util.xml.StaxEventHandler",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.xml.StaxEventHandler#setDocumentLocator(Locator)",
      "tail_type": "class"
    },
    {
      "tail": "setDocumentLocator(Locator)",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.xml.StaxEventHandler#setDocumentLocator(Locator)",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "org.springframework.util.xml.StaxEventHandler",
      "head_type": "useSampleCode",
      "relation": "have",
      "head": "setDocumentLocator(Locator)",
      "tail_type": "class"
    },
    {
      "tail": "Locator",
      "head_type": "useSampleCode",
      "relation": "have",
      "head": "setDocumentLocator(Locator)",
      "tail_type": "class"
    },
    {
      "tail": "Locator",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.xml.StaxEventHandler#setDocumentLocator(Locator)",
      "tail_type": "class"
    },
    {
      "tail": "org.springframework.util.xml.StaxEventHandler",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.xml.StaxEventHandler#setDocumentLocator(Locator)",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.StaxEventHandler#set"
    },
    {
      "head": "org.springframework.util.xml.StaxEventHandler#cDataInternal(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "handle CDATA sections",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxEventHandler#cDataInternal(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.xml.StaxEventHandler#cDataInternal(String) sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.StaxEventHandler#cDataInternal(String) sample code",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "Complete example of handling CDATA sections in XML processing",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxEventHandler#ignorableWhitespaceInternal(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "handle ignorable whitespace in XML",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxEventHandler#ignorableWhitespaceInternal(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.xml.StaxEventHandler#ignorableWhitespaceInternal(String) sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.StaxEventHandler#ignorableWhitespaceInternal(String) sample code",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "complete example of handling ignorable whitespace in XML",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.StaxEventXMLReader#handleStartElement(StartElement)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "xml parsing",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxEventXMLReader#handleStartElement(StartElement)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "SAXException handling",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.xml.StaxEventXMLReader#handleStartElement(StartElement)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "namespace handling",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.xml.StaxEventXMLReader#handleStartElement(StartElement)",
      "head_type": "method",
      "relation": "have",
      "tail": "namespace handling sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.StaxEventXMLReader#handleStartElement(StartElement)",
      "head_type": "method",
      "relation": "have",
      "tail": "related concept interpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxEventXMLReader#handleStartElement(StartElement)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle interpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxEventXMLReader#handleStartElement(StartElement)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.StaxEventXMLReader",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamXMLReader#getAttributes()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "parse XML attributes",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamXMLReader#getAttributes()",
      "head_type": "method",
      "relation": "have",
      "tail": "private Attributes getAttributes() {\n    AttributesImpl attributes = new AttributesImpl();\n    for (int i = 0; i < this.reader.getAttributeCount(); i++) {\n        String namespace = this.reader.getAttributeNamespace(i);\n        if (namespace == null || !hasNamespacesFeature()) {\n            namespace = \"\";\n        }\n        String type = this.reader.getAttributeType(i);\n        if (type == null) {\n            type = \"CDATA\";\n        }\n        attributes.addAttribute(namespace, this.reader.getAttributeLocalName(i), toQualifiedName(this.reader.getAttributeName(i)), type, this.reader.getAttributeValue(i));\n    }\n    if (hasNamespacePrefixesFeature()) {\n        for (int i = 0; i < this.reader.getNamespaceCount(); i++) {\n            String prefix = this.reader.getNamespacePrefix(i);\n            String namespaceUri = this.reader.getNamespaceURI(i);\n            String qName;\n            if (StringUtils.hasLength(prefix)) {\n                qName = \"xmlns:\" + prefix;\n            } else {\n                qName = \"xmlns\";\n            }\n            attributes.addAttribute(\"\", \"\", qName, \"CDATA\", namespaceUri);\n        }\n    }\n    return attributes;\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamXMLReader",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.StaxStreamXMLReader#getAttributes()",
      "tail_type": "method"
    },
    {
      "head": "parse XML attributes",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "XML attribute retrieval",
      "tail_type": "useScenario"
    },
    {
      "head": "parse XML attributes",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "namespace handling",
      "tail_type": "useConstraint"
    },
    {
      "head": "parse XML attributes",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "Handles namespace and attribute parsing for XML documents.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "parse XML attributes",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "Efficiently parses XML attributes using StAX API.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter#setDefaultNamespace(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "setDefaultNamespace",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter#setDefaultNamespace(String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.XMLEventStreamWriter",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter",
      "head_type": "class",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter",
      "head_type": "class",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter#setDefaultNamespace(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter#writeNamespace(String,String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "writeNamespace",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter#writeNamespace(String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.xml.XMLEventStreamWriter",
      "tail_type": "class"
    },
    {
      "head": "writeNamespace",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "org.springframework.util.xml.XMLEventStreamWriter",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter",
      "head_type": "class",
      "relation": "have",
      "tail": "writeNamespace",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter",
      "head_type": "class",
      "relation": "have",
      "tail": "org.springframework.util.xml.XMLEventStreamWriter#writeNamespace(String,String)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter#writeEntityRef(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "writeEntityRef",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter#writeEntityRef(String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.XMLEventStreamWriter",
      "tail_type": "class"
    },
    {
      "head": "writeEntityRef",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "This method is used to write an entity reference in XML.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "writeEntityRef",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "public void writeEntityRef(String name) throws XMLStreamException { closeEmptyElementIfNecessary(); this.eventWriter.add(this.eventFactory.createEntityReference(name, null)); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "example.type.SomeDaoLikeImpl",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "lazy loading",
      "tail_type": "apiFunction"
    },
    {
      "head": "example.type.SomeDaoLikeImpl",
      "head_type": "class",
      "relation": "constrained_by",
      "tail": "circular aliases are prohibited",
      "tail_type": "useConstraint"
    },
    {
      "head": "example.type.SomeDaoLikeImpl",
      "head_type": "class",
      "relation": "applied_to",
      "tail": "multiple aliases for a single name",
      "tail_type": "useScenario"
    },
    {
      "head": "example.type.SomeDaoLikeImpl",
      "head_type": "class",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "example.type.SomeDaoLikeImpl",
      "head_type": "class",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "example.type.SomeDaoLikeImpl",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.core.SimpleAliasRegistryTests",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#forMemberWhenPublicClassWithPackagePrivateGenericOnConstructorParameter()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "Access Control",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#forMemberWhenPublicClassWithPackagePrivateGenericOnConstructorParameter()",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.aot.generate.AccessControlTests#forMemberWhenPublicClassWithPackagePrivateGenericOnConstructorParameter() Sample Code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#forMemberWhenPublicClassWithPackagePrivateGenericOnConstructorParameter() Sample Code",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "org.springframework.aot.generate.AccessControlTests#forMemberWhenPublicClassWithPackagePrivateGenericOnConstructorParameter() Code Content",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#forMemberWhenPublicClassWithPackagePrivateGenericOnConstructorParameter()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.AccessControl",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#forMemberWhenPublicClassWithPackagePrivateGenericOnConstructorParameter()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.AccessControlTests",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#forMemberWhenPublicClassWithPackagePrivateGenericOnConstructorParameter()",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.aot.generate.AccessControlTests#forMemberWhenPublicClassWithPackagePrivateGenericOnConstructorParameter() Related Concept Interpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#forMemberWhenPublicClassWithPackagePrivateGenericOnConstructorParameter()",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.aot.generate.AccessControlTests#forMemberWhenPublicClassWithPackagePrivateGenericOnConstructorParameter() Design Principle Interpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.ClassNameGeneratorTests#generateClassWithClassWhenMultipleCallsGeneratesSequencedName()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "generateClassName",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.ClassNameGeneratorTests#generateClassWithClassWhenMultipleCallsGeneratesSequencedName()",
      "head_type": "method",
      "relation": "have",
      "tail": "generateClassWithClassWhenMultipleCallsGeneratesSequencedName useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "generateClassWithClassWhenMultipleCallsGeneratesSequencedName useSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "generateClassWithClassWhenMultipleCallsGeneratesSequencedName relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "generateClassWithClassWhenMultipleCallsGeneratesSequencedName useSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "generateClassWithClassWhenMultipleCallsGeneratesSequencedName designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "generateClassWithClassWhenMultipleCallsGeneratesSequencedName relatedConceptInterpretation",
      "head_type": "relatedConceptInterpretation",
      "relation": "associated_with",
      "tail": "ClassName",
      "tail_type": "class"
    },
    {
      "head": "generateClassWithClassWhenMultipleCallsGeneratesSequencedName designPrincipleInterpretation",
      "head_type": "designPrincipleInterpretation",
      "relation": "associated_with",
      "tail": "ClassName",
      "tail_type": "class"
    },
    {
      "head": "generateClassWithClassWhenMultipleCallsGeneratesSequencedName relatedConceptInterpretation",
      "head_type": "relatedConceptInterpretation",
      "relation": "associated_with",
      "tail": "InputStream",
      "tail_type": "class"
    },
    {
      "head": "generateClassWithClassWhenMultipleCallsGeneratesSequencedName designPrincipleInterpretation",
      "head_type": "designPrincipleInterpretation",
      "relation": "associated_with",
      "tail": "InputStream",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassesTests#addForFeatureWhenFeatureNameIsEmptyThrowsException()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "addForFeature",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassesTests#addForFeatureWhenFeatureNameIsEmptyThrowsException()",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "featureNameMustNotBeEmpty",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassesTests#addForFeatureWhenFeatureNameIsEmptyThrowsException()",
      "head_type": "method",
      "relation": "have",
      "tail": "addForFeatureWhenFeatureNameIsEmptyThrowsExceptionUseSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "addForFeatureWhenFeatureNameIsEmptyThrowsExceptionUseSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "org.springframework.aot.generate.GeneratedClassesTests",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassesTests#addForFeatureWhenFeatureNameIsEmptyThrowsException()",
      "head_type": "method",
      "relation": "have",
      "tail": "addForFeatureWhenFeatureNameIsEmptyThrowsExceptionRelatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "addForFeatureWhenFeatureNameIsEmptyThrowsExceptionRelatedConceptInterpretation",
      "head_type": "relatedConceptInterpretation",
      "relation": "have",
      "tail": "IllegalArgumentException",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassesTests#addForFeatureWhenFeatureNameIsEmptyThrowsException()",
      "head_type": "method",
      "relation": "have",
      "tail": "addForFeatureWhenFeatureNameIsEmptyThrowsExceptionDesignPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "addForFeatureWhenFeatureNameIsEmptyThrowsExceptionDesignPrincipleInterpretation",
      "head_type": "designPrincipleInterpretation",
      "relation": "have",
      "tail": "ExceptionHandlingPrinciple",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.TestGeneratedFiles#assertThatFileAdded(Kind,String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "assert file added",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.TestGeneratedFiles#assertThatFileAdded(Kind,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "GeneratedFileAssert assertThatFileAdded(Kind kind, String path) throws IOException {\n    assertThat(this.kind).as(\"kind\").isEqualTo(kind);\n    assertThat(this.path).as(\"path\").isEqualTo(path);\n    assertThat(this.fileHandler.content).as(\"content\").isNotNull();\n    return new GeneratedFileAssert(this.fileHandler.content, this.fileHandler.override);\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.TestGeneratedFiles#assertThatFileAdded(Kind,String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.TestGeneratedFiles",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFileAssert",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "constructor",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFileAssert",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "hasOverride",
      "tail_type": "apiFunction"
    },
    {
      "head": "constructor",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "hasOverride",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedTypeReferenceTests#createWithClassName()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "createWithClassName",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedTypeReferenceTests#createWithClassName()",
      "head_type": "method",
      "relation": "have",
      "tail": "createWithClassName() sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "createWithClassName() sample code",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "package com.example; import com.example.Test; public class GeneratedTypeReferenceExample { @Test void createWithClassName() { GeneratedTypeReference typeReference = GeneratedTypeReference.of(ClassName.get(\"com.example\", \"Test\")); assertThat(typeReference.getPackageName()).isEqualTo(\"com.example\"); assertThat(typeReference.getSimpleName()).isEqualTo(\"Test\"); assertThat(typeReference.getCanonicalName()).isEqualTo(\"com.example.Test\"); assertThat(typeReference.getEnclosingType()).isNull(); } }",
      "tail_type": "code"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedTypeReferenceTests#nameOfCglibProxy()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "GeneratedTypeReference generation",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedTypeReferenceTests#nameOfCglibProxy()",
      "head_type": "method",
      "relation": "have",
      "tail": "GeneratedTypeReference usage sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "GeneratedTypeReference usage sample code",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "Complete example of using GeneratedTypeReference",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedTypeReferenceTests#nameOfCglibProxy()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.GeneratedTypeReference",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedTypeReferenceTests#nameOfCglibProxy()",
      "head_type": "method",
      "relation": "have",
      "tail": "Detailed explanation of related concepts",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedTypeReferenceTests#nameOfCglibProxy()",
      "head_type": "method",
      "relation": "have",
      "tail": "Design principles of GeneratedTypeReference",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.ConfigurationTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "createWithListOfDelegatesInvokeThemInOrder",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.ConfigurationTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "generateCodeWithMatchingDelegateStops",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.ConfigurationTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "scopedReturnsImmutableCopy",
      "tail_type": "apiFunction"
    },
    {
      "head": "createWithListOfDelegatesInvokeThemInOrder",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "generateCodeWithMatchingDelegateStops",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "scopedReturnsImmutableCopy",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "createWithListOfDelegatesInvokeThemInOrder",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "generateCodeWithMatchingDelegateStops",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "scopedReturnsImmutableCopy",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "createWithListOfDelegatesInvokeThemInOrder",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "generateCodeWithMatchingDelegateStops",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "scopedReturnsImmutableCopy",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.ResolvableTypeTests#generateWhenGenericResolvableType()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "generate generic resolvable type",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.ResolvableTypeTests#generateWhenGenericResolvableType()",
      "head_type": "method",
      "relation": "have",
      "tail": "generate generic resolvable type sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "generate generic resolvable type sample code",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "generate generic resolvable type sample code content",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.ResolvableTypeTests#generateWhenGenericResolvableType()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.ResolvableTypeTests",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.ResolvableTypeTests",
      "head_type": "class",
      "relation": "have",
      "tail": "related concept interpretation for ResolvableTypeTests",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.ResolvableTypeTests",
      "head_type": "class",
      "relation": "have",
      "tail": "design principle interpretation for ResolvableTypeTests",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.ValueCodeAssert#hasImport(Class<?>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "hasImport",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.ValueCodeAssert#hasImport(Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "hasImport(Class<?>... imports) {\n    for (Class<?> anImport : imports) {\n        assertThat(this.actual.imports).contains(anImport.getName());\n    }\n    return this;\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.ValueCodeAssert#hasImport(Class<?>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.ValueCodeAssert",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.hint.annotation.SampleConstructorAnnotatedBean",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "constructorAnnotation",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.hint.annotation.SampleConstructorAnnotatedBean",
      "head_type": "class",
      "relation": "have",
      "tail": "constructorAnnotationUseSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "constructorAnnotationUseSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "constructorAnnotationSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.PatternInfo#getTotalCount()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getTotalCount",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.PatternInfo#getTotalCount()",
      "head_type": "method",
      "relation": "have",
      "tail": "Calculate the total count based on uriVars, singleWildcards, and doubleWildcards.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.PatternInfo#getTotalCount()",
      "head_type": "method",
      "relation": "have",
      "tail": "public int getTotalCount() {\n    return this.uriVars + this.singleWildcards + (2 * this.doubleWildcards);\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.Assert",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "lazy loading",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.Assert",
      "head_type": "class",
      "relation": "constrained_by",
      "tail": "circular aliases are prohibited",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.Assert",
      "head_type": "class",
      "relation": "applied_to",
      "tail": "multiple aliases for a single name",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.Assert",
      "head_type": "class",
      "relation": "have",
      "tail": "package com.healthMgr.common.email; import java.xxxx; public class OneClass { // specific code }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.Assert",
      "head_type": "class",
      "relation": "have",
      "tail": "An explanation of related concepts",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.Assert",
      "head_type": "class",
      "relation": "have",
      "tail": "An explanation of the design principles of the class or method",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.Assert",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.core.SimpleAliasRegistryTests",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.Assert#isAssignable(Class<?>,Class<?>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "type checking",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.Assert#isAssignable(Class<?>,Class<?>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "superType must be assignable from subType",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.Assert#isAssignable(Class<?>,Class<?>)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "ensuring type compatibility",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.Assert#isAssignable(Class<?>,Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for isAssignable method",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.Assert#isAssignable(Class<?>,Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "related concept interpretation for isAssignable",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.Assert#isAssignable(Class<?>,Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle interpretation for Assert class",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.Assert#isAssignable(Class<?>,Class<?>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.Assert",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.AutoPopulatingList#size()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "size determination",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.AutoPopulatingList#size()",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is used to determine the size of the backing list.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.AutoPopulatingList#size()",
      "head_type": "method",
      "relation": "have",
      "tail": "public int size() { return this.backingList.size(); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.AutoPopulatingList",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.AutoPopulatingList#size()",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.backoff.ExponentialBackOff#toString()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "toString",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.backoff.ExponentialBackOff#toString()",
      "head_type": "method",
      "relation": "have",
      "tail": "StringJoiner",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.backoff.ExponentialBackOff#toString()",
      "head_type": "method",
      "relation": "have",
      "tail": "initialInterval",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.backoff.ExponentialBackOff#toString()",
      "head_type": "method",
      "relation": "have",
      "tail": "multiplier",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.backoff.ExponentialBackOff#toString()",
      "head_type": "method",
      "relation": "have",
      "tail": "maxInterval",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.backoff.ExponentialBackOff#toString()",
      "head_type": "method",
      "relation": "have",
      "tail": "maxElapsedTime",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.backoff.ExponentialBackOff#toString()",
      "head_type": "method",
      "relation": "have",
      "tail": "maxAttempts",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.backoff.ExponentialBackOff#toString()",
      "head_type": "method",
      "relation": "have",
      "tail": "StringJoiner",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.backoff.ExponentialBackOff#toString()",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.backoff.ExponentialBackOff#toString()",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#getMethodCountForName(Class<?>,String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "counting methods with a given name",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ClassUtils#getMethodCountForName(Class<?>,String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "class and method name must not be null",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ClassUtils#getMethodCountForName(Class<?>,String)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "counting methods in a class hierarchy",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ClassUtils#getMethodCountForName(Class<?>,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for counting methods",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ClassUtils#getMethodCountForName(Class<?>,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "interpretation of method counting in class hierarchy",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#getMethodCountForName(Class<?>,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle of method counting",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.ClassUtils#getMethodCountForName(Class<?>,String)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.ClassUtils#isGroovyObjectMethod(Method)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "Check if a method belongs to GroovyObject",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ClassUtils#isGroovyObjectMethod(Method)",
      "head_type": "method",
      "relation": "have",
      "tail": "Checks if the declaring class of a method is named 'groovy.lang.GroovyObject'.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#isGroovyObjectMethod(Method)",
      "head_type": "method",
      "relation": "have",
      "tail": "private static boolean isGroovyObjectMethod(Method method) {\n    return method.getDeclaringClass().getName().equals(\"groovy.lang.GroovyObject\");\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.CollectionUtils#computeInitialCapacity(int)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "computeInitialCapacity",
      "tail_type": "apiFunction"
    },
    {
      "head": "computeInitialCapacity",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "Calculate the initial capacity of a collection based on the expected size",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "computeInitialCapacity",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "private static int computeInitialCapacity(int expectedSize) { return (int) Math.ceil(expectedSize / (double) DEFAULT_LOAD_FACTOR); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.CollectionUtils#containsAny(Collection<?>,Collection<?>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "check for common elements",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.CollectionUtils#containsAny(Collection<?>,Collection<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "Return true if any element in 'candidates' is contained in 'source'; otherwise returns false.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.CollectionUtils#containsAny(Collection<?>,Collection<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "public static boolean containsAny(Collection<?> source, Collection<?> candidates) {\n    return findFirstMatch(source, candidates) != null;\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.CompositeMap#containsValue(Object)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "value containment check",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.CompositeMap#containsValue(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "Checks if the map contains the specified value.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.CompositeMap#containsValue(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "public boolean containsValue(Object value) {\n    if (this.first.containsValue(value)) {\n        return true;\n    } else {\n        return this.second.containsValue(value);\n    }\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.CompositeMap#containsValue(Object)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.CompositeMap",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.AddTask#run()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "lazy loading",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.AddTask#run()",
      "head_type": "method",
      "relation": "have",
      "tail": "currentSize.lazySet(currentSize.get() + 1);",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.AddTask#run()",
      "head_type": "method",
      "relation": "have",
      "tail": "if (this.node.get().isActive()) { evictionQueue.add(this.node); evictEntries(); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.AddTask#run()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "evictionQueue",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.AddTask#run()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "evictEntries()",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.AddTask#run()",
      "head_type": "method",
      "relation": "have",
      "tail": "This method implements the 'lazy loading' functionality by incrementing the current size and adding the node to the eviction queue if it is active.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.AddTask#run()",
      "head_type": "method",
      "relation": "have",
      "tail": "The design principle followed here is to defer operations until necessary, optimizing performance by avoiding unnecessary computations.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.Node#setNext(Node<K,V>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "setNext",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.Node#setNext(Node<K,V>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.Node",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.Node",
      "head_type": "class",
      "relation": "have",
      "tail": "org.springframework.util.Node#setNext(Node<K,V>)",
      "tail_type": "method"
    },
    {
      "head": "setNext",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "public void setNext(@Nullable Node<K, V> next) {\n    this.next = next;\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.EvictionQueue#add(Node<K,V>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "add elements to EvictionQueue",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.EvictionQueue#add(Node<K,V>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "element must not already exist in the queue",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.EvictionQueue#add(Node<K,V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "void add(Node<K, V> e) {\n    if (contains(e)) {\n        return;\n    }\n    linkLast(e);\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.EvictionQueue#add(Node<K,V>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.EvictionQueue",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.ConcurrentReferenceHashMap#getLoadFactor()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getLoadFactor",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ConcurrentReferenceHashMap#getLoadFactor()",
      "head_type": "method",
      "relation": "have",
      "tail": "getLoadFactor returns the load factor of the hash map",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ConcurrentReferenceHashMap",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.ConcurrentReferenceHashMap#getLoadFactor()",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.ConcurrentReferenceHashMap#getLoadFactor()",
      "head_type": "method",
      "relation": "have",
      "tail": "protected final float getLoadFactor() {\n    return this.loadFactor;\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.SoftEntryReference",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "SoftReference Management",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.SoftEntryReference",
      "head_type": "class",
      "relation": "have",
      "tail": "Internal Reference Implementation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.SoftEntryReference",
      "head_type": "class",
      "relation": "have",
      "tail": "SoftReference Handling",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.SoftEntryReference",
      "head_type": "class",
      "relation": "have",
      "tail": "Sample Code for SoftEntryReference",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.WeakEntryReference#getNext()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "reference retrieval",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.WeakEntryReference#getNext()",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.WeakEntryReference",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.WeakEntryReference",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.WeakReference",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.WeakEntryReference",
      "head_type": "class",
      "relation": "designPrincipleInterpretation",
      "tail": "WeakReference Design",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.WeakEntryReference",
      "head_type": "class",
      "relation": "relatedConceptInterpretation",
      "tail": "Weak vs Soft Reference",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.WeakEntryReference#getNext()",
      "head_type": "method",
      "relation": "useSampleCode",
      "tail": "WeakEntryReference Usage",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.CustomizableThreadCreator#setThreadPriority(int)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "setThreadPriority",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.CustomizableThreadCreator#setThreadPriority(int)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "threadPriority must be a valid priority value",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.CustomizableThreadCreator#setThreadPriority(int)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "customizing thread creation",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.CustomizableThreadCreator#setThreadPriority(int)",
      "head_type": "method",
      "relation": "have",
      "tail": "public void setThreadPriority(int threadPriority) { this.threadPriority = threadPriority; }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.CustomizableThreadCreator#setThreadPriority(int)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.CustomizableThreadCreator#setThreadPriority(int)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.CustomizableThreadCreator#setThreadPriority(int)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "java.lang.Thread#NORM_PRIORITY",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.CustomizableThreadCreator#getThreadGroup()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getThreadGroup",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.CustomizableThreadCreator#getThreadGroup()",
      "head_type": "method",
      "relation": "have",
      "tail": "Return the thread group that threads should be created in (or null for the default group)",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.CustomizableThreadCreator",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.CustomizableThreadCreator#getThreadGroup()",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.CustomizableThreadCreator#getThreadGroup()",
      "head_type": "method",
      "relation": "have",
      "tail": "public ThreadGroup getThreadGroup() { return this.threadGroup; }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.DigestUtils#appendDigestAsHex(String,InputStream,StringBuilder)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "appendDigestAsHex",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.DigestUtils#appendDigestAsHex(String,InputStream,StringBuilder)",
      "head_type": "method",
      "relation": "have",
      "tail": "appendDigestAsHex(String algorithm, InputStream inputStream, StringBuilder builder)",
      "tail_type": "useSampleCode"
    },
    {
      "head": "appendDigestAsHex(String algorithm, InputStream inputStream, StringBuilder builder)",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "tail": "org.springframework.util.DigestUtils#appendDigestAsHex(String,InputStream,StringBuilder)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.DigestUtils#appendDigestAsHex(String,InputStream,StringBuilder)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.DigestUtils",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.FileCopyUtils#copyToString(Reader)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "copy contents of a Reader into a String",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.FileCopyUtils#copyToString(Reader)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "Reader may be null or empty",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.FileCopyUtils#copyToString(Reader)",
      "head_type": "method",
      "relation": "have",
      "tail": "Closes the reader when done",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.FileCopyUtils#copyToString(Reader)",
      "head_type": "method",
      "relation": "have",
      "tail": "Returns an empty String if the input Reader is null",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.FileCopyUtils#copyToString(Reader)",
      "head_type": "method",
      "relation": "have",
      "tail": "Throws IOException in case of I/O errors",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.FileCopyUtils#copyToString(Reader)",
      "head_type": "method",
      "relation": "have",
      "tail": "public static String copyToString(@Nullable Reader in) throws IOException { if (in == null) { return \"\"; } StringWriter out = new StringWriter(BUFFER_SIZE); copy(in, out); return out.toString(); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.FileCopyUtils#copyToString(Reader)",
      "head_type": "method",
      "relation": "have",
      "tail": "The method is designed to handle null input gracefully by returning an empty string, ensuring that no NullPointerException is thrown. It also ensures that all resources are properly closed after use, adhering to the try-with-resources pattern.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.FileCopyUtils#copyToString(Reader)",
      "head_type": "method",
      "relation": "have",
      "tail": "The design principle followed here is to provide a utility method that is robust and easy to use, abstracting away the complexities of I/O operations. It aims to improve code readability and maintainability by encapsulating common I/O tasks.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.FilteredIterator",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "filtered iteration",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.FilteredIterator",
      "head_type": "class",
      "relation": "constrained_by",
      "tail": "null delegate or filter",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.FilteredIterator",
      "head_type": "class",
      "relation": "applied_to",
      "tail": "iterating with a predicate",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.FilteredIterator",
      "head_type": "class",
      "relation": "have",
      "tail": "sample code for filtered iteration",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.FilteredIterator",
      "head_type": "class",
      "relation": "have",
      "tail": "related concept interpretation for filtered iteration",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.FilteredIterator",
      "head_type": "class",
      "relation": "have",
      "tail": "design principle interpretation for filtered iteration",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.FilteredIterator",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "CompositeMap",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.function.SupplierUtils#resolve(Supplier<T>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "resolveSupplier",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.function.SupplierUtils#resolve(Supplier<T>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "supplierNotNull",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.function.SupplierUtils#resolve(Supplier<T>)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "supplierResolution",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.function.SupplierUtils#resolve(Supplier<T>)",
      "head_type": "method",
      "relation": "have",
      "tail": "resolveSupplierSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.function.SupplierUtils#resolve(Supplier<T>)",
      "head_type": "method",
      "relation": "have",
      "tail": "supplierResolutionExplanation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.function.SupplierUtils#resolve(Supplier<T>)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleExplanation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.function.SupplierUtils#resolve(Supplier<T>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.function.SupplierUtils",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.function.ThrowingFunction#throwing(BiFunction<String,Exception,RuntimeException>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "exception wrapping",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.function.ThrowingFunction#throwing(BiFunction<String,Exception,RuntimeException>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "exceptionWrapper must not be null",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.function.ThrowingFunction#throwing(BiFunction<String,Exception,RuntimeException>)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "handling checked exceptions in functional interfaces",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.function.ThrowingFunction#throwing(BiFunction<String,Exception,RuntimeException>)",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.function.ThrowingFunction#throwing(BiFunction<String,Exception,RuntimeException>)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.function.ThrowingFunction#throwing(BiFunction<String,Exception,RuntimeException>)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.function.ThrowingFunction#throwing(BiFunction<String,Exception,RuntimeException>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.function.ThrowingFunction",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.InstanceFilter#toString()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "stringConversion",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.InstanceFilter#toString()",
      "head_type": "method",
      "relation": "have",
      "tail": "StringBuilderUsage",
      "tail_type": "useSampleCode"
    },
    {
      "head": "StringBuilderUsage",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "tail": "org.springframework.util.InstanceFilter#toString()",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.InstanceFilter#toString()",
      "head_type": "method",
      "relation": "have",
      "tail": "StringBuilderAppendExample",
      "tail_type": "useSampleCode"
    },
    {
      "head": "StringBuilderAppendExample",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "tail": "org.springframework.util.InstanceFilter#toString()",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.InstanceFilter#toString()",
      "head_type": "method",
      "relation": "have",
      "tail": "OverrideAnnotationUsage",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "OverrideAnnotationUsage",
      "head_type": "relatedConceptInterpretation",
      "relation": "associated_with",
      "tail": "org.springframework.util.InstanceFilter#toString()",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.InstanceFilter#toString()",
      "head_type": "method",
      "relation": "have",
      "tail": "MethodOverridePrinciple",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "MethodOverridePrinciple",
      "head_type": "designPrincipleInterpretation",
      "relation": "associated_with",
      "tail": "org.springframework.util.InstanceFilter#toString()",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.LinkedCaseInsensitiveMap#containsKey(Object)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "checkKeyExistence",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.LinkedCaseInsensitiveMap#containsKey(Object)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "keyMustBeString",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.LinkedCaseInsensitiveMap#containsKey(Object)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "caseInsensitiveKeyLookup",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.LinkedCaseInsensitiveMap#containsKey(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.LinkedCaseInsensitiveMap#containsKey(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.LinkedCaseInsensitiveMap#containsKey(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.LinkedCaseInsensitiveMap#containsKey(Object)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.LinkedCaseInsensitiveMap",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.MimeType#unquote(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "stringUnquoting",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MimeType#unquote(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "protected String unquote(String s) { return (isQuotedString(s) ? s.substring(1, s.length() - 1) : s); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.MimeType#unquote(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is used to remove the quotes from a string if it is quoted.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.MimeType#unquote(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "The method follows the principle of simplicity and readability, ensuring that the code is easy to understand and maintain.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.MimeType#addCharsetParameter(Charset,Map<String,String>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "add character parameter",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MimeType#addCharsetParameter(Charset,Map<String,String>)",
      "head_type": "method",
      "relation": "have",
      "tail": "add character parameter sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "add character parameter sample code",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "private static Map<String, String> addCharsetParameter(Charset charset, Map<String, String> parameters) {\n    Map<String, String> map = new LinkedHashMap<>(parameters);\n    map.put(PARAM_CHARSET, charset.name());\n    return map;\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.MimeTypeUtils#sortBySpecificity(List<T>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "sort by specificity",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MimeTypeUtils#sortBySpecificity(List<T>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "list size limit",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.MimeTypeUtils#sortBySpecificity(List<T>)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "list of MimeType objects",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.MimeTypeUtils#sortBySpecificity(List<T>)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.MimeTypeUtils#sortBySpecificity(List<T>)",
      "head_type": "method",
      "relation": "have",
      "tail": "related concept interpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.MimeTypeUtils#sortBySpecificity(List<T>)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle interpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.MimeTypeUtils#sortBySpecificity(List<T>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "MimeType",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.MimeTypeUtils#bubbleSort(List<T>,BiPredicate<? super T,? super T>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "sorting",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MimeTypeUtils#bubbleSort(List<T>,BiPredicate<? super T,? super T>)",
      "head_type": "method",
      "relation": "have",
      "tail": " bubble sort algorithm implementation",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.MimeTypeUtils#bubbleSort(List<T>,BiPredicate<? super T,? super T>)",
      "head_type": "method",
      "relation": "have",
      "tail": " Bubble sort is a simple sorting algorithm that repeatedly steps through the list, compares adjacent elements and swaps them if they are in the wrong order. The pass through the list is repeated until the list is sorted.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.MimeTypeUtils#bubbleSort(List<T>,BiPredicate<? super T,? super T>)",
      "head_type": "method",
      "relation": "have",
      "tail": " Bubble sort is not suitable for large data sets due to its time complexity of O(n^2).",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.MultiToSingleValueMapAdapter#get(Object)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "adaptValue",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MultiToSingleValueMapAdapter#get(Object)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "this.targetMap.get(key)",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MultiToSingleValueMapAdapter",
      "head_type": "class",
      "relation": "have",
      "tail": "org.springframework.util.MultiToSingleValueMapAdapter#get(Object)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.MultiToSingleValueMapAdapter",
      "head_type": "class",
      "relation": "have",
      "tail": "adaptValue",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MultiToSingleValueMapAdapter",
      "head_type": "class",
      "relation": "have",
      "tail": "this.targetMap.get(key)",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MultiToSingleValueMapAdapter",
      "head_type": "class",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.MultiToSingleValueMapAdapter",
      "head_type": "class",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.MultiToSingleValueMapAdapter",
      "head_type": "class",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.MultiValueMapAdapter#containsKey(Object)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "check key existence",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MultiValueMapAdapter#containsKey(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.MultiValueMapAdapter#containsKey(Object) is used to determine if a specified key is present in the map.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.MultiValueMapAdapter#containsKey(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "public boolean containsKey(Object key) { return this.targetMap.containsKey(key); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.MultiValueMapAdapter#containsKey(Object)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.MultiValueMapAdapter",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeToString(char[])",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "convert array to string",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeToString(char[])",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "array cannot be null",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeToString(char[])",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "array conversion",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeToString(char[])",
      "head_type": "method",
      "relation": "have",
      "tail": "converts a char array to a string representation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeToString(char[])",
      "head_type": "method",
      "relation": "have",
      "tail": "efficiently handles null and empty arrays",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeToString(char[])",
      "head_type": "method",
      "relation": "have",
      "tail": "public static String nullSafeToString(char @Nullable [] array) {\n    if (array == null) {\n        return NULL_STRING;\n    }\n    if (array.length == 0) {\n        return EMPTY_ARRAY;\n    }\n    StringJoiner stringJoiner = new StringJoiner(ARRAY_ELEMENT_SEPARATOR, ARRAY_START, ARRAY_END);\n    for (char c : array) {\n        stringJoiner.add('\\'' + String.valueOf(c) + '\\');\n    }\n    return stringJoiner.toString();\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#doWithLocalMethods(Class<?>,MethodCallback)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "introspection",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#doWithLocalMethods(Class<?>,MethodCallback)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "callback invocation",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#doWithLocalMethods(Class<?>,MethodCallback)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "IllegalStateException on failure",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#doWithLocalMethods(Class<?>,MethodCallback)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "locally declared methods",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#doWithLocalMethods(Class<?>,MethodCallback)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "relatedConceptInterpretation",
      "head_type": "relatedConceptInterpretation",
      "relation": "have",
      "tail": "introspection is the process of examining the structure of a class at runtime.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#doWithLocalMethods(Class<?>,MethodCallback)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "designPrincipleInterpretation",
      "head_type": "designPrincipleInterpretation",
      "relation": "have",
      "tail": "The method follows the principle of reflection, allowing for dynamic interaction with objects based on their class information.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#doWithLocalMethods(Class<?>,MethodCallback)",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "useSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "public static void doWithLocalMethods(Class<?> clazz, MethodCallback mc) {\n    Method[] methods = getDeclaredMethods(clazz, false);\n    for (Method method : methods) {\n        try {\n            mc.doWith(method);\n        } catch (IllegalAccessException ex) {\n            throw new IllegalStateException(\"Not allowed to access method '\" + method.getName() + \"': \" + ex);\n        }\n    }\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.FieldFilter",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "fieldMatching",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.FieldFilter",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "compositeFilterCreation",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.FieldFilter",
      "head_type": "class",
      "relation": "constrained_by",
      "tail": "nullFieldFilterArgumentProhibited",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.FieldFilter",
      "head_type": "class",
      "relation": "have",
      "tail": "callbackFilteringFields",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "fieldMatching",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "booleanMatchesMethod",
      "tail_type": "useSampleCode"
    },
    {
      "head": "compositeFilterCreation",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "andMethodCompositeFilter",
      "tail_type": "useSampleCode"
    },
    {
      "head": "nullFieldFilterArgumentProhibited",
      "head_type": "useConstraint",
      "relation": "have",
      "tail": "IllegalArgumentExceptionOnNull",
      "tail_type": "useSampleCode"
    },
    {
      "head": "callbackFilteringFields",
      "head_type": "relatedConceptInterpretation",
      "relation": "have",
      "tail": "fieldCallbackFilteringMechanism",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ResourceUtils#getFile(URL,String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "Resolving a resource URL to a java.io.File",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ResourceUtils#getFile(URL,String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "Resource URL must not be null",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ResourceUtils#getFile(URL,String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "Resource URL must reside in the file system",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ResourceUtils#getFile(URL,String)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "Resolving a file system resource",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ResourceUtils#getFile(URL,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "Resolving a resource URL to a java.io.File",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ResourceUtils#getFile(URL,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "Resource URL must not be null",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ResourceUtils#getFile(URL,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "Resource URL must reside in the file system",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ResourceUtils#getFile(URL,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "Resolving a file system resource",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ResourceUtils#getFile(URL,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "Sample Code for Resolving a resource URL to a java.io.File",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ResourceUtils#getFile(URL,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "Detailed explanation of related concepts",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ResourceUtils#getFile(URL,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "Design principles behind resolving a resource URL to a java.io.File",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ResourceUtils#getFile(URL,String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.ResourceUtils",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.ResourceUtils",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "Resolving a resource URL to a java.io.File",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ResourceUtils",
      "head_type": "class",
      "relation": "constrained_by",
      "tail": "Resource URL must not be null",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ResourceUtils",
      "head_type": "class",
      "relation": "constrained_by",
      "tail": "Resource URL must reside in the file system",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ResourceUtils",
      "head_type": "class",
      "relation": "applied_to",
      "tail": "Resolving a file system resource",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ResourceUtils",
      "head_type": "class",
      "relation": "have",
      "tail": "Resolving a resource URL to a java.io.File",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ResourceUtils",
      "head_type": "class",
      "relation": "have",
      "tail": "Resource URL must not be null",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ResourceUtils",
      "head_type": "class",
      "relation": "have",
      "tail": "Resource URL must reside in the file system",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ResourceUtils",
      "head_type": "class",
      "relation": "have",
      "tail": "Resolving a file system resource",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ResourceUtils",
      "head_type": "class",
      "relation": "have",
      "tail": "Sample Code for Resolving a resource URL to a java.io.File",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ResourceUtils",
      "head_type": "class",
      "relation": "have",
      "tail": "Detailed explanation of related concepts",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ResourceUtils",
      "head_type": "class",
      "relation": "have",
      "tail": "Design principles behind resolving a resource URL to a java.io.File",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.StopWatch#getLastTaskInfo()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getLastTaskInfo",
      "tail_type": "apiFunction"
    },
    {
      "head": "getLastTaskInfo",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "deprecated",
      "tail_type": "useConstraint"
    },
    {
      "head": "getLastTaskInfo",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "StopWatch",
      "tail_type": "class"
    },
    {
      "head": "getLastTaskInfo",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "TaskInfo",
      "tail_type": "useSampleCode"
    },
    {
      "head": "getLastTaskInfo",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "getLastTaskInfo",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.StopWatch",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "getLastTaskInfo",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StopWatch#getTotalTimeSeconds()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getTotalTime",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StopWatch#getTotalTimeSeconds()",
      "head_type": "method",
      "relation": "have",
      "tail": "getTotalTimeSecondsSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "getTotalTimeSecondsSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "getTotalTimeSecondsSampleCodeContent",
      "tail_type": "codeContent"
    },
    {
      "head": "org.springframework.util.StopWatch#getTotalTimeSeconds()",
      "head_type": "method",
      "relation": "have",
      "tail": "getTotalTimeSecondsRelatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "getTotalTimeSecondsRelatedConceptInterpretation",
      "head_type": "relatedConceptInterpretation",
      "relation": "have",
      "tail": "getTotalTimeSecondsRelatedConceptInterpretationContent",
      "tail_type": "interpretationContent"
    },
    {
      "head": "org.springframework.util.StopWatch#getTotalTimeSeconds()",
      "head_type": "method",
      "relation": "have",
      "tail": "getTotalTimeSecondsDesignPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "getTotalTimeSecondsDesignPrincipleInterpretation",
      "head_type": "designPrincipleInterpretation",
      "relation": "have",
      "tail": "getTotalTimeSecondsDesignPrincipleInterpretationContent",
      "tail_type": "interpretationContent"
    },
    {
      "head": "org.springframework.util.NonClosingOutputStream#close()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "close stream",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.NonClosingOutputStream#close()",
      "head_type": "method",
      "relation": "have",
      "tail": "This method closes the output stream and releases any system resources associated with it. It does not close the underlying stream.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.NonClosingOutputStream#close()",
      "head_type": "method",
      "relation": "have",
      "tail": "public void close() throws IOException",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.NonClosingOutputStream#close()",
      "head_type": "method",
      "relation": "have",
      "tail": "Ensure that the stream is flushed before closing it to write all data to the underlying stream.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.StringUtils#split(String,String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "splitting a string",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils#split(String,String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "delimiter must be non-null and non-empty",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.StringUtils#split(String,String)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "splitting a string at the first occurrence of a delimiter",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.StringUtils#split(String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for splitting a string",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.StringUtils#split(String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "interpretation of related concepts for splitting strings",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.StringUtils#split(String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle interpretation for splitting strings",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.StringUtils#split(String,String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.StringUtils",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.StringUtils#commaDelimitedListToStringArray(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "convert comma delimited list to array",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils#commaDelimitedListToStringArray(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "Convert a comma delimited list (for example, a row from a CSV file) into an array of strings.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.StringUtils#commaDelimitedListToStringArray(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "The method takes a string input potentially null or empty and returns an array of strings or an empty array if the input is empty.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.StringUtils#commaDelimitedListToStringArray(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "public static String[] commaDelimitedListToStringArray(@Nullable String str) {\n    return delimitedListToStringArray(str, \",\");\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySpliterator#getComparator()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getComparator",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySpliterator#getComparator()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "Comparator",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySpliterator#getComparator()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "Entry",
      "tail_type": "class"
    },
    {
      "head": "getComparator",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "useSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "sampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntry#toString()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "toString()",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntry#toString()",
      "head_type": "method",
      "relation": "have",
      "tail": "Converts the entry to a string representation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntry#toString()",
      "head_type": "method",
      "relation": "have",
      "tail": "Delegates the conversion to the internal delegate object",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntry#toString()",
      "head_type": "method",
      "relation": "have",
      "tail": "public String toString() {\n    return this.delegate.toString();\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#ignorableWhitespace(char[],int,int)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "handle ignorable whitespace",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#ignorableWhitespace(char[],int,int)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "must throw SAXException on failure",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#ignorableWhitespace(char[],int,int)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "parsing XML with ignorable whitespace",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#ignorableWhitespace(char[],int,int)",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#ignorableWhitespace(char[],int,int)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#ignorableWhitespace(char[],int,int)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#ignorableWhitespace(char[],int,int)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.AbstractStaxHandler",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#startCDATA()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "startCDATA",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#startCDATA()",
      "head_type": "method",
      "relation": "have",
      "tail": "Starts CDATA section",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#startCDATA()",
      "head_type": "method",
      "relation": "have",
      "tail": "public final void startCDATA() throws SAXException { this.inCData = true; }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#startCDATA()",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is used to handle the start of a CDATA section.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#startCDATA()",
      "head_type": "method",
      "relation": "have",
      "tail": "The method follows the principle of simplicity and clarity in handling XML parsing events.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#endDocumentInternal()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "end XML document processing",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#endDocumentInternal()",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is called to end the processing of an XML document.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#endDocumentInternal()",
      "head_type": "method",
      "relation": "have",
      "tail": "Ensure resources are cleaned up and the state is reset after document processing.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#endDocumentInternal()",
      "head_type": "method",
      "relation": "have",
      "tail": "package com.example.xml;\n\nimport javax.xml.stream.XMLStreamException;\n\npublic class XMLProcessor {\n    public void processDocument() throws XMLStreamException {\n        // Initialize processing\n        System.out.println(\"Starting XML document processing\");\n\n        // Process the document\n        System.out.println(\"Processing the document...\");\n\n        // End processing\n        endDocumentInternal();\n    }\n\n    protected void endDocumentInternal() throws XMLStreamException {\n        // Clean up resources\n        System.out.println(\"Ending XML document processing\");\n        // Reset state if necessary\n    }\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#cDataInternal(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "handle character data internally",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#cDataInternal(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "protected abstract void cDataInternal(String data) throws XMLStreamException;",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#cDataInternal(String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.AbstractStaxHandler",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLStreamReader",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getNamespaceURI()",
      "tail_type": "apiFunction"
    },
    {
      "head": "getNamespaceURI()",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "getNamespaceURI() useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "getNamespaceURI() useSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "getNamespaceURI() useSampleCode content",
      "tail_type": "content"
    },
    {
      "head": "getNamespaceURI()",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "Parser state constraint",
      "tail_type": "useConstraint"
    },
    {
      "head": "Parser state constraint",
      "head_type": "useConstraint",
      "relation": "have",
      "tail": "Parser state constraint description",
      "tail_type": "description"
    },
    {
      "head": "getNamespaceURI()",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "XML parsing scenario",
      "tail_type": "useScenario"
    },
    {
      "head": "XML parsing scenario",
      "head_type": "useScenario",
      "relation": "have",
      "tail": "XML parsing scenario description",
      "tail_type": "description"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLStreamReader",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml",
      "tail_type": "package"
    },
    {
      "head": "org.springframework.util.xml",
      "head_type": "package",
      "relation": "have",
      "tail": "org.springframework.util.xml package description",
      "tail_type": "description"
    },
    {
      "head": "org.springframework.util.xml.DomContentHandler#skippedEntity(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "skippingEntity",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.DomContentHandler#skippedEntity(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.DomContentHandler#skippedEntity(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.DomContentHandler#skippedEntity(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.SimpleTransformErrorListener",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "XSLT transformation warning logging",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.SimpleTransformErrorListener",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "XSLT transformation error logging",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.SimpleTransformErrorListener",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "XML transformation error rethrowing",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.SimpleTransformErrorListener",
      "head_type": "class",
      "relation": "have",
      "tail": "SimpleTransformErrorListener usage sample",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.SimpleTransformErrorListener",
      "head_type": "class",
      "relation": "have",
      "tail": "ErrorListener implementation details",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.SimpleTransformErrorListener",
      "head_type": "class",
      "relation": "have",
      "tail": "Design principles of SimpleTransformErrorListener",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "SimpleTransformErrorListener usage sample",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "Complete usage example of SimpleTransformErrorListener",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamHandler#ignorableWhitespaceInternal(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "handle ignorable whitespace in XML",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamHandler#ignorableWhitespaceInternal(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "writes characters to the stream writer",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamHandler#ignorableWhitespaceInternal(String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.StaxStreamHandler",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamHandler#ignorableWhitespaceInternal(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is used to handle ignorable whitespace in XML documents. It writes the given data to the stream writer.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamHandler#ignorableWhitespaceInternal(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is a part of the StaxStreamHandler class and is used to process XML data. It ensures that ignorable whitespace is correctly handled and written to the output stream.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils#isStaxResult(Result)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "Indicate whether the given Result is a JAXP 1.4 StAX Result or custom StAX Result",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils#isStaxResult(Result)",
      "head_type": "method",
      "relation": "have",
      "tail": "public static boolean isStaxResult(Result result) { return (result instanceof StAXResult || result instanceof StaxResult); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils#isStaxResult(Result)",
      "head_type": "method",
      "relation": "have",
      "tail": "The method checks if the provided Result object is an instance of StAXResult or StaxResult, returning true if it is, and false otherwise.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils#isStaxResult(Result)",
      "head_type": "method",
      "relation": "have",
      "tail": "The design principle followed here is to provide a utility method that can be used to easily determine if a Result object is a StAX Result, which can be useful in XML processing scenarios.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamReader",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "XML Stream Reading",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamReader",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "XML Event Handling",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamReader",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "XML Document Parsing",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamReader",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "StAX and DOM Conversion",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamReader",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "XML Namespace Management",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamReader",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "XML Processing Instruction Handling",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamReader",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "XML Comment Handling",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamReader",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "XML Character Data Handling",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamReader",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "XML Attribute Access",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamReader",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "XML Stream Navigation",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamReader",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "Resource Management",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamReader",
      "head_type": "class",
      "relation": "constrained_by",
      "tail": "XML Stream Exception Handling",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamReader",
      "head_type": "class",
      "relation": "constrained_by",
      "tail": "Valid XML Event Handling",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamReader",
      "head_type": "class",
      "relation": "applied_to",
      "tail": "XML Data Binding",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamReader",
      "head_type": "class",
      "relation": "applied_to",
      "tail": "XML Document Transformation",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamReader",
      "head_type": "class",
      "relation": "have",
      "tail": "XML Event Reader Encapsulation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamReader",
      "head_type": "class",
      "relation": "have",
      "tail": "StAX Interface Implementation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamReader",
      "head_type": "class",
      "relation": "have",
      "tail": "XML Parsing Efficiency",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamReader",
      "head_type": "class",
      "relation": "have",
      "tail": "XML Event Stream Processing",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamReader",
      "head_type": "class",
      "relation": "have",
      "tail": "Sample Code for XML Event Stream Reading",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamReader#getLocation()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getLocation",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamReader#getLocation()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.XMLEventStreamReader",
      "tail_type": "class"
    },
    {
      "head": "getLocation",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamReader#isAttributeSpecified(int)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "Check if an attribute is specified",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamReader#isAttributeSpecified(int)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.xml.XMLEventStreamReader#getAttribute(int)",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamReader#getAttribute(int)",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.XMLEventStreamReader",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamReader#isAttributeSpecified(int)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.XMLEventStreamReader",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter#writeStartElement(String,String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "writeStartElement",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter#writeStartElement(String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "writeStartElementSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "writeStartElementSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "writeStartElementSampleCodeContent",
      "tail_type": "useSampleCodeContent"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter#close()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "close XML stream",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter#close()",
      "head_type": "method",
      "relation": "have",
      "tail": "Closes the XML stream writer",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter#close()",
      "head_type": "method",
      "relation": "have",
      "tail": "Ensure proper closing of XML elements",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter#close()",
      "head_type": "method",
      "relation": "have",
      "tail": "public void close() throws XMLStreamException { closeEmptyElementIfNecessary(); this.eventWriter.close(); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.XmlValidationModeDetector#hasDoctype(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "check for DTD DOCTYPE declaration",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.XmlValidationModeDetector#hasDoctype(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "check if the content contains the DTD DOCTYPE declaration",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.XmlValidationModeDetector#hasDoctype(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "private boolean hasDoctype(String content) { return content.contains(DOCTYPE); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "a.ClassHavingNestedClass",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "nested class",
      "tail_type": "apiFunction"
    },
    {
      "head": "a.ClassHavingNestedClass",
      "head_type": "class",
      "relation": "constrained_by",
      "tail": "package name length constraint",
      "tail_type": "useConstraint"
    },
    {
      "head": "a.ClassHavingNestedClass",
      "head_type": "class",
      "relation": "applied_to",
      "tail": "single character package name",
      "tail_type": "useScenario"
    },
    {
      "head": "a.ClassHavingNestedClass",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.ClassUtilsTests",
      "tail_type": "class"
    },
    {
      "head": "a.ClassHavingNestedClass",
      "head_type": "class",
      "relation": "have",
      "tail": "related concept interpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "a.ClassHavingNestedClass",
      "head_type": "class",
      "relation": "have",
      "tail": "design principle interpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "a.ClassHavingNestedClass",
      "head_type": "class",
      "relation": "have",
      "tail": "sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "example.type.SimpleJdbcDaoSupport",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "JDBC data access support",
      "tail_type": "apiFunction"
    },
    {
      "head": "example.type.SimpleJdbcDaoSupport",
      "head_type": "class",
      "relation": "have",
      "tail": "This class provides support for JDBC data access operations.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "example.type.SimpleJdbcDaoSupport",
      "head_type": "class",
      "relation": "have",
      "tail": "It simplifies the use of JDBC templates and manages database connections.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "example.type.SimpleJdbcDaoSupport",
      "head_type": "class",
      "relation": "have",
      "tail": "import org.springframework.jdbc.core.JdbcTemplate;\n\npublic class SimpleJdbcDaoSupportExample {\n    private JdbcTemplate jdbcTemplate;\n\n    public SimpleJdbcDaoSupportExample(JdbcTemplate jdbcTemplate) {\n        this.jdbcTemplate = jdbcTemplate;\n    }\n\n    public void someMethod() {\n        // Example of using JdbcTemplate\n        String sql = \"SELECT COUNT(*) FROM some_table\";\n        int count = jdbcTemplate.queryForObject(sql, Integer.class);\n        System.out.println(\"Count: \" + count);\n    }\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassesTests#withNameUpdatesNamingConventions()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "GeneratedClassesTests",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassesTests#withNameUpdatesNamingConventions()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "addForFeatureComponent",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassesTests#withNameUpdatesNamingConventions()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "withFeatureNamePrefix",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassesTests#withNameUpdatesNamingConventions()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "GeneratedClass.getName",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassesTests#withNameUpdatesNamingConventions()",
      "head_type": "method",
      "relation": "have",
      "tail": "GeneratedClass",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassesTests#withNameUpdatesNamingConventions()",
      "head_type": "method",
      "relation": "have",
      "tail": "TestComponent",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassesTests#withNameUpdatesNamingConventions()",
      "head_type": "method",
      "relation": "have",
      "tail": "endsWith",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassesTests#withNameUpdatesNamingConventions()",
      "head_type": "method",
      "relation": "have",
      "tail": "assertThat",
      "tail_type": "apiFunction"
    },
    {
      "head": "addForFeatureComponent",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.GeneratedClassesTests#withNameUpdatesNamingConventions()",
      "tail_type": "method"
    },
    {
      "head": "withFeatureNamePrefix",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.GeneratedClassesTests#withNameUpdatesNamingConventions()",
      "tail_type": "method"
    },
    {
      "head": "GeneratedClass.getName",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.GeneratedClassesTests#withNameUpdatesNamingConventions()",
      "tail_type": "method"
    },
    {
      "head": "GeneratedClass",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.GeneratedClassesTests#withNameUpdatesNamingConventions()",
      "tail_type": "method"
    },
    {
      "head": "TestComponent",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.GeneratedClassesTests#withNameUpdatesNamingConventions()",
      "tail_type": "method"
    },
    {
      "head": "endsWith",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.GeneratedClassesTests#withNameUpdatesNamingConventions()",
      "tail_type": "method"
    },
    {
      "head": "assertThat",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.GeneratedClassesTests#withNameUpdatesNamingConventions()",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassTests#reserveMethodNamesWhenNameUsedThrowsException()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "reserve method names",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassTests#reserveMethodNamesWhenNameUsedThrowsException()",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "name conflict",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassTests#reserveMethodNamesWhenNameUsedThrowsException()",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "method name reservation",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassTests#reserveMethodNamesWhenNameUsedThrowsException()",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.aot.generate.GeneratedClass",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassTests#reserveMethodNamesWhenNameUsedThrowsException()",
      "head_type": "method",
      "relation": "have",
      "tail": "void reserveMethodNamesWhenNameUsedThrowsException() {\n    GeneratedClass generatedClass = createGeneratedClass(TEST_CLASS_NAME);\n    generatedClass.getMethods().add(\"apply\", emptyMethodCustomizer);\n    assertThatIllegalStateException().isThrownBy(() -> generatedClass.reserveMethodNames(\"apply\"));\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassTests#reserveMethodNamesWhenNameUsedThrowsException()",
      "head_type": "method",
      "relation": "have",
      "tail": "GeneratedClass is used to represent a class generated at runtime, and it provides methods to add and reserve method names. The method reserveMethodNames is used to reserve a method name, and if the name is already used, it throws an IllegalStateException.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassTests#reserveMethodNamesWhenNameUsedThrowsException()",
      "head_type": "method",
      "relation": "have",
      "tail": "The design principle behind reserveMethodNames is to ensure that method names are unique within a generated class to avoid conflicts. This is important for maintaining the integrity of the generated code.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassTests#generateJavaFileIncludesDeclaredClasses()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "generateJavaFileIncludesDeclaredClasses",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassTests#generateJavaFileIncludesDeclaredClasses()",
      "head_type": "method",
      "relation": "have",
      "tail": "GeneratedClass is used to create and manipulate classes at runtime.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassTests#generateJavaFileIncludesDeclaredClasses()",
      "head_type": "method",
      "relation": "have",
      "tail": "Design principle follows test-driven development to ensure generated classes include declared classes.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassTests#generateJavaFileIncludesDeclaredClasses()",
      "head_type": "method",
      "relation": "have",
      "tail": "package org.springframework.aot.generate;\n\nimport org.junit.jupiter.api.Test;\nimport static org.assertj.core.api.Assertions.assertThat;\n\npublic class GeneratedClassTests {\n\n    @Test\n    void generateJavaFileIncludesDeclaredClasses() {\n        GeneratedClass generatedClass = createGeneratedClass(\"TEST_CLASS_NAME\");\n        generatedClass.getOrAdd(\"First\", type -> type.modifiers.add(Modifier.STATIC));\n        generatedClass.getOrAdd(\"Second\", type -> type.modifiers.add(Modifier.PRIVATE));\n        assertThat(generatedClass.generateJavaFile().toString()).contains(\"static class First\").contains(\"private class Second\");\n    }\n\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.ValueCodeAssert",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "hasImport",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.ValueCodeAssert",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "hasValueCode",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.ValueCodeAssert",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "valueCode",
      "tail_type": "apiFunction"
    },
    {
      "head": "hasImport",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "hasImport",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "hasValueCode",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "hasValueCode",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "valueCode",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "valueCode",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.ValueCodeAssert#hasValueCode(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "assertion",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.ValueCodeAssert#hasValueCode(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.aot.generate.ValueCodeAssert#hasValueCode(String) sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.ValueCodeAssert#hasValueCode(String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.ValueCodeAssert",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldProcessAnnotationOnInterface()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "processAnnotationOnInterface",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldProcessAnnotationOnInterface()",
      "head_type": "method",
      "relation": "have",
      "tail": "processAnnotationOnInterfaceSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "processAnnotationOnInterfaceSampleCode",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "tail": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldProcessAnnotationOnInterface()",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldProcessAnnotationOnInterface()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#setCaseSensitive(boolean)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "case-sensitive pattern matching",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#setCaseSensitive(boolean)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "default is true",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#setCaseSensitive(boolean)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "case-insensitive matching",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#setCaseSensitive(boolean)",
      "head_type": "method",
      "relation": "have",
      "tail": "public void setCaseSensitive(boolean caseSensitive) {    this.caseSensitive = caseSensitive;}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#setCaseSensitive(boolean)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#setCaseSensitive(boolean)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.AntPathMatcher",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.AntPathMatcher#setCaseSensitive(boolean)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.PathSeparatorPatternCache",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getEndsOnWildCard()",
      "tail_type": "apiFunction"
    },
    {
      "head": "getEndsOnWildCard()",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "public String getEndsOnWildCard() { return this.endsOnWildCard; }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.PathSeparatorPatternCache",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.PathSeparatorPatternCache#getEndsOnWildCard()",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.PathSeparatorPatternCache#getEndsOnWildCard()",
      "head_type": "method",
      "relation": "have",
      "tail": "public String getEndsOnWildCard() { return this.endsOnWildCard; }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.Assert#noNullElements(Collection<?>,Supplier<String>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "assertNoNullElements",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.Assert#noNullElements(Collection<?>,Supplier<String>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "collectionNotNull",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.Assert#noNullElements(Collection<?>,Supplier<String>)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "checkCollectionForNullElements",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.Assert#noNullElements(Collection<?>,Supplier<String>)",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.Assert#noNullElements(Collection<?>,Supplier<String>)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.Assert#noNullElements(Collection<?>,Supplier<String>)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "assertNoNullElements",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "org.springframework.util.Assert",
      "tail_type": "class"
    },
    {
      "head": "collectionNotNull",
      "head_type": "useConstraint",
      "relation": "associated_with",
      "tail": "org.springframework.util.Assert#noNullElements(Collection<?>,Supplier<String>)",
      "tail_type": "method"
    },
    {
      "head": "checkCollectionForNullElements",
      "head_type": "useScenario",
      "relation": "associated_with",
      "tail": "org.springframework.util.Assert#noNullElements(Collection<?>,Supplier<String>)",
      "tail_type": "method"
    },
    {
      "head": "useSampleCode",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "tail": "org.springframework.util.Assert#noNullElements(Collection<?>,Supplier<String>)",
      "tail_type": "method"
    },
    {
      "head": "relatedConceptInterpretation",
      "head_type": "relatedConceptInterpretation",
      "relation": "associated_with",
      "tail": "org.springframework.util.Assert#noNullElements(Collection<?>,Supplier<String>)",
      "tail_type": "method"
    },
    {
      "head": "designPrincipleInterpretation",
      "head_type": "designPrincipleInterpretation",
      "relation": "associated_with",
      "tail": "org.springframework.util.Assert#noNullElements(Collection<?>,Supplier<String>)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.Assert#messageWithTypeName(String,Object)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "concatenateMessageWithTypeName",
      "tail_type": "apiFunction"
    },
    {
      "head": "concatenateMessageWithTypeName",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "concatenateMessageWithTypeNameSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "concatenateMessageWithTypeName",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "concatenateMessageWithTypeNameRelatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "concatenateMessageWithTypeName",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "concatenateMessageWithTypeNameDesignPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.backoff.ExponentialBackOff",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "exponential back off",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.backoff.ExponentialBackOff",
      "head_type": "class",
      "relation": "constrained_by",
      "tail": "multiplier should be greater than or equal to 1",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.backoff.ExponentialBackOff",
      "head_type": "class",
      "relation": "applied_to",
      "tail": "retry attempts with increasing intervals",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.backoff.ExponentialBackOff",
      "head_type": "class",
      "relation": "have",
      "tail": "complete sample code for using exponential back off",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.backoff.ExponentialBackOff",
      "head_type": "class",
      "relation": "have",
      "tail": "related concept interpretation for exponential back off",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.backoff.ExponentialBackOff",
      "head_type": "class",
      "relation": "have",
      "tail": "design principle interpretation for exponential back off",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.backoff.ExponentialBackOff",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.core.SimpleAliasRegistryTests",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.backoff.FixedBackOff",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "fixed interval backoff",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.backoff.FixedBackOff",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "maximum number of retries",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.backoff.FixedBackOff",
      "head_type": "class",
      "relation": "have",
      "tail": "default recovery interval of 5000 ms",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.backoff.FixedBackOff",
      "head_type": "class",
      "relation": "have",
      "tail": " unlimited number of attempts",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.backoff.FixedBackOff",
      "head_type": "class",
      "relation": "have",
      "tail": " interval between two attempts",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.backoff.FixedBackOff",
      "head_type": "class",
      "relation": "have",
      "tail": "maximum number of attempts",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.backoff.FixedBackOff",
      "head_type": "class",
      "relation": "have",
      "tail": "start method returning BackOffExecution",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.backoff.FixedBackOff",
      "head_type": "class",
      "relation": "have",
      "tail": "nextBackOff method",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.backoff.FixedBackOff",
      "head_type": "class",
      "relation": "have",
      "tail": "toString method",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.backoff.FixedBackOff",
      "head_type": "class",
      "relation": "have",
      "tail": "related to BackOff interface",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.backoff.FixedBackOff",
      "head_type": "class",
      "relation": "have",
      "tail": "designed to provide a fixed interval between attempts and a maximum number of retries",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.backoff.FixedBackOff",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "Stephane Nicoll",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.backoff.FixedBackOff",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "4.1",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.ClassUtils#getUserClass(Object)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "returnUserDefinedClass",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ClassUtils#getUserClass(Object)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "instanceNotNull",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ClassUtils#getUserClass(Object)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "CGLIBGeneratedSubclass",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ClassUtils#getUserClass(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "CGLIBGeneratedSubclass",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ClassUtils#getUserClass(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "returnUserDefinedClassSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ClassUtils#getUserClass(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "CGLIBGeneratedSubclassInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#getUserClass(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleForUserClassRetrieval",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#getUserClass(Object)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.Assert",
      "tail_type": "class"
    },
    {
      "head": "returnUserDefinedClassSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "completeExampleForUserClassRetrieval",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ClassUtils#getUserClass(Class<?>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getUserClass",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ClassUtils#getUserClass(Class<?>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "CGLIB-generated subclass",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ClassUtils#getUserClass(Class<?>)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "class checking",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ClassUtils#getUserClass(Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "Return the user-defined class for the given class",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#getUserClass(Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "Design principle: Return the original class in case of a CGLIB-generated subclass",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#getUserClass(Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "package com.healthMgr.common.email; import java.util.Class; public class OneClass { public static Class<?> getUserClass(Class<?> clazz) { if (clazz.getName().contains(\"CGLIB_CLASS_SEPARATOR\")) { Class<?> superclass = clazz.getSuperclass(); if (superclass != null && superclass != Object.class) { return superclass; } } return clazz; } }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ClassUtils#getUserClass(Class<?>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.ClassUtils",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.ClassUtils#getShortName(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getShortName",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ClassUtils#getShortName(String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "IllegalArgumentException if the className is empty",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ClassUtils#getShortName(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "Get the class name without the qualified package name",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#getShortName(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "public static String getShortName(String className) {    Assert.hasLength(className, \"Class name must not be empty\");    int lastDotIndex = className.lastIndexOf(PACKAGE_SEPARATOR);    int nameEndIndex = className.indexOf(CGLIB_CLASS_SEPARATOR);    if (nameEndIndex == -1) {        nameEndIndex = className.length();    }    String shortName = className.substring(lastDotIndex + 1, nameEndIndex);    shortName = shortName.replace(NESTED_CLASS_SEPARATOR, PACKAGE_SEPARATOR);    return shortName;}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "getShortName",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "org.springframework.util.ClassUtils",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.ClassUtils",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getShortName",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ClassUtils#getInterfaceMethodIfPossible(Method,Class<?>,boolean)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getInterfaceMethodIfPossible",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ClassUtils#getInterfaceMethodIfPossible(Method,Class<?>,boolean)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "requirePublicInterface",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ClassUtils#getInterfaceMethodIfPossible(Method,Class<?>,boolean)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "findInterfaceMethodIfPossible",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ClassUtils#getInterfaceMethodIfPossible(Method,Class<?>,boolean)",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ClassUtils#getInterfaceMethodIfPossible(Method,Class<?>,boolean)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#getInterfaceMethodIfPossible(Method,Class<?>,boolean)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "getInterfaceMethodIfPossible",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "org.springframework.util.ClassUtils",
      "tail_type": "class"
    },
    {
      "head": "requirePublicInterface",
      "head_type": "useConstraint",
      "relation": "associated_with",
      "tail": "org.springframework.util.ClassUtils",
      "tail_type": "class"
    },
    {
      "head": "findInterfaceMethodIfPossible",
      "head_type": "useScenario",
      "relation": "associated_with",
      "tail": "org.springframework.util.ClassUtils",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.CompositeCollection#size()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "sizeCalculation",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.CompositeCollection#size()",
      "head_type": "method",
      "relation": "have",
      "tail": "sizeCalculationSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "sizeCalculationSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "Complete sizeCalculation Example",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ConcurrencyThrottleSupport#setConcurrencyLimit(int)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "set maximum number of concurrent access attempts",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ConcurrencyThrottleSupport#setConcurrencyLimit(int)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "do not switch between -1 and any concrete limit at runtime",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ConcurrencyThrottleSupport#setConcurrencyLimit(int)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ConcurrencyThrottleSupport#setConcurrencyLimit(int)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ConcurrencyThrottleSupport#setConcurrencyLimit(int)",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "relatedConceptInterpretation",
      "head_type": "relatedConceptInterpretation",
      "relation": "associated_with",
      "tail": "concurrency limit",
      "tail_type": "apiFunction"
    },
    {
      "head": "designPrincipleInterpretation",
      "head_type": "designPrincipleInterpretation",
      "relation": "associated_with",
      "tail": "runtime configuration setting",
      "tail_type": "apiFunction"
    },
    {
      "head": "useSampleCode",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "tail": "setConcurrencyLimit method",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ReadOperations#clear()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "clearing buffers",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ReadOperations#clear()",
      "head_type": "method",
      "relation": "have",
      "tail": "void clear() {\n    for (int i = 0; i < BUFFER_COUNT; i++) {\n        AtomicReferenceArray<Node<K, V>> buffer = this.buffers[i];\n        for (int j = 0; j < BUFFER_SIZE; j++) {\n            buffer.lazySet(j, null);\n        }\n    }\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ReadOperations#clear()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.ReadOperations",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.WriteOperations#drainAll()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "execute all tasks",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.WriteOperations#drainAll()",
      "head_type": "method",
      "relation": "have",
      "tail": "public void drainAll() {\n    Runnable task;\n    while ((task = this.operations.poll()) != null) {\n        task.run();\n    }\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.WriteOperations#drainAll()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.WriteOperations",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.Entries",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "addEntry",
      "tail_type": "apiFunction"
    },
    {
      "head": "addEntry",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "addEntrySampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "addEntry",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "nullValueConstraint",
      "tail_type": "useConstraint"
    },
    {
      "head": "addEntry",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "taskAccessToSegmentEntries",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.Entries",
      "head_type": "class",
      "relation": "have",
      "tail": "taskAccessToSegmentEntries",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.Entries",
      "head_type": "class",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.Entries",
      "head_type": "class",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.FileCopyUtils#copyToByteArray(File)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "copy file to byte array",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.FileCopyUtils#copyToByteArray(File)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "input file must not be null",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.FileCopyUtils#copyToByteArray(File)",
      "head_type": "method",
      "relation": "have",
      "tail": "Copy the contents of the given input File into a new byte array.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.FileCopyUtils#copyToByteArray(File)",
      "head_type": "method",
      "relation": "have",
      "tail": "Ensure the input file is not null to prevent null pointer exceptions.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.FileCopyUtils#copyToByteArray(File)",
      "head_type": "method",
      "relation": "have",
      "tail": "public static byte[] copyToByteArray(File in) throws IOException {\n    Assert.notNull(in, \"No input File specified\");\n    return copyToByteArray(Files.newInputStream(in.toPath()));\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.function.ThrowingConsumer#of(ThrowingConsumer<T>,BiFunction<String,Exception,RuntimeException>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "create ThrowingConsumer",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.function.ThrowingConsumer#of(ThrowingConsumer<T>,BiFunction<String,Exception,RuntimeException>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "exceptionWrapper must handle thrown checked exceptions",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.function.ThrowingConsumer#of(ThrowingConsumer<T>,BiFunction<String,Exception,RuntimeException>)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "working with method references",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.function.ThrowingConsumer#of(ThrowingConsumer<T>,BiFunction<String,Exception,RuntimeException>)",
      "head_type": "method",
      "relation": "have",
      "tail": "convert method that throws checked exception to Consumer",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.function.ThrowingConsumer#of(ThrowingConsumer<T>,BiFunction<String,Exception,RuntimeException>)",
      "head_type": "method",
      "relation": "have",
      "tail": "static <T> ThrowingConsumer<T> of(ThrowingConsumer<T> consumer, BiFunction<String, Exception, RuntimeException> exceptionWrapper) { return consumer.throwing(exceptionWrapper); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.function.ThrowingConsumer#of(ThrowingConsumer<T>,BiFunction<String,Exception,RuntimeException>)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method wraps any thrown checked exceptions using the given exceptionWrapper, making it useful for converting methods that throw checked exceptions into instances compatible with a regular Consumer.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.function.ThrowingConsumer#of(ThrowingConsumer<T>,BiFunction<String,Exception,RuntimeException>)",
      "head_type": "method",
      "relation": "have",
      "tail": "The design principle is to provide a convenient way to handle checked exceptions in lambda expressions, enhancing code readability and maintainability.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.function.ThrowingConsumer#of(ThrowingConsumer<T>,BiFunction<String,Exception,RuntimeException>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.function.ThrowingConsumer",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.InstanceFilter#match(T,T)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "equality check",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.InstanceFilter#match(T,T)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.InstanceFilter#match(T,T)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.InstanceFilter#match(T,T)",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "equality check",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "type constraint",
      "tail_type": "useConstraint"
    },
    {
      "head": "equality check",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "object comparison",
      "tail_type": "useScenario"
    },
    {
      "head": "relatedConceptInterpretation",
      "head_type": "relatedConceptInterpretation",
      "relation": "associated_with",
      "tail": "org.springframework.util.InstanceFilter#match(T,T)",
      "tail_type": "method"
    },
    {
      "head": "designPrincipleInterpretation",
      "head_type": "designPrincipleInterpretation",
      "relation": "associated_with",
      "tail": "org.springframework.util.InstanceFilter#match(T,T)",
      "tail_type": "method"
    },
    {
      "head": "useSampleCode",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "tail": "org.springframework.util.InstanceFilter#match(T,T)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.LinkedCaseInsensitiveMap#size()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "size determination",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.LinkedCaseInsensitiveMap#size()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "java.util.Map",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.LinkedCaseInsensitiveMap#size()",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is used to determine the number of elements in the map.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.LinkedCaseInsensitiveMap#size()",
      "head_type": "method",
      "relation": "have",
      "tail": "The design principle followed here is to delegate the size determination to the underlying targetMap, ensuring consistency and leveraging existing implementations.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.LinkedCaseInsensitiveMap#size()",
      "head_type": "method",
      "relation": "have",
      "tail": "java\npackage org.springframework.util;\n\nimport java.util.Map;\n\npublic class LinkedCaseInsensitiveMapExample {\n    public static void main(String[] args) {\n        LinkedCaseInsensitiveMap<String, String> map = new LinkedCaseInsensitiveMap<>();\n        map.put(\"Key1\", \"Value1\");\n        map.put(\"key2\", \"Value2\");\n        \n        int size = map.size();\n        System.out.println(\"Size of map: \" + size);\n    }\n}\n",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.LinkedCaseInsensitiveMap#getOrDefault(Object,V)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getOrDefault",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.LinkedCaseInsensitiveMap#getOrDefault(Object,V)",
      "head_type": "method",
      "relation": "have",
      "tail": "getOrDefault checks if the key exists in the map and returns its value; otherwise, it returns the defaultValue.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.LinkedCaseInsensitiveMap#getOrDefault(Object,V)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is designed to handle keys in a case-insensitive manner, enhancing the flexibility of key retrieval.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.LinkedCaseInsensitiveMap#getOrDefault(Object,V)",
      "head_type": "method",
      "relation": "have",
      "tail": "package com.example.demo;\n\nimport java.util.LinkedHashMap;\nimport java.util.Map;\n\npublic class Main {\n    public static void main(String[] args) {\n        Map<String, Integer> map = new LinkedCaseInsensitiveMap<>();\n        map.put(\"Key\", 1);\n        System.out.println(map.getOrDefault(\"key\", 0)); // Output: 1\n        System.out.println(map.getOrDefault(\"nonexistent\", 0)); // Output: 0\n    }\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.EntrySetIterator#next()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "Entry retrieval",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.EntrySetIterator#next()",
      "head_type": "method",
      "relation": "have",
      "tail": "Retrieves the next entry in the iteration",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.EntrySetIterator#next()",
      "head_type": "method",
      "relation": "have",
      "tail": "public Entry<String, V> next() { return nextEntry(); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.EntrySetIterator#next()",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is used to iterate over the entries in a set, providing a way to access each entry sequentially.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.MimeTypeUtils#parseMimeTypes(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "parse comma-separated string into list of MimeType objects",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MimeTypeUtils#parseMimeTypes(String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "string must be valid, otherwise throw InvalidMimeTypeException",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.MimeTypeUtils#parseMimeTypes(String)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "parse MIME types from a string input",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.MimeTypeUtils#parseMimeTypes(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "public static List<MimeType> parseMimeTypes(String mimeTypes) { if (!StringUtils.hasLength(mimeTypes)) { return Collections.emptyList(); } return tokenize(mimeTypes).stream().filter(StringUtils::hasText).map(MimeTypeUtils::parseMimeType).collect(Collectors.toList()); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.MimeTypeUtils#parseMimeTypes(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "related to MIME type parsing and validation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.MimeTypeUtils#parseMimeTypes(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle: efficient parsing with error handling",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.MimeTypeUtils#parseMimeTypes(String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.MimeTypeUtils",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.MultiValueMapAdapter#getFirst(K)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getFirst",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MultiValueMapAdapter#getFirst(K)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "MultiValueMap",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.MultiValueMapAdapter#getFirst(K)",
      "head_type": "method",
      "relation": "have",
      "tail": "getFirst(K) returns the first value associated with the specified key in the MultiValueMap",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.MultiValueMapAdapter#getFirst(K)",
      "head_type": "method",
      "relation": "have",
      "tail": "The method ensures that if the list of values is not empty, the first element is returned; otherwise, null is returned",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.MultiValueMapAdapter#getFirst(K)",
      "head_type": "method",
      "relation": "have",
      "tail": "package org.springframework.util;\n\nimport java.util.List;\n\npublic class MultiValueMapAdapter<K, V> extends AbstractMultiValueMap<K, V> {\n    \n    @Override\n    @Nullable\n    public V getFirst(K key) {\n        List<V> values = this.targetMap.get(key);\n        return (!CollectionUtils.isEmpty(values) ? values.get(0) : null);\n    }\n\n    // Other methods and necessary imports\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.MultiValueMapAdapter#add(K,V)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "add elements to a collection",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MultiValueMapAdapter#add(K,V)",
      "head_type": "method",
      "relation": "have",
      "tail": "add elements to a collection",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MultiValueMapAdapter#add(K,V)",
      "head_type": "method",
      "relation": "have",
      "tail": "public void add(K key, @Nullable V value) { List<V> values = this.targetMap.computeIfAbsent(key, k -> new ArrayList<>(1)); values.add(value); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.MultiValueMapAdapter#add(K,V)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.MultiValueMapAdapter",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.PlaceholderParser#parse(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "parse placeholders in a string",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.PlaceholderParser#parse(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.PlaceholderParser#parse(String) sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.PlaceholderParser#parse(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "related concept interpretation for PlaceholderParser",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.PlaceholderParser#parse(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle interpretation for PlaceholderParser",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.PlaceholderParser#parse(String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.PlaceholderParser",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.PlaceholderParser#nextValidEndPrefix(String,int)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "parsing placeholders",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.PlaceholderParser#nextValidEndPrefix(String,int)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "valid placeholder syntax",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.PlaceholderParser#nextValidEndPrefix(String,int)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "resolving nested placeholders",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.PlaceholderParser#nextValidEndPrefix(String,int)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for parsing placeholders",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.PlaceholderParser#nextValidEndPrefix(String,int)",
      "head_type": "method",
      "relation": "have",
      "tail": "related concepts in placeholder resolution",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.PlaceholderParser#nextValidEndPrefix(String,int)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principles of placeholder parsing",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.PlaceholderParser#nextValidEndPrefix(String,int)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.PlaceholderParser",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.PropertiesPersister#loadFromXml(Properties,InputStream)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "load properties from XML",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.PropertiesPersister#loadFromXml(Properties,InputStream)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "I/O errors",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.PropertiesPersister#loadFromXml(Properties,InputStream)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.PropertiesPersister#loadFromXml(Properties,InputStream)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.PropertiesPersister#loadFromXml(Properties,InputStream)",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.PropertiesPersister",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "java.util.Properties",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.PropertiesPersister",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "java.io.InputStream",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.PropertiesPersister",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "java.io.IOException",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#getDeclaredMethods(Class<?>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getDeclaredMethods",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#getDeclaredMethods(Class<?>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "IllegalStateException if introspection fails",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#getDeclaredMethods(Class<?>)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "introspection of classes",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#getDeclaredMethods(Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "Java 8 default methods from locally implemented interfaces",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#getDeclaredMethods(Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "local cache to avoid new Method instances",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#getDeclaredMethods(Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "public static Method[] getDeclaredMethods(Class<?> clazz) { return getDeclaredMethods(clazz, true); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "getDeclaredMethods",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "Class<?> clazz",
      "tail_type": "class"
    },
    {
      "head": "getDeclaredMethods",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "Method[]",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.RouteMatcher#matchAndExtract(String,Route)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "template variable extraction",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.RouteMatcher#matchAndExtract(String,Route)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "route pattern matching",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.RouteMatcher#matchAndExtract(String,Route)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.RouteMatcher#matchAndExtract(String,Route) sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.RouteMatcher#matchAndExtract(String,Route)",
      "head_type": "method",
      "relation": "have",
      "tail": "related concept interpretation for org.springframework.util.RouteMatcher#matchAndExtract(String,Route)",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.RouteMatcher#matchAndExtract(String,Route)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle interpretation for org.springframework.util.RouteMatcher#matchAndExtract(String,Route)",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.RouteMatcher#matchAndExtract(String,Route)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.RouteMatcher",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.SingleToMultiValueMapAdapter#keySet()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "keySetRetrieval",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.SingleToMultiValueMapAdapter#keySet()",
      "head_type": "method",
      "relation": "have",
      "tail": "keySetRetrievalSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "keySetRetrievalSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "Complete keySet Retrieval Example",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.SingleToMultiValueMapAdapter#entrySet()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": " adapts a single value map to a multi-value map",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.SingleToMultiValueMapAdapter#entrySet()",
      "head_type": "method",
      "relation": "have",
      "tail": " returns a set view of the mappings contained in the map",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.SingleToMultiValueMapAdapter#entrySet()",
      "head_type": "method",
      "relation": "have",
      "tail": " ensures that the entries are initialized if they are null",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.SingleToMultiValueMapAdapter#entrySet()",
      "head_type": "method",
      "relation": "have",
      "tail": " creates a new set of entries if entries are null",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.SingleToMultiValueMapAdapter#entrySet()",
      "head_type": "method",
      "relation": "have",
      "tail": " uses an abstract set to create the entries",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.SingleToMultiValueMapAdapter#entrySet()",
      "head_type": "method",
      "relation": "have",
      "tail": " iterates over the entries using a custom iterator",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.SingleToMultiValueMapAdapter#entrySet()",
      "head_type": "method",
      "relation": "have",
      "tail": " each entry is transformed to have a single-element list as its value",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.SingleToMultiValueMapAdapter#entrySet()",
      "head_type": "method",
      "relation": "have",
      "tail": " the size of the entries set is the same as the target map's entry set",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.SingleToMultiValueMapAdapter#entrySet()",
      "head_type": "method",
      "relation": "have",
      "tail": " ensures that the entries are only created once",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.SingleToMultiValueMapAdapter#entrySet()",
      "head_type": "method",
      "relation": "have",
      "tail": " this method adapts a single value map to a multi-value map by transforming each entry's value into a single-element list",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.SingleToMultiValueMapAdapter#entrySet()",
      "head_type": "method",
      "relation": "have",
      "tail": " the design principle is to provide a convenient way to adapt existing single-value maps to the multi-value map interface without changing the underlying data structure",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.StopWatch#getTotalTimeMillis()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getTotalTime",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StopWatch#getTotalTimeMillis()",
      "head_type": "method",
      "relation": "have",
      "tail": "getTotalTimeSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "getTotalTimeSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "getTotalTimeSampleCodeContent",
      "tail_type": "useSampleCodeContent"
    },
    {
      "head": "org.springframework.util.StopWatch#getTotalTimeMillis()",
      "head_type": "method",
      "relation": "have",
      "tail": "getTotalTimeRelatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "getTotalTimeRelatedConceptInterpretation",
      "head_type": "relatedConceptInterpretation",
      "relation": "have",
      "tail": "getTotalTimeRelatedConceptInterpretationContent",
      "tail_type": "relatedConceptInterpretationContent"
    },
    {
      "head": "org.springframework.util.StopWatch#getTotalTimeMillis()",
      "head_type": "method",
      "relation": "have",
      "tail": "getTotalTimeDesignPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "getTotalTimeDesignPrincipleInterpretation",
      "head_type": "designPrincipleInterpretation",
      "relation": "have",
      "tail": "getTotalTimeDesignPrincipleInterpretationContent",
      "tail_type": "designPrincipleInterpretationContent"
    },
    {
      "head": "org.springframework.util.StringUtils#isEmpty(Object)",
      "head_type": "method",
      "relation": "haveFuntion",
      "tail": "check if a string is empty",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils#isEmpty(Object)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "accepts any Object as an argument",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.StringUtils#isEmpty(Object)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "general attribute handling code",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.StringUtils#isEmpty(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "shortcut for !hasLength(String)",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.StringUtils#isEmpty(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "prefer hasLength(String) or hasText(String) if object is typed to String",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.StringUtils#isEmpty(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "public static boolean isEmpty(@Nullable Object str) { return (str == null || \"\".equals(str)); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.StringUtils",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.StringUtils#isEmpty(Object)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.StringUtils#isEmpty(Object)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.StringUtils",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.StringUtils#hasLength(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "checkStringLength",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils#hasLength(String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "nullOrEmptyString",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.StringUtils#hasLength(String)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "stringValidation",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.StringUtils#hasLength(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "stringLengthCheckSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.StringUtils#hasLength(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.StringUtils#hasLength(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.StringUtils#hasLength(String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.StringUtils",
      "tail_type": "class"
    },
    {
      "head": "checkStringLength",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "stringLengthCheckSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "nullOrEmptyString",
      "head_type": "useConstraint",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "stringValidation",
      "head_type": "useScenario",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.StringUtils#sortStringArray(String[])",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "sortStringArray",
      "tail_type": "apiFunction"
    },
    {
      "head": "sortStringArray",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "sort the given String array if necessary",
      "tail_type": "useScenario"
    },
    {
      "head": "sortStringArray",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "public static String[] sortStringArray(String[] array) { if (ObjectUtils.isEmpty(array)) { return array; } Arrays.sort(array); return array; }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "sortStringArray",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "Sort the given String array if necessary. @param array the original array (potentially empty) @return the array in sorted form (never null)",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "sortStringArray",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "This function sorts a given array of strings. It first checks if the array is empty or null using ObjectUtils.isEmpty(array). If the array is empty or null, it returns the array as is. Otherwise, it sorts the array using Arrays.sort(array) and returns the sorted array.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.TypeUtils#getLowerBounds(WildcardType)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getLowerBounds",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.TypeUtils#getLowerBounds(WildcardType)",
      "head_type": "method",
      "relation": "have",
      "tail": "getLowerBounds(WildcardType) useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "getLowerBounds(WildcardType) useSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "private static Type[] getLowerBounds(WildcardType wildcardType) {\n    Type[] lowerBounds = wildcardType.getLowerBounds();\n    // supply the implicit lower bound if none are specified\n    return (lowerBounds.length == 0 ? IMPLICIT_LOWER_BOUNDS : lowerBounds);\n}",
      "tail_type": "code"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#asSingleValueMap()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "convert multi-value map to single-value map",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#asSingleValueMap()",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is used to transform a MultiValueMap into a regular Map where each key is associated with a single value. If a key in the original MultiValueMap has multiple values, only one of those values is retained in the resulting Map.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#asSingleValueMap()",
      "head_type": "method",
      "relation": "have",
      "tail": "public Map<K, V> asSingleValueMap() {\n    return this.delegate.asSingleValueMap();\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#asSingleValueMap()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.MultiValueMap",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntry#getKey()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getKey",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntry#getKey()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.UnmodifiableEntry",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntry",
      "head_type": "class",
      "relation": "have",
      "tail": "org.springframework.util.UnmodifiableEntry is a part of Spring Framework's utility classes.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntry",
      "head_type": "class",
      "relation": "have",
      "tail": "This class provides an unmodifiable view of a Map.Entry, ensuring that the entry cannot be modified after creation.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntry#getKey()",
      "head_type": "method",
      "relation": "have",
      "tail": "public K getKey() {\n    return this.delegate.getKey();\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#removeAllNamespaceMappings()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "removeAllNamespaceMappings",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#removeAllNamespaceMappings()",
      "head_type": "method",
      "relation": "have",
      "tail": "private void removeAllNamespaceMappings() { this.namespaceMappings.clear(); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "removeAllNamespaceMappings",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "private void removeAllNamespaceMappings() { this.namespaceMappings.clear(); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.StaxLocator#getColumnNumber()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getColumnNumber",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxLocator#getColumnNumber()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.StaxLocator",
      "tail_type": "class"
    },
    {
      "head": "getColumnNumber",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "This method returns the column number where the current parsing event ends.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "getColumnNumber",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "The design principle of this method is to provide precise location information for XML parsing events, aiding in debugging and error reporting.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "getColumnNumber",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "package com.example.xmlparsing;\n\nimport org.springframework.util.xml.StaxLocator;\n\npublic class XMLParser {\n    public static void main(String[] args) {\n        StaxLocator locator = new StaxLocator();\n        int columnNumber = locator.getColumnNumber();\n        System.out.println(\"Column Number: \" + columnNumber);\n    }\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLStreamReader#getAttributeNamespace(int)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getAttributeNamespace",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLStreamReader#getAttributeNamespace(int)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.AbstractXMLStreamReader",
      "tail_type": "class"
    },
    {
      "head": "getAttributeNamespace",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "This method is used to get the namespace URI of an attribute in an XML document by specifying the index of the attribute.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "getAttributeNamespace",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "This method is part of the XML processing capabilities provided by the Spring Framework, specifically designed to work with XMLStreamReader instances.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "getAttributeNamespace",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "public String getAttributeNamespace(int index) {\n    return getAttributeName(index).getNamespaceURI();\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.DomUtils#createContentHandler(Node)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "transform callback calls to DOM Nodes",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.DomUtils#createContentHandler(Node)",
      "head_type": "method",
      "relation": "have",
      "tail": "Returns a SAX ContentHandler that transforms callback calls to DOM Nodes.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.DomUtils#createContentHandler(Node)",
      "head_type": "method",
      "relation": "have",
      "tail": "The method takes a DOM Node as input and returns a SAX ContentHandler.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.DomUtils#createContentHandler(Node)",
      "head_type": "method",
      "relation": "have",
      "tail": "public static ContentHandler createContentHandler(Node node) {\n    return new DomContentHandler(node);\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.ListBasedXMLEventReader#nextTag()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "xmlEventProcessing",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.ListBasedXMLEventReader#nextTag()",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "xmlStreamExceptionHandling",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.xml.ListBasedXMLEventReader#nextTag()",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "xmlParsing",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.xml.ListBasedXMLEventReader#nextTag()",
      "head_type": "method",
      "relation": "have",
      "tail": "xmlEventProcessingSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.ListBasedXMLEventReader#nextTag()",
      "head_type": "method",
      "relation": "have",
      "tail": "xmlEventExplanation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.ListBasedXMLEventReader#nextTag()",
      "head_type": "method",
      "relation": "have",
      "tail": "xmlStreamDesignPrinciples",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.ListBasedXMLEventReader#nextTag()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.ListBasedXMLEventReader",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.StaxEventXMLReader#handleProcessingInstruction(ProcessingInstruction)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "processing instruction handling",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxEventXMLReader#handleProcessingInstruction(ProcessingInstruction)",
      "head_type": "method",
      "relation": "have",
      "tail": "private void handleProcessingInstruction(ProcessingInstruction pi) throws SAXException {\n    if (getContentHandler() != null) {\n        getContentHandler().processingInstruction(pi.getTarget(), pi.getData());\n    }\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "processing instruction handling",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "private void handleProcessingInstruction(ProcessingInstruction pi) throws SAXException {\n    if (getContentHandler() != null) {\n        getContentHandler().processingInstruction(pi.getTarget(), pi.getData());\n    }\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.StaxEventXMLReader#handleProcessingInstruction(ProcessingInstruction)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.StaxEventXMLReader",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.StaxEventXMLReader",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "processing instruction handling",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxResult#setLexicalHandler(LexicalHandler)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "throwing UnsupportedOperationException",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxResult#setLexicalHandler(LexicalHandler)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "always throwing UnsupportedOperationException",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.xml.StaxResult#setLexicalHandler(LexicalHandler)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for throwing UnsupportedOperationException",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.StaxResult#setLexicalHandler(LexicalHandler)",
      "head_type": "method",
      "relation": "have",
      "tail": "interpretation of throwing UnsupportedOperationException",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxResult#setLexicalHandler(LexicalHandler)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle behind throwing UnsupportedOperationException",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils#createXMLEventReader(List<XMLEvent>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "create XMLEventReader from list of XMLEvent",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils#createXMLEventReader(List<XMLEvent>)",
      "head_type": "method",
      "relation": "have",
      "tail": "Create a XMLEventReader from the given list of XMLEvent.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "create XMLEventReader from list of XMLEvent",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "Create a XMLEventReader from the given list of XMLEvent.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.StaxUtils#createXMLEventReader(List<XMLEvent>)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils#createXMLEventReader(List<XMLEvent>)",
      "head_type": "method",
      "relation": "have",
      "tail": "public static XMLEventReader createXMLEventReader(List<XMLEvent> events) { return new ListBasedXMLEventReader(events); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter#doWriteStartElement(StartElement)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "writeStartElement",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter#doWriteStartElement(StartElement)",
      "head_type": "method",
      "relation": "have",
      "tail": "private void doWriteStartElement(StartElement startElement) throws XMLStreamException {\n    this.eventWriter.add(startElement);\n    this.endElements.add(this.eventFactory.createEndElement(startElement.getName(), startElement.getNamespaces()));\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter#doWriteStartElement(StartElement)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.XMLEventStreamWriter",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter#doWriteStartElement(StartElement)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "StartElement",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter#doWriteStartElement(StartElement)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "XMLStreamException",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#forMemberWhenPublicClassWithPublicFieldAndPackagePrivateFieldType()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "Access Control",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#forMemberWhenPublicClassWithPublicFieldAndPackagePrivateFieldType()",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.aot.generate.AccessControlTests#forMemberWhenPublicClassWithPublicFieldAndPackagePrivateFieldType() Sample Code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#forMemberWhenPublicClassWithPublicFieldAndPackagePrivateFieldType() Sample Code",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "Complete Example for Access Control",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "Access Control",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.AccessControl",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#forMemberWhenPublicClassWithPublicFieldAndPackagePrivateFieldType()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.AccessControl",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.DefaultGenerationContextTests#createWhenGeneratedClassesIsNullThrowsException()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "handle null parameters",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.DefaultGenerationContextTests#createWhenGeneratedClassesIsNullThrowsException()",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "null parameters are not allowed",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.aot.generate.DefaultGenerationContextTests#createWhenGeneratedClassesIsNullThrowsException()",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.aot.generate.DefaultGenerationContext requires non-null GeneratedClasses",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.DefaultGenerationContextTests#createWhenGeneratedClassesIsNullThrowsException()",
      "head_type": "method",
      "relation": "have",
      "tail": "ensuring non-null parameters is crucial for robustness",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.DefaultGenerationContextTests#createWhenGeneratedClassesIsNullThrowsException()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.DefaultGenerationContext",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.DefaultGenerationContextTests#createWhenGeneratedClassesIsNullThrowsException()",
      "head_type": "method",
      "relation": "have",
      "tail": "java\nimport org.junit.jupiter.api.Test;\nimport org.springframework.aot.generate.DefaultGenerationContext;\nimport org.springframework.aot.generate.GeneratedClasses;\nimport org.springframework.aot.generate.GeneratedFiles;\nimport org.springframework.aot.generate.RuntimeHints;\n\npublic class TestClass {\n    @Test\n    void createWhenGeneratedClassesIsNullThrowsException() {\n        GeneratedFiles generatedFiles = new GeneratedFiles();\n        RuntimeHints runtimeHints = new RuntimeHints();\n        DefaultGenerationContext context = new DefaultGenerationContext(null, generatedFiles, runtimeHints);\n    }\n}\n",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "addSourceFileWithJavaFileAddsFile",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "addSourceFileWithJavaFileInTheDefaultPackageThrowsException",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "addSourceFileWithCharSequenceAddsFile",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "addSourceFileWithCharSequenceWhenClassNameIsEmptyThrowsException",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "addSourceFileWithCharSequenceWhenClassNameIsInTheDefaultPackageThrowsException",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "addSourceFileWithCharSequenceWhenClassNameIsInvalidThrowsException",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "addSourceFileWithConsumedAppendableAddsFile",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "addSourceFileWithInputStreamSourceAddsFile",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "addResourceFileWithCharSequenceAddsFile",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "addResourceFileWithConsumedAppendableAddsFile",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "addResourceFileWithInputStreamSourceAddsFile",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "addClassFileWithInputStreamSourceAddsFile",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "addFileWithCharSequenceAddsFile",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "addFileWithConsumedAppendableAddsFile",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "handleFileWhenFileDoesNotExist",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "handleFileWhenFileExistsCanOverride",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "handleFileWhenFileExistsCanOverrideUsingExistingContent",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "handleFileWhenFileExistsFailedToCreate",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests",
      "head_type": "class",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests",
      "head_type": "class",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "addSourceFileWithJavaFileAddsFile",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "addSourceFileWithJavaFileAddsFile",
      "tail_type": "useScenario"
    },
    {
      "head": "addSourceFileWithJavaFileInTheDefaultPackageThrowsException",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "addSourceFileWithJavaFileInTheDefaultPackageThrowsException",
      "tail_type": "useScenario"
    },
    {
      "head": "addSourceFileWithCharSequenceAddsFile",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "addSourceFileWithCharSequenceAddsFile",
      "tail_type": "useScenario"
    },
    {
      "head": "addSourceFileWithCharSequenceWhenClassNameIsEmptyThrowsException",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "addSourceFileWithCharSequenceWhenClassNameIsEmptyThrowsException",
      "tail_type": "useScenario"
    },
    {
      "head": "addSourceFileWithCharSequenceWhenClassNameIsInTheDefaultPackageThrowsException",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "addSourceFileWithCharSequenceWhenClassNameIsInTheDefaultPackageThrowsException",
      "tail_type": "useScenario"
    },
    {
      "head": "addSourceFileWithCharSequenceWhenClassNameIsInvalidThrowsException",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "addSourceFileWithCharSequenceWhenClassNameIsInvalidThrowsException",
      "tail_type": "useScenario"
    },
    {
      "head": "addSourceFileWithConsumedAppendableAddsFile",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "addSourceFileWithConsumedAppendableAddsFile",
      "tail_type": "useScenario"
    },
    {
      "head": "addSourceFileWithInputStreamSourceAddsFile",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "addSourceFileWithInputStreamSourceAddsFile",
      "tail_type": "useScenario"
    },
    {
      "head": "addResourceFileWithCharSequenceAddsFile",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "addResourceFileWithCharSequenceAddsFile",
      "tail_type": "useScenario"
    },
    {
      "head": "addResourceFileWithConsumedAppendableAddsFile",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "addResourceFileWithConsumedAppendableAddsFile",
      "tail_type": "useScenario"
    },
    {
      "head": "addResourceFileWithInputStreamSourceAddsFile",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "addResourceFileWithInputStreamSourceAddsFile",
      "tail_type": "useScenario"
    },
    {
      "head": "addClassFileWithInputStreamSourceAddsFile",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "addClassFileWithInputStreamSourceAddsFile",
      "tail_type": "useScenario"
    },
    {
      "head": "addFileWithCharSequenceAddsFile",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "addFileWithCharSequenceAddsFile",
      "tail_type": "useScenario"
    },
    {
      "head": "addFileWithConsumedAppendableAddsFile",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "addFileWithConsumedAppendableAddsFile",
      "tail_type": "useScenario"
    },
    {
      "head": "handleFileWhenFileDoesNotExist",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "handleFileWhenFileDoesNotExist",
      "tail_type": "useScenario"
    },
    {
      "head": "handleFileWhenFileExistsCanOverride",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "handleFileWhenFileExistsCanOverride",
      "tail_type": "useScenario"
    },
    {
      "head": "handleFileWhenFileExistsCanOverrideUsingExistingContent",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "handleFileWhenFileExistsCanOverrideUsingExistingContent",
      "tail_type": "useScenario"
    },
    {
      "head": "handleFileWhenFileExistsFailedToCreate",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "handleFileWhenFileExistsFailedToCreate",
      "tail_type": "useScenario"
    },
    {
      "head": "addSourceFileWithJavaFileAddsFile",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "addSourceFileWithJavaFileInTheDefaultPackageThrowsException",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "addSourceFileWithCharSequenceAddsFile",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "addSourceFileWithCharSequenceWhenClassNameIsEmptyThrowsException",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "addSourceFileWithCharSequenceWhenClassNameIsInTheDefaultPackageThrowsException",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "addSourceFileWithCharSequenceWhenClassNameIsInvalidThrowsException",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "addSourceFileWithConsumedAppendableAddsFile",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "addSourceFileWithInputStreamSourceAddsFile",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "addResourceFileWithCharSequenceAddsFile",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "addResourceFileWithConsumedAppendableAddsFile",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "addResourceFileWithInputStreamSourceAddsFile",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "addClassFileWithInputStreamSourceAddsFile",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "addFileWithCharSequenceAddsFile",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "addFileWithConsumedAppendableAddsFile",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "handleFileWhenFileDoesNotExist",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "handleFileWhenFileExistsCanOverride",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "handleFileWhenFileExistsCanOverrideUsingExistingContent",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "handleFileWhenFileExistsFailedToCreate",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedMethodsTests#createWhenClassNameIsNullThrowsException()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "generate methods",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedMethodsTests#createWhenClassNameIsNullThrowsException()",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "class name must not be null",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedMethodsTests#createWhenClassNameIsNullThrowsException()",
      "head_type": "method",
      "relation": "have",
      "tail": "GeneratedMethods(null, MethodName::toString)",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedMethodsTests",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.GeneratedMethodsTests#createWhenClassNameIsNullThrowsException()",
      "tail_type": "method"
    },
    {
      "head": "GeneratedMethods",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.GeneratedMethodsTests#createWhenClassNameIsNullThrowsException()",
      "tail_type": "method"
    },
    {
      "head": "MethodName",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.GeneratedMethodsTests#createWhenClassNameIsNullThrowsException()",
      "tail_type": "method"
    },
    {
      "head": "IllegalArgumentException",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.GeneratedMethodsTests#createWhenClassNameIsNullThrowsException()",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedMethodTests#generateMethodSpecReturnsMethodSpec()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "generateMethodSpec",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedMethodTests#generateMethodSpecReturnsMethodSpec()",
      "head_type": "method",
      "relation": "have",
      "tail": "GeneratedMethod generation with Javadoc",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedMethodTests#generateMethodSpecReturnsMethodSpec()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.GeneratedMethod",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedMethodTests#generateMethodSpecReturnsMethodSpec()",
      "head_type": "method",
      "relation": "have",
      "tail": "Testing method generation with Javadoc",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedMethodTests#generateMethodSpecReturnsMethodSpec()",
      "head_type": "method",
      "relation": "have",
      "tail": "Design principles for testing generated methods",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.ValueCodeGeneratorTests#resolve(CodeBlock)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "resolveValueCode",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.ValueCodeGeneratorTests#resolve(CodeBlock)",
      "head_type": "method",
      "relation": "have",
      "tail": "extracts value code and imports from a given CodeBlock",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.ValueCodeGeneratorTests#resolve(CodeBlock)",
      "head_type": "method",
      "relation": "have",
      "tail": "design follows the principle of separating code generation from value extraction",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.ValueCodeGeneratorTests#resolve(CodeBlock)",
      "head_type": "method",
      "relation": "have",
      "tail": "public static ValueCode resolve(CodeBlock valueCode) {\n    String code = writeCode(valueCode);\n    List<String> imports = code.lines().filter(candidate -> candidate.startsWith(\"import\") && candidate.endsWith(\";')).map(line -> line.substring(\"import\".length(), line.length() - 1)).map(String::trim).toList();\n    int start = code.indexOf(\"value = \");\n    int end = code.indexOf(\";\", start);\n    return new ValueCode(code.substring(start + \"value = \".length(), end), imports);\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.EnumTests#generateWhenEnum()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "generateCode",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.EnumTests#generateWhenEnum()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "resolve",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.EnumTests#generateWhenEnum()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "hasImport",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.EnumTests#generateWhenEnum()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "hasValueCode",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.EnumTests#generateWhenEnum()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "ChronoUnit",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.EnumTests#generateWhenEnum()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "ChronoUnit.DAYS",
      "tail_type": "class"
    },
    {
      "head": "generateCode",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "ChronoUnit.DAYS",
      "tail_type": "class"
    },
    {
      "head": "resolve",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "ChronoUnit.DAYS",
      "tail_type": "class"
    },
    {
      "head": "hasImport",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "ChronoUnit",
      "tail_type": "class"
    },
    {
      "head": "hasValueCode",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "ChronoUnit.DAYS",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.EnumTests#generateWhenEnum()",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.ResolvableTypeTests#generateWhenUnresolvedGenericType()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "generateCode",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.ResolvableTypeTests#generateWhenUnresolvedGenericType()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "forField",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.ResolvableTypeTests#generateWhenUnresolvedGenericType()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "hasImport",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.ResolvableTypeTests#generateWhenUnresolvedGenericType()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "hasValueCode",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.ResolvableTypeTests#generateWhenUnresolvedGenericType()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "ResolvableType",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.ResolvableTypeTests#generateWhenUnresolvedGenericType()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "SampleTypes",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.ResolvableTypeTests#generateWhenUnresolvedGenericType()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "List",
      "tail_type": "class"
    },
    {
      "head": "ResolvableType",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "forField",
      "tail_type": "apiFunction"
    },
    {
      "head": "ResolvableType",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "forClass",
      "tail_type": "apiFunction"
    },
    {
      "head": "generateCode",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "forField",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "hasImport",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "hasValueCode",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "useSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "code",
      "tail_type": "code"
    },
    {
      "head": "org.springframework.aot.hint.annotation.SampleMethodAnnotatedBean#notManaged()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "voidFunction",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.hint.annotation.SampleMethodAnnotatedBean#notManaged()",
      "head_type": "method",
      "relation": "have",
      "tail": "voidFunctionSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "voidFunctionSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "voidFunctionCompleteExample",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.hint.annotation.SampleMethodAnnotatedBeanWithInterface#notManaged()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "notManaged",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.hint.annotation.SampleMethodAnnotatedBeanWithInterface#notManaged()",
      "head_type": "method",
      "relation": "have",
      "tail": "public void notManaged() ;",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.hint.annotation.SampleMethodAnnotatedBeanWithInheritance#managed()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "managedFunction",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.hint.annotation.SampleMethodAnnotatedBeanWithInheritance#managed()",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.aot.hint.annotation.SampleMethodAnnotatedBeanWithInheritance",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.hint.annotation.SampleMethodAnnotatedBeanWithInheritance",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.aot.hint.annotation",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.hint.annotation.SampleMethodAnnotatedBeanWithInheritance#managed()",
      "head_type": "method",
      "relation": "have",
      "tail": "sampleManagedMethodCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.hint.annotation.SampleMethodAnnotatedBeanWithInheritance#managed()",
      "head_type": "method",
      "relation": "have",
      "tail": "managedMethodDescription",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.hint.annotation.SampleMethodAnnotatedBeanWithInheritance#managed()",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleForManagedMethod",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.core.type.StandardAnnotationMetadata#getAnnotationTypes()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getAnnotationTypes",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.core.type.StandardAnnotationMetadata#getAnnotationTypes()",
      "head_type": "method",
      "relation": "have",
      "tail": "getAnnotationTypes returns a set of annotation types",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.core.type.StandardAnnotationMetadata#getAnnotationTypes()",
      "head_type": "method",
      "relation": "have",
      "tail": "This method ensures thread-safe lazy initialization of annotation types",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.core.type.StandardAnnotationMetadata#getAnnotationTypes()",
      "head_type": "method",
      "relation": "have",
      "tail": "java\npackage org.springframework.core.type;\n\nimport java.util.Collections;\nimport java.util.Set;\n\npublic class StandardAnnotationMetadata {\n    private Set<String> annotationTypes;\n\n    @Override\n    public Set<String> getAnnotationTypes() {\n        if (this.annotationTypes == null) {\n            this.annotationTypes = Collections.unmodifiableSet(AnnotationMetadata.super.getAnnotationTypes());\n        }\n        return this.annotationTypes;\n    }\n}\n",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.core.type.StandardMethodMetadata#isPrivate()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "check if method is private",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.core.type.StandardMethodMetadata#isPrivate()",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.core.type.StandardMethodMetadata#isPrivate()",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.core.type.StandardMethodMetadata#isPrivate()",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.core.type.StandardMethodMetadata#isPrivate()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.core.type.StandardMethodMetadata",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#setPathSeparator(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "setPathSeparator",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#setPathSeparator(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "Set the path separator to use for pattern parsing",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#setPathSeparator(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "Default is \"/\", as in Ant",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#setPathSeparator(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "package com.example.util; import org.springframework.util.AntPathMatcher; public class SetPathSeparatorExample { public static void main(String[] args) { AntPathMatcher matcher = new AntPathMatcher(); matcher.setPathSeparator(\"-\"); System.out.println(\"Path separator set to: \" + matcher.getPathSeparator()); } }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#setPathSeparator(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "The method allows for setting a custom path separator which is used in pattern matching within the AntPathMatcher class.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#setPathSeparator(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is designed to provide flexibility in pattern parsing by allowing the path separator to be customized, which is essential for adapting to different file path conventions across various systems.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.PatternInfo#isLeastSpecific()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "determine specificity of pattern",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.PatternInfo#isLeastSpecific()",
      "head_type": "method",
      "relation": "have",
      "tail": " checks if the pattern is least specific, which means it either matches everything or is null",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.PatternInfo#isLeastSpecific()",
      "head_type": "method",
      "relation": "have",
      "tail": "used to determine if a pattern is the least specific among a set of patterns",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.PatternInfo#isLeastSpecific()",
      "head_type": "method",
      "relation": "have",
      "tail": "java\npublic boolean isLeastSpecific() {\n    return (this.pattern == null || this.catchAllPattern);\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.Assert#doesNotContain(String,String,String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "assertion",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.Assert#doesNotContain(String,String,String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "text must not contain the given substring",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.Assert#doesNotContain(String,String,String)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "validating input strings",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.Assert#doesNotContain(String,String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.Assert#doesNotContain(String,String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.Assert#doesNotContain(String,String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.Assert#doesNotContain(String,String,String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "IllegalArgumentException",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.AutoPopulatingList#add(int,E)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "add elements to list",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.AutoPopulatingList#add(int,E)",
      "head_type": "method",
      "relation": "have",
      "tail": "add elements to list sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "add elements to list sample code",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "org.springframework.util.AutoPopulatingList#add(int,E) sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.AutoPopulatingList#addAll(Collection<? extends E>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "add elements to a collection",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.AutoPopulatingList#addAll(Collection<? extends E>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.AutoPopulatingList",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.AutoPopulatingList#addAll(Collection<? extends E>)",
      "head_type": "method",
      "relation": "have",
      "tail": "add elements to a collection sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "add elements to a collection sample code",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "Complete example of adding elements to a collection",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.AutoPopulatingList#set(int,E)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "elementSetting",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.AutoPopulatingList#set(int,E)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is used to set an element at a specified index in a list.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.AutoPopulatingList#set(int,E)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is a part of the AutoPopulatingList class, which is designed to automatically populate elements in a list.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.AutoPopulatingList#set(int,E)",
      "head_type": "method",
      "relation": "have",
      "tail": "public E set(int index, E element) {\n    return this.backingList.set(index, element);\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ClassUtils#getPackageName(Class<?>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "get package name",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ClassUtils#getPackageName(Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "get package name sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ClassUtils",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "get package name",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ClassUtils",
      "head_type": "class",
      "relation": "have",
      "tail": "get package name sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "get package name sample code",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "get package name",
      "tail_type": "apiFunction"
    },
    {
      "head": "get package name sample code",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "org.springframework.util.ClassUtils",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.ClassUtils#findPubliclyAccessibleMethodIfPossible(String,Class<?>[],Class<?>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "findPubliclyAccessibleMethodIfPossible",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ClassUtils#findPubliclyAccessibleMethodIfPossible(String,Class<?>[],Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "findPubliclyAccessibleMethodIfPossible sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "findPubliclyAccessibleMethodIfPossible sample code",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "package org.springframework.util; import java.lang.reflect.Method; public class ClassUtils { public static Method findPubliclyAccessibleMethodIfPossible(String methodName, Class<?>[] parameterTypes, Class<?> declaringClass) { Class<?> current = declaringClass.getSuperclass(); while (current != null) { if (Modifier.isPublic(current.getModifiers())) { try { return current.getDeclaredMethod(methodName, parameterTypes); } catch (NoSuchMethodException ex) { // ignore } } current = current.getSuperclass(); } return null; } }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.CollectionUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "isEmpty",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.CollectionUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "newHashMap",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.CollectionUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "newLinkedHashMap",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.CollectionUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "newHashSet",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.CollectionUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "newLinkedHashSet",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.CollectionUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "computeInitialCapacity",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.CollectionUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "arrayToList",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.CollectionUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "mergeArrayIntoCollection",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.CollectionUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "mergePropertiesIntoMap",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.CollectionUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "contains",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.CollectionUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "containsInstance",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.CollectionUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "containsAny",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.CollectionUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "findFirstMatch",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.CollectionUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "findValueOfType",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.CollectionUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "findValueOfType",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.CollectionUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "hasUniqueObject",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.CollectionUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "findCommonElementType",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.CollectionUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "firstElement",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.CollectionUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "firstElement",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.CollectionUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "lastElement",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.CollectionUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "lastElement",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.CollectionUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "toArray",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.CollectionUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "toIterator",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.CollectionUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "toMultiValueMap",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.CollectionUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "unmodifiableMultiValueMap",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.CollectionUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "compositeMap",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.CollectionUtils",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "compositeMap",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.CollectionUtils#isEmpty(Collection<? extends Object>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "check if a collection is empty",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.CollectionUtils#isEmpty(Collection<? extends Object>)",
      "head_type": "method",
      "relation": "have",
      "tail": "Return true if the supplied Collection is null or empty. Otherwise, return false.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.CollectionUtils#isEmpty(Collection<? extends Object>)",
      "head_type": "method",
      "relation": "have",
      "tail": "public static boolean isEmpty(@Nullable Collection<? extends @Nullable Object> collection) { return (collection == null || collection.isEmpty()); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.CollectionUtils",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.CollectionUtils#isEmpty(Collection<? extends Object>)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.CollectionUtils#isEmpty(Collection<? extends Object>)",
      "head_type": "method",
      "relation": "have",
      "tail": "The method uses a null check and then the isEmpty method of the Collection to determine if it is empty.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.CollectionUtils#lastElement(List<T>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "retrieveLastElement",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.CollectionUtils#lastElement(List<T>)",
      "head_type": "method",
      "relation": "have",
      "tail": "retrieveLastElementSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "retrieveLastElementSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "retrieveLastElementSampleCodeContent",
      "tail_type": "useSampleCodeContent"
    },
    {
      "head": "org.springframework.util.CollectionUtils#lastElement(List<T>)",
      "head_type": "method",
      "relation": "have",
      "tail": "retrieveLastElementRelatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "retrieveLastElementRelatedConceptInterpretation",
      "head_type": "relatedConceptInterpretation",
      "relation": "have",
      "tail": "retrieveLastElementRelatedConceptInterpretationContent",
      "tail_type": "relatedConceptInterpretationContent"
    },
    {
      "head": "org.springframework.util.CollectionUtils#lastElement(List<T>)",
      "head_type": "method",
      "relation": "have",
      "tail": "retrieveLastElementDesignPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "retrieveLastElementDesignPrincipleInterpretation",
      "head_type": "designPrincipleInterpretation",
      "relation": "have",
      "tail": "retrieveLastElementDesignPrincipleInterpretationContent",
      "tail_type": "designPrincipleInterpretationContent"
    },
    {
      "head": "org.springframework.util.comparator.NullSafeComparator#compare(T,T)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "compare",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.comparator.NullSafeComparator#compare(T,T)",
      "head_type": "method",
      "relation": "have",
      "tail": "compare(T,T)",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.comparator.NullSafeComparator#compare(T,T)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "Comparator<T>",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.comparator.NullSafeComparator#compare(T,T)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "Comparator.nullsFirst(this.nonNullComparator)",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.comparator.NullSafeComparator#compare(T,T)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "Comparator.nullsLast(this.nonNullComparator)",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.comparator.NullSafeComparator#compare(T,T)",
      "head_type": "method",
      "relation": "designPrincipleInterpretation",
      "tail": "NullSafeComparator is designed to provide a safe comparison mechanism that handles null values gracefully, enhancing the robustness of comparisons in collections.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.concurrent.FutureAdapter#get(long,TimeUnit)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "adaptInternal",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.concurrent.FutureAdapter#get(long,TimeUnit)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "InterruptedException",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.concurrent.FutureAdapter#get(long,TimeUnit)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "ExecutionException",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.concurrent.FutureAdapter#get(long,TimeUnit)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "TimeoutException",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.concurrent.FutureAdapter",
      "head_type": "class",
      "relation": "have",
      "tail": "get(long,TimeUnit)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.concurrent.FutureAdapter",
      "head_type": "class",
      "relation": "have",
      "tail": "adaptInternal",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.concurrent.FutureAdapter",
      "head_type": "class",
      "relation": "have",
      "tail": "InterruptedException",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.concurrent.FutureAdapter",
      "head_type": "class",
      "relation": "have",
      "tail": "ExecutionException",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.concurrent.FutureAdapter",
      "head_type": "class",
      "relation": "have",
      "tail": "TimeoutException",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.concurrent.FutureAdapter",
      "head_type": "class",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.concurrent.FutureAdapter",
      "head_type": "class",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.concurrent.FutureAdapter",
      "head_type": "class",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.FileCopyUtils#copy(Reader,Writer)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "copy contents of Reader to Writer",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.FileCopyUtils#copy(Reader,Writer)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "IOException in case of I/O errors",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.FileCopyUtils#copy(Reader,Writer)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "java.io.Reader and java.io.Writer",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.FileCopyUtils#copy(Reader,Writer)",
      "head_type": "method",
      "relation": "have",
      "tail": "public static int copy(Reader in, Writer out) throws IOException",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.FileCopyUtils#copy(Reader,Writer)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.FileCopyUtils#copy(Reader,Writer)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.FileCopyUtils#copy(Reader,Writer)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.FileCopyUtils",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.FilteredMap#remove(Object)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "removeElement",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.FilteredMap#remove(Object)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "keyMustMatchFilter",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.FilteredMap#remove(Object)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "elementRemoval",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.FilteredMap#remove(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.FilteredMap#remove(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.FilteredMap#remove(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.FilteredMap#remove(Object)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.FilteredMap",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.function.ThrowingBiFunction#throwing(BiFunction<String,Exception,RuntimeException>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "exception wrapping",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.function.ThrowingBiFunction#throwing(BiFunction<String,Exception,RuntimeException>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "exceptionWrapper must not be null",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.function.ThrowingBiFunction#throwing(BiFunction<String,Exception,RuntimeException>)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "wrapping checked exceptions in runtime exceptions",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.function.ThrowingBiFunction#throwing(BiFunction<String,Exception,RuntimeException>)",
      "head_type": "method",
      "relation": "have",
      "tail": "return a new ThrowingBiFunction instance",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.function.ThrowingBiFunction#throwing(BiFunction<String,Exception,RuntimeException>)",
      "head_type": "method",
      "relation": "have",
      "tail": "exceptionWrapper explanation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.function.ThrowingBiFunction#throwing(BiFunction<String,Exception,RuntimeException>)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle of exception handling",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.function.ThrowingBiFunction",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.function.ThrowingBiFunction#throwing(BiFunction<String,Exception,RuntimeException>)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.LinkedCaseInsensitiveMap#get(Object)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "caseInsensitive Retrieval",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.LinkedCaseInsensitiveMap#get(Object)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "key must be a string",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.LinkedCaseInsensitiveMap#get(Object)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "retrieving values case insensitively",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.LinkedCaseInsensitiveMap#get(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.LinkedCaseInsensitiveMap#get(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.LinkedCaseInsensitiveMap#get(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.LinkedCaseInsensitiveMap#get(Object)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.LinkedCaseInsensitiveMap",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.KeySet#clear()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "clearing contents",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.KeySet#clear()",
      "head_type": "method",
      "relation": "have",
      "tail": "This method clears the contents of the KeySet.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.KeySet#clear()",
      "head_type": "method",
      "relation": "have",
      "tail": "public void clear() {\n    LinkedCaseInsensitiveMap.this.clear();\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.KeySet#clear()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "LinkedCaseInsensitiveMap",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.MethodInvoker#getPreparedMethod()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "return the prepared Method object",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MethodInvoker#getPreparedMethod()",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "Invoker must be prepared before invoking",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.MethodInvoker#getPreparedMethod()",
      "head_type": "method",
      "relation": "have",
      "tail": "Can be used to determine the return type",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.MethodInvoker#getPreparedMethod()",
      "head_type": "method",
      "relation": "have",
      "tail": "Sample Code: \npublic Method getPreparedMethod() throws IllegalStateException {\n    if (this.methodObject == null) {\n        throw new IllegalStateException(\"prepare() must be called prior to invoke() on MethodInvoker\");\n    }\n    return this.methodObject;\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.MethodInvoker#getPreparedMethod()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.MethodInvoker",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.MethodInvoker#getPreparedMethod()",
      "head_type": "method",
      "relation": "have",
      "tail": "Related Concept Interpretation: The method is designed to retrieve a prepared Method object which is ready to be invoked. It ensures that the method has been prepared and is in a valid state to be executed.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.MethodInvoker#getPreparedMethod()",
      "head_type": "method",
      "relation": "have",
      "tail": "Design Principle Interpretation: The design principle behind this method is to ensure that the method invocation is safe and consistent. By preparing the method beforehand, it allows for checks and validations to be performed, reducing the risk of runtime errors.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.MultiValueMap#setAll(Map<K,V>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "set values",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MultiValueMap#setAll(Map<K,V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "Set the given values under.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.MultiValueMap#setAll(Map<K,V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "void setAll(Map<K, V> values);",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.MultiValueMapAdapter#clear()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "clearing a map",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MultiValueMapAdapter#clear()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.MultiValueMapAdapter",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.MultiValueMapAdapter#clear()",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for clearing a map",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.MultiValueMapAdapter#clear()",
      "head_type": "method",
      "relation": "have",
      "tail": "clearing a map",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.MultiValueMapAdapter#clear()",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle for clearing a map",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ObjectUtils#getDisplayString(Object)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "content-based String representation",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ObjectUtils#getDisplayString(Object)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "null value handling",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ObjectUtils#getDisplayString(Object)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "building display String for object",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ObjectUtils#getDisplayString(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for getDisplayString",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ObjectUtils#getDisplayString(Object)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.ObjectUtils#nullSafeToString(Object)",
      "tail_type": "method"
    },
    {
      "head": "sample code for getDisplayString",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "complete example of getDisplayString usage",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeToString(byte[])",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "String representation of array",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeToString(byte[])",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "array must not be null",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeToString(byte[])",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "convert array to string",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeToString(byte[])",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for array to string conversion",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeToString(byte[])",
      "head_type": "method",
      "relation": "have",
      "tail": "related concept interpretation for array to string conversion",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeToString(byte[])",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle interpretation for array to string conversion",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ObjectUtils",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.ObjectUtils#nullSafeToString(byte[])",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeToString(long[])",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "String representation of array",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeToString(long[])",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "array must not be null",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeToString(long[])",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "convert array to String",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeToString(long[])",
      "head_type": "method",
      "relation": "have",
      "tail": "public static String nullSafeToString(long @Nullable [] array) { if (array == null) { return NULL_STRING; } int length = array.length; if (length == 0) { return EMPTY_ARRAY; } StringJoiner stringJoiner = new StringJoiner(ARRAY_ELEMENT_SEPARATOR, ARRAY_START, ARRAY_END); for (long l : array) { stringJoiner.add(String.valueOf(l)); } return stringJoiner.toString(); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeToString(long[])",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is used to safely convert an array to a String representation, handling null values gracefully.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeToString(long[])",
      "head_type": "method",
      "relation": "have",
      "tail": "The design principle followed here is to provide a utility method that can handle null inputs without throwing an exception, ensuring robustness in applications.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.PlaceholderParser#isEscaped(String,int)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "check if a character at a specific index in a string is escaped",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.PlaceholderParser#isEscaped(String,int)",
      "head_type": "method",
      "relation": "have",
      "tail": "private boolean isEscaped(String value, int index) {\n    return (this.escape != null && index > 0 && value.charAt(index - 1) == this.escape);\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.PlaceholderParser#isEscaped(String,int)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.PlaceholderParser",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.MethodCallback#doWith(Method)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "perform an operation using the given method",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MethodCallback#doWith(Method)",
      "head_type": "method",
      "relation": "have",
      "tail": "Perform an operation using the given method.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.MethodCallback#doWith(Method)",
      "head_type": "method",
      "relation": "have",
      "tail": "void doWith(Method method) throws IllegalArgumentException, IllegalAccessException { /* implementation code */ }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.SingleToMultiValueMapAdapter#containsKey(Object)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "check key existence",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.SingleToMultiValueMapAdapter#containsKey(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method checks if the specified key is present in the target map.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.SingleToMultiValueMapAdapter#containsKey(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "public boolean containsKey(Object key) { return this.targetMap.containsKey(key); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.SingleToMultiValueMapAdapter",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.SingleToMultiValueMapAdapter#containsKey(Object)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.StreamUtils#emptyInput()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "efficient empty InputStream",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StreamUtils#emptyInput()",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "deprecated as of 6.0",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.StreamUtils#emptyInput()",
      "head_type": "method",
      "relation": "have",
      "tail": "Return an efficient empty InputStream",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.StreamUtils#emptyInput()",
      "head_type": "method",
      "relation": "have",
      "tail": "InputStream which contains no bytes",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.StreamUtils#emptyInput()",
      "head_type": "method",
      "relation": "have",
      "tail": "Since 4.2.2",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.StreamUtils#emptyInput()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "InputStream",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.StringUtils#trimTrailingCharacter(String,char)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "trimming trailing characters",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils#trimTrailingCharacter(String[char])",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "input string must have length",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.StringUtils#trimTrailingCharacter(String[char])",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "strings with trailing characters to be removed",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.StringUtils#trimTrailingCharacter(String[char])",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for trimming trailing characters",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.StringUtils#trimTrailingCharacter(String[char])",
      "head_type": "method",
      "relation": "have",
      "tail": "related concept interpretation for string trimming",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.StringUtils#trimTrailingCharacter(String[char])",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle interpretation for string trimming",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.StringUtils#trimTrailingCharacter(String[char])",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.StringUtils",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.StringUtils#parseLocale(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "parseLocale",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils#parseLocale(String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "IllegalArgumentException",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.StringUtils#parseLocale(String)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "BCP 47 language tags",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.StringUtils#parseLocale(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "parseLocaleSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.StringUtils#parseLocale(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "localeParsingExplanation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.StringUtils#parseLocale(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleForLocaleParsing",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "parseLocaleSampleCode",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "tail": "org.springframework.util.StringUtils#parseLocale(String)",
      "tail_type": "method"
    },
    {
      "head": "localeParsingExplanation",
      "head_type": "relatedConceptInterpretation",
      "relation": "associated_with",
      "tail": "org.springframework.util.StringUtils#parseLocale(String)",
      "tail_type": "method"
    },
    {
      "head": "designPrincipleForLocaleParsing",
      "head_type": "designPrincipleInterpretation",
      "relation": "associated_with",
      "tail": "org.springframework.util.StringUtils#parseLocale(String)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#getFirst(K)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getFirst",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#getFirst(K)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.MultiValueMap",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#getFirst(K)",
      "head_type": "method",
      "relation": "have",
      "tail": "getFirst(K key) { return this.delegate.getFirst(key); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySet#toString()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "toString()",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySet#toString()",
      "head_type": "method",
      "relation": "have",
      "tail": "Delegate method call",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySet#toString()",
      "head_type": "method",
      "relation": "have",
      "tail": "toString() implementation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySet#toString()",
      "head_type": "method",
      "relation": "have",
      "tail": "Design principle for UnmodifiableEntrySet",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#startEntity(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "startEntity",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#startEntity(String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.AbstractStaxHandler",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler",
      "head_type": "class",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler",
      "head_type": "class",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#processingInstructionInternal(String,String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "processing XML instructions",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#processingInstructionInternal(String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.xml.AbstractStaxHandler",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#processingInstructionInternal(String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "protected abstract void processingInstructionInternal(String target, String data) throws XMLStreamException;",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLReader#setErrorHandler(ErrorHandler)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "error handling",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLReader#setErrorHandler(ErrorHandler)",
      "head_type": "method",
      "relation": "have",
      "tail": "Sets the error handler for this XML reader.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLReader#setErrorHandler(ErrorHandler)",
      "head_type": "method",
      "relation": "have",
      "tail": "Ensure that the XML reader can handle errors gracefully.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLReader#setErrorHandler(ErrorHandler)",
      "head_type": "method",
      "relation": "have",
      "tail": "public void setErrorHandler(@Nullable ErrorHandler errorHandler) {\n    this.errorHandler = errorHandler;\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils#getXMLStreamReader(Source)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "get XMLStreamReader from StAX Source",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils#getXMLStreamReader(Source)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "source must be a JAXP 1.4 StAXSource or custom StAX Source",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils#getXMLStreamReader(Source)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for getting XMLStreamReader from StAX Source",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils#getXMLStreamReader(Source)",
      "head_type": "method",
      "relation": "have",
      "tail": "interpretation of related concepts for XMLStreamReader and StAX Source",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils#getXMLStreamReader(Source)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle interpretation for StaxUtils",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.StaxUtils#getXMLStreamReader(Source)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamReader",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getNamespace(int)",
      "tail_type": "apiFunction"
    },
    {
      "head": "getNamespace(int)",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "getNamespace(int) Sample Code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "getNamespace(int) Sample Code",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "getNamespace(int) Sample Code Content",
      "tail_type": "useSampleCode"
    },
    {
      "head": "getNamespace(int)",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "index must be valid",
      "tail_type": "useConstraint"
    },
    {
      "head": "getNamespace(int)",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "retrieve namespace from XML event",
      "tail_type": "useScenario"
    },
    {
      "head": "getNamespace(int)",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "relatedConceptInterpretation",
      "head_type": "relatedConceptInterpretation",
      "relation": "have",
      "tail": "Namespace in XML",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "getNamespace(int)",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "designPrincipleInterpretation",
      "head_type": "designPrincipleInterpretation",
      "relation": "have",
      "tail": "Efficient Namespace Retrieval",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.XmlValidationModeDetector",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "detectValidationMode",
      "tail_type": "apiFunction"
    },
    {
      "head": "detectValidationMode",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "InputStream must be closed after parsing",
      "tail_type": "useConstraint"
    },
    {
      "head": "detectValidationMode",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "XML document validation",
      "tail_type": "useScenario"
    },
    {
      "head": "detectValidationMode",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "XmlValidationModeDetectorSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.XmlValidationModeDetector",
      "head_type": "class",
      "relation": "have",
      "tail": "RelatedConceptsXmlValidation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.XmlValidationModeDetector",
      "head_type": "class",
      "relation": "have",
      "tail": "DesignPrinciplesXmlValidationModeDetector",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.FileSystemGeneratedFilesTests#addFileWhenFileAlreadyAddedThrowsException()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "addResourceFile",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.FileSystemGeneratedFilesTests#addFileWhenFileAlreadyAddedThrowsException()",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "fileAlreadyExists",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.aot.generate.FileSystemGeneratedFilesTests#addFileWhenFileAlreadyAddedThrowsException()",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.FileSystemGeneratedFilesTests#addFileWhenFileAlreadyAddedThrowsException()",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.FileSystemGeneratedFilesTests#addFileWhenFileAlreadyAddedThrowsException()",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.FileSystemGeneratedFilesTests#addFileWhenFileAlreadyAddedThrowsException()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "FileSystemGeneratedFiles",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedMethodsTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "generate methods",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedMethodsTests",
      "head_type": "class",
      "relation": "constrained_by",
      "tail": "null parameters are prohibited",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedMethodsTests",
      "head_type": "class",
      "relation": "applied_to",
      "tail": "method generation",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedMethodsTests",
      "head_type": "class",
      "relation": "have",
      "tail": "sample code for generating methods",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedMethodsTests",
      "head_type": "class",
      "relation": "have",
      "tail": " GeneratedMethods is used for generating methods in runtime",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedMethodsTests",
      "head_type": "class",
      "relation": "have",
      "tail": "design principle of runtime method generation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedMethodsTests",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "GeneratedMethods",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedTypeReferenceTests#createWithClassNameAndParent()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "create type reference with class name and parent",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedTypeReferenceTests#createWithClassNameAndParent()",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for creating type reference with class name and parent",
      "tail_type": "useSampleCode"
    },
    {
      "head": "create type reference with class name and parent",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "sample code for creating type reference with class name and parent",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedTypeReferenceTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "create type reference with class name and parent",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedTypeReferenceTests",
      "head_type": "class",
      "relation": "have",
      "tail": "sample code for creating type reference with class name and parent",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.InMemoryGeneratedFilesTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "addFileAddsInMemoryFile",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.InMemoryGeneratedFilesTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "addFileWhenFileAlreadyAddedThrowsException",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.InMemoryGeneratedFilesTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getGeneratedFilesReturnsFiles",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.InMemoryGeneratedFilesTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getGeneratedFileContentWhenFileExistsReturnsContent",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.InMemoryGeneratedFilesTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getGeneratedFileContentWhenFileIsMissingReturnsNull",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.InMemoryGeneratedFilesTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getGeneratedFileWhenFileExistsReturnsInputStreamSource",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.InMemoryGeneratedFilesTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getGeneratedFileWhenFileIsMissingReturnsNull",
      "tail_type": "apiFunction"
    },
    {
      "head": "addFileAddsInMemoryFile",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "addResourceFile",
      "tail_type": "useScenario"
    },
    {
      "head": "addFileWhenFileAlreadyAddedThrowsException",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "addResourceFile",
      "tail_type": "useScenario"
    },
    {
      "head": "getGeneratedFilesReturnsFiles",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "getGeneratedFiles",
      "tail_type": "useScenario"
    },
    {
      "head": "getGeneratedFileContentWhenFileExistsReturnsContent",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "getGeneratedFileContent",
      "tail_type": "useScenario"
    },
    {
      "head": "getGeneratedFileContentWhenFileIsMissingReturnsNull",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "getGeneratedFileContent",
      "tail_type": "useScenario"
    },
    {
      "head": "getGeneratedFileWhenFileExistsReturnsInputStreamSource",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "getGeneratedFile",
      "tail_type": "useScenario"
    },
    {
      "head": "getGeneratedFileWhenFileIsMissingReturnsNull",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "getGeneratedFile",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.aot.generate.InMemoryGeneratedFilesTests",
      "head_type": "class",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.InMemoryGeneratedFilesTests",
      "head_type": "class",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.InMemoryGeneratedFilesTests",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "InMemoryGeneratedFiles",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.ClassTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "generateWhenClass",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.ClassTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "generateWhenCglibClass",
      "tail_type": "apiFunction"
    },
    {
      "head": "generateWhenClass",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "InputStream.class",
      "tail_type": "useSampleCode"
    },
    {
      "head": "generateWhenCglibClass",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "ExampleClass.class",
      "tail_type": "useSampleCode"
    },
    {
      "head": "generateWhenClass",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "resolve(generateCode(InputStream.class))",
      "tail_type": "useSampleCode"
    },
    {
      "head": "generateWhenCglibClass",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "resolve(generateCode(ExampleClass$$GeneratedBy.class))",
      "tail_type": "useSampleCode"
    },
    {
      "head": "generateWhenClass",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "assertThat(resolve(generateCode(InputStream.class))).hasImport(InputStream.class).hasValueCode(\"InputStream.class\")",
      "tail_type": "useSampleCode"
    },
    {
      "head": "generateWhenCglibClass",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "assertThat(resolve(generateCode(ExampleClass$$GeneratedBy.class))).hasImport(ExampleClass.class).hasValueCode(\"ExampleClass.class\")",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.hint.annotation.SampleMethodAnnotatedBean",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "reflectiveMethod",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.hint.annotation.SampleMethodAnnotatedBean",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "nonManagedMethod",
      "tail_type": "apiFunction"
    },
    {
      "head": "reflectiveMethod",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "reflectionUsage",
      "tail_type": "useConstraint"
    },
    {
      "head": "nonManagedMethod",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "noSpecialConstraints",
      "tail_type": "useConstraint"
    },
    {
      "head": "reflectiveMethod",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "runtimeReflection",
      "tail_type": "useScenario"
    },
    {
      "head": "nonManagedMethod",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "regularMethodExecution",
      "tail_type": "useScenario"
    },
    {
      "head": "reflectiveMethod",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "sampleCodeForReflectiveMethod",
      "tail_type": "useSampleCode"
    },
    {
      "head": "nonManagedMethod",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "sampleCodeForNonManagedMethod",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.hint.annotation.SampleMethodAnnotatedBean",
      "head_type": "class",
      "relation": "have",
      "tail": "relatedConceptsExplanation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.hint.annotation.SampleMethodAnnotatedBean",
      "head_type": "class",
      "relation": "have",
      "tail": "designPrinciplesExplanation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.hint.annotation.SampleMethodAnnotatedBean",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.aot.hint.annotation",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.hint.annotation.SampleMethodAnnotatedBeanWithInheritance#notManaged()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "notManaged",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.hint.annotation.SampleMethodAnnotatedBeanWithInheritance#notManaged()",
      "head_type": "method",
      "relation": "have",
      "tail": "public void notManaged() ;",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.AntPathMatcher",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "path matching",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.AntPathMatcher",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "pattern parsing",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.AntPathMatcher",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "tokenization",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.AntPathMatcher",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "caching",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.AntPathMatcher",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "case sensitivity",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.AntPathMatcher",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "trimming tokens",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.AntPathMatcher",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "wildcard matching",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.AntPathMatcher",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "URI template variable extraction",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.AntPathMatcher",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "pattern combination",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.AntPathMatcher",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "pattern sorting",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.AntPathMatcher",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "glob pattern matching",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.AntPathMatcher",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "variable pattern matching",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.AntPathMatcher",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "path separator pattern caching",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.AntPathMatcher",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "Ant-style path pattern matching",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.AntPathMatcher",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "Ant-style path pattern sorting",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.AntPathMatcher",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "Ant-style path pattern variable extraction",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.AntPathMatcher",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "Ant-style path pattern combination",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.AntPathMatcher",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "Ant-style path pattern comparator",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.AntPathMatcher",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "Ant-style path pattern string matcher",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.AntPathMatcher",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "Ant-style path pattern pattern info",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.AntPathMatcher",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "Ant-style path pattern path separator pattern cache",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.AntPathMatcher",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "Ant-style path pattern ant pattern comparator",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.AntPathMatcher",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "Ant-style path pattern ant path string matcher",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.AntPathMatcher",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "Ant-style path pattern pattern info",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.AntPathMatcher",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "Ant-style path pattern path separator pattern cache",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.Assert#notNull(Object,Supplier<String>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "assertNotNull",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.Assert#notNull(Object,Supplier<String>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "objectNotNull",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.Assert#notNull(Object,Supplier<String>)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "checkObjectNotNull",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.Assert#notNull(Object,Supplier<String>)",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.Assert#notNull(Object,Supplier<String>)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.Assert#notNull(Object,Supplier<String>)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.Assert#notNull(Object,Supplier<String>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "IllegalArgumentException",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.Assert#noNullElements(Collection<?>,String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "assertNoNullElements",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.Assert#noNullElements(Collection<?>,String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "collectionNotNull",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.Assert#noNullElements(Collection<?>,String)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "checkCollectionForNullElements",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.Assert#noNullElements(Collection<?>,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.Assert#noNullElements(Collection<?>,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.Assert#noNullElements(Collection<?>,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.Assert#noNullElements(Collection<?>,String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "IllegalArgumentException",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.ClassUtils#findInterfaceMethodIfPossible(String,Class<?>[],Class<?>,Class<?>,boolean)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "findInterfaceMethodIfPossible",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ClassUtils#findInterfaceMethodIfPossible(String,Class<?>[],Class<?>,Class<?>,boolean)",
      "head_type": "method",
      "relation": "have",
      "tail": "findInterfaceMethodIfPossible(String,Class<?>[],Class<?>,Class<?>,boolean) sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "findInterfaceMethodIfPossible(String,Class<?>[],Class<?>,Class<?>,boolean) sample code",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "private static Method findInterfaceMethodIfPossible(String methodName, Class<?>[] parameterTypes, Class<?> startClass, Class<?> endClass, boolean requirePublicInterface) {\n    Class<?> current = startClass;\n    while (current != null && current != endClass) {\n        for (Class<?> ifc : current.getInterfaces()) {\n            try {\n                if (!requirePublicInterface || Modifier.isPublic(ifc.getModifiers())) {\n                    return ifc.getMethod(methodName, parameterTypes);\n                }\n            } catch (NoSuchMethodException ex) {\n                // ignore\n            }\n        }\n        current = current.getSuperclass();\n    }\n    return null;\n}",
      "tail_type": "code"
    },
    {
      "head": "org.springframework.util.CollectionUtils#contains(Enumeration<?>,Object)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "check whether the given Enumeration contains the given element",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.CollectionUtils#contains(Enumeration<?>,Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "Check whether the given Enumeration contains the given element.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.CollectionUtils#contains(Enumeration<?>,Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "The method iterates over the elements of the given Enumeration and compares each element with the specified element using the ObjectUtils.nullSafeEquals method.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.CollectionUtils#contains(Enumeration<?>,Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "public static boolean contains(@Nullable Enumeration<?> enumeration, Object element) {\n    if (enumeration != null) {\n        while (enumeration.hasMoreElements()) {\n            Object candidate = enumeration.nextElement();\n            if (ObjectUtils.nullSafeEquals(candidate, element)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.CompositeCollection#add(E)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "add elements to collection",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.CompositeCollection#add(E)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "unsupported operation exception",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.CompositeCollection#add(E)",
      "head_type": "method",
      "relation": "have",
      "tail": "throwing exception when adding elements",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.CompositeCollection#add(E)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for adding elements to collection",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.CompositeCollection#add(E)",
      "head_type": "method",
      "relation": "have",
      "tail": "related concept interpretation for adding elements",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.CompositeCollection#add(E)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle interpretation for adding elements",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.CompositeCollection#add(E)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.CompositeCollection",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.ConcurrentLruCache",
      "head_type": "class",
      "relation": "haveFuntion",
      "tail": "lazy loading",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ConcurrentLruCache",
      "head_type": "class",
      "relation": "constrained_by",
      "tail": "circular aliases are prohibited",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ConcurrentLruCache",
      "head_type": "class",
      "relation": "applied_to",
      "tail": "multiple aliases for a single name",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ConcurrentLruCache",
      "head_type": "class",
      "relation": "have",
      "tail": "package com.healthMgr.common.email; import java.xxxx; public class OneClass { // specific code }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ConcurrentLruCache",
      "head_type": "class",
      "relation": "have",
      "tail": "org.springframework.core.SimpleAliasRegistryTests",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.ConcurrentLruCache",
      "head_type": "class",
      "relation": "have",
      "tail": "An explanation of related concepts",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ConcurrentLruCache",
      "head_type": "class",
      "relation": "have",
      "tail": "An explanation of the design principles of the class or method",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ConcurrentLruCache",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.ConcurrentLruCache",
      "tail_type": "class"
    },
    {
      "tail": "Write operation recorded when an entry is removed to the cache",
      "head_type": "class",
      "relation": "haveFunction",
      "head": "org.springframework.util.RemovalTask",
      "tail_type": "apiFunction"
    },
    {
      "tail": "Write operation recorded when an entry is removed to the cache",
      "head_type": "class",
      "relation": "have",
      "head": "org.springframework.util.RemovalTask",
      "tail_type": "apiFunction"
    },
    {
      "tail": "Removes an entry from the cache",
      "head_type": "class",
      "relation": "have",
      "head": "org.springframework.util.RemovalTask",
      "tail_type": "useScenario"
    },
    {
      "tail": "public void run() {    evictionQueue.remove(this.node);    markAsRemoved(this.node);}",
      "head_type": "class",
      "relation": "have",
      "head": "org.springframework.util.RemovalTask",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "Eviction queue management",
      "head_type": "class",
      "relation": "have",
      "head": "org.springframework.util.RemovalTask",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "tail": "Design principles for efficient cache management",
      "head_type": "class",
      "relation": "have",
      "head": "org.springframework.util.RemovalTask",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ReadOperations#drain()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "drainReadBuffer",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ReadOperations#drain()",
      "head_type": "method",
      "relation": "have",
      "tail": "drainReadBuffer(i & BUFFERS_MASK)",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ReadOperations#drain()",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is used to drain the read buffers for a range of thread IDs.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ReadOperations#drain()",
      "head_type": "method",
      "relation": "have",
      "tail": "The method iterates over a range of thread IDs and calls drainReadBuffer for each.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ReadOperations#drainReadBuffer(int)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "buffer management",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ReadOperations#drainReadBuffer(int)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "bufferIndex bounds",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ReadOperations#drainReadBuffer(int)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "concurrent read/write operations",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ReadOperations#drainReadBuffer(int)",
      "head_type": "method",
      "relation": "have",
      "tail": "private void drainReadBuffer(int bufferIndex) { final long writeCount = this.recordedCount.get(bufferIndex); for (int i = 0; i < MAX_DRAIN_COUNT; i++) { final int index = (int) (this.readCount[bufferIndex] & BUFFER_INDEX_MASK); final AtomicReferenceArray<Node<K, V>> buffer = this.buffers[bufferIndex]; final Node<K, V> node = buffer.get(index); if (node == null) { break; } buffer.lazySet(index, null); this.evictionQueue.moveToBack(node); this.readCount[bufferIndex]++; } this.processedCount.lazySet(bufferIndex, writeCount); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ReadOperations#drainReadBuffer(int)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is used to drain the read buffer for a given index, ensuring that the read operations are properly synchronized with the write operations.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ReadOperations#drainReadBuffer(int)",
      "head_type": "method",
      "relation": "have",
      "tail": "The method follows a design principle of ensuring thread safety and efficient buffer management in concurrent environments.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ReadOperations#drainReadBuffer(int)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.ReadOperations",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.EvictionQueue#contains(Node<K,V>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "checkNodePresence",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.EvictionQueue#contains(Node<K,V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.EvictionQueue",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.EvictionQueue#contains(Node<K,V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "private boolean contains(Node<K, V> e) {\n    return (e.getPrevious() != null) || (e.getNext() != null) || (e == this.first);\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.EvictionQueue#contains(Node<K,V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "Checks if a given node is present in the EvictionQueue.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.EvictionQueue#contains(Node<K,V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is designed to efficiently determine if a node is part of the EvictionQueue by checking its previous and next references, as well as its position relative to the first node.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.Entry",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "Map Entry Representation",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.Entry",
      "head_type": "class",
      "relation": "have",
      "tail": "A single map entry",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.Entry",
      "head_type": "class",
      "relation": "have",
      "tail": "Key-Value Pair Management",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.Entry",
      "head_type": "class",
      "relation": "have",
      "tail": "Sample Code for Map Entry",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ErrorHandler#handleError(Throwable)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "handleError",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ErrorHandler#handleError(Throwable)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "rethrowing as a fatal exception",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ErrorHandler#handleError(Throwable)",
      "head_type": "method",
      "relation": "have",
      "tail": "Handle the given error, possibly rethrowing it as a fatal exception.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ErrorHandler#handleError(Throwable)",
      "head_type": "method",
      "relation": "have",
      "tail": "Handle the given error, possibly rethrowing it as a fatal exception.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.MethodInvoker#findMatchingMethod()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "find a matching method",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MethodInvoker#findMatchingMethod()",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "target class must be set",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.MethodInvoker#findMatchingMethod()",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "invoking a method with arguments",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.MethodInvoker#findMatchingMethod()",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for finding a matching method",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.MethodInvoker#findMatchingMethod()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.MethodInvoker",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.MethodInvoker#findMatchingMethod()",
      "head_type": "method",
      "relation": "have",
      "tail": "related concept interpretation for method invocation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.MethodInvoker#findMatchingMethod()",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle interpretation for method matching",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.MultiValueMap#fromSingleValue(Map<K,V>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "adaptSingleValueMap",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MultiValueMap#fromSingleValue(Map<K,V>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "noMultipleValuesForKey",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.MultiValueMap#fromSingleValue(Map<K,V>)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "singleValueMapAdaptation",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.MultiValueMap#fromSingleValue(Map<K,V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "sampleCodeForAdaptingSingleValueMap",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.MultiValueMap#fromSingleValue(Map<K,V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretationForAdaptingSingleValueMap",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.MultiValueMap#fromSingleValue(Map<K,V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretationForAdaptingSingleValueMap",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "adaptSingleValueMap",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "org.springframework.util.MultiValueMap#fromSingleValue(Map<K,V>)",
      "tail_type": "method"
    },
    {
      "head": "noMultipleValuesForKey",
      "head_type": "useConstraint",
      "relation": "associated_with",
      "tail": "org.springframework.util.MultiValueMap#fromSingleValue(Map<K,V>)",
      "tail_type": "method"
    },
    {
      "head": "singleValueMapAdaptation",
      "head_type": "useScenario",
      "relation": "associated_with",
      "tail": "org.springframework.util.MultiValueMap#fromSingleValue(Map<K,V>)",
      "tail_type": "method"
    },
    {
      "head": "sampleCodeForAdaptingSingleValueMap",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "tail": "org.springframework.util.MultiValueMap#fromSingleValue(Map<K,V>)",
      "tail_type": "method"
    },
    {
      "head": "relatedConceptInterpretationForAdaptingSingleValueMap",
      "head_type": "relatedConceptInterpretation",
      "relation": "associated_with",
      "tail": "org.springframework.util.MultiValueMap#fromSingleValue(Map<K,V>)",
      "tail_type": "method"
    },
    {
      "head": "designPrincipleInterpretationForAdaptingSingleValueMap",
      "head_type": "designPrincipleInterpretation",
      "relation": "associated_with",
      "tail": "org.springframework.util.MultiValueMap#fromSingleValue(Map<K,V>)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.MultiValueMapAdapter#size()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "size determination",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MultiValueMapAdapter#size()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.MultiValueMapAdapter",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.MultiValueMapAdapter",
      "head_type": "class",
      "relation": "have",
      "tail": "Map implementation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.MultiValueMapAdapter#size()",
      "head_type": "method",
      "relation": "have",
      "tail": "public int size() { return this.targetMap.size(); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ObjectUtils",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "nullSafeHashCode(int[])",
      "tail_type": "apiFunction"
    },
    {
      "head": "nullSafeHashCode(int[])",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "deprecated as of 6.1",
      "tail_type": "useConstraint"
    },
    {
      "head": "nullSafeHashCode(int[])",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "return a hash code based on the contents of the specified array",
      "tail_type": "useScenario"
    },
    {
      "head": "nullSafeHashCode(int[])",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "public static int nullSafeHashCode(int @Nullable [] array) { return Arrays.hashCode(array); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "nullSafeHashCode(int[])",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "nullSafeHashCode(int[])",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ObjectUtils",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "java.util.Arrays",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.PathMatcher#extractUriTemplateVariables(String,String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "extractUriTemplateVariables",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.PathMatcher#extractUriTemplateVariables(String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "Given a pattern and a full path, extract the URI template variables. URI template variables are expressed through curly brackets ('{' and '}'). For example: For pattern \"/hotels/{hotel}\" and path \"/hotels/1\", this method will return a map containing \"hotel\" &rarr; \"1\".",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.PathMatcher#extractUriTemplateVariables(String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "URI template variables are expressed through curly brackets ('{' and '}'). For example: For pattern \"/hotels/{hotel}\" and path \"/hotels/1\", this method will return a map containing \"hotel\" &rarr; \"1\".",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.PathMatcher#extractUriTemplateVariables(String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is designed to extract variables from a URI template, which is a common requirement in web applications for routing and URL mapping. The design principle here is to provide a flexible and easy-to-use mechanism for developers to handle dynamic URL segments.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "extractUriTemplateVariables",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "web applications for routing and URL mapping",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.PathMatcher#getPatternComparator(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "sorting patterns by explicitness",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.PathMatcher#getPatternComparator(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "Given a full path, returns a Comparator suitable for sorting patterns in order of explicitness for that path.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.PathMatcher#getPatternComparator(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "The full algorithm used depends on the underlying implementation, but generally, the returned Comparator will sort a list so that more specific patterns come before generic patterns.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.PathMatcher#getPatternComparator(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "package com.healthMgr.common.email; import java.util.Comparator; import java.util.List; public class PatternComparatorExample { public static void main(String[] args) { List<String> patterns = List.of(\"/users/**\", \"/users/{userId}\", \"/users/{userId}/details\"); Comparator<String> comparator = new PathMatcher().getPatternComparator(\"/users/123\"); patterns.sort(comparator); System.out.println(patterns); } }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.PartResolutionContext#removePlaceholder(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "removePlaceholder",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.PartResolutionContext#removePlaceholder(String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "placeholder must be visited",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.PartResolutionContext#removePlaceholder(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "Visited placeholders must not be null",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.PartResolutionContext#removePlaceholder(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "public void removePlaceholder(String placeholder) {    Assert.state(this.visitedPlaceholders != null, \"Visited placeholders must not be null\");    this.visitedPlaceholders.remove(placeholder);}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.PartResolutionContext#removePlaceholder(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is used to remove a placeholder from the visited placeholders list.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.PartResolutionContext#removePlaceholder(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "The method ensures that placeholders are only removed if they have been visited, maintaining the integrity of the placeholder tracking.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.AbstractPart#isTextOnly(List<Part>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "check if all parts are text",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.AbstractPart#isTextOnly(List<Part>)",
      "head_type": "method",
      "relation": "have",
      "tail": "private boolean isTextOnly(List<Part> parts) {\n    return parts.stream().allMatch(TextPart.class::isInstance);\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.AbstractPart#isTextOnly(List<Part>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.AbstractPart",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.AbstractPart",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "check if all parts are text",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.AbstractPart",
      "head_type": "class",
      "relation": "have",
      "tail": "private boolean isTextOnly(List<Part> parts) {\n    return parts.stream().allMatch(TextPart.class::isInstance);\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.PropertiesPersister#store(Properties,OutputStream,String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "store properties",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.PropertiesPersister#store(Properties,OutputStream,String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "IOException in case of I/O errors",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.PropertiesPersister#store(Properties,OutputStream,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "store the contents of the given Properties object to the given OutputStream",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.PropertiesPersister#store(Properties,OutputStream,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "java.util.Properties#store",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.PropertiesPersister#store(Properties,OutputStream,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "void store(Properties props, OutputStream os, String header) throws IOException",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.PropertiesPersister#store(Properties,OutputStream,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "Write the contents of the given Properties object to the given OutputStream",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ResourceUtils#isFileURL(URL)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "check if URL points to a file system resource",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ResourceUtils#isFileURL(URL)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "URL must have 'file', 'vfsfile', or 'vfs' protocol",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ResourceUtils#isFileURL(URL)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "identifying file system URLs",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ResourceUtils#isFileURL(URL)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for checking file system URL",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ResourceUtils#isFileURL(URL)",
      "head_type": "method",
      "relation": "have",
      "tail": "explanation of URL protocols and file system resources",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ResourceUtils#isFileURL(URL)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle behind URL protocol checking",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ResourceUtils#isFileURL(URL)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.ResourceUtils",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.SerializationUtils",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "serialize",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.SerializationUtils",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "deserialize",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.SerializationUtils",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "clone",
      "tail_type": "apiFunction"
    },
    {
      "head": "serialize",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "object must be non-null",
      "tail_type": "useConstraint"
    },
    {
      "head": "deserialize",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "bytes must be non-null",
      "tail_type": "useConstraint"
    },
    {
      "head": "deserialize",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "deprecated due to security concerns",
      "tail_type": "useConstraint"
    },
    {
      "head": "clone",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "object must implement Serializable",
      "tail_type": "useConstraint"
    },
    {
      "head": "serialize",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "object serialization to byte array",
      "tail_type": "useScenario"
    },
    {
      "head": "deserialize",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "object deserialization from byte array",
      "tail_type": "useScenario"
    },
    {
      "head": "clone",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "object deep copy via serialization",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.SerializationUtils",
      "head_type": "class",
      "relation": "have",
      "tail": "Java Object Serialization utilities",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.SerializationUtils",
      "head_type": "class",
      "relation": "have",
      "tail": "security concerns with Java Object Serialization",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.SerializationUtils",
      "head_type": "class",
      "relation": "have",
      "tail": " serialization and deserialization sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.SimpleIdGenerator",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "generateId",
      "tail_type": "apiFunction"
    },
    {
      "head": "generateId",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "UUID generation",
      "tail_type": "useSampleCode"
    },
    {
      "head": "generateId",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "Simple ID generation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.SimpleIdGenerator",
      "head_type": "class",
      "relation": "have",
      "tail": "Simple ID generation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.StringUtils#collectionToDelimitedString(Collection<?>,String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "Convert a Collection into a delimited String",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils#collectionToDelimitedString(Collection<?>,String)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "toString() implementations",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.StringUtils#collectionToDelimitedString(Collection<?>,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "Convert a Collection into a delimited String (for example, CSV)",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.StringUtils#collectionToDelimitedString(Collection<?>,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "The method is useful for generating a string representation of a collection, which is particularly useful for logging or displaying the contents of a collection in a readable format.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.StringUtils#collectionToDelimitedString(Collection<?>,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "The design principle followed here is to provide a utility method that can be widely used across different contexts where a collection needs to be converted into a string format. This method abstracts the common pattern of joining elements of a collection with a delimiter, thus promoting code reuse and reducing redundancy.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.SystemPropertyPlaceholderResolver#resolvePlaceholder(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "resolvePlaceholder",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.SystemPropertyPlaceholderResolver#resolvePlaceholder(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "resolvePlaceholder(String) useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "resolvePlaceholder(String) useSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "package com.example.demo;\nimport org.springframework.util.SystemPropertyPlaceholderResolver;\n\npublic class PlaceholderResolverExample {\n    public static void main(String[] args) {\n        SystemPropertyPlaceholderResolver resolver = new SystemPropertyPlaceholderResolver();\n        String placeholderName = \"example.property\";\n        String resolvedValue = resolver.resolvePlaceholder(placeholderName);\n        System.out.println(\"Resolved value: \" + resolvedValue);\n    }\n}",
      "tail_type": "String"
    },
    {
      "head": "org.springframework.util.SystemPropertyPlaceholderResolver#resolvePlaceholder(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "resolvePlaceholder(String) relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "resolvePlaceholder(String) relatedConceptInterpretation",
      "head_type": "relatedConceptInterpretation",
      "relation": "have",
      "tail": "This method is used to resolve placeholders by searching system properties and environment variables. It attempts to retrieve the value of a placeholder from system properties first, and if not found, it falls back to searching the system environment. If the placeholder cannot be resolved, it returns null and logs an error message.",
      "tail_type": "String"
    },
    {
      "head": "org.springframework.util.SystemPropertyPlaceholderResolver#resolvePlaceholder(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "resolvePlaceholder(String) designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "resolvePlaceholder(String) designPrincipleInterpretation",
      "head_type": "designPrincipleInterpretation",
      "relation": "have",
      "tail": "The design principle behind this method is to provide a flexible way to resolve placeholders that can be configured via system properties or environment variables. This allows for easy configuration management and the ability to override settings without modifying the code.",
      "tail_type": "String"
    },
    {
      "head": "org.springframework.util.unit.DataSize#isNegative()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "checkNegativeSize",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.unit.DataSize#isNegative()",
      "head_type": "method",
      "relation": "have",
      "tail": "checkNegativeSizeSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "checkNegativeSizeSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "org.springframework.util.unit.DataSize",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.unit.DataSize#isNegative()",
      "head_type": "method",
      "relation": "have",
      "tail": "negativeSizeInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "negativeSizeInterpretation",
      "head_type": "relatedConceptInterpretation",
      "relation": "have",
      "tail": "org.springframework.util.unit.DataSize",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySet#hashCode()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "calculateHashCode",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySet#hashCode()",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.UnmodifiableEntrySet",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySet#hashCode()",
      "head_type": "method",
      "relation": "have",
      "tail": "delegation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "calculateHashCode",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "org.springframework.util.UnmodifiableEntrySet#hashCode()",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySet",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.UnmodifiableEntrySet#hashCode()",
      "tail_type": "method"
    },
    {
      "head": "delegation",
      "head_type": "designPrincipleInterpretation",
      "relation": "have",
      "tail": "org.springframework.util.UnmodifiableEntrySet#hashCode()",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueCollection",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "UnmodifiableValueCollection",
      "tail_type": "apiFunction"
    },
    {
      "head": "UnmodifiableValueCollection",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "UnsupportedOperationException",
      "tail_type": "useConstraint"
    },
    {
      "head": "UnmodifiableValueCollection",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "Collection",
      "tail_type": "useScenario"
    },
    {
      "head": "UnmodifiableValueCollection",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "UnmodifiableValueCollectionSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "UnmodifiableValueCollection",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "UnmodifiableValueCollectionRelatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "UnmodifiableValueCollection",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "UnmodifiableValueCollectionDesignPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueCollection",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "java.util.Collection",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueCollection",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "java.util.Collections",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueCollection",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "java.util.Iterator",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueCollection",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "java.util.Spliterator",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueCollection",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "java.util.stream.Stream",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueCollection",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "java.util.function.Consumer",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueCollection",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "java.util.function.Predicate",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueCollection",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "java.util.Comparator",
      "tail_type": "class"
    },
    {
      "tail": "UnmodifiableValueCollection",
      "head_type": "method",
      "relation": "haveFunction",
      "head": "org.springframework.util.UnmodifiableValueCollection#spliterator()",
      "tail_type": "class"
    },
    {
      "tail": "spliterator",
      "head_type": "method",
      "relation": "haveFunction",
      "head": "org.springframework.util.UnmodifiableValueCollection#spliterator()",
      "tail_type": "apiFunction"
    },
    {
      "tail": "UnmodifiableValueSpliterator",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.UnmodifiableValueCollection#spliterator()",
      "tail_type": "class"
    },
    {
      "tail": "UnmodifiableValueCollection",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.UnmodifiableValueCollection#spliterator()",
      "tail_type": "class"
    },
    {
      "tail": "UnmodifiableValueSpliterator",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.UnmodifiableValueCollection#spliterator()",
      "tail_type": "class"
    },
    {
      "tail": "UnmodifiableValueCollection",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.UnmodifiableValueCollection#spliterator()",
      "tail_type": "class"
    },
    {
      "tail": "UnmodifiableValueSpliterator",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.UnmodifiableValueCollection#spliterator()",
      "tail_type": "class"
    },
    {
      "tail": "UnmodifiableValueCollection",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.UnmodifiableValueCollection#spliterator()",
      "tail_type": "class"
    },
    {
      "tail": "UnmodifiableValueSpliterator",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.UnmodifiableValueCollection#spliterator()",
      "tail_type": "class"
    },
    {
      "tail": "UnmodifiableValueCollection",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.UnmodifiableValueCollection#spliterator()",
      "tail_type": "class"
    },
    {
      "tail": "UnmodifiableValueSpliterator",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.UnmodifiableValueCollection#spliterator()",
      "tail_type": "class"
    },
    {
      "tail": "UnmodifiableValueCollection",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.UnmodifiableValueCollection#spliterator()",
      "tail_type": "class"
    },
    {
      "tail": "UnmodifiableValueSpliterator",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.UnmodifiableValueCollection#spliterator()",
      "tail_type": "class"
    },
    {
      "tail": "UnmodifiableValueCollection",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.UnmodifiableValueCollection#spliterator()",
      "tail_type": "class"
    },
    {
      "tail": "UnmodifiableValueSpliterator",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.UnmodifiableValueCollection#spliterator()",
      "tail_type": "class"
    },
    {
      "tail": "UnmodifiableValueCollection",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.UnmodifiableValueCollection#spliterator()",
      "tail_type": "class"
    },
    {
      "tail": "UnmodifiableValueSpliterator",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.UnmodifiableValueCollection#spliterator()",
      "tail_type": "class"
    },
    {
      "tail": "UnmodifiableValueCollection",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.UnmodifiableValueCollection#spliterator()",
      "tail_type": "class"
    },
    {
      "tail": "UnmodifiableValueSpliterator",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.UnmodifiableValueCollection#spliterator()",
      "tail_type": "class"
    },
    {
      "tail": "UnmodifiableValueCollection",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.UnmodifiableValueCollection#spliterator()",
      "tail_type": "class"
    },
    {
      "tail": "UnmodifiableValueSpliterator",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.UnmodifiableValueCollection#spliterator()",
      "tail_type": "class"
    },
    {
      "tail": "UnmodifiableValueCollection",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.UnmodifiableValueCollection#spliterator()",
      "tail_type": "class"
    },
    {
      "tail": "UnmodifiableValueSpliterator",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.UnmodifiableValueCollection#spliterator()",
      "tail_type": "class"
    },
    {
      "tail": "UnmodifiableValueCollection",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.UnmodifiableValueCollection#spliterator()",
      "tail_type": "class"
    },
    {
      "tail": "UnmodifiableValueSpliterator",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.UnmodifiableValueCollection#spliterator()",
      "tail_type": "class"
    },
    {
      "tail": "UnmodifiableValueCollection",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.UnmodifiableValueCollection#spliterator()",
      "tail_type": "class"
    },
    {
      "tail": "UnmodifiableValueSpliterator",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.UnmodifiableValueCollection#spliterator()",
      "tail_type": "class"
    },
    {
      "tail": "UnmodifiableValueCollection",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.UnmodifiableValueCollection#spliterator()",
      "tail_type": "class"
    },
    {
      "tail": "UnmodifiableValueSpliterator",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.UnmodifiableValueCollection#spliterator()",
      "tail_type": "class"
    },
    {
      "tail": "UnmodifiableValueCollection",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.UnmodifiableValueCollection#spliterator()",
      "tail_type": "class"
    },
    {
      "tail": "UnmodifiableValueSpliterator",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.UnmodifiableValueCollection#spliterator()",
      "tail_type": "class"
    },
    {
      "tail": "UnmodifiableValueCollection",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.UnmodifiableValueCollection#spliterator()",
      "tail_type": "class"
    },
    {
      "tail": "UnmodifiableValueSpliterator",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.UnmodifiableValueCollection#spliterator()",
      "tail_type": "class"
    },
    {
      "tail": "UnmodifiableValueCollection",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.UnmodifiableValueCollection#spliterator()",
      "tail_type": "class"
    },
    {
      "tail": "UnmodifiableValueSpliterator",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.UnmodifiableValueCollection#spliterator()",
      "tail_type": "class"
    },
    {
      "tail": "UnmodifiableValueCollection",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.UnmodifiableValueCollection#spliterator()",
      "tail_type": "class"
    },
    {
      "tail": "UnmodifiableValueSpliterator",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.UnmodifiableValueCollection#spliterator()",
      "tail_type": "class"
    },
    {
      "tail": "UnmodifiableValueCollection",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.UnmodifiableValueCollection#spliterator()",
      "tail_type": "class"
    },
    {
      "tail": "UnmodifiableValueSpliterator",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.UnmodifiableValueCollection#spliterator()",
      "tail_type": "class"
    },
    {
      "tail": "UnmodifiableValueCollection",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.UnmodifiableValueCollection#spliterator()",
      "tail_type": "class"
    },
    {
      "tail": "UnmodifiableValueSpliterator",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.UnmodifiableValueCollection#spliterator()",
      "tail_type": "class"
    },
    {
      "tail": "UnmodifiableValueCollection",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.UnmodifiableValueCollection#spliterator()",
      "tail_type": "class"
    },
    {
      "tail": "UnmodifiableValueSpliterator",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.UnmodifiableValueCollection#spliterator()",
      "tail_type": "class"
    },
    {
      "tail": "UnmodifiableValueCollection",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.UnmodifiableValueCollection#spliterator()",
      "tail_type": "class"
    },
    {
      "tail": "UnmodifiableValueSpliterator",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.UnmodifiableValueCollection#spliterator()",
      "tail_type": "class"
    },
    {
      "tail": "UnmodifiableValueCollection",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.UnmodifiableValueCollection#spliterator()",
      "tail_type": "class"
    },
    {
      "tail": "UnmodifiableValueSpliterator",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.UnmodifiableValueCollection#spliterator()",
      "tail_type": "class"
    },
    {
      "tail": "UnmodifiableValueCollection",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.UnmodifiableValueCollection#spliterator()",
      "tail_type": "class"
    },
    {
      "tail": "UnmodifiableValueSpliterator",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.UnmodifiableValueCollection#spliterator()",
      "tail_type": "class"
    },
    {
      "tail": "UnmodifiableValueCollection",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.UnmodifiableValueCollection#spliterator()",
      "tail_type": "class"
    },
    {
      "tail": "UnmodifiableValueSpliterator",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.UnmodifiableValueCollection#spliterator()",
      "tail_type": "class"
    },
    {
      "tail": "UnmodifiableValueCollection",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.UnmodifiableValueCollection#spliterator()",
      "tail_type": "class"
    },
    {
      "tail": "UnmodifiableValueSpliterator",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.UnmodifiableValueCollection#spliterator()",
      "tail_type": "class"
    },
    {
      "tail": "UnmodifiableValueCollection",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.UnmodifiableValueCollection#spliterator()",
      "tail_type": "class"
    },
    {
      "tail": "UnmodifiableValueSpliterator",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.UnmodifiableValueCollection#spliterator()",
      "tail_type": "class"
    },
    {
      "tail": "UnmodifiableValueCollection",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.UnmodifiableValueCollection#spliterator()",
      "tail_type": "class"
    },
    {
      "tail": "UnmodifiableValueSpliterator",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.UnmodifiableValueCollection#spliterator()",
      "tail_type": "class"
    },
    {
      "tail": "UnmodifiableValueCollection",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.UnmodifiableValueCollection#spliterator()",
      "tail_type": "class"
    },
    {
      "tail": "UnmodifiableValueSpliterator",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.UnmodifiableValueCollection#spliterator()",
      "tail_type": "class"
    },
    {
      "tail": "UnmodifiableValueCollection",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.UnmodifiableValueCollection#spliterator()",
      "tail_type": "class"
    },
    {
      "tail": "UnmodifiableValueSpliterator",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.UnmodifiableValueCollection#spliterator()",
      "tail_type": "class"
    },
    {
      "tail": "UnmodifiableValueCollection",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.UnmodifiableValueCollection#spliterator()",
      "tail_type": "class"
    },
    {
      "tail": "UnmodifiableValueSpliterator",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.UnmodifiableValueCollection#spliterator()",
      "tail_type": "class"
    },
    {
      "tail": "UnmodifiableValueCollection",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.UnmodifiableValueCollection#spliterator()",
      "tail_type": "class"
    },
    {
      "tail": "UnmodifiableValueSpliterator",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.UnmodifiableValueCollection#spliterator()",
      "tail_type": "class"
    },
    {
      "tail": "UnmodifiableValueCollection",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.UnmodifiableValueCollection#spliterator()",
      "tail_type": "class"
    },
    {
      "tail": "UnmodifiableValueSpliterator",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.UnmodifiableValueCollection#spliterator()",
      "tail_type": "class"
    },
    {
      "tail": "UnmodifiableValueCollection",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.UnmodifiableValueCollection#spliterator()",
      "tail_type": "class"
    },
    {
      "tail": "UnmodifiableValueSpliterator",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.UnmodifiableValueCollection#spliterator()",
      "tail_type": "class"
    },
    {
      "tail": "UnmodifiableValueCollection",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.UnmodifiableValueCollection#spliterator()",
      "tail_type": "class"
    },
    {
      "tail": "UnmodifiableValueSpliterator",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.UnmodifiableValueCollection#spliterator()",
      "tail_type": "class"
    },
    {
      "tail": "UnmodifiableValueCollection",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.UnmodifiableValueCollection#spliterator()",
      "tail_type": "class"
    },
    {
      "tail": "UnmodifiableValueSpliterator",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.UnmodifiableValueCollection#spliterator()",
      "tail_type": "class"
    },
    {
      "tail": "UnmodifiableValueCollection",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.UnmodifiableValueCollection#spliterator()",
      "tail_type": "class"
    },
    {
      "tail": "UnmodifiableValueSpliterator",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.UnmodifiableValueCollection#spliterator()",
      "tail_type": "class"
    },
    {
      "tail": "UnmodifiableValueCollection",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.UnmodifiableValueCollection#spliterator()",
      "tail_type": "class"
    },
    {
      "tail": "UnmodifiableValueSpliterator",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.UnmodifiableValueCollection#spliterator()",
      "tail_type": "class"
    },
    {},
    {
      "head": "org.springframework.util.UnmodifiableValueSpliterator#tryAdvance(Consumer<? super List<T>>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "tryAdvance",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueSpliterator#tryAdvance(Consumer<? super List<T>>)",
      "head_type": "method",
      "relation": "have",
      "tail": "UnmodifiableValueSpliterator",
      "tail_type": "class"
    },
    {
      "head": "UnmodifiableValueSpliterator",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.UnmodifiableValueSpliterator#tryAdvance(Consumer<? super List<T>>)",
      "tail_type": "method"
    },
    {
      "head": "tryAdvance",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "UnmodifiableValueSpliterator",
      "tail_type": "class"
    },
    {
      "head": "tryAdvance",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "Consumer<? super List<T>>",
      "tail_type": "useScenario"
    },
    {
      "head": "tryAdvance",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "Collections.unmodifiableList(l)",
      "tail_type": "useSampleCode"
    },
    {
      "head": "tryAdvance",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "tryAdvance",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#comment(char[],int,int)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "handle comment",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#comment(char[],int,int)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "SAXException may be thrown",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#comment(char[],int,int)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#comment(char[],int,int)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#comment(char[],int,int)",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.AbstractStaxHandler#comment(char[],int,int)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLEventReader#getProperty(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "throw IllegalArgumentException for any property",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLEventReader#getProperty(String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "IllegalArgumentException when called",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLEventReader#getProperty(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "This implementation throws an {@code IllegalArgumentException} for any property.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLEventReader",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.AbstractXMLEventReader#getProperty(String)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLReader#getContentHandler()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "ContentHandler retrieval",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLReader#getContentHandler()",
      "head_type": "method",
      "relation": "have",
      "tail": "Return the current content handler",
      "tail_type": "useSampleCode"
    },
    {
      "head": "ContentHandler retrieval",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "Used to get the content handler of the XML reader",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLReader#getContentHandler()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.AbstractXMLReader",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.SimpleNamespaceContext#removeBinding(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "removePrefix",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.SimpleNamespaceContext#removeBinding(String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "prefixNotNull",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.xml.SimpleNamespaceContext#removeBinding(String)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "xmlNamespaceManagement",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.xml.SimpleNamespaceContext#removeBinding(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.SimpleNamespaceContext#removeBinding(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.SimpleNamespaceContext#removeBinding(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.SimpleNamespaceContext#removeBinding(String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.SimpleNamespaceContext",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.StaxEventHandler#getAttributes(Attributes)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "extracting XML attributes",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxEventHandler#getAttributes(Attributes)",
      "head_type": "method",
      "relation": "have",
      "tail": "extracting XML attributes sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "extracting XML attributes sample code",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "private List<Attribute> getAttributes(Attributes attributes) {\n    int attrLength = attributes.getLength();\n    List<Attribute> result = new ArrayList<>(attrLength);\n    for (int i = 0; i < attrLength; i++) {\n        QName attrName = toQName(attributes.getURI(i), attributes.getQName(i));\n        if (!isNamespaceDeclaration(attrName)) {\n            result.add(this.eventFactory.createAttribute(attrName, attributes.getValue(i)));\n        }\n    }\n    return result;\n}",
      "tail_type": "code"
    },
    {
      "head": "org.springframework.util.xml.StaxEventHandler",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.StaxEventHandler#getAttributes(Attributes)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.xml.StaxEventHandler",
      "head_type": "class",
      "relation": "have",
      "tail": "StaxEventHandler class interpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "StaxEventHandler class interpretation",
      "head_type": "relatedConceptInterpretation",
      "relation": "have",
      "tail": "StaxEventHandler is a class in the Spring Framework used for handling XML parsing events. It processes XML data using the StAX (Streaming API for XML) approach, which is a pull-parsing API for XML. This allows for efficient and memory-friendly processing of XML data by handling events such as start elements, end elements, and characters as they occur in the XML stream.",
      "tail_type": "description"
    },
    {
      "head": "org.springframework.util.xml.StaxEventXMLReader#handleDtd(DTD)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "handle DTD",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxEventXMLReader#handleDtd(DTD)",
      "head_type": "method",
      "relation": "have",
      "tail": "private void handleDtd(DTD dtd) throws SAXException {\n    if (getLexicalHandler() != null) {\n        Location location = dtd.getLocation();\n        getLexicalHandler().startDTD(null, location.getPublicId(), location.getSystemId());\n    }\n    if (getLexicalHandler() != null) {\n        getLexicalHandler().endDTD();\n    }\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.StaxEventXMLReader#handleDtd(DTD)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.StaxEventXMLReader",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.StaxEventXMLReader#handleDtd(DTD)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxEventXMLReader#handleDtd(DTD)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamReader#getTextStart()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getTextStart",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamReader#getTextStart()",
      "head_type": "method",
      "relation": "have",
      "tail": "This method returns the start index of the text content.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamReader#getTextStart()",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is used to get the start index of the text content.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamReader#getTextStart()",
      "head_type": "method",
      "relation": "have",
      "tail": "java\npackage org.springframework.util.xml;\n\nimport javax.xml.stream.XMLStreamReader;\nimport javax.xml.stream.events.XMLEvent;\n\npublic class XMLEventStreamReader {\n    // Sample method\n    public int getTextStart() {\n        return 0;\n    }\n}\n",
      "tail_type": "useSampleCode"
    },
    {
      "head": "example.type.SomeComponentInterface",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "unknownFunctionality",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.DefaultGenerationContextTests#getGeneratedFilesReturnsGeneratedFiles()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getGeneratedFiles",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.DefaultGenerationContextTests#getGeneratedFilesReturnsGeneratedFiles()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "DefaultGenerationContext",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.DefaultGenerationContextTests#getGeneratedFilesReturnsGeneratedFiles()",
      "head_type": "method",
      "relation": "have",
      "tail": "void getGeneratedFilesReturnsGeneratedFiles() {    DefaultGenerationContext context = new DefaultGenerationContext(this.generatedClasses, this.generatedFiles, this.runtimeHints);    assertThat(context.getGeneratedFiles()).isSameAs(this.generatedFiles);}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassesTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "generate classes",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassesTests",
      "head_type": "class",
      "relation": "constrained_by",
      "tail": "classNameGenerator must not be null",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassesTests",
      "head_type": "class",
      "relation": "constrained_by",
      "tail": "feature name must not be empty",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassesTests",
      "head_type": "class",
      "relation": "constrained_by",
      "tail": "type spec customizer must not be null",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassesTests",
      "head_type": "class",
      "relation": "applied_to",
      "tail": "generate classes for features",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassesTests",
      "head_type": "class",
      "relation": "applied_to",
      "tail": "generate classes for feature components",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassesTests",
      "head_type": "class",
      "relation": "have",
      "tail": "generate unique names for classes",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassesTests",
      "head_type": "class",
      "relation": "have",
      "tail": "handle naming conventions",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassesTests",
      "head_type": "class",
      "relation": "have",
      "tail": "write generated classes to files",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassesTests",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.GeneratedClasses",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassesTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getOrAddForFeatureComponentWhenRepeatReturnsSameGeneratedClass()",
      "tail_type": "apiFunction"
    },
    {
      "head": "getOrAddForFeatureComponentWhenRepeatReturnsSameGeneratedClass()",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "GeneratedClassesTests.java",
      "tail_type": "useSampleCode"
    },
    {
      "head": "getOrAddForFeatureComponentWhenRepeatReturnsSameGeneratedClass()",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "Ensure that repeated calls to getOrAddForFeatureComponent with the same parameters return the same GeneratedClass instance.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "getOrAddForFeatureComponentWhenRepeatReturnsSameGeneratedClass()",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "Design Principle: Consistency and Efficiency in Object Generation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.InMemoryGeneratedFilesTests#addFileAddsInMemoryFile()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "addResourceFile",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.InMemoryGeneratedFilesTests#addFileAddsInMemoryFile()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getGeneratedFileContent",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.InMemoryGeneratedFilesTests#addFileAddsInMemoryFile()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.InMemoryGeneratedFilesTests",
      "tail_type": "class"
    },
    {
      "head": "addResourceFile",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "addResourceFile useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "getGeneratedFileContent",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "getGeneratedFileContent useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "addResourceFile useSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "package org.springframework.aot.generate; import org.junit.jupiter.api.Test; import static org.assertThat.assertThat; public class InMemoryGeneratedFilesTests { @Test void addFileAddsInMemoryFile() throws Exception { this.generatedFiles.addResourceFile(\"META-INF/test\", \"test\"); assertThat(this.generatedFiles.getGeneratedFileContent(Kind.RESOURCE, \"META-INF/test\")).isEqualTo(\"test\"); } }",
      "tail_type": "String"
    },
    {
      "head": "getGeneratedFileContent useSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "package org.springframework.aot.generate; import org.junit.jupiter.api.Test; import static org.assertThat.assertThat; public class InMemoryGeneratedFilesTests { @Test void addFileAddsInMemoryFile() throws Exception { this.generatedFiles.addResourceFile(\"META-INF/test\", \"test\"); assertThat(this.generatedFiles.getGeneratedFileContent(Kind.RESOURCE, \"META-INF/test\")).isEqualTo(\"test\"); } }",
      "tail_type": "String"
    },
    {
      "head": "org.springframework.aot.generate.InMemoryGeneratedFilesTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getGeneratedFileContentWhenFileIsMissingReturnsNull",
      "tail_type": "apiFunction"
    },
    {
      "head": "getGeneratedFileContentWhenFileIsMissingReturnsNull",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "getGeneratedFileContentWhenFileIsMissingReturnsNull() { this.generatedFiles.addResourceFile(\"META-INF/test\", \"test\"); assertThat(this.generatedFiles.getGeneratedFileContent(Kind.RESOURCE, \"META-INF/missing\")).isNull(); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "getGeneratedFileContentWhenFileIsMissingReturnsNull",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "getGeneratedFileContentWhenFileIsMissingReturnsNull() { this.generatedFiles.addResourceFile(\"META-INF/test\", \"test\"); assertThat(this.generatedFiles.getGeneratedFileContent(Kind.RESOURCE, \"META-INF/missing\")).isNull(); }",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.aot.generate.InMemoryGeneratedFilesTests",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.InMemoryGeneratedFiles",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.InMemoryGeneratedFilesTests",
      "head_type": "class",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.InMemoryGeneratedFilesTests",
      "head_type": "class",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.ExceptionTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "generateWhenUnsupportedValue",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.ExceptionTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "generateWhenUnsupportedDataTypeThrowsException",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.ExceptionTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "generateWhenListOfUnsupportedElement",
      "tail_type": "apiFunction"
    },
    {
      "head": "generateWhenUnsupportedValue",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "generateWhenUnsupportedValue_sampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "generateWhenUnsupportedDataTypeThrowsException",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "generateWhenUnsupportedDataTypeThrowsException_sampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "generateWhenListOfUnsupportedElement",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "generateWhenListOfUnsupportedElement_sampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "generateWhenUnsupportedValue_sampleCode",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "tail": "StringWriter",
      "tail_type": "class"
    },
    {
      "head": "generateWhenUnsupportedValue_sampleCode",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "tail": "ValueCodeGenerationException",
      "tail_type": "class"
    },
    {
      "head": "generateWhenUnsupportedValue_sampleCode",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "tail": "UnsupportedTypeValueCodeGenerationException",
      "tail_type": "class"
    },
    {
      "head": "generateWhenUnsupportedDataTypeThrowsException_sampleCode",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "tail": "StringWriter",
      "tail_type": "class"
    },
    {
      "head": "generateWhenUnsupportedDataTypeThrowsException_sampleCode",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "tail": "ValueCodeGenerationException",
      "tail_type": "class"
    },
    {
      "head": "generateWhenListOfUnsupportedElement_sampleCode",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "tail": "StringWriter",
      "tail_type": "class"
    },
    {
      "head": "generateWhenListOfUnsupportedElement_sampleCode",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "tail": "List",
      "tail_type": "class"
    },
    {
      "head": "generateWhenListOfUnsupportedElement_sampleCode",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "tail": "ValueCodeGenerationException",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.core.type.StandardClassMetadata#getSuperClassName()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getSuperClassName",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.core.type.StandardClassMetadata#getSuperClassName()",
      "head_type": "method",
      "relation": "have",
      "tail": "getSuperClassName returns the name of the superclass for the introspected class",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.core.type.StandardClassMetadata#getSuperClassName()",
      "head_type": "method",
      "relation": "have",
      "tail": "The method checks if the introspected class has a superclass and returns its name if it exists",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.core.type.StandardClassMetadata#getSuperClassName()",
      "head_type": "method",
      "relation": "have",
      "tail": "public String getSuperClassName() {\n    Class<?> superClass = this.introspectedClass.getSuperclass();\n    return (superClass != null ? superClass.getName() : null);\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.core.type.StandardMethodMetadata#getMethodName()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getMethodName",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.core.type.StandardMethodMetadata#getMethodName()",
      "head_type": "method",
      "relation": "have",
      "tail": "getMethodName returns the name of the method",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.core.type.StandardMethodMetadata#getMethodName()",
      "head_type": "method",
      "relation": "have",
      "tail": "StandardMethodMetadata is designed to provide metadata for methods",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.core.type.StandardMethodMetadata#getMethodName()",
      "head_type": "method",
      "relation": "have",
      "tail": "public String getMethodName() { return this.introspectedMethod.getName(); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.core.type.StandardMethodMetadata#getAnnotationAttributes(String,boolean)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getAnnotationAttributes",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.core.type.StandardMethodMetadata#getAnnotationAttributes(String,boolean)",
      "head_type": "method",
      "relation": "have",
      "tail": "getAnnotationAttributes(String,boolean) useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "getAnnotationAttributes(String,boolean) useSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "package com.healthMgr.common.email; import java.xxxx; public class OneClass { // specific code }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.objenesis(SpringObjenesis",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "instance creation via Objenesis",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.objenesis(SpringObjenesis",
      "head_type": "class",
      "relation": "constrained_by",
      "tail": "Objenesis instantiator strategy may not work on all JVMs",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.objenesis(SpringObjenesis",
      "head_type": "class",
      "relation": "applied_to",
      "tail": "creating instances without default constructor",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.objenesis(SpringObjenesis",
      "head_type": "class",
      "relation": "have",
      "tail": " caches ObjectInstantiators based on Class keys",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.objenesis(SpringObjenesis",
      "head_type": "class",
      "relation": "have",
      "tail": " allows selective use of the cache",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.objenesis(SpringObjenesis",
      "head_type": "class",
      "relation": "have",
      "tail": " related to ObjenesisStd and ObjenesisBase",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.objenesis(SpringObjenesis",
      "head_type": "class",
      "relation": "have",
      "tail": " designed to work around JVM limitations with reflection-based instantiation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.objenesis(SpringObjenesis",
      "head_type": "class",
      "relation": "have",
      "tail": " sample code for creating instances with and without cache",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.objenesis(SpringObjenesis",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.objenesis.InstantiatorStrategy",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.objenesis(SpringObjenesis",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.objenesis.ObjectInstantiator",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.ElementFactory",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "createElement",
      "tail_type": "apiFunction"
    },
    {
      "head": "createElement",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "ElementInstantiationException",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ElementFactory",
      "head_type": "class",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ElementFactory",
      "head_type": "class",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ElementFactory",
      "head_type": "class",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.backoff.ExponentialBackOff#getMaxInterval()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "get maximum back off time",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.backoff.ExponentialBackOff#getMaxInterval()",
      "head_type": "method",
      "relation": "have",
      "tail": "Return the maximum back off time in milliseconds.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.backoff.ExponentialBackOff",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.backoff.ExponentialBackOff#getMaxInterval()",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.CollectionUtils#hasUniqueObject(Collection<?>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "check if a collection contains a single unique object",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.CollectionUtils#hasUniqueObject(Collection<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "Determine whether the given Collection only contains a single unique object.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.CollectionUtils#hasUniqueObject(Collection<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "The method returns true if the collection contains a single reference or multiple references to the same instance, and false otherwise.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.CollectionUtils#hasUniqueObject(Collection<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "public static boolean hasUniqueObject(Collection<?> collection) {\n    if (isEmpty(collection)) {\n        return false;\n    }\n    boolean hasCandidate = false;\n    Object candidate = null;\n    for (Object elem : collection) {\n        if (!hasCandidate) {\n            hasCandidate = true;\n            candidate = elem;\n        } else if (candidate != elem) {\n            return false;\n        }\n    }\n    return true;\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.comparator.InstanceComparator",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "compare objects based on class order",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.comparator.InstanceComparator",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "sort objects based on class inheritance",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.comparator.InstanceComparator",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "prioritize objects based on class order",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.comparator.InstanceComparator",
      "head_type": "class",
      "relation": "constrained_by",
      "tail": "only specified classes in instanceOrder are considered",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.comparator.InstanceComparator",
      "head_type": "class",
      "relation": "applied_to",
      "tail": "sort a list of objects with mixed types",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.comparator.InstanceComparator",
      "head_type": "class",
      "relation": "have",
      "tail": "sample code for sorting objects",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.comparator.InstanceComparator",
      "head_type": "class",
      "relation": "have",
      "tail": "related concept interpretation for sorting",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.comparator.InstanceComparator",
      "head_type": "class",
      "relation": "have",
      "tail": "design principle interpretation for comparator",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "compare objects based on class order",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "org.springframework.util.comparator.InstanceComparator",
      "tail_type": "class"
    },
    {
      "head": "sort objects based on class inheritance",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "org.springframework.util.comparator.InstanceComparator",
      "tail_type": "class"
    },
    {
      "head": "prioritize objects based on class order",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "org.springframework.util.comparator.InstanceComparator",
      "tail_type": "class"
    },
    {
      "head": "only specified classes in instanceOrder are considered",
      "head_type": "useConstraint",
      "relation": "associated_with",
      "tail": "org.springframework.util.comparator.InstanceComparator",
      "tail_type": "class"
    },
    {
      "head": "sort a list of objects with mixed types",
      "head_type": "useScenario",
      "relation": "associated_with",
      "tail": "org.springframework.util.comparator.InstanceComparator",
      "tail_type": "class"
    },
    {
      "head": "sample code for sorting objects",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "tail": "org.springframework.util.comparator.InstanceComparator",
      "tail_type": "class"
    },
    {
      "head": "related concept interpretation for sorting",
      "head_type": "relatedConceptInterpretation",
      "relation": "associated_with",
      "tail": "org.springframework.util.comparator.InstanceComparator",
      "tail_type": "class"
    },
    {
      "head": "design principle interpretation for comparator",
      "head_type": "designPrincipleInterpretation",
      "relation": "associated_with",
      "tail": "org.springframework.util.comparator.InstanceComparator",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.CompositeCollection#containsAll(Collection<?>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "check collection inclusion",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.CompositeCollection#containsAll(Collection<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "Iterates over each object in the provided collection to verify its presence in the main collection.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.CompositeCollection#containsAll(Collection<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "Returns true only if all objects in the provided collection are present in the main collection.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.CompositeCollection#containsAll(Collection<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "package com.example.collectiondemo;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\n\npublic class CollectionInclusionCheck {\n    public static void main(String[] args) {\n        List<Integer> mainCollection = new ArrayList<>();\n        mainCollection.add(1);\n        mainCollection.add(2);\n        mainCollection.add(3);\n\n        Collection<Integer> checkCollection = new ArrayList<>();\n        checkCollection.add(1);\n        checkCollection.add(2);\n\n        boolean containsAll = mainCollection.containsAll(checkCollection);\n        System.out.println(\"Contains all: \" + containsAll);\n    }\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.CompositeIterator#hasNext()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "checkNextElementAvailability",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.CompositeIterator#hasNext()",
      "head_type": "method",
      "relation": "have",
      "tail": "Iterates over multiple iterators to determine if any iterator has a next element",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.CompositeIterator#hasNext()",
      "head_type": "method",
      "relation": "have",
      "tail": "Design principle: The method follows the principle of composite design, allowing it to work with multiple iterators as a single iterator",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.CompositeIterator#hasNext()",
      "head_type": "method",
      "relation": "have",
      "tail": "package com.example.demo; import java.util.Iterator; import java.util.List; public class Main { public static void main(String[] args) { List<String> list1 = List.of(\"a\", \"b\", \"c\"); List<String> list2 = List.of(\"d\", \"e\"); Iterator<String> iterator1 = list1.iterator(); Iterator<String> iterator2 = list2.iterator(); CompositeIterator<String> compositeIterator = new CompositeIterator<>(List.of(iterator1, iterator2)); while (compositeIterator.hasNext()) { System.out.println(compositeIterator.next()); } } }",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "adapt a Future parameterized over S into a Future parameterized over T",
      "head_type": "class",
      "relation": "haveFunction",
      "head": "org.springframework.util.concurrent.FutureAdapter",
      "tail_type": "apiFunction"
    },
    {
      "tail": "Delegate must not be null",
      "head_type": "class",
      "relation": "constrained_by",
      "head": "org.springframework.util.concurrent.FutureAdapter",
      "tail_type": "useConstraint"
    },
    {
      "tail": "all methods are delegated to the adaptee",
      "head_type": "class",
      "relation": "applied_to",
      "head": "org.springframework.util.concurrent.FutureAdapter",
      "tail_type": "useScenario"
    },
    {
      "tail": "sample code for using FutureAdapter",
      "head_type": "class",
      "relation": "have",
      "head": "org.springframework.util.concurrent.FutureAdapter",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "related concept interpretation for FutureAdapter",
      "head_type": "class",
      "relation": "have",
      "head": "org.springframework.util.concurrent.FutureAdapter",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "tail": "design principle interpretation for FutureAdapter",
      "head_type": "class",
      "relation": "have",
      "head": "org.springframework.util.concurrent.FutureAdapter",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "tail": "Future",
      "head_type": "class",
      "relation": "associated_with",
      "head": "org.springframework.util.concurrent.FutureAdapter",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.concurrent.FutureAdapter#get()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "adaptInternal",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.concurrent.FutureAdapter#get()",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "InterruptedException",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.concurrent.FutureAdapter#get()",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "ExecutionException",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.concurrent.FutureAdapter#get()",
      "head_type": "method",
      "relation": "have",
      "tail": "adaptInternal(this.adaptee.get())",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.concurrent.FutureAdapter",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.concurrent.FutureAdapter#get()",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.concurrent.FutureAdapter",
      "head_type": "class",
      "relation": "have",
      "tail": "FutureAdapter is a class that adapts a Future to another type.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.concurrent.FutureAdapter",
      "head_type": "class",
      "relation": "have",
      "tail": "FutureAdapter is designed to bridge different Future implementations.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ConcurrentLruCache#contains(K)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "checkKeyPresence",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ConcurrentLruCache#contains(K)",
      "head_type": "method",
      "relation": "have",
      "tail": "checkKeyPresenceDescription",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ConcurrentLruCache#contains(K)",
      "head_type": "method",
      "relation": "have",
      "tail": "concurrentLruCacheUsageSample",
      "tail_type": "useSampleCode"
    },
    {
      "head": "checkKeyPresence",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "keyPresenceCheckScenario",
      "tail_type": "useScenario"
    },
    {
      "head": "checkKeyPresence",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "keyTypeConstraint",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ConcurrentLruCache",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.ConcurrentLruCache#contains(K)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.ConcurrentLruCache",
      "head_type": "class",
      "relation": "have",
      "tail": "concurrentLruCacheDesignPrinciple",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.Entries#add(V)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "addEntry",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.Entries#add(V)",
      "head_type": "method",
      "relation": "have",
      "tail": "Add a new entry with the specified value.",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.Entries#add(V)",
      "head_type": "method",
      "relation": "have",
      "tail": "The method allows adding a new entry with a specified value to the collection or data structure.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.Entries#add(V)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method follows the design principle of encapsulation, ensuring that the internal representation of the data is hidden from the outside and only accessible through well-defined interfaces.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.DigestUtils#md5DigestAsHex(InputStream)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "MD5 digest calculation",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.DigestUtils#md5DigestAsHex(InputStream)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "Does not close the input stream",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.DigestUtils#md5DigestAsHex(InputStream)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "Calculating digest over an InputStream",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.DigestUtils#md5DigestAsHex(InputStream)",
      "head_type": "method",
      "relation": "have",
      "tail": "Return a hexadecimal string representation of the MD5 digest of the given stream.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.DigestUtils#md5DigestAsHex(InputStream)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method provides a way to generate a hexadecimal string representation of the MD5 digest for a given input stream. It is commonly used for generating hashes for data, such as files or strings, in a human-readable format.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.DigestUtils#md5DigestAsHex(InputStream)",
      "head_type": "method",
      "relation": "have",
      "tail": "import java.io.IOException;\nimport java.io.InputStream;\nimport org.springframework.util.DigestUtils;\n\npublic class MD5DigestExample {\n    public static void main(String[] args) throws IOException {\n        String data = \"Example data\";\n        InputStream inputStream = new java.io.ByteArrayInputStream(data.getBytes());\n        String md5Hex = DigestUtils.md5DigestAsHex(inputStream);\n        System.out.println(\"MD5 Hex: \" + md5Hex);\n    }\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.FileCopyUtils#copy(String,Writer)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "copy contents of a String to a Writer",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.FileCopyUtils#copy(String,Writer)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "IOException in case of I/O errors",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.FileCopyUtils#copy(String,Writer)",
      "head_type": "method",
      "relation": "have",
      "tail": "Copy the contents of the given String to the given Writer. Closes the writer when done.",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.FileCopyUtils#copy(String,Writer)",
      "head_type": "method",
      "relation": "have",
      "tail": "public static void copy(String in, Writer out) throws IOException { Assert.notNull(in, \"No input String specified\"); Assert.notNull(out, \"No Writer specified\"); try { out.write(in); } finally { close(out); } }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.FileCopyUtils#copy(String,Writer)",
      "head_type": "method",
      "relation": "have",
      "tail": "The method ensures that the writer is closed after the operation, preventing resource leaks.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.FileCopyUtils#copy(String,Writer)",
      "head_type": "method",
      "relation": "have",
      "tail": "The design principle followed here is to handle resources efficiently by ensuring proper closure of the Writer, adhering to the 'close resources' best practice.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.function.ThrowingSupplier#of(ThrowingSupplier<T>,BiFunction<String,Exception,RuntimeException>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "create ThrowingSupplier",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.function.ThrowingSupplier#of(ThrowingSupplier<T>,BiFunction<String,Exception,RuntimeException>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "must use exceptionWrapper",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.function.ThrowingSupplier#of(ThrowingSupplier<T>,BiFunction<String,Exception,RuntimeException>)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "method references",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.function.ThrowingSupplier#of(ThrowingSupplier<T>,BiFunction<String,Exception,RuntimeException>)",
      "head_type": "method",
      "relation": "have",
      "tail": "optional.orElseGet(ThrowingSupplier.of(Example::methodThatCanThrowCheckedException, IllegalStateException::new))",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.function.ThrowingSupplier#of(ThrowingSupplier<T>,BiFunction<String,Exception,RuntimeException>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.function.ThrowingSupplier",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.function.ThrowingSupplier#of(ThrowingSupplier<T>,BiFunction<String,Exception,RuntimeException>)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method can be especially useful when working with method references. It allows you to easily convert a method that throws a checked exception into an instance compatible with a regular Supplier.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.function.ThrowingSupplier#of(ThrowingSupplier<T>,BiFunction<String,Exception,RuntimeException>)",
      "head_type": "method",
      "relation": "have",
      "tail": "The design principle behind this method is to provide a convenient way to handle checked exceptions in a functional programming context, making it easier to work with lambda expressions and method references.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.LinkedCaseInsensitiveMap#computeIfAbsent(String,Function<? super String,? extends V>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "computeIfAbsent",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.LinkedCaseInsensitiveMap#computeIfAbsent(String,Function<? super String,? extends V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "computeIfAbsent(String,Function<? super String,? extends V>)",
      "tail_type": "useSampleCode"
    },
    {
      "head": "computeIfAbsent(String,Function<? super String,? extends V>)",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "tail": "org.springframework.util.LinkedCaseInsensitiveMap",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.LinkedCaseInsensitiveMap",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "computeIfAbsent",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.LinkedCaseInsensitiveMap",
      "head_type": "class",
      "relation": "have",
      "tail": "LinkedCaseInsensitiveMap",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "LinkedCaseInsensitiveMap",
      "head_type": "relatedConceptInterpretation",
      "relation": "designPrincipleInterpretation",
      "tail": "Case Insensitivity and Key Mapping",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.LinkedCaseInsensitiveMap#forEach(BiConsumer<? super String,? super V>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "forEach",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.LinkedCaseInsensitiveMap#forEach(BiConsumer<? super String,? super V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "Iterates over each entry in the map",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.LinkedCaseInsensitiveMap#forEach(BiConsumer<? super String,? super V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "public void forEach(BiConsumer<? super String, ? super V> action) { this.targetMap.forEach(action); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.LinkedCaseInsensitiveMap#forEach(BiConsumer<? super String,? super V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "Delegate iteration to the targetMap",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.MultiValueMap#addIfAbsent(K,V)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "addIfAbsent",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MultiValueMap#addIfAbsent(K,V)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "key presence check",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.MultiValueMap#addIfAbsent(K,V)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "unique key-value pair addition",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.MultiValueMap#addIfAbsent(K,V)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for addIfAbsent",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.MultiValueMap#addIfAbsent(K,V)",
      "head_type": "method",
      "relation": "have",
      "tail": "MultiValueMap explanation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.MultiValueMap#addIfAbsent(K,V)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle behind addIfAbsent",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.MultiValueMap#addIfAbsent(K,V)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.MultiValueMap",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.MultiValueMap#toSingleValueMap()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "convert multi-value map to single-value map",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MultiValueMap#toSingleValueMap()",
      "head_type": "method",
      "relation": "have",
      "tail": "Return a Map with the first values contained in this MultiValueMap",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.MultiValueMap#toSingleValueMap()",
      "head_type": "method",
      "relation": "have",
      "tail": "The difference between this method and asSingleValueMap() is that this method returns a copy of the entries of this map, whereas the latter returns a view.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.MultiValueMap#toSingleValueMap()",
      "head_type": "method",
      "relation": "have",
      "tail": "Ensure data integrity by providing a snapshot of the current state of the MultiValueMap",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.MultiValueMap#toSingleValueMap()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.MultiValueMap",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.MultiValueMap#toSingleValueMap()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "asSingleValueMap()",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.ObjectUtils#containsElement(Object[],Object)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "check whether the given array contains the given element",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ObjectUtils#containsElement(Object[],Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "Check whether the given array contains the given element.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ObjectUtils#containsElement(Object[],Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "The method checks if an array contains a specific element. It returns true if the element is found, otherwise false.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ObjectUtils#containsElement(Object[],Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "public static boolean containsElement(@Nullable Object @Nullable [] array, @Nullable Object element) {\n    if (array == null) {\n        return false;\n    }\n    for (Object arrayEle : array) {\n        if (nullSafeEquals(arrayEle, element)) {\n            return true;\n        }\n    }\n    return false;\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeHash(Object)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "hashing elements",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeHash(Object)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "elements can be null",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeHash(Object)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "hashing arrays and objects",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeHash(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "complete sample code for nullSafeHash",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeHash(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "related concept interpretation for nullSafeHash",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeHash(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle interpretation for nullSafeHash",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeHash(Object)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.ObjectUtils",
      "tail_type": "class"
    },
    {
      "head": "hashing elements",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "related concept interpretation for hashing elements",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "hashing elements",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "design principle interpretation for hashing elements",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "elements can be null",
      "head_type": "useConstraint",
      "relation": "have",
      "tail": "related concept interpretation for elements can be null",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "elements can be null",
      "head_type": "useConstraint",
      "relation": "have",
      "tail": "design principle interpretation for elements can be null",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "hashing arrays and objects",
      "head_type": "useScenario",
      "relation": "have",
      "tail": "related concept interpretation for hashing arrays and objects",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "hashing arrays and objects",
      "head_type": "useScenario",
      "relation": "have",
      "tail": "design principle interpretation for hashing arrays and objects",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ObjectUtils#getIdentityHexString(Object)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "hex string conversion",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ObjectUtils#getIdentityHexString(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "Return a hex String form of an object's identity hash code.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ObjectUtils#getIdentityHexString(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "Converts an object's identity hash code into a hexadecimal string representation.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ObjectUtils#getIdentityHexString(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "public static String getIdentityHexString(Object obj) {\n    return Integer.toHexString(System.identityHashCode(obj));\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.PartResolutionContext",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "resolvePlaceholder",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.PartResolutionContext",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "handleUnresolvablePlaceholder",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.PartResolutionContext",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "parse",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.PartResolutionContext",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "flagPlaceholderAsVisited",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.PartResolutionContext",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "removePlaceholder",
      "tail_type": "apiFunction"
    },
    {
      "head": "resolvePlaceholder",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "ignoreUnresolvablePlaceholders",
      "tail_type": "useConstraint"
    },
    {
      "head": "handleUnresolvablePlaceholder",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "ignoreUnresolvablePlaceholders",
      "tail_type": "useConstraint"
    },
    {
      "head": "flagPlaceholderAsVisited",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "visitedPlaceholders",
      "tail_type": "useConstraint"
    },
    {
      "head": "removePlaceholder",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "visitedPlaceholders",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.PartResolutionContext",
      "head_type": "class",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.PartResolutionContext",
      "head_type": "class",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.PartResolutionContext",
      "head_type": "class",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#doWithFields(Class<?>,FieldCallback,FieldFilter)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "introspection",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#doWithFields(Class<?>,FieldCallback,FieldFilter)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "field callback invocation",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#doWithFields(Class<?>,FieldCallback,FieldFilter)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "field filtering",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#doWithFields(Class<?>,FieldCallback,FieldFilter)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "IllegalStateException on introspection failure",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#doWithFields(Class<?>,FieldCallback,FieldFilter)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "class hierarchy traversal",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#doWithFields(Class<?>,FieldCallback,FieldFilter)",
      "head_type": "method",
      "relation": "have",
      "tail": "class hierarchy traversal",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#doWithFields(Class<?>,FieldCallback,FieldFilter)",
      "head_type": "method",
      "relation": "have",
      "tail": "field callback invocation",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#doWithFields(Class<?>,FieldCallback,FieldFilter)",
      "head_type": "method",
      "relation": "have",
      "tail": "field filtering",
      "tail_type": "useScenario"
    },
    {
      "head": "introspection",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "introspection",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "field callback invocation",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "field callback invocation",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "field filtering",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "field filtering",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "class hierarchy traversal",
      "head_type": "useScenario",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "field callback invocation",
      "head_type": "useScenario",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "field filtering",
      "head_type": "useScenario",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "introspection",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ResizableByteArrayOutputStream",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "resize",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ResizableByteArrayOutputStream",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "grow",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ResizableByteArrayOutputStream",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "capacity",
      "tail_type": "apiFunction"
    },
    {
      "head": "resize",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "IllegalArgumentException if the given capacity is smaller than the actual size of the content stored in the buffer already",
      "tail_type": "useConstraint"
    },
    {
      "head": "grow",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "Additional capacity must be 0 or higher",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ResizableByteArrayOutputStream",
      "head_type": "class",
      "relation": "have",
      "tail": "has public grow and resize methods to get more control over the size of the internal buffer",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ResizableByteArrayOutputStream",
      "head_type": "class",
      "relation": "have",
      "tail": "has a higher initial capacity (256) by default",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ResizableByteArrayOutputStream",
      "head_type": "class",
      "relation": "have",
      "tail": "An extension of java.io.ByteArrayOutputStream",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ResizableByteArrayOutputStream",
      "head_type": "class",
      "relation": "have",
      "tail": "As of 4.2, this class has been superseded by FastByteArrayOutputStream for Spring's internal use where no assignability to ByteArrayOutputStream is needed (since FastByteArrayOutputStream is more efficient with buffer resize management but doesn't extend the standard ByteArrayOutputStream)",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ResizableByteArrayOutputStream",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "java.io.ByteArrayOutputStream",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.ResizableByteArrayOutputStream",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "FastByteArrayOutputStream",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.Route#value()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getOriginalRouteValue",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.Route#value()",
      "head_type": "method",
      "relation": "have",
      "tail": "The original route value.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.SimpleRouteMatcher",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "routeParsing",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.SimpleRouteMatcher",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "patternMatching",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.SimpleRouteMatcher",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "patternCombining",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.SimpleRouteMatcher",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "routeMatching",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.SimpleRouteMatcher",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "variableExtraction",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.SimpleRouteMatcher",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "patternComparison",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.SimpleRouteMatcher",
      "head_type": "class",
      "relation": "constrained_by",
      "tail": "performanceConsideration",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.SimpleRouteMatcher",
      "head_type": "class",
      "relation": "applied_to",
      "tail": "webApplications",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.SimpleRouteMatcher",
      "head_type": "class",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.SimpleRouteMatcher",
      "head_type": "class",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.SimpleRouteMatcher",
      "head_type": "class",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.SimpleRouteMatcher",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.PathMatcher",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.SimpleRouteMatcher",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.web.util.PathPatternRouteMatcher",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.StreamUtils#drain(InputStream)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "drain the remaining content of the given InputStream",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StreamUtils#drain(InputStream)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "Leaves the InputStream open when done",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.StreamUtils#drain(InputStream)",
      "head_type": "method",
      "relation": "have",
      "tail": "Drain the remaining content of the given InputStream",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.StreamUtils#drain(InputStream)",
      "head_type": "method",
      "relation": "have",
      "tail": "InputStream operations",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.StreamUtils#drain(InputStream)",
      "head_type": "method",
      "relation": "have",
      "tail": "public static int drain(@Nullable InputStream in) throws IOException {\n    if (in == null) {\n        return 0;\n    }\n    return (int) in.transferTo(OutputStream.nullOutputStream());\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.StringUtils#endsWithIgnoreCase(String,String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "case-insensitive string ending check",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils#endsWithIgnoreCase(String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "relatedConceptInterpretation",
      "head_type": "relatedConceptInterpretation",
      "relation": "associated_with",
      "tail": "case-insensitive string comparison",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.StringUtils#endsWithIgnoreCase(String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "designPrincipleInterpretation",
      "head_type": "designPrincipleInterpretation",
      "relation": "associated_with",
      "tail": "string manipulation utilities",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.StringUtils#endsWithIgnoreCase(String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "useSampleCode",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "tail": "complete example of using endsWithIgnoreCase method",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.StringUtils#replace(String,String,String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "replaceSubstring",
      "tail_type": "apiFunction"
    },
    {
      "head": "replaceSubstring",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "replace all occurrences of a substring within a string with another string",
      "tail_type": "useSampleCode"
    },
    {
      "head": "replaceSubstring",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "The method replaces all occurrences of a specified substring ('oldPattern') within a given string ('inString') with a new substring ('newPattern'). It checks for the presence of 'oldPattern' in 'inString'. If found, it replaces all occurrences and constructs the new string using a StringBuilder for efficiency. If 'oldPattern' is not found or 'newPattern' is null, it returns the original 'inString'.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "replaceSubstring",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "This method is designed to efficiently handle string replacements by utilizing a StringBuilder to construct the new string. It iterates through the input string, appending parts of the original string and the new pattern as it encounters matches. This approach minimizes the number of string concatenations, thus optimizing performance for cases with multiple replacements.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.StringUtils",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.StringUtils#replace(String,String,String)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.TypeUtils#isAssignableBound(Type,Type)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "Type Assignability Check",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.TypeUtils#isAssignableBound(Type,Type)",
      "head_type": "method",
      "relation": "have",
      "tail": "Checks if one type is assignable from another type considering type bounds.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.TypeUtils#isAssignableBound(Type,Type)",
      "head_type": "method",
      "relation": "have",
      "tail": "public static boolean isAssignableBound(@Nullable Type lhsType, @Nullable Type rhsType) {\n    if (rhsType == null) {\n        return true;\n    }\n    if (lhsType == null) {\n        return false;\n    }\n    return isAssignable(lhsType, rhsType);\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.TypeUtils#isAssignableBound(Type,Type)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is used to determine if one type can be safely assigned to another type, taking into account generic type bounds.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#keySet()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "lazy init",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#keySet()",
      "head_type": "method",
      "relation": "have",
      "tail": "lazy init",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#keySet()",
      "head_type": "method",
      "relation": "have",
      "tail": "public Set<K> keySet() { if (this.keySet == null) { this.keySet = Collections.unmodifiableSet(this.delegate.keySet()); } return this.keySet; }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySet#containsAll(Collection<?>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "check subset",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySet#containsAll(Collection<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.UnmodifiableEntrySet#containsAll(Collection<?>)",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySet#containsAll(Collection<?>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.UnmodifiableEntrySet",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueSpliterator#hasCharacteristics(int)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "characteristic checking",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueSpliterator#hasCharacteristics(int)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.UnmodifiableValueSpliterator",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueSpliterator",
      "head_type": "class",
      "relation": "have",
      "tail": "org.springframework.util.UnmodifiableValueSpliterator#hasCharacteristics(int) characteristic checking",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#characters(char[],int,int)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "handle characters in XML",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#characters(char[],int,int)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "must handle SAXException",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#characters(char[],int,int)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "parsing XML content",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#characters(char[],int,int)",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#characters(char[],int,int)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#characters(char[],int,int)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler#characters(char[],int,int)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.AbstractStaxHandler",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxXMLReader#parse(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "parse XML using StAX",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxXMLReader#parse(String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "system identifier is ignored",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxXMLReader#parse(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "system identifier is not read, but ignored",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxXMLReader#parse(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxXMLReader#parse(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxXMLReader#parse(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxXMLReader",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.AbstractStaxXMLReader#parse(String)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.xml.StaxEventHandler",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "Construct a new instance of StaxEventHandler",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxEventHandler",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "Construct a new instance of StaxEventHandler with event factory",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxEventHandler",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "Set document locator",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxEventHandler",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "Start document internal",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxEventHandler",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "End document internal",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxEventHandler",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "Start element internal",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxEventHandler",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "End element internal",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxEventHandler",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "Characters internal",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxEventHandler",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "CData internal",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxEventHandler",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "Ignorable whitespace internal",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxEventHandler",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "Processing instruction internal",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxEventHandler",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "Dtd internal",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxEventHandler",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "Comment internal",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxEventHandler",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "Skipped entity internal",
      "tail_type": "apiFunction"
    },
    {
      "head": "Construct a new instance of StaxEventHandler",
      "head_type": "apiFunction",
      "relation": "useSampleCode",
      "tail": "public StaxEventHandler(XMLEventWriter eventWriter) { this.eventFactory = XMLEventFactory.newInstance(); this.eventWriter = eventWriter; }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "Construct a new instance of StaxEventHandler with event factory",
      "head_type": "apiFunction",
      "relation": "useSampleCode",
      "tail": "public StaxEventHandler(XMLEventWriter eventWriter, XMLEventFactory factory) { this.eventFactory = factory; this.eventWriter = eventWriter; }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "Set document locator",
      "head_type": "apiFunction",
      "relation": "useSampleCode",
      "tail": "public void setDocumentLocator(@Nullable Locator locator) { if (locator != null) { this.eventFactory.setLocation(new LocatorLocationAdapter(locator)); } }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "Start document internal",
      "head_type": "apiFunction",
      "relation": "useSampleCode",
      "tail": "protected void startDocumentInternal() throws XMLStreamException { this.eventWriter.add(this.eventFactory.createStartDocument()); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "End document internal",
      "head_type": "apiFunction",
      "relation": "useSampleCode",
      "tail": "protected void endDocumentInternal() throws XMLStreamException { this.eventWriter.add(this.eventFactory.createEndDocument()); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "Start element internal",
      "head_type": "apiFunction",
      "relation": "useSampleCode",
      "tail": "protected void startElementInternal(QName name, Attributes atts, Map<String, String> namespaceMapping) throws XMLStreamException { List<Attribute> attributes = getAttributes(atts); List<Namespace> namespaces = getNamespaces(namespaceMapping); this.eventWriter.add(this.eventFactory.createStartElement(name, attributes.iterator(), namespaces.iterator())); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "End element internal",
      "head_type": "apiFunction",
      "relation": "useSampleCode",
      "tail": "protected void endElementInternal(QName name, Map<String, String> namespaceMapping) throws XMLStreamException { List<Namespace> namespaces = getNamespaces(namespaceMapping); this.eventWriter.add(this.eventFactory.createEndElement(name, namespaces.iterator())); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "Characters internal",
      "head_type": "apiFunction",
      "relation": "useSampleCode",
      "tail": "protected void charactersInternal(String data) throws XMLStreamException { this.eventWriter.add(this.eventFactory.createCharacters(data)); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "CData internal",
      "head_type": "apiFunction",
      "relation": "useSampleCode",
      "tail": "protected void cDataInternal(String data) throws XMLStreamException { this.eventWriter.add(this.eventFactory.createCData(data)); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "Ignorable whitespace internal",
      "head_type": "apiFunction",
      "relation": "useSampleCode",
      "tail": "protected void ignorableWhitespaceInternal(String data) throws XMLStreamException { this.eventWriter.add(this.eventFactory.createIgnorableSpace(data)); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "Processing instruction internal",
      "head_type": "apiFunction",
      "relation": "useSampleCode",
      "tail": "protected void processingInstructionInternal(String target, String data) throws XMLStreamException { this.eventWriter.add(this.eventFactory.createProcessingInstruction(target, data)); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "Dtd internal",
      "head_type": "apiFunction",
      "relation": "useSampleCode",
      "tail": "protected void dtdInternal(String dtd) throws XMLStreamException { this.eventWriter.add(this.eventFactory.createDTD(dtd)); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "Comment internal",
      "head_type": "apiFunction",
      "relation": "useSampleCode",
      "tail": "protected void commentInternal(String comment) throws XMLStreamException { this.eventWriter.add(this.eventFactory.createComment(comment)); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "Skipped entity internal",
      "head_type": "apiFunction",
      "relation": "useSampleCode",
      "tail": "protected void skippedEntityInternal(String name);",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.StaxEventHandler",
      "head_type": "class",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxEventHandler",
      "head_type": "class",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "relatedConceptInterpretation",
      "head_type": "relatedConceptInterpretation",
      "relation": "associated_with",
      "tail": "SAX ContentHandler and LexicalHandler",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "designPrincipleInterpretation",
      "head_type": "designPrincipleInterpretation",
      "relation": "associated_with",
      "tail": "Author: Arjen Poutsma, Since: 4.0.3",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxEventXMLReader#handleEndDocument()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "handleEndDocument",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxEventXMLReader#handleEndDocument()",
      "head_type": "method",
      "relation": "have",
      "tail": "handleEndDocument sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "handleEndDocument sample code",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "private void handleEndDocument() throws SAXException {\n    if (getContentHandler() != null) {\n        getContentHandler().endDocument();\n    }\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.StaxSource#getXMLEventReader()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "apiFunction",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxSource#getXMLEventReader()",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.StaxSource",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.StaxSource#getXMLEventReader()",
      "tail_type": "method"
    },
    {
      "head": "apiFunction",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "apiFunction",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamHandler#commentInternal(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "writeComment",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamHandler#commentInternal(String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.StaxStreamHandler",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamHandler#commentInternal(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils#createEventStreamWriter(XMLEventWriter)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "create XMLStreamWriter from XMLEventWriter",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils#createEventStreamWriter(XMLEventWriter)",
      "head_type": "method",
      "relation": "have",
      "tail": "Return a XMLStreamWriter that writes to a XMLEventWriter",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils#createEventStreamWriter(XMLEventWriter)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "XMLStreamWriter",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils#createEventStreamWriter(XMLEventWriter)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "XMLEventWriter",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils#createEventStreamWriter(XMLEventWriter)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method creates an XMLStreamWriter instance that outputs to an XMLEventWriter. It's useful for integrating XML stream writing capabilities in applications that primarily use the XMLEventWriter API.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxUtils#createEventStreamWriter(XMLEventWriter)",
      "head_type": "method",
      "relation": "have",
      "tail": "The design principle behind this method is to provide flexibility and convenience in XML processing by bridging the gap between XMLStreamWriter and XMLEventWriter. This promotes code reuse and simplifies the integration of different XML processing libraries.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "example.type.AspectJTypeFilterTestsTypes",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "standalone set of types",
      "tail_type": "apiFunction"
    },
    {
      "head": "example.type.AspectJTypeFilterTestsTypes",
      "head_type": "class",
      "relation": "constrained_by",
      "tail": "no interference from other loaded types",
      "tail_type": "useConstraint"
    },
    {
      "head": "example.type.AspectJTypeFilterTestsTypes",
      "head_type": "class",
      "relation": "applied_to",
      "tail": "ensuring no interference with class loading assertions",
      "tail_type": "useScenario"
    },
    {
      "head": "example.type.AspectJTypeFilterTestsTypes",
      "head_type": "class",
      "relation": "have",
      "tail": "org.springframework.core.type.ClassloadingAssertions#assertClassNotLoaded(String)",
      "tail_type": "useSampleCode"
    },
    {
      "head": "example.type.AspectJTypeFilterTestsTypes",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.core.type.AspectJTypeFilterTests",
      "tail_type": "class"
    },
    {
      "head": "example.type.AspectJTypeFilterTestsTypes",
      "head_type": "class",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "example.type.AspectJTypeFilterTestsTypes",
      "head_type": "class",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#forMemberWhenPublicClassWithPackagePrivateArrayComponent()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "Access Control",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#forMemberWhenPublicClassWithPackagePrivateArrayComponent()",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.aot.generate.AccessControlTests#forMemberWhenPublicClassWithPackagePrivateArrayComponent() Sample Code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#forMemberWhenPublicClassWithPackagePrivateArrayComponent() Sample Code",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "org.springframework.aot.generate.AccessControlTests#forMemberWhenPublicClassWithPackagePrivateArrayComponent() Code Content",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#forMemberWhenPublicClassWithPackagePrivateArrayComponent()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.AccessControl",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#forMemberWhenPublicClassWithPackagePrivateArrayComponent()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.PublicClass",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#forResolvableTypeWhenRecursiveType()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "forResolvableTypeWhenRecursiveType",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#forResolvableTypeWhenRecursiveType()",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.aot.generate.AccessControlTests#forResolvableTypeWhenRecursiveType() Sample Code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#forResolvableTypeWhenRecursiveType() Sample Code",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "Complete Example Code for forResolvableTypeWhenRecursiveType Method",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#forResolvableTypeWhenRecursiveType()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.AccessControl",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#forResolvableTypeWhenRecursiveType()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.ResolvableType",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#forResolvableTypeWhenRecursiveType()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.SelfReference",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#forResolvableTypeWhenRecursiveType()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.Visibility",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#toCodeBlockWithStaticMethodRequiresDeclaringClass()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "generate code block",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#toCodeBlockWithStaticMethodRequiresDeclaringClass()",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "static method requires declaring class",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#toCodeBlockWithStaticMethodRequiresDeclaringClass()",
      "head_type": "method",
      "relation": "have",
      "tail": "void toCodeBlockWithStaticMethodRequiresDeclaringClass() {\n    MethodSpec method = createTestMethod(\"methodName\", new TypeName[0], Modifier.STATIC);\n    MethodReference methodReference = new DefaultMethodReference(method, null);\n    assertThatIllegalStateException().isThrownBy(methodReference::toCodeBlock).withMessage(\"Static method reference must define a declaring class\");\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#toCodeBlockWithStaticMethodRequiresDeclaringClass()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.DefaultMethodReferenceTests",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#toCodeBlockWithStaticMethodRequiresDeclaringClass()",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#toCodeBlockWithStaticMethodRequiresDeclaringClass()",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithNullDeclaringClassAndNullTargetClass()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "toInvokeCodeBlockWithNullDeclaringClassAndNullTargetClass",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithNullDeclaringClassAndNullTargetClass()",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "useSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithNullDeclaringClassAndNullTargetClass()",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.FileSystemGeneratedFilesTests#addFilesWithCustomRootsCopiesToFileSystem()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "fileSystemOperation",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.FileSystemGeneratedFilesTests#addFilesWithCustomRootsCopiesToFileSystem()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "fileContentVerification",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.FileSystemGeneratedFilesTests#addFilesWithCustomRootsCopiesToFileSystem()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "customRootHandling",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.FileSystemGeneratedFilesTests#addFilesWithCustomRootsCopiesToFileSystem()",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "useSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "completeExample",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.FileSystemGeneratedFilesTests#addFilesWithCustomRootsCopiesToFileSystem()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "FileSystemGeneratedFiles",
      "tail_type": "class"
    },
    {
      "head": "FileSystemGeneratedFiles",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "fileSystemOperation",
      "tail_type": "apiFunction"
    },
    {
      "head": "FileSystemGeneratedFiles",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "customRootHandling",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.FileSystemGeneratedFilesTests#addFilesWithCustomRootsCopiesToFileSystem()",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "relatedConceptInterpretation",
      "head_type": "relatedConceptInterpretation",
      "relation": "have",
      "tail": "fileSystemGeneratedFilesConcept",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.FileSystemGeneratedFilesTests#addFilesWithCustomRootsCopiesToFileSystem()",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "designPrincipleInterpretation",
      "head_type": "designPrincipleInterpretation",
      "relation": "have",
      "tail": "flexibilityAndCustomizationPrinciple",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests#assertThatFileAdded(Kind,String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "assert file added",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests#assertThatFileAdded(Kind,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "GeneratedFilesTests related concept interpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests#assertThatFileAdded(Kind,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "GeneratedFilesTests design principle interpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests#assertThatFileAdded(Kind,String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.GeneratedFilesTests",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests#assertThatFileAdded(Kind,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "use sample code for assertThatFileAdded",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.NullTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "generateWhenNull",
      "tail_type": "apiFunction"
    },
    {
      "head": "generateWhenNull",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "void generateWhenNull() {\n    assertThat(generateCode(null)).hasToString(\"null\");\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.NullTests",
      "head_type": "class",
      "relation": "have",
      "tail": "This class is designed to test the behavior of the generateCode method when it is passed a null value.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.NullTests",
      "head_type": "class",
      "relation": "have",
      "tail": "The design principle behind this class is to ensure that the generateCode method can handle null values gracefully and produce a meaningful output.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.StringTests#generateWhenString()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "generateCode",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.StringTests#generateWhenString()",
      "head_type": "method",
      "relation": "have",
      "tail": "generateWhenStringSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.ResolvableTypeTests#generateWhenSimpleResolvableType()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "generateCode",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.ResolvableTypeTests#generateWhenSimpleResolvableType()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "forClass",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.ResolvableTypeTests#generateWhenSimpleResolvableType()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "hasImport",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.ResolvableTypeTests#generateWhenSimpleResolvableType()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "hasValueCode",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.ResolvableTypeTests#generateWhenSimpleResolvableType()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "ResolvableType",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.ResolvableTypeTests#generateWhenSimpleResolvableType()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "String",
      "tail_type": "class"
    },
    {
      "head": "ResolvableType",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "forClass",
      "tail_type": "apiFunction"
    },
    {
      "head": "generateCode",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "useSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "complete sample code",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "forClass",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "related concept interpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "hasImport",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "related concept interpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "hasValueCode",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "related concept interpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.ListTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "generateWhenStringList",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.ListTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "generateWhenEmptyList",
      "tail_type": "apiFunction"
    },
    {
      "head": "generateWhenStringList",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "generateWhenEmptyList",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.hint.annotation.SampleInterface#managed()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "reflectiveOperation",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.hint.annotation.SampleInterface#managed()",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.hint.annotation.SampleInterface#managed()",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.hint.annotation.SampleInterface#managed()",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.hint.annotation.SampleInterface#managed()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.hint.annotation.SampleInterface",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.core.type.StandardAnnotationMetadata#hasAnnotatedMethods(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "hasAnnotatedMethods",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.core.type.StandardAnnotationMetadata#hasAnnotatedMethods(String)",
      "head_type": "method",
      "relation": "have",
      "tail": " Checks if the class has methods annotated with a specific annotation.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.core.type.StandardAnnotationMetadata#hasAnnotatedMethods(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is used to determine if a class contains methods that are annotated with a given annotation. It iterates over all declared methods of the class and checks if any of them are annotated with the specified annotation.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.core.type.StandardAnnotationMetadata#hasAnnotatedMethods(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "java\npackage org.springframework.core.type;\n\nimport java.lang.reflect.Method;\nimport java.util.Arrays;\n\npublic class AnnotationMetadataExample {\n    public static void main(String[] args) {\n        Class<?> clazz = ExampleClass.class;\n        String annotationName = \"org.example.MyAnnotation\";\n        boolean hasAnnotatedMethods = Arrays.stream(clazz.getDeclaredMethods())\n                .anyMatch(method -> method.isAnnotationPresent(MyAnnotation.class));\n        System.out.println(\"Has annotated methods: \" + hasAnnotatedMethods);\n    }\n}\n",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.core.type.StandardClassMetadata#getMemberClassNames()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getMemberClassNames",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.core.type.StandardClassMetadata#getMemberClassNames()",
      "head_type": "method",
      "relation": "have",
      "tail": "getMemberClassNames() useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "getMemberClassNames() useSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "package com.healthMgr.common.email; import java.xxxx; public class OneClass { // specific code }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.core.type.StandardClassMetadata",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.core.type.StandardClassMetadata#getMemberClassNames()",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#combine(String,String)",
      "head_type": "method",
      "relation": "haveFuntion",
      "tail": "combine two patterns into a new pattern",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#combine(String,String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "IllegalArgumentException if the two patterns cannot be combined",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#combine(String,String)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "concatenate two patterns unless the first contains a file extension match",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#combine(String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for combining patterns",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#combine(String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "related concept interpretation for pattern combination",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.AntPathMatcher#combine(String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle interpretation for pattern combination",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.AntPathMatcher",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.AntPathMatcher#combine(String,String)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.AutoPopulatingList#remove(Object)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "remove an element from the list",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.AutoPopulatingList#remove(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.AutoPopulatingList",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.AutoPopulatingList#remove(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "public boolean remove(Object o) { return this.backingList.remove(o); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.AutoPopulatingList#remove(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "Removes the first occurrence of the specified element from this list, if it is present.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.AutoPopulatingList#remove(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is part of the List interface and is overridden here to provide a specific implementation for the AutoPopulatingList.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.backoff.BackOff#start()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "start a new back off execution",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.backoff.BackOff#start()",
      "head_type": "method",
      "relation": "have",
      "tail": "a fresh BackOffExecution ready to be used",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.backoff.BackOff#start()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "BackOffExecution",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.ClassUtils#isSimpleValueType(Class<?>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "check if a type represents a common simple value type",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ClassUtils#isSimpleValueType(Class<?>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "Void and void are not considered simple value types",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ClassUtils#isSimpleValueType(Class<?>)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "value-based data binding and toString output",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ClassUtils#isSimpleValueType(Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "Delegate for org.springframework.beans.BeanUtils#isSimpleValueType. Also used by ObjectUtils#nullSafeConciseToString.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#isSimpleValueType(Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "public static boolean isSimpleValueType(Class<?> type) { return (!isVoidType(type) && (isPrimitiveOrWrapper(type) || Enum.class.isAssignableFrom(type) || CharSequence.class.isAssignableFrom(type) || Number.class.isAssignableFrom(type) || Date.class.isAssignableFrom(type) || Temporal.class.isAssignableFrom(type) || ZoneId.class.isAssignableFrom(type) || TimeZone.class.isAssignableFrom(type) || File.class.isAssignableFrom(type) || Path.class.isAssignableFrom(type) || Charset.class.isAssignableFrom(type) || Currency.class.isAssignableFrom(type) || InetAddress.class.isAssignableFrom(type) || URI.class == type || URL.class == type || UUID.class == type || Locale.class == type || Pattern.class == type || Class.class == type)); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ClassUtils#isSimpleValueType(Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is designed to determine if a given type is a simple value type, which includes primitives, their wrappers, and a variety of common types such as Enum, String, Number, Date, etc. It is used to suggest value-based data binding and appropriate toString output.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#isSimpleValueType(Class<?>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.beans.BeanUtils#isSimpleValueType",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.ClassUtils#isSimpleValueType(Class<?>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "ObjectUtils#nullSafeConciseToString",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.ClassUtils",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getDescriptiveType",
      "tail_type": "apiFunction"
    },
    {
      "head": "getDescriptiveType",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "introspect object's type",
      "tail_type": "useScenario"
    },
    {
      "head": "getDescriptiveType",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "return class name or component type class name + \"[]\" for arrays",
      "tail_type": "useSampleCode"
    },
    {
      "head": "getDescriptiveType",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": " appended list of implemented interfaces for JDK proxies",
      "tail_type": "useSampleCode"
    },
    {
      "head": "getDescriptiveType",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "Return a descriptive name for the given object's type",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "getDescriptiveType",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "usually simply the class name, but component type class name + \"[]\" for arrays, and an appended list of implemented interfaces for JDK proxies.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.ClassUtils#getDescriptiveType(Object)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.ClassUtils#getInterfaceMethodIfPossible(Method,Class<?>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "determine corresponding interface method",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ClassUtils#getInterfaceMethodIfPossible(Method,Class<?>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "method handle must be from an implementation class",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ClassUtils#getInterfaceMethodIfPossible(Method,Class<?>)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "invoking method via reflection without illegal access warning",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ClassUtils#getInterfaceMethodIfPossible(Method,Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for invoking method via reflection",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ClassUtils#getInterfaceMethodIfPossible(Method,Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "explanation of reflection and Java Module System",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#getInterfaceMethodIfPossible(Method,Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle behind method invocation via reflection",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#getInterfaceMethodIfPossible(Method,Class<?>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.core.SimpleAliasRegistryTests",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.CollectionUtils#mergeArrayIntoCollection(Object,Collection<E>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "mergeArrayIntoCollection",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.CollectionUtils#mergeArrayIntoCollection(Object,Collection<E>)",
      "head_type": "method",
      "relation": "have",
      "tail": "mergeArrayIntoCollectionSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "mergeArrayIntoCollectionSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "mergeArrayIntoCollectionSampleCodeContent",
      "tail_type": "useSampleCodeContent"
    },
    {
      "head": "org.springframework.util.CollectionUtils#mergeArrayIntoCollection(Object,Collection<E>)",
      "head_type": "method",
      "relation": "have",
      "tail": "mergeArrayIntoCollectionRelatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "mergeArrayIntoCollectionRelatedConceptInterpretation",
      "head_type": "relatedConceptInterpretation",
      "relation": "have",
      "tail": "mergeArrayIntoCollectionRelatedConceptInterpretationContent",
      "tail_type": "relatedConceptInterpretationContent"
    },
    {
      "head": "org.springframework.util.CollectionUtils#mergeArrayIntoCollection(Object,Collection<E>)",
      "head_type": "method",
      "relation": "have",
      "tail": "mergeArrayIntoCollectionDesignPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "mergeArrayIntoCollectionDesignPrincipleInterpretation",
      "head_type": "designPrincipleInterpretation",
      "relation": "have",
      "tail": "mergeArrayIntoCollectionDesignPrincipleInterpretationContent",
      "tail_type": "designPrincipleInterpretationContent"
    },
    {
      "head": "org.springframework.util.CollectionUtils#containsInstance(Collection<?>,Object)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "check whether the given Collection contains the given element instance",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.CollectionUtils#containsInstance(Collection<?>,Object)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "Enforces the given instance to be present, rather than returning true for an equal element as well",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.CollectionUtils#containsInstance(Collection<?>,Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "public static boolean containsInstance(@Nullable Collection<?> collection, Object element) { if (collection != null) { for (Object candidate : collection) { if (candidate == element) { return true; } } } return false; }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.CollectionUtils#containsInstance(Collection<?>,Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is used to check if a given collection contains a specific element instance. It iterates through the collection and checks if any object in the collection is the same instance as the given element. If a match is found, it returns true; otherwise, it returns false.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.CollectionUtils#containsInstance(Collection<?>,Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "The design principle behind this method is to provide a way to check for the presence of a specific element instance within a collection. It ensures that the exact instance is checked for, rather than just an equal element, which can be important in cases where object identity is significant.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.CompositeSet#equals(Object)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "equality check",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.CompositeSet#equals(Object)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "null parameter handling",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.CompositeSet#equals(Object)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "set comparison",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.CompositeSet#equals(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.CompositeSet#containsAll(Set<?>)",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.CompositeSet#equals(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "related concept interpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.CompositeSet#equals(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle interpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.CompositeSet#equals(Object)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.Set",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.ConcurrentLruCache#markForRemoval(Node<K,V>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "transition node state",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ConcurrentLruCache#markForRemoval(Node<K,V>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "valid transition required",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ConcurrentLruCache#markForRemoval(Node<K,V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.ConcurrentLruCache",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.ConcurrentLruCache#markForRemoval(Node<K,V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ConcurrentLruCache#markForRemoval(Node<K,V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ConcurrentLruCache#markForRemoval(Node<K,V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.EvictionQueue#poll()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "polling",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.EvictionQueue#poll()",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.EvictionQueue",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.EvictionQueue",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.EvictionQueue#poll()",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.EvictionQueue#poll()",
      "head_type": "method",
      "relation": "have",
      "tail": "This method removes and returns the first element of the EvictionQueue.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.EvictionQueue#poll()",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is thread-safe and non-blocking.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.EvictionQueue#poll()",
      "head_type": "method",
      "relation": "have",
      "tail": "package com.example;\n\nimport org.springframework.util.EvictionQueue;\n\npublic class Main {\n    public static void main(String[] args) {\n        EvictionQueue<String, String> queue = new EvictionQueue<>();\n        queue.put(\"key1\", \"value1\");\n        queue.put(\"key2\", \"value2\");\n        \n        String value = queue.poll();\n        System.out.println(value); // Outputs: value1\n    }\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.WeakEntryReference#release()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "release",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.WeakEntryReference#release()",
      "head_type": "method",
      "relation": "have",
      "tail": "Releases the weak reference to the entry.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.WeakEntryReference#release()",
      "head_type": "method",
      "relation": "have",
      "tail": "public void release() {\n    enqueue();\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.WeakEntryReference#release()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.WeakReference",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.DigestUtils#digestAsHexString(String,byte[])",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "convert byte array to hex string",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.DigestUtils#digestAsHexString(String,byte[])",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "useSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "private static String digestAsHexString(String algorithm, byte[] bytes) {\n    char[] hexDigest = digestAsHexChars(algorithm, bytes);\n    return new String(hexDigest);\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.FastByteArrayInputStream#skip(long)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "skip bytes in stream",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.FastByteArrayInputStream#skip(long)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "n must be non-negative and not exceed Integer.MAX_VALUE",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.FastByteArrayInputStream#skip(long)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "stream data processing",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.FastByteArrayInputStream#skip(long)",
      "head_type": "method",
      "relation": "have",
      "tail": "stream data processing example",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.FastByteArrayInputStream#skip(long)",
      "head_type": "method",
      "relation": "have",
      "tail": "stream data processing explanation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.FastByteArrayInputStream#skip(long)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principles for skipping bytes in stream",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.FastByteArrayInputStream#skip(long)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.FastByteArrayInputStream",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.FilteredMap#get(Object)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "filtered retrieval",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.FilteredMap#get(Object)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "key type must match filter input",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.FilteredMap#get(Object)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "retrieving values based on a filter condition",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.FilteredMap#get(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "public V get(Object key) { V value = this.delegate.get(key); if (value != null && this.filter.test((K) key)) { return value; } else { return null; } }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.FilteredMap#get(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method retrieves a value from the delegate map only if the key passes the filter condition.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.FilteredMap#get(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "The design principle here is to provide a filtered view of the underlying map, ensuring that only desired elements are accessible.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.FilteredMap#get(Object)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.FilteredMap",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.function.ThrowingConsumer#accept(T)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "wrapping checked exceptions",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.function.ThrowingConsumer#accept(T)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "must throw checked exceptions",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.function.ThrowingConsumer#accept(T)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "handling exceptions in functional interfaces",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.function.ThrowingConsumer#accept(T)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for handling exceptions",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.function.ThrowingConsumer#accept(T)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "java.util.function.Consumer",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.function.ThrowingConsumer#accept(T)",
      "head_type": "method",
      "relation": "have",
      "tail": "functional interfaces and exception handling",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.function.ThrowingConsumer#accept(T)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principles for robust functional interfaces",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.function.ThrowingFunction#of(ThrowingFunction<T,R>,BiFunction<String,Exception,RuntimeException>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "create ThrowingFunction",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.function.ThrowingFunction#of(ThrowingFunction<T,R>,BiFunction<String,Exception,RuntimeException>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "exceptionWrapper must handle thrown checked exceptions",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.function.ThrowingFunction#of(ThrowingFunction<T,R>,BiFunction<String,Exception,RuntimeException>)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "working with method references",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.function.ThrowingFunction#of(ThrowingFunction<T,R>,BiFunction<String,Exception,RuntimeException>)",
      "head_type": "method",
      "relation": "have",
      "tail": "stream.map(ThrowingFunction.of(Example::methodThatCanThrowCheckedException, IllegalStateException::new));",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.function.ThrowingFunction#of(ThrowingFunction<T,R>,BiFunction<String,Exception,RuntimeException>)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method can be especially useful when working with method references. It allows you to easily convert a method that throws a checked exception into an instance compatible with a regular Function.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.function.ThrowingFunction#of(ThrowingFunction<T,R>,BiFunction<String,Exception,RuntimeException>)",
      "head_type": "method",
      "relation": "have",
      "tail": "The design principle behind this method is to provide a convenient way to handle checked exceptions in functional interfaces, making it easier to work with lambda expressions and method references.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.function.ThrowingFunction#of(ThrowingFunction<T,R>,BiFunction<String,Exception,RuntimeException>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.function.ThrowingFunction",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.LinkedCaseInsensitiveMap#keySet()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "keySet retrieval",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.LinkedCaseInsensitiveMap#keySet()",
      "head_type": "method",
      "relation": "have",
      "tail": "Lazy initialization of keySet",
      "tail_type": "useSampleCode"
    },
    {
      "head": "keySet retrieval",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "Case insensitive key retrieval",
      "tail_type": "useScenario"
    },
    {
      "head": "keySet retrieval",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "Must return a case-insensitive set of keys",
      "tail_type": "useConstraint"
    },
    {
      "head": "Lazy initialization of keySet",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "tail": "org.springframework.util.LinkedCaseInsensitiveMap",
      "tail_type": "class"
    },
    {
      "head": "Case insensitive key retrieval",
      "head_type": "useScenario",
      "relation": "have",
      "tail": "Useful when keys are stored in a case-insensitive manner",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "Must return a case-insensitive set of keys",
      "head_type": "useConstraint",
      "relation": "have",
      "tail": "Ensures that the keys are treated uniformly regardless of their case",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.MimeTypeUtils#generateMultipartBoundary()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "generate random MIME boundary",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MimeTypeUtils#generateMultipartBoundary()",
      "head_type": "method",
      "relation": "have",
      "tail": "used in multipart mime types",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.MimeTypeUtils#generateMultipartBoundary()",
      "head_type": "method",
      "relation": "have",
      "tail": "public static byte[] generateMultipartBoundary() {    Random randomToUse = initRandom();    byte[] boundary = new byte[randomToUse.nextInt(11) + 30];    for (int i = 0; i < boundary.length; i++) {        boundary[i] = BOUNDARY_CHARS[randomToUse.nextInt(BOUNDARY_CHARS.length)];    }    return boundary;}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "generate random MIME boundary",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "org.springframework.util.MimeTypeUtils#generateMultipartBoundary()",
      "tail_type": "method"
    },
    {
      "head": "used in multipart mime types",
      "head_type": "useScenario",
      "relation": "have",
      "tail": "org.springframework.util.MimeTypeUtils#generateMultipartBoundary()",
      "tail_type": "method"
    },
    {
      "head": "public static byte[] generateMultipartBoundary() {    Random randomToUse = initRandom();    byte[] boundary = new byte[randomToUse.nextInt(11) + 30];    for (int i = 0; i < boundary.length; i++) {        boundary[i] = BOUNDARY_CHARS[randomToUse.nextInt(BOUNDARY_CHARS.length)];    }    return boundary;}",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "org.springframework.util.MimeTypeUtils#generateMultipartBoundary()",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.MultiToSingleValueMapAdapter#values()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "adapt collection values",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MultiToSingleValueMapAdapter#values()",
      "head_type": "method",
      "relation": "have",
      "tail": "lazy initialization of values collection",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.MultiToSingleValueMapAdapter#values()",
      "head_type": "method",
      "relation": "have",
      "tail": " 确保 values 集合在需要时才被初始化，以节省内存和提高性能。",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.MultiToSingleValueMapAdapter#values()",
      "head_type": "method",
      "relation": "have",
      "tail": "通过延迟初始化，确保在第一次调用 values() 方法时才创建 values 集合，这符合软件开发中的延迟加载原则。",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.MultiToSingleValueMapAdapter#values()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.MultiToSingleValueMapAdapter",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeToString(int[])",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "String representation of array",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeToString(int[])",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "array must not be null",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeToString(int[])",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "convert array to String",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeToString(int[])",
      "head_type": "method",
      "relation": "have",
      "tail": "public static String nullSafeToString(int @Nullable [] array) { if (array == null) { return NULL_STRING; } if (array.length == 0) { return EMPTY_ARRAY; } StringJoiner stringJoiner = new StringJoiner(ARRAY_ELEMENT_SEPARATOR, ARRAY_START, ARRAY_END); for (int i : array) { stringJoiner.add(String.valueOf(i)); } return stringJoiner.toString(); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeToString(int[])",
      "head_type": "method",
      "relation": "have",
      "tail": "Converts an array to a String representation, handling null and empty arrays gracefully.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeToString(int[])",
      "head_type": "method",
      "relation": "have",
      "tail": "This method follows the principle of null safety, ensuring that null inputs are handled without causing exceptions.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.Part#resolve(PartResolutionContext)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "resolve part",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.Part#resolve(PartResolutionContext)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "PartResolutionContext must be provided",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.Part#resolve(PartResolutionContext)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "resolving a part using context",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.Part#resolve(PartResolutionContext)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.Part",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.Part#resolve(PartResolutionContext)",
      "head_type": "method",
      "relation": "have",
      "tail": "Resolving a part involves interpreting its context and returning the resolved part.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.Part#resolve(PartResolutionContext)",
      "head_type": "method",
      "relation": "have",
      "tail": "Design principle involves ensuring that the part resolution is context-aware and returns the correct resolved part.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.Part#resolve(PartResolutionContext)",
      "head_type": "method",
      "relation": "have",
      "tail": "java\npackage org.springframework.util;\n\nimport org.springframework.core.io.Resource;\n\npublic class Part {\n    public String resolve(PartResolutionContext resolutionContext) {\n        // Implementation for resolving the part using the provided context\n        return resolvedPart;\n    }\n}\n",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ResizableByteArrayOutputStream#grow(int)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "growing internal buffer size",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ResizableByteArrayOutputStream#grow(int)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "additional capacity must be 0 or higher",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ResizableByteArrayOutputStream#grow(int)",
      "head_type": "method",
      "relation": "have",
      "tail": "ResizableByteArrayOutputStream#size()",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ResizableByteArrayOutputStream#grow(int)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "ResizableByteArrayOutputStream",
      "tail_type": "class"
    },
    {
      "head": "ResizableByteArrayOutputStream#size()",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "sample code for using ResizableByteArrayOutputStream#size()",
      "tail_type": "useSampleCode"
    },
    {
      "head": "growing internal buffer size",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "apiFunction for growing internal buffer size",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "additional capacity must be 0 or higher",
      "head_type": "useConstraint",
      "relation": "have",
      "tail": "useConstraint for ensuring non-negative additional capacity",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.RouteMatcher#match(String,Route)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "Route Matching",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.RouteMatcher#match(String,Route)",
      "head_type": "method",
      "relation": "have",
      "tail": "Matching a given route against a pattern",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.RouteMatcher#match(String,Route)",
      "head_type": "method",
      "relation": "have",
      "tail": "public boolean match(String pattern, Route route) {\n    // Implementation code here\n    return false;\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.RouteMatcher#match(String,Route)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.RouteMatcher",
      "tail_type": "class"
    },
    {
      "head": "Route Matching",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "Pattern and Route must be non-null",
      "tail_type": "useConstraint"
    },
    {
      "head": "Route Matching",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "Used to determine if a given route matches a specified pattern",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "Route Matching",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "Efficiency in pattern matching is crucial for performance",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.StopWatch#toString()",
      "head_type": "method",
      "relation": "haveFuntion",
      "tail": "generate informative string",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StopWatch#toString()",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "describing all tasks performed in seconds",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.StopWatch#toString()",
      "head_type": "method",
      "relation": "have",
      "tail": "StringBuilder sb = new StringBuilder(shortSummary());\n    if (this.taskList != null) {\n        for (TaskInfo task : this.taskList) {\n            sb.append(\"; [\").append(task.getTaskName()).append(\"] took \").append(task.getTimeSeconds()).append(\" seconds\");\n            long percent = Math.round(100.0 * task.getTimeSeconds() / getTotalTimeSeconds());\n            sb.append(\" = \").append(percent).append('%');\n        }\n    } else {\n        sb.append(\"; no task info kept\");\n    }\n    return sb.toString();",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.StopWatch#toString()",
      "head_type": "method",
      "relation": "have",
      "tail": "Generate an informative string describing all tasks performed in seconds.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.StopWatch#toString()",
      "head_type": "method",
      "relation": "have",
      "tail": "This method uses StringBuilder to create a detailed summary of tasks and their execution times in seconds. It iterates over taskList, appending each task's name and execution time to the StringBuilder. If taskList is null, it appends a message indicating no task info is kept.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.StopWatch#toString()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.StopWatch",
      "tail_type": "class"
    },
    {
      "tail": "stripFilenameExtension",
      "head_type": "method",
      "relation": "haveFunction",
      "head": "org.springframework.util.StringUtils#stripFilenameExtension(String)",
      "tail_type": "apiFunction"
    },
    {
      "tail": "stripFilenameExtension(String path) { ... }",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.StringUtils#stripFilenameExtension(String)",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "String path = \"mypath/myfile.txt\"; String result = stripFilenameExtension(path);",
      "head_type": "useSampleCode",
      "relation": "have",
      "head": "stripFilenameExtension(String path) { ... }",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "Strip the filename extension from the given Java resource path, for example, 'mypath/myfile.txt' -> 'mypath/myfile'.",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.StringUtils#stripFilenameExtension(String)",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "tail": "This method is designed to remove the extension from a filename, which is useful for processing file paths in a way that is independent of the file's format.",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.util.StringUtils#stripFilenameExtension(String)",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.TypeUtils#isAssignable(ParameterizedType,ParameterizedType)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "Type Assignability Check",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.TypeUtils#isAssignable(ParameterizedType,ParameterizedType)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "Type Compatibility",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.TypeUtils#isAssignable(ParameterizedType,ParameterizedType)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "Generic Type Comparison",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.TypeUtils#isAssignable(ParameterizedType,ParameterizedType)",
      "head_type": "method",
      "relation": "have",
      "tail": "private static boolean isAssignable(ParameterizedType lhsType, ParameterizedType rhsType) {\n    if (lhsType.equals(rhsType)) {\n        return true;\n    }\n    Type[] lhsTypeArguments = lhsType.getActualTypeArguments();\n    Type[] rhsTypeArguments = rhsType.getActualTypeArguments();\n    if (lhsTypeArguments.length != rhsTypeArguments.length) {\n        return false;\n    }\n    for (int size = lhsTypeArguments.length, i = 0; i < size; ++i) {\n        Type lhsArg = lhsTypeArguments[i];\n        Type rhsArg = rhsTypeArguments[i];\n        if (!lhsArg.equals(rhsArg) && !(lhsArg instanceof WildcardType wildcardType && isAssignable(wildcardType, rhsArg))) {\n            return false;\n        }\n    }\n    return true;\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.TypeUtils#isAssignable(ParameterizedType,ParameterizedType)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method checks if one parameterized type is assignable from another. It compares the type arguments of both types and ensures they are compatible, considering wildcard types.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.TypeUtils#isAssignable(ParameterizedType,ParameterizedType)",
      "head_type": "method",
      "relation": "have",
      "tail": "The method follows the principle of type compatibility and ensures that generic types are compared correctly, respecting the constraints of wildcard types.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "Type Assignability Check",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "org.springframework.util.TypeUtils",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.unit.DataSize#toGigabytes()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "convert to gigabytes",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.unit.DataSize#toGigabytes()",
      "head_type": "method",
      "relation": "have",
      "tail": "Return the number of gigabytes in this instance.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.unit.DataSize#toGigabytes()",
      "head_type": "method",
      "relation": "have",
      "tail": "public long toGigabytes() { return this.bytes / BYTES_PER_GB; }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.unit.DataSize#toGigabytes()",
      "head_type": "method",
      "relation": "have",
      "tail": "This method converts the data size to gigabytes by dividing the number of bytes by the number of bytes per gigabyte.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#put(K,List<V>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "unsupportedOperation",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#put(K,List<V>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "unsupportedOperationException",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#put(K,List<V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "unsupportedOperationException",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#put(K,List<V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "unsupportedOperationException",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#put(K,List<V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "unsupportedOperationException",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#setAll(Map<K,V>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "org.springframework.util.UnmodifiableMultiValueMap#setAll(Map<K,V>)",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#setAll(Map<K,V>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "UnsupportedOperationException",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#setAll(Map<K,V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "throw new UnsupportedOperationException()",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#setAll(Map<K,V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#setAll(Map<K,V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySet#remove(Object)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "org.springframework.util.UnmodifiableEntrySet#remove(Object)",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySet#remove(Object)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "UnsupportedOperationException",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySet#remove(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "public boolean remove(Object o) { throw new UnsupportedOperationException(); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySet#remove(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.UnmodifiableEntrySet#remove(Object)",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySet#remove(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.UnmodifiableEntrySet#remove(Object)",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySet#addAll(Collection<? extends Entry<K,List<V>>>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "add entries to set",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySet#addAll(Collection<? extends Entry<K,List<V>>>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "operation not supported",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySet#addAll(Collection<? extends Entry<K,List<V>>>)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.UnmodifiableEntrySet",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySet#addAll(Collection<? extends Entry<K,List<V>>>)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySet#addAll(Collection<? extends Entry<K,List<V>>>)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySet#addAll(Collection<? extends Entry<K,List<V>>>)",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySpliterator#tryAdvance(Consumer<? super Entry<K,List<V>>>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "tryAdvance",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySpliterator#tryAdvance(Consumer<? super Entry<K,List<V>>>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "Consumer<? super Entry<K,List<V>>>",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySpliterator#tryAdvance(Consumer<? super Entry<K,List<V>>>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "Entry<K,List<V>>",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySpliterator#tryAdvance(Consumer<? super Entry<K,List<V>>>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "UnmodifiableEntry<>",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySpliterator#tryAdvance(Consumer<? super Entry<K,List<V>>>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "delegate",
      "tail_type": "class"
    },
    {
      "head": "tryAdvance",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "tryAdvance",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "tryAdvance",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueCollection#hashCode()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "calculateHashCode",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueCollection#hashCode()",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.UnmodifiableValueCollection",
      "tail_type": "class"
    },
    {
      "head": "calculateHashCode",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "org.springframework.util.UnmodifiableValueCollection",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueCollection#hashCode()",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "startDocument",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "endDocument",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "startPrefixMapping",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "endPrefixMapping",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "startElement",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "endElement",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "characters",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "ignorableWhitespace",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "processingInstruction",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "skippedEntity",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "startDTD",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "endDTD",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "startCDATA",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "endCDATA",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "comment",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "startEntity",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "endEntity",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "toQName",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "isNamespaceDeclaration",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "currentNamespaceMapping",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "newNamespaceMapping",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "removeNamespaceMapping",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "removeAllNamespaceMappings",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "startDocumentInternal",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "endDocumentInternal",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "startElementInternal",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "endElementInternal",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "charactersInternal",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "cDataInternal",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "ignorableWhitespaceInternal",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "processingInstructionInternal",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "skippedEntityInternal",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "dtdInternal",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "commentInternal",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler",
      "head_type": "class",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler",
      "head_type": "class",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxHandler",
      "head_type": "class",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLEventReader#remove()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "removeUnsupportedOperation",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLEventReader#remove()",
      "head_type": "method",
      "relation": "have",
      "tail": "throwUnsupportedOperationException",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLEventReader#remove()",
      "head_type": "method",
      "relation": "have",
      "tail": "removeNotSupportedOnClass",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLEventReader#remove()",
      "head_type": "method",
      "relation": "have",
      "tail": "ClassUtilsGetShortNameUsage",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLEventReader#remove()",
      "head_type": "method",
      "relation": "have",
      "tail": "OverrideAnnotationUsage",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "removeUnsupportedOperation",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "removeNotSupportedOnClass",
      "tail_type": "useScenario"
    },
    {
      "head": "removeUnsupportedOperation",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "throwUnsupportedOperationException",
      "tail_type": "useSampleCode"
    },
    {
      "head": "throwUnsupportedOperationException",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "removeUnsupportedOperation",
      "tail_type": "apiFunction"
    },
    {
      "head": "ClassUtilsGetShortNameUsage",
      "head_type": "relatedConceptInterpretation",
      "relation": "associated_with",
      "tail": "org.springframework.util.ClassUtils",
      "tail_type": "class"
    },
    {
      "head": "OverrideAnnotationUsage",
      "head_type": "designPrincipleInterpretation",
      "relation": "associated_with",
      "tail": "java.lang.Overview",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.LocatorLocationAdapter#getPublicId()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getPublicId",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.LocatorLocationAdapter#getPublicId()",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.xml.LocatorLocationAdapter#getPublicId() Sample Code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.LocatorLocationAdapter#getPublicId()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.LocatorLocationAdapter",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.StaxEventXMLReader#parseInternal()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "XML Parsing",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxEventXMLReader#parseInternal()",
      "head_type": "method",
      "relation": "have",
      "tail": "XML Parsing Sample Code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "XML Parsing Sample Code",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "Complete XML Parsing Example",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.StaxEventXMLReader#parseInternal()",
      "head_type": "method",
      "relation": "have",
      "tail": "XML Parsing Related Concepts",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "XML Parsing Related Concepts",
      "head_type": "relatedConceptInterpretation",
      "relation": "have",
      "tail": "Explanation of XML Parsing Concepts",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxEventXMLReader#parseInternal()",
      "head_type": "method",
      "relation": "have",
      "tail": "XML Parsing Design Principles",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "XML Parsing Design Principles",
      "head_type": "designPrincipleInterpretation",
      "relation": "have",
      "tail": "Explanation of XML Parsing Design Principles",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamXMLReader#parseInternal()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "XML Parsing",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamXMLReader#parseInternal()",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "SAXException Handling",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamXMLReader#parseInternal()",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "XML Document Processing",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamXMLReader#parseInternal()",
      "head_type": "method",
      "relation": "have",
      "tail": "XML Document Processing Sample Code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamXMLReader#parseInternal()",
      "head_type": "method",
      "relation": "have",
      "tail": "XML Parsing Concepts",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamXMLReader#parseInternal()",
      "head_type": "method",
      "relation": "have",
      "tail": "Design Principles of XML Parsing",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.StaxStreamXMLReader#parseInternal()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.StaxStreamXMLReader",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.XmlValidationModeDetector#detectValidationMode(InputStream)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "XmlValidationModeDetection",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.XmlValidationModeDetector#detectValidationMode(InputStream)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "InputStreamClosure",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.xml.XmlValidationModeDetector#detectValidationMode(InputStream)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "XmlDocumentValidation",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.xml.XmlValidationModeDetector#detectValidationMode(InputStream)",
      "head_type": "method",
      "relation": "have",
      "tail": "XmlValidationModeSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.XmlValidationModeDetector#detectValidationMode(InputStream)",
      "head_type": "method",
      "relation": "have",
      "tail": "RelatedConceptsInXmlValidation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.XmlValidationModeDetector#detectValidationMode(InputStream)",
      "head_type": "method",
      "relation": "have",
      "tail": "DesignPrinciplesOfXmlValidationModeDetection",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.XmlValidationModeDetector#detectValidationMode(InputStream)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.XmlValidationModeDetector",
      "tail_type": "class"
    },
    {
      "head": "example.type.AnnotationTypeFilterTestsTypes",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "standalone set of types",
      "tail_type": "apiFunction"
    },
    {
      "head": "example.type.AnnotationTypeFilterTestsTypes",
      "head_type": "class",
      "relation": "constrained_by",
      "tail": "no interference from other loaded types",
      "tail_type": "useConstraint"
    },
    {
      "head": "example.type.AnnotationTypeFilterTestsTypes",
      "head_type": "class",
      "relation": "applied_to",
      "tail": "ensuring no one else is loading types",
      "tail_type": "useScenario"
    },
    {
      "head": "example.type.AnnotationTypeFilterTestsTypes",
      "head_type": "class",
      "relation": "have",
      "tail": "org.springframework.core.type.ClassloadingAssertions#assertClassNotLoaded(String)",
      "tail_type": "useSampleCode"
    },
    {
      "head": "example.type.AnnotationTypeFilterTestsTypes",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.core.type.AnnotationTypeFilterTests",
      "tail_type": "class"
    },
    {
      "head": "example.type.AnnotationTypeFilterTestsTypes",
      "head_type": "class",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "example.type.AnnotationTypeFilterTestsTypes",
      "head_type": "class",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "example.type.SomeSubclassOfSomeClassMarkedWithNonInheritedAnnotation",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "lazy loading",
      "tail_type": "apiFunction"
    },
    {
      "head": "example.type.SomeSubclassOfSomeClassMarkedWithNonInheritedAnnotation",
      "head_type": "class",
      "relation": "constrained_by",
      "tail": "circular aliases are prohibited",
      "tail_type": "useConstraint"
    },
    {
      "head": "example.type.SomeSubclassOfSomeClassMarkedWithNonInheritedAnnotation",
      "head_type": "class",
      "relation": "applied_to",
      "tail": "multiple aliases for a single name",
      "tail_type": "useScenario"
    },
    {
      "head": "example.type.SomeSubclassOfSomeClassMarkedWithNonInheritedAnnotation",
      "head_type": "class",
      "relation": "have",
      "tail": "complete sample code for using the apiFunction",
      "tail_type": "useSampleCode"
    },
    {
      "head": "example.type.SomeSubclassOfSomeClassMarkedWithNonInheritedAnnotation",
      "head_type": "class",
      "relation": "have",
      "tail": "related concept interpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "example.type.SomeSubclassOfSomeClassMarkedWithNonInheritedAnnotation",
      "head_type": "class",
      "relation": "have",
      "tail": "design principle interpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "example.type.SomeSubclassOfSomeClassMarkedWithNonInheritedAnnotation",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.core.SimpleAliasRegistryTests",
      "tail_type": "class"
    },
    {
      "tail": "generateClassNameUseFeatureNamePrefix",
      "head_type": "method",
      "relation": "haveFunction",
      "head": "org.springframework.aot.generate.ClassNameGeneratorTests#generateClassNameUseFeatureNamePrefix()",
      "tail_type": "apiFunction"
    },
    {
      "tail": "generateClassNameUseFeatureNamePrefix() {    ClassName generated = new ClassNameGenerator(TEST_TARGET, \\\"One\\\").generateClassName(\\\"test\\\", ClassName.get(InputStream.class));    assertThat(generated).hasToString(\\\"java.io.InputStream__OneTest\\",
      ",": "ail_type",
      "head_type": "apiFunction",
      "relation": "have",
      "head": "generateClassNameUseFeatureNamePrefix"
    },
    {
      "tail": "ClassNameGenerator",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "head": "generateClassNameUseFeatureNamePrefix",
      "tail_type": "class"
    },
    {
      "tail": "InputStream",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "head": "generateClassNameUseFeatureNamePrefix",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.DefaultGenerationContextTests#withNameKeepsTrackOfAllGeneratedFiles()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "file tracking",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.DefaultGenerationContextTests#withNameKeepsTrackOfAllGeneratedFiles()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "context naming",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.DefaultGenerationContextTests#withNameKeepsTrackOfAllGeneratedFiles()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "generated content management",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.DefaultGenerationContextTests#withNameKeepsTrackOfAllGeneratedFiles()",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "context manipulation",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.aot.generate.DefaultGenerationContextTests#withNameKeepsTrackOfAllGeneratedFiles()",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.aot.generate.DefaultGenerationContext",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.DefaultGenerationContextTests#withNameKeepsTrackOfAllGeneratedFiles()",
      "head_type": "method",
      "relation": "have",
      "tail": "context naming affects generated files",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.DefaultGenerationContextTests#withNameKeepsTrackOfAllGeneratedFiles()",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle of maintaining state across contexts",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.DefaultGenerationContextTests#withNameKeepsTrackOfAllGeneratedFiles()",
      "head_type": "method",
      "relation": "have",
      "tail": "package com.example;\nimport org.springframework.aot.generate.GenerationContext;\nimport org.springframework.aot.generate.ClassNameGenerator;\n\npublic class ContextExample {\n    public static void main(String[] args) {\n        DefaultGenerationContext context = new DefaultGenerationContext(new ClassNameGenerator(\"com.example\"), null);\n        context.getGeneratedClasses().addForFeature(\"Test\", typeSpec -> {});\n        GenerationContext anotherContext = context.withName(\"Another\");\n        anotherContext.getGeneratedClasses().addForFeature(\"AnotherTest\", typeSpec -> {});\n        context.writeGeneratedContent();\n    }\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithNullDeclaringClassAndTargetClass()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "toInvokeCodeBlockWithNullDeclaringClassAndTargetClass",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithNullDeclaringClassAndTargetClass()",
      "head_type": "method",
      "relation": "have",
      "tail": "void toInvokeCodeBlockWithNullDeclaringClassAndTargetClass() {\n    MethodSpec method = createTestMethod(\"methodName\", new TypeName[0]);\n    MethodReference methodReference = new DefaultMethodReference(method, null);\n    assertThat(methodReference.toInvokeCodeBlock(ArgumentCodeGenerator.none(), TEST_CLASS_NAME)).isEqualTo(CodeBlock.of(\"methodName()\"));\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithNullDeclaringClassAndTargetClass()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.DefaultMethodReferenceTests",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithNullDeclaringClassAndTargetClass()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "DefaultMethodReference",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithNullDeclaringClassAndTargetClass()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "MethodReference",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithNullDeclaringClassAndTargetClass()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "MethodSpec",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithNullDeclaringClassAndTargetClass()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "CodeBlock",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.DefaultMethodReferenceTests#toInvokeCodeBlockWithNullDeclaringClassAndTargetClass()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "ArgumentCodeGenerator",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedMethodsTests#doWithMethodSpecsAcceptsMethodSpecs()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "add",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedMethodsTests#doWithMethodSpecsAcceptsMethodSpecs()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "doWithMethodSpecs",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedMethodsTests#doWithMethodSpecsAcceptsMethodSpecs()",
      "head_type": "method",
      "relation": "have",
      "tail": "names.add(methodSpec.name)",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedMethodsTests#doWithMethodSpecsAcceptsMethodSpecs()",
      "head_type": "method",
      "relation": "have",
      "tail": "assertThat(names).containsExactly(\"springBeans\", \"springContext\")",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedMethodsTests#doWithMethodSpecsAcceptsMethodSpecs()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.GeneratedMethodsTests",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedMethodsTests#doWithMethodSpecsAcceptsMethodSpecs()",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedMethodsTests#doWithMethodSpecsAcceptsMethodSpecs()",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedMethodTests#toMethodReferenceWithStaticMethod()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "toMethodReference",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedMethodTests#toMethodReferenceWithStaticMethod()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "toInvokeCodeBlock",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedMethodTests#toMethodReferenceWithStaticMethod()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "create",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedMethodTests#toMethodReferenceWithStaticMethod()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "addModifiers",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedMethodTests#toMethodReferenceWithStaticMethod()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "isEqualTo",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedMethodTests#toMethodReferenceWithStaticMethod()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "of",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedMethodTests#toMethodReferenceWithStaticMethod()",
      "head_type": "method",
      "relation": "have",
      "tail": "GeneratedMethod generatedMethod = create(method -> method.addModifiers(Modifier.STATIC)); MethodReference methodReference = generatedMethod.toMethodReference(); assertThat(methodReference).isNotNull(); ClassName anotherDeclaringClass = ClassName.get(\"com.example\", \"Another\"); assertThat(methodReference.toInvokeCodeBlock(ArgumentCodeGenerator.none(), anotherDeclaringClass)).isEqualTo(CodeBlock.of(\"com.example.Test.spring()\"));",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedMethodTests#toMethodReferenceWithStaticMethod()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.GeneratedMethod",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedMethodTests#toMethodReferenceWithStaticMethod()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.MethodReference",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedMethodTests#toMethodReferenceWithStaticMethod()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "com.example.Another",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedMethodTests#toMethodReferenceWithStaticMethod()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "com.example.Test",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedMethodTests#toMethodReferenceWithStaticMethod()",
      "head_type": "method",
      "relation": "have",
      "tail": "This method tests the conversion of a static method to a method reference and then to an invocation code block. It demonstrates the use of the GeneratedMethod and MethodReference classes, as well as the interaction with the CodeBlock class for generating code.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedMethodTests#toMethodReferenceWithStaticMethod()",
      "head_type": "method",
      "relation": "have",
      "tail": "The design principle demonstrated in this method is the use of fluent interfaces and method chaining to create and manipulate objects. This approach simplifies the code and makes it more readable by reducing the need for intermediate variables and explicit type conversions.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.InMemoryGeneratedFilesTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getGeneratedFileContentWhenFileExistsReturnsContent",
      "tail_type": "apiFunction"
    },
    {
      "head": "getGeneratedFileContentWhenFileExistsReturnsContent",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "getGeneratedFileContentWhenFileExistsReturnsContent() { ... }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "getGeneratedFileContentWhenFileExistsReturnsContent() { ... }",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "tail": "InMemoryGeneratedFilesTests",
      "tail_type": "class"
    },
    {
      "head": "getGeneratedFileContentWhenFileExistsReturnsContent() { ... }",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.InMemoryGeneratedFilesTests",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.ConfigurationTests#generateCodeWithMatchingDelegateStops()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "generateCodeWithMatchingDelegateStops",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.ConfigurationTests#generateCodeWithMatchingDelegateStops()",
      "head_type": "method",
      "relation": "have",
      "tail": "generateCodeWithMatchingDelegateStopsSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "generateCodeWithMatchingDelegateStopsSampleCode",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.ConfigurationTests#generateCodeWithMatchingDelegateStops()",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.aot.generate.StringTests#generateWhenStringWithCarriageReturn()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "generateCode",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.StringTests#generateWhenStringWithCarriageReturn()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.StringTests",
      "tail_type": "class"
    },
    {
      "head": "generateCode",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "useSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "completeSampleCode",
      "tail_type": "completeSampleCode"
    },
    {
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldProcessWithMultipleProcessorsWithAnnotationOnType()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "process multiple custom processors",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldProcessWithMultipleProcessorsWithAnnotationOnType()",
      "head_type": "method",
      "relation": "have",
      "tail": "TypeHint typeHint = this.runtimeHints.reflection().getTypeHint(SampleMultipleCustomProcessors.class);",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldProcessWithMultipleProcessorsWithAnnotationOnType()",
      "head_type": "method",
      "relation": "have",
      "tail": "assertThat(typeHint).isNotNull(); assertThat(typeHint.getMemberCategories()).containsExactly(MemberCategory.INVOKE_DECLARED_METHODS);",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldProcessWithMultipleProcessorsWithAnnotationOnType()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "SampleMultipleCustomProcessors",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldProcessWithMultipleProcessorsWithAnnotationOnType()",
      "head_type": "method",
      "relation": "have",
      "tail": "This method processes multiple custom processors and verifies the reflection hints.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldProcessWithMultipleProcessorsWithAnnotationOnType()",
      "head_type": "method",
      "relation": "have",
      "tail": "The design principle is to ensure that multiple custom processors are correctly processed and verified.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "tail": "processAnnotationOnConstructor",
      "head_type": "method",
      "relation": "haveFunction",
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldProcessAnnotationOnConstructor()",
      "tail_type": "apiFunction"
    },
    {
      "tail": "SampleConstructorAnnotatedBean",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldProcessAnnotationOnConstructor()",
      "tail_type": "class"
    },
    {
      "tail": "runtimeHints",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldProcessAnnotationOnConstructor()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "reflection().getTypeHint()",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldProcessAnnotationOnConstructor()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "TypeReference.of(String.class)",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldProcessAnnotationOnConstructor()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "containsExactly",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldProcessAnnotationOnConstructor()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "singleElement()",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldProcessAnnotationOnConstructor()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "satisfies",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldProcessAnnotationOnConstructor()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "assertThat",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldProcessAnnotationOnConstructor()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "TypeReference",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldProcessAnnotationOnConstructor()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "String.class",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldProcessAnnotationOnConstructor()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "constructorHint",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldProcessAnnotationOnConstructor()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "getParameterTypes()",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldProcessAnnotationOnConstructor()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "containsExactly(TypeReference.of(String.class))",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldProcessAnnotationOnConstructor()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "assertThat(this.runtimeHints.reflection().getTypeHint(SampleConstructorAnnotatedBean.class)).satisfies(typeHint -> assertThat(typeHint.constructors()).singleElement().satisfies(constructorHint -> assertThat(constructorHint.getParameterTypes()).containsExactly(TypeReference.of(String.class))))",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldProcessAnnotationOnConstructor()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "process(SampleConstructorAnnotatedBean.class)",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldProcessAnnotationOnConstructor()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "SampleConstructorAnnotatedBean.class",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldProcessAnnotationOnConstructor()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "typeHint.constructors()",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldProcessAnnotationOnConstructor()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "typeHint",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldProcessAnnotationOnConstructor()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "constructorHint.getParameterTypes()",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldProcessAnnotationOnConstructor()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "constructorHint.getParameterTypes().containsExactly(TypeReference.of(String.class))",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldProcessAnnotationOnConstructor()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "typeHint.constructors().singleElement().satisfies(constructorHint -> assertThat(constructorHint.getParameterTypes()).containsExactly(TypeReference.of(String.class)))",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldProcessAnnotationOnConstructor()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "typeHint.constructors().singleElement()",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldProcessAnnotationOnConstructor()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "typeHint.constructors().singleElement().satisfies(constructorHint -> assertThat(constructorHint.getParameterTypes()).containsExactly(TypeReference.of(String.class)))",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldProcessAnnotationOnConstructor()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "typeHint.constructors().singleElement().satisfies(constructorHint -> assertThat(constructorHint.getParameterTypes()).containsExactly(TypeReference.of(String.class)))",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldProcessAnnotationOnConstructor()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "typeHint.constructors().singleElement().satisfies(constructorHint -> assertThat(constructorHint.getParameterTypes()).containsExactly(TypeReference.of(String.class)))",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldProcessAnnotationOnConstructor()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "typeHint.constructors().singleElement().satisfies(constructorHint -> assertThat(constructorHint.getParameterTypes()).containsExactly(TypeReference.of(String.class)))",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldProcessAnnotationOnConstructor()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "typeHint.constructors().singleElement().satisfies(constructorHint -> assertThat(constructorHint.getParameterTypes()).containsExactly(TypeReference.of(String.class)))",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldProcessAnnotationOnConstructor()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "typeHint.constructors().singleElement().satisfies(constructorHint -> assertThat(constructorHint.getParameterTypes()).containsExactly(TypeReference.of(String.class)))",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldProcessAnnotationOnConstructor()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "typeHint.constructors().singleElement().satisfies(constructorHint -> assertThat(constructorHint.getParameterTypes()).containsExactly(TypeReference.of(String.class)))",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldProcessAnnotationOnConstructor()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "typeHint.constructors().singleElement().satisfies(constructorHint -> assertThat(constructorHint.getParameterTypes()).containsExactly(TypeReference.of(String.class)))",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldProcessAnnotationOnConstructor()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "typeHint.constructors().singleElement().satisfies(constructorHint -> assertThat(constructorHint.getParameterTypes()).containsExactly(TypeReference.of(String.class)))",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldProcessAnnotationOnConstructor()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "typeHint.constructors().singleElement().satisfies(constructorHint -> assertThat(constructorHint.getParameterTypes()).containsExactly(TypeReference.of(String.class)))",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldProcessAnnotationOnConstructor()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "typeHint.constructors().singleElement().satisfies(constructorHint -> assertThat(constructorHint.getParameterTypes()).containsExactly(TypeReference.of(String.class)))",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldProcessAnnotationOnConstructor()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "typeHint.constructors().singleElement().satisfies(constructorHint -> assertThat(constructorHint.getParameterTypes()).containsExactly(TypeReference.of(String.class)))",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldProcessAnnotationOnConstructor()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "typeHint.constructors().singleElement().satisfies(constructorHint -> assertThat(constructorHint.getParameterTypes()).containsExactly(TypeReference.of(String.class)))",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldProcessAnnotationOnConstructor()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "typeHint.constructors().singleElement().satisfies(constructorHint -> assertThat(constructorHint.getParameterTypes()).containsExactly(TypeReference.of(String.class)))",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldProcessAnnotationOnConstructor()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "typeHint.constructors().singleElement().satisfies(constructorHint -> assertThat(constructorHint.getParameterTypes()).containsExactly(TypeReference.of(String.class)))",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldProcessAnnotationOnConstructor()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "typeHint.constructors().singleElement().satisfies(constructorHint -> assertThat(constructorHint.getParameterTypes()).containsExactly(TypeReference.of(String.class)))",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldProcessAnnotationOnConstructor()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "typeHint.constructors().singleElement().satisfies(constructorHint -> assertThat(constructorHint.getParameterTypes()).containsExactly(TypeReference.of(String.class)))",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldProcessAnnotationOnConstructor()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "typeHint.constructors().singleElement().satisfies(constructorHint -> assertThat(constructorHint.getParameterTypes()).containsExactly(TypeReference.of(String.class)))",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldProcessAnnotationOnConstructor()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "typeHint.constructors().singleElement().satisfies(constructorHint -> assertThat(constructorHint.getParameterTypes()).containsExactly(TypeReference.of(String.class)))",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldProcessAnnotationOnConstructor()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "typeHint.constructors().singleElement().satisfies(constructorHint -> assertThat(constructorHint.getParameterTypes()).containsExactly(TypeReference.of(String.class)))",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldProcessAnnotationOnConstructor()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "typeHint.constructors().singleElement().satisfies(constructorHint -> assertThat(constructorHint.getParameterTypes()).containsExactly(TypeReference.of(String.class)))",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldProcessAnnotationOnConstructor()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "typeHint.constructors().singleElement().satisfies(constructorHint -> assertThat(constructorHint.getParameterTypes()).containsExactly(TypeReference.of(String.class)))",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldProcessAnnotationOnConstructor()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "typeHint.constructors().singleElement().satisfies(constructorHint -> assertThat(constructorHint.getParameterTypes()).containsExactly(TypeReference.of(String.class)))",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldProcessAnnotationOnConstructor()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "typeHint.constructors().singleElement().satisfies(constructorHint -> assertThat(constructorHint.getParameterTypes()).containsExactly(TypeReference.of(String.class)))",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldProcessAnnotationOnConstructor()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "typeHint.constructors().singleElement().satisfies(constructorHint -> assertThat(constructorHint.getParameterTypes()).containsExactly(TypeReference.of(String.class)))",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldProcessAnnotationOnConstructor()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "typeHint.constructors().singleElement().satisfies(constructorHint -> assertThat(constructorHint.getParameterTypes()).containsExactly(TypeReference.of(String.class)))",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldProcessAnnotationOnConstructor()",
      "tail_type": "useSampleCode"
    },
    {
      "tail": "typeHint.constructors().singleElement().satisfies(constructorHint -> assertThat(constructorHint.getParameterTypes()).containsExactly(TypeReference.of(String.class)))",
      "head_type": "method",
      "relation": "have",
      "head": "org.springframework.aot.hint.annotation.ReflectiveRuntimeHintsRegistrarTests#shouldProcessAnnotationOnConstructor()",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.AntPathStringMatcher#getGlobPattern(String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "Pattern compilation",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.AntPathStringMatcher#getGlobPattern(String)",
      "head_type": "method",
      "relation": "have",
      "tail": "private static Pattern getGlobPattern(String pathSeparator) {\n    String pattern = \"\\\\?|\\\\*|\\\\{((?:\\\\{[^\" + pathSeparator + \"]+?\\\\}|[^\" + pathSeparator + \";]|\\\\[;])+?)\\\\}\";\n    return Pattern.compile(pattern);\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.AntPathStringMatcher",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.AntPathStringMatcher#getGlobPattern(String)",
      "tail_type": "method"
    },
    {
      "head": "Pattern compilation",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "private static Pattern getGlobPattern(String pathSeparator) {\n    String pattern = \"\\\\?|\\\\*|\\\\{((?:\\\\{[^\" + pathSeparator + \"]+?\\\\}|[^\" + pathSeparator + \";]|\\\\[;])+?)\\\\}\";\n    return Pattern.compile(pattern);\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "Pattern compilation",
      "head_type": "apiFunction",
      "relation": "relatedConceptInterpretation",
      "tail": "Pattern compilation involves creating a regex pattern for string matching, often used in routing and path matching scenarios.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "Pattern compilation",
      "head_type": "apiFunction",
      "relation": "designPrincipleInterpretation",
      "tail": "Pattern compilation is designed to efficiently match strings against a specified pattern, optimizing performance for large datasets.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.AntPatternComparator#compare(String,String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "pattern comparison",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.AntPatternComparator#compare(String,String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "patterns must be valid strings",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.AntPatternComparator#compare(String,String)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "determining pattern specificity",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.AntPatternComparator#compare(String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for comparing patterns",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.AntPatternComparator#compare(String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "related concept interpretation for pattern comparison",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.AntPatternComparator#compare(String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle interpretation for AntPatternComparator",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.AntPatternComparator#compare(String,String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.AntPatternComparator",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.PathSeparatorPatternCache",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getEndsOnDoubleWildCard()",
      "tail_type": "apiFunction"
    },
    {
      "head": "getEndsOnDoubleWildCard()",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "public String getEndsOnDoubleWildCard() { return this.endsOnDoubleWildCard; }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "getEndsOnDoubleWildCard()",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "This method returns the value of the endsOnDoubleWildCard field.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "getEndsOnDoubleWildCard()",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "The method follows the principle of encapsulation, providing controlled access to the field.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.AutoPopulatingList#equals(Object)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "equality check",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.AutoPopulatingList#equals(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "override annotation",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.AutoPopulatingList#equals(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "nullable parameter",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.AutoPopulatingList#equals(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "delegation to backing list",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.AutoPopulatingList#equals(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "public boolean equals(@Nullable Object other) { return this.backingList.equals(other); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.AutoPopulatingList#equals(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "The method checks if the AutoPopulatingList is equal to the specified object by comparing it with the backing list.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.AutoPopulatingList#equals(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "The design principle followed here is the Liskov Substitution Principle, ensuring that the AutoPopulatingList can be used as a drop-in replacement for its backing list without altering the correctness of the program.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.AutoPopulatingList",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.AutoPopulatingList#equals(Object)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.ClassUtils#getAllInterfacesAsSet(Object)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getAllInterfacesAsSet",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ClassUtils#getAllInterfacesAsSet(Object)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "instance analysis for interfaces",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ClassUtils#getAllInterfacesAsSet(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.ClassUtils#getAllInterfacesAsSet(Object) sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ClassUtils#getAllInterfacesAsSet(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.ClassUtils#getAllInterfacesAsSet(Object) related concept interpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#getAllInterfacesAsSet(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.ClassUtils#getAllInterfacesAsSet(Object) design principle interpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "getAllInterfacesAsSet",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "org.springframework.util.ClassUtils",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.ClassUtils#getAllInterfacesAsSet(Object) sample code",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "complete example of using getAllInterfacesAsSet",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ClassUtils#hasConstructor(Class<?>,Class<?>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "check public constructor existence",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ClassUtils#hasConstructor(Class<?>,Class<?>)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "constructor must be public",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ClassUtils#hasConstructor(Class<?>,Class<?>)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "class analysis",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ClassUtils#hasConstructor(Class<?>,Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for checking constructor existence",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ClassUtils#hasConstructor(Class<?>,Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "constructor existence interpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#hasConstructor(Class<?>,Class<?>)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle for constructor existence check",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ClassUtils#hasConstructor(Class<?>,Class<?>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "Class",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.comparator.NullSafeComparator",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "safely comparing nulls",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.comparator.NullSafeComparator",
      "head_type": "class",
      "relation": "constrained_by",
      "tail": "non-null elements must implement Comparable",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.comparator.NullSafeComparator",
      "head_type": "class",
      "relation": "applied_to",
      "tail": "comparing objects with potential nulls",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.comparator.NullSafeComparator",
      "head_type": "class",
      "relation": "have",
      "tail": "sample code for comparing objects",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.comparator.NullSafeComparator",
      "head_type": "class",
      "relation": "have",
      "tail": "related concept interpretation for Comparator",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.comparator.NullSafeComparator",
      "head_type": "class",
      "relation": "have",
      "tail": "design principle interpretation for null safety",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.comparator.NullSafeComparator",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.core.Comparable",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.comparator.NullSafeComparator",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.Comparators",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.ConcurrencyThrottleSupport#afterAccess()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "concurrency control",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ConcurrencyThrottleSupport#afterAccess()",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "main execution logic must be completed",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ConcurrencyThrottleSupport#afterAccess()",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "managing resource access",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ConcurrencyThrottleSupport#afterAccess()",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.ConcurrencyThrottleSupport#afterAccess() sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ConcurrencyThrottleSupport#afterAccess()",
      "head_type": "method",
      "relation": "have",
      "tail": "ConcurrencyThrottleSupport related concept interpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ConcurrencyThrottleSupport#afterAccess()",
      "head_type": "method",
      "relation": "have",
      "tail": "ConcurrencyThrottleSupport design principle interpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ConcurrencyThrottleSupport#afterAccess()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.ConcurrencyThrottleSupport",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.concurrent.FutureUtils",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "callAsync",
      "tail_type": "apiFunction"
    },
    {
      "head": "callAsync",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "Callable must not be null",
      "tail_type": "useConstraint"
    },
    {
      "head": "callAsync",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "asynchronous task execution",
      "tail_type": "useScenario"
    },
    {
      "head": "callAsync",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "sample code for callAsync",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.concurrent.FutureUtils",
      "head_type": "class",
      "relation": "have",
      "tail": "related concept interpretation for FutureUtils",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.concurrent.FutureUtils",
      "head_type": "class",
      "relation": "have",
      "tail": "design principle interpretation for FutureUtils",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.Node#getNext()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "retrieve the next node",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.Node#getNext()",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is used to get the next node in a sequence.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.Node#getNext()",
      "head_type": "method",
      "relation": "have",
      "tail": "The design principle followed here is to provide a simple and direct way to access the next node, ensuring efficient traversal in data structures like linked lists or trees.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.Node#getNext()",
      "head_type": "method",
      "relation": "have",
      "tail": "package com.example;\nimport org.springframework.util.Node;\n\nclass Example {\n    public static void main(String[] args) {\n        Node<String, String> node = new Node<>(\"key\", \"value\");\n        Node<String, String> nextNode = node.getNext();\n        System.out.println(nextNode);\n    }\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ConcurrentReferenceHashMap#size()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "sizeCalculation",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ConcurrentReferenceHashMap#size()",
      "head_type": "method",
      "relation": "have",
      "tail": "sizeCalculationSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "sizeCalculationSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "sizeCalculationSampleCodeContent",
      "tail_type": "useSampleCodeContent"
    },
    {
      "head": "org.springframework.util.Entry#toString()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "toString()",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.Entry#toString()",
      "head_type": "method",
      "relation": "have",
      "tail": "Return a string representation of the entry",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.Entry#toString()",
      "head_type": "method",
      "relation": "have",
      "tail": "Concatenates the key and value with an equals sign",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.Entry#toString()",
      "head_type": "method",
      "relation": "have",
      "tail": "Design principle: Provide a concise representation of the entry",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.EntryIterator#remove()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "removeElement",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.EntryIterator#remove()",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "elementPresence",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.EntryIterator#remove()",
      "head_type": "method",
      "relation": "have",
      "tail": "elementPresence",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.EntryIterator#remove()",
      "head_type": "method",
      "relation": "have",
      "tail": "sampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.EntryIterator#remove()",
      "head_type": "method",
      "relation": "have",
      "tail": "elementPresence",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.EntryIterator#remove()",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrinciple",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.EntryIterator#remove()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.EntryIterator",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.CustomizableThreadCreator#setThreadGroup(ThreadGroup)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "specifyThreadGroup",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.CustomizableThreadCreator#setThreadGroup(ThreadGroup)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "threadGroupNotNull",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.CustomizableThreadCreator#setThreadGroup(ThreadGroup)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "threadCreation",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.CustomizableThreadCreator#setThreadGroup(ThreadGroup)",
      "head_type": "method",
      "relation": "have",
      "tail": "setThreadGroupSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.CustomizableThreadCreator#setThreadGroup(ThreadGroup)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.CustomizableThreadCreator",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.CustomizableThreadCreator#setThreadGroup(ThreadGroup)",
      "head_type": "method",
      "relation": "have",
      "tail": "threadGroupExplanation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.CustomizableThreadCreator#setThreadGroup(ThreadGroup)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleExplanation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.FileCopyUtils#copy(File,File)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "copy contents of input File to output File",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.FileCopyUtils#copy(File,File)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "IOException in case of I/O errors",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.FileCopyUtils#copy(File,File)",
      "head_type": "method",
      "relation": "have",
      "tail": "Copy the contents of the given input File to the given output File.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.FileCopyUtils#copy(File,File)",
      "head_type": "method",
      "relation": "have",
      "tail": "Ensure the input and output Files are not null, and handle I/O exceptions appropriately.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.FileCopyUtils#copy(File,File)",
      "head_type": "method",
      "relation": "have",
      "tail": "public static int copy(File in, File out) throws IOException {\n    Assert.notNull(in, \"No input File specified\");\n    Assert.notNull(out, \"No output File specified\");\n    return copy(Files.newInputStream(in.toPath()), Files.newOutputStream(out.toPath()));\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.FileSystemUtils#copyRecursively(Path,Path)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "recursive file/directory copying",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.FileSystemUtils#copyRecursively(Path,Path)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "source and destination must not be null",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.FileSystemUtils#copyRecursively(Path,Path)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "source must denote a directory or file",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.FileSystemUtils#copyRecursively(Path,Path)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "copying contents between directories or files",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.FileSystemUtils#copyRecursively(Path,Path)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for recursive copying",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.FileSystemUtils#copyRecursively(Path,Path)",
      "head_type": "method",
      "relation": "have",
      "tail": "interpretation of recursive copying",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.FileSystemUtils#copyRecursively(Path,Path)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle behind recursive copying",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.FileSystemUtils",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.FileSystemUtils#copyRecursively(Path,Path)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.FilteredMap#containsKey(Object)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "check key existence with filter",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.FilteredMap#containsKey(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "Delegate map checking and apply filter",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.FilteredMap#containsKey(Object)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.FilteredMap",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.function.ThrowingFunction#apply(T)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "wrapping checked exceptions",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.function.ThrowingFunction#apply(T)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "must wrap exceptions in a RuntimeException",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.function.ThrowingFunction#apply(T)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "applying a function that may throw checked exceptions",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.function.ThrowingFunction#apply(T)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code applying a function with exception handling",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.function.ThrowingFunction#apply(T)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "java.util.function.Function#apply(java.lang.Object)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.function.ThrowingFunction#apply(T)",
      "head_type": "method",
      "relation": "have",
      "tail": "related concept interpretation of exception handling in functional interfaces",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.function.ThrowingFunction#apply(T)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle interpretation of robustness in functional interfaces",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.IdGenerator",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "generateId",
      "tail_type": "apiFunction"
    },
    {
      "head": "generateId",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "UUID generateId();",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.IdGenerator",
      "head_type": "class",
      "relation": "have",
      "tail": "Contract for generating universally unique identifiers (UUIDs).",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.IdGenerator",
      "head_type": "class",
      "relation": "have",
      "tail": "Author: Rossen Stoyanchev, Since: 4.0",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.EntrySet",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "forEach",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.EntrySet#forEach(Consumer<? super Entry<String,V>>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "forEach",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.EntrySet#forEach(Consumer<? super Entry<String,V>>)",
      "head_type": "method",
      "relation": "have",
      "tail": "Delegate action to the underlying set",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.EntrySet#forEach(Consumer<? super Entry<String,V>>)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "this.delegate",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.MimeType#equalsTypeAndSubtype(MimeType)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "compareMimeType",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MimeType#equalsTypeAndSubtype(MimeType)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "nullMimeType",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.MimeType#equalsTypeAndSubtype(MimeType)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "ignoreParameters",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.MimeType#equalsTypeAndSubtype(MimeType)",
      "head_type": "method",
      "relation": "have",
      "tail": "compareMimeTypeSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.MimeType#equalsTypeAndSubtype(MimeType)",
      "head_type": "method",
      "relation": "have",
      "tail": "MimeTypeComparisonInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.MimeType#equalsTypeAndSubtype(MimeType)",
      "head_type": "method",
      "relation": "have",
      "tail": "DesignPrinciplesMimeTypeComparison",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "compareMimeTypeSampleCode",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "tail": "org.springframework.util.MimeType",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.MultiToSingleValueMapAdapter#keySet()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "keySetRetrieval",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MultiToSingleValueMapAdapter#keySet()",
      "head_type": "method",
      "relation": "have",
      "tail": "keySetRetrievalSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "keySetRetrievalSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "Complete keySet Retrieval Example",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.MultiToSingleValueMapAdapter#forEach(BiConsumer<? super K,? super V>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "forEach",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MultiToSingleValueMapAdapter#forEach(BiConsumer<? super K,? super V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "Iterates over each key-value pair in the target map and applies the given action to the first value associated with each key.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.MultiToSingleValueMapAdapter#forEach(BiConsumer<? super K,? super V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "public void forEach(BiConsumer<? super K, ? super V> action) {\n    this.targetMap.forEach((k, vs) -> action.accept(k, vs.get(0)));\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.MultiToSingleValueMapAdapter#equals(Object)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "equality check",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MultiToSingleValueMapAdapter#equals(Object)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "null values handling",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.MultiToSingleValueMapAdapter#equals(Object)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "map comparison",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.MultiToSingleValueMapAdapter#equals(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.MultiToSingleValueMapAdapter#equals(Object) sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.MultiToSingleValueMapAdapter#equals(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "related concept interpretation for org.springframework.util.MultiToSingleValueMapAdapter#equals(Object)",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.MultiToSingleValueMapAdapter#equals(Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle interpretation for org.springframework.util.MultiToSingleValueMapAdapter#equals(Object)",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.MultiToSingleValueMapAdapter#equals(Object)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.MultiToSingleValueMapAdapter",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.MultiToSingleValueMapAdapter#hashCode()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "generate hash code",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MultiToSingleValueMapAdapter#hashCode()",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.MultiToSingleValueMapAdapter#hashCode() returns the hash code of the target map.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.MultiToSingleValueMapAdapter#hashCode()",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.MultiToSingleValueMapAdapter#hashCode() is used to generate a hash code value for the object.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.MultiToSingleValueMapAdapter#hashCode()",
      "head_type": "method",
      "relation": "have",
      "tail": "package com.healthMgr.common.util; import java.util.Map; import org.springframework.util.MultiToSingleValueMapAdapter; public class OneClass { public static void main(String[] args) { MultiToSingleValueMapAdapter adapter = new MultiToSingleValueMapAdapter(); // specific code } }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.MultiValueMapAdapter#addAll(K,List<? extends V>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "adding multiple values to a map",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MultiValueMapAdapter#addAll(K,List<? extends V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.MultiValueMapAdapter",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.MultiValueMapAdapter#addAll(K,List<? extends V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.MultiValueMapAdapter#addAll(K,List<? extends V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.MultiValueMapAdapter#addAll(K,List<? extends V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.MultiValueMapAdapter#hashCode()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "generate hash code",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.MultiValueMapAdapter#hashCode()",
      "head_type": "method",
      "relation": "have",
      "tail": "The method overrides the default hashCode behavior to provide a hash code based on the targetMap's hash code.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.MultiValueMapAdapter#hashCode()",
      "head_type": "method",
      "relation": "have",
      "tail": "This ensures that the hash code of the MultiValueMapAdapter is consistent with the hash code of the underlying targetMap.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.MultiValueMapAdapter#hashCode()",
      "head_type": "method",
      "relation": "have",
      "tail": "java\n@Override\npublic int hashCode() {\n    return this.targetMap.hashCode();\n}\n",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ObjectUtils",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "nullSafeHashCode(short[])",
      "tail_type": "apiFunction"
    },
    {
      "head": "nullSafeHashCode(short[])",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "deprecated as of 6.1",
      "tail_type": "useConstraint"
    },
    {
      "head": "nullSafeHashCode(short[])",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "hash code generation for short array",
      "tail_type": "useScenario"
    },
    {
      "head": "nullSafeHashCode(short[])",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "public static int nullSafeHashCode(short @Nullable [] array) { return Arrays.hashCode(array); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "nullSafeHashCode(short[])",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "Handles null arrays by returning 0, ensuring no NullPointerExceptions.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "nullSafeHashCode(short[])",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "Design principle of null safety to prevent common errors in Java.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ObjectUtils#nullSafeHashCode(short[])",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.ObjectUtils",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.SimplePlaceholderPart#resolveRecursively(PartResolutionContext)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "recursiveResolution",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.SimplePlaceholderPart#resolveRecursively(PartResolutionContext)",
      "head_type": "method",
      "relation": "have",
      "tail": "resolveRecursivelySampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "resolveRecursivelySampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "org.springframework.util.SimplePlaceholderPart",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.SimplePlaceholderPart#resolveRecursively(PartResolutionContext)",
      "head_type": "method",
      "relation": "have",
      "tail": "recursiveResolutionExplanation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.PlaceholderResolutionException#buildMessage(String,List<String>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "buildMessage",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.PlaceholderResolutionException#buildMessage(String,List<String>)",
      "head_type": "method",
      "relation": "have",
      "tail": "Concatenates a reason with a formatted list of values to build an error message.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.PlaceholderResolutionException#buildMessage(String,List<String>)",
      "head_type": "method",
      "relation": "have",
      "tail": "private static String buildMessage(String reason, List<String> values) {\n    StringBuilder sb = new StringBuilder();\n    sb.append(reason);\n    if (!CollectionUtils.isEmpty(values)) {\n        String valuesChain = values.stream().map(value -> \\\"\" + value + \"\\\"\").collect(Collectors.joining(\" <-- \"));\n        sb.append(\" in value %s\".formatted(valuesChain));\n    }\n    return sb.toString();\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#doWithMethods(Class<?>,MethodCallback)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "introspection",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#doWithMethods(Class<?>,MethodCallback)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "callback invocation",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#doWithMethods(Class<?>,MethodCallback)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "introspection failure",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#doWithMethods(Class<?>,MethodCallback)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "class and superclass methods",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#doWithMethods(Class<?>,MethodCallback)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "relatedConceptInterpretation",
      "head_type": "relatedConceptInterpretation",
      "relation": "have",
      "tail": "The method iterates over all methods of the given class and its superclasses, applying a callback to each method. It handles method filtering and introspection.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#doWithMethods(Class<?>,MethodCallback)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "designPrincipleInterpretation",
      "head_type": "designPrincipleInterpretation",
      "relation": "have",
      "tail": "The method follows the principle of reflection and callback to provide a flexible way to process class methods. It ensures that each method is processed only once unless specified by a MethodFilter.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.ReflectionUtils#doWithMethods(Class<?>,MethodCallback)",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "useSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "package com.example;\nimport org.springframework.util.ReflectionUtils;\nimport java.lang.reflect.Method;\npublic class Sample {\n    public static void main(String[] args) {\n        ReflectionUtils.doWithMethods(SampleClass.class, new ReflectionUtils.MethodCallback() {\n            @Override\n            public void doWith(Method method) throws IllegalArgumentException, IllegalAccessException {\n                System.out.println(method.getName());\n            }\n        });\n    }\n}\n\nclass SampleClass {\n    public void sampleMethod() {}\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.SimpleRouteMatcher#getPathMatcher()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getPathMatcher",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.SimpleRouteMatcher#getPathMatcher()",
      "head_type": "method",
      "relation": "have",
      "tail": "Return the underlying PathMatcher delegate.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.SimpleRouteMatcher",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.SimpleRouteMatcher#getPathMatcher()",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.StopWatch#getLastTaskName()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "get the name of the last task",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StopWatch#getLastTaskName()",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "deprecated as of 6.1",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.StopWatch#getLastTaskName()",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "TaskInfo#getTaskName()",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.StopWatch#getLastTaskName()",
      "head_type": "method",
      "relation": "have",
      "tail": "get the name of the last task",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.StopWatch#getLastTaskName()",
      "head_type": "method",
      "relation": "have",
      "tail": "prefer lastTaskInfo() since 6.1",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.StopWatch#getLastTaskName()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "TaskInfo",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.StopWatch#getLastTaskName()",
      "head_type": "method",
      "relation": "have",
      "tail": "public String getLastTaskName() throws IllegalStateException { return lastTaskInfo().getTaskName(); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.StopWatch#getTaskInfo()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "get an array of the data for tasks performed",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StopWatch#getTaskInfo()",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "Task info is not being kept",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.StopWatch#getTaskInfo()",
      "head_type": "method",
      "relation": "have",
      "tail": "Task info is not being kept",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.StopWatch#getTaskInfo()",
      "head_type": "method",
      "relation": "have",
      "tail": "Get an array of the data for tasks performed",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.StopWatch#getTaskInfo()",
      "head_type": "method",
      "relation": "have",
      "tail": "Get an array of the data for tasks performed",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.StreamUtils",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "copyToByteArray",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StreamUtils",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "copyToString",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StreamUtils",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "copy",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StreamUtils",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "copyRange",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StreamUtils",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "drain",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StreamUtils",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "emptyInput",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StreamUtils",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "nonClosing",
      "tail_type": "apiFunction"
    },
    {
      "head": "copyToByteArray",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "InputStream",
      "tail_type": "class"
    },
    {
      "head": "copyToString",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "InputStream",
      "tail_type": "class"
    },
    {
      "head": "copy",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "InputStream",
      "tail_type": "class"
    },
    {
      "head": "copyRange",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "InputStream",
      "tail_type": "class"
    },
    {
      "head": "drain",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "InputStream",
      "tail_type": "class"
    },
    {
      "head": "emptyInput",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "InputStream",
      "tail_type": "class"
    },
    {
      "head": "nonClosing",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "InputStream",
      "tail_type": "class"
    },
    {
      "head": "nonClosing",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "OutputStream",
      "tail_type": "class"
    },
    {
      "head": "copyToString",
      "head_type": "apiFunction",
      "relation": "useSampleCode",
      "tail": "public static String copyToString(@Nullable InputStream in, Charset charset) throws IOException {\n    if (in == null) {\n        return \"\";\n    }\n    StringBuilder out = new StringBuilder();\n    InputStreamReader reader = new InputStreamReader(in, charset);\n    char[] buffer = new char[BUFFER_SIZE];\n    int charsRead;\n    while ((charsRead = reader.read(buffer)) != -1) {\n        out.append(buffer, 0, charsRead);\n    }\n    return out.toString();\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "StreamUtils",
      "head_type": "class",
      "relation": "relatedConceptInterpretation",
      "tail": "Stream manipulation utilities",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "StreamUtils",
      "head_type": "class",
      "relation": "designPrincipleInterpretation",
      "tail": "Provide efficient stream manipulation methods",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.StringUtils#tokenizeToStringArray(String,String,boolean,boolean)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "tokenize string into array",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.StringUtils#tokenizeToStringArray(String,String,boolean,boolean)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "input string can be null or empty",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.StringUtils#tokenizeToStringArray(String,String,boolean,boolean)",
      "head_type": "method",
      "relation": "applied_to",
      "tail": "string manipulation",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.StringUtils#tokenizeToStringArray(String,String,boolean,boolean)",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for tokenizing string",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.StringUtils#tokenizeToStringArray(String,String,boolean,boolean)",
      "head_type": "method",
      "relation": "have",
      "tail": "related concept interpretation for string tokenization",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.StringUtils#tokenizeToStringArray(String,String,boolean,boolean)",
      "head_type": "method",
      "relation": "have",
      "tail": "design principle interpretation for string tokenization",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.StringUtils#tokenizeToStringArray(String,String,boolean,boolean)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "java.util.StringTokenizer",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.StringUtils#tokenizeToStringArray(String,String,boolean,boolean)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "String#trim()",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.StringUtils#tokenizeToStringArray(String,String,boolean,boolean)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "delimitedListToStringArray",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.unit.DataSize#ofBytes(long)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "representing the specified number of bytes",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.unit.DataSize#ofBytes(long)",
      "head_type": "method",
      "relation": "have",
      "tail": "Obtain a DataSize representing the specified number of bytes",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.unit.DataSize#ofBytes(long)",
      "head_type": "method",
      "relation": "have",
      "tail": "The method returns a DataSize object representing the specified number of bytes, which can be positive or negative",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.unit.DataSize#ofBytes(long)",
      "head_type": "method",
      "relation": "have",
      "tail": "The method is designed to be simple and efficient, directly creating a DataSize object with the specified number of bytes",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.unit.DataSize#toKilobytes()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "Return the number of kilobytes in this instance.",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.unit.DataSize#toKilobytes()",
      "head_type": "method",
      "relation": "have",
      "tail": "Return the number of kilobytes in this instance.",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.unit.DataSize#toKilobytes()",
      "head_type": "method",
      "relation": "have",
      "tail": "Converts the data size to kilobytes by dividing the number of bytes by the number of bytes per kilobyte.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.unit.DataSize#toKilobytes()",
      "head_type": "method",
      "relation": "have",
      "tail": "This method follows the principle of unit conversion, ensuring that the data size is accurately represented in kilobytes.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#getOrDefault(Object,List<V>)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getOrDefault",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#getOrDefault(Object,List<V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "getOrDefault returns an unmodifiable list if it is not the default value",
      "tail_type": "useSampleCode"
    },
    {
      "head": "getOrDefault returns an unmodifiable list if it is not the default value",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "tail": "org.springframework.util.UnmodifiableMultiValueMap#getOrDefault(Object,List<V>)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#getOrDefault(Object,List<V>)",
      "head_type": "method",
      "relation": "have",
      "tail": "Ensure thread-safe access to the underlying delegate map",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "Ensure thread-safe access to the underlying delegate map",
      "head_type": "designPrincipleInterpretation",
      "relation": "associated_with",
      "tail": "org.springframework.util.UnmodifiableMultiValueMap#getOrDefault(Object,List<V>)",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#entrySet()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "entrySet",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#entrySet()",
      "head_type": "method",
      "relation": "have",
      "tail": "UnmodifiableMultiValueMap",
      "tail_type": "class"
    },
    {
      "head": "entrySet",
      "head_type": "apiFunction",
      "relation": "associated_with",
      "tail": "UnmodifiableMultiValueMap",
      "tail_type": "class"
    },
    {
      "head": "UnmodifiableMultiValueMap",
      "head_type": "class",
      "relation": "have",
      "tail": "UnmodifiableEntrySet",
      "tail_type": "class"
    },
    {
      "head": "UnmodifiableMultiValueMap",
      "head_type": "class",
      "relation": "have",
      "tail": "delegate",
      "tail_type": "class"
    },
    {
      "head": "UnmodifiableEntrySet",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "delegate",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#entrySet()",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#entrySet()",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#entrySet()",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#remove(Object,Object)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "removeElement",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#remove(Object,Object)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "unsupportedOperation",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#remove(Object,Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "unsupportedOperationSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#remove(Object,Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#remove(Object,Object)",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableMultiValueMap#remove(Object,Object)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.UnmodifiableMultiValueMap",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySet#stream()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "streaming",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySet#stream()",
      "head_type": "method",
      "relation": "have",
      "tail": "StreamSupport.stream(spliterator(), false)",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySet#stream()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "Stream",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.UnmodifiableEntrySet#stream()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "Entry",
      "tail_type": "class"
    },
    {
      "head": "streaming",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "org.springframework.util.UnmodifiableEntrySet#stream()",
      "tail_type": "method"
    },
    {
      "head": "StreamSupport.stream(spliterator(), false)",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "org.springframework.util.UnmodifiableEntrySet#stream()",
      "tail_type": "method"
    },
    {
      "head": "Stream",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.UnmodifiableEntrySet#stream()",
      "tail_type": "method"
    },
    {
      "head": "Entry",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.UnmodifiableEntrySet#stream()",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueCollection#toString()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "toString()",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueCollection#toString()",
      "head_type": "method",
      "relation": "have",
      "tail": "Converts the collection to a string representation.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueCollection#toString()",
      "head_type": "method",
      "relation": "have",
      "tail": "Delegates the toString operation to the underlying delegate collection.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.UnmodifiableValueCollection#toString()",
      "head_type": "method",
      "relation": "have",
      "tail": "public String toString() {\n    return this.delegate.toString();\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxXMLReader#hasNamespacesFeature()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "Indicates whether the SAX feature is turned on",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxXMLReader#hasNamespacesFeature()",
      "head_type": "method",
      "relation": "have",
      "tail": "Indicates whether the SAX feature http://xml.org/sax/features/namespaces is turned on",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.AbstractStaxXMLReader",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.AbstractStaxXMLReader#hasNamespacesFeature()",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLStreamReader#isWhiteSpace()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "check if the current event is a whitespace",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLStreamReader#isWhiteSpace()",
      "head_type": "method",
      "relation": "have",
      "tail": "getEventType() == XMLStreamConstants.SPACE",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.AbstractXMLStreamReader#isWhiteSpace()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.AbstractXMLStreamReader",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.DomContentHandler",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "SAXContentHandlerToDOMNodes",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.DomContentHandler",
      "head_type": "class",
      "relation": "have",
      "tail": "SAXContentHandlerToDOMNodesDescription",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "SAXContentHandlerToDOMNodesDescription",
      "head_type": "relatedConceptInterpretation",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.DomContentHandler",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.DomContentHandler",
      "head_type": "class",
      "relation": "have",
      "tail": "SAXContentHandlerToDOMNodesSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "SAXContentHandlerToDOMNodesSampleCode",
      "head_type": "useSampleCode",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.DomContentHandler",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.DomUtils#nodeNameEquals(Node,String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "namespace-aware equals comparison",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.DomUtils#nodeNameEquals(Node,String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "Node must not be null",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.xml.DomUtils#nodeNameEquals(Node,String)",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "Desired name must not be null",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.util.xml.DomUtils#nodeNameEquals(Node,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "Returns true if either Node.getLocalName or Node.getNodeName equals desiredName, otherwise returns false",
      "tail_type": "useScenario"
    },
    {
      "head": "org.springframework.util.xml.DomUtils#nodeNameEquals(Node,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "public static boolean nodeNameEquals(Node node, String desiredName) { Assert.notNull(node, \"Node must not be null\"); Assert.notNull(desiredName, \"Desired name must not be null\"); return nodeNameMatch(node, desiredName); }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.DomUtils#nodeNameEquals(Node,String)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.DomUtils",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.DomUtils#nodeNameEquals(Node,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "This method is used for namespace-aware comparison of node names in XML documents.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.DomUtils#nodeNameEquals(Node,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "The design principle behind this method is to provide a utility for comparing node names in a way that is aware of XML namespaces, enhancing flexibility and accuracy in XML processing.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.SimpleNamespaceContext",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getPrefixesSet(String namespaceUri)",
      "tail_type": "apiFunction"
    },
    {
      "head": "getPrefixesSet(String namespaceUri)",
      "head_type": "apiFunction",
      "relation": "constrained_by",
      "tail": "namespaceUri must not be null",
      "tail_type": "useConstraint"
    },
    {
      "head": "getPrefixesSet(String namespaceUri)",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "retrieve prefixes for a given namespace URI",
      "tail_type": "useScenario"
    },
    {
      "head": "getPrefixesSet(String namespaceUri)",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "private Set<String> getPrefixesSet(String namespaceUri) { Assert.notNull(namespaceUri, 'namespaceUri' must not be null'); if (this.defaultNamespaceUri.equals(namespaceUri)) { return Collections.singleton(XMLConstants.DEFAULT_NS_PREFIX); } else if (XMLConstants.XML_NS_URI.equals(namespaceUri)) { return Collections.singleton(XMLConstants.XML_NS_PREFIX); } else if (XMLConstants.XMLNS_ATTRIBUTE_NS_URI.equals(namespaceUri)) { return Collections.singleton(XMLConstants.XMLNS_ATTRIBUTE); } else { Set<String> prefixes = this.namespaceUriToPrefixes.get(namespaceUri); return (prefixes != null ? Collections.unmodifiableSet(prefixes) : Collections.emptySet()); } }",
      "tail_type": "useSampleCode"
    },
    {
      "head": "getPrefixesSet(String namespaceUri)",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "This method retrieves the prefixes set associated with a given namespace URI. It checks if the provided namespace URI matches any of the predefined ones and returns the corresponding prefix. If the namespace URI is not predefined, it fetches the prefixes from a map and returns them as an unmodifiable set.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "getPrefixesSet(String namespaceUri)",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "The design principle behind this method is to provide a flexible and efficient way to retrieve prefixes for namespace URIs. It ensures that the method can handle both predefined and dynamic namespace URIs, returning the appropriate prefixes while maintaining immutability of the returned set.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.SimpleNamespaceContext",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamReader#getAttributeCount()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getAttributeCount",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamReader#getAttributeCount()",
      "head_type": "method",
      "relation": "have",
      "tail": "��取属性数量",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamReader#getAttributeCount()",
      "head_type": "method",
      "relation": "have",
      "tail": "确保事件是StartElement",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamReader#getAttributeCount()",
      "head_type": "method",
      "relation": "have",
      "tail": "使用XMLEventStreamReader获取属性数量",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamReader#close()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "close XMLEventStreamReader",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamReader#close()",
      "head_type": "method",
      "relation": "have",
      "tail": "close XMLEventStreamReader sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "close XMLEventStreamReader sample code",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "package com.xml.stream.reader;\n\nimport org.springframework.util.xml.XMLEventStreamReader;\n\npublic class XMLStreamCloser {\n    public static void main(String[] args) {\n        XMLEventStreamReader reader = new XMLEventStreamReader();\n        try {\n            reader.close();\n        } catch (XMLStreamException e) {\n            e.printStackTrace();\n        }\n    }\n}",
      "tail_type": "String"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter#writeStartDocument(String,String)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "writeStartDocument",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter#writeStartDocument(String,String)",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.util.xml.XMLEventStreamWriter",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.util.xml.XMLEventStreamWriter#writeStartDocument(String,String)",
      "tail_type": "method"
    },
    {
      "head": "writeStartDocument",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "org.springframework.util.xml.XMLEventStreamWriter#writeStartDocument(String,String)",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.util.xml.XMLEventStreamWriter#writeStartDocument(String,String)",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "public void writeStartDocument(String encoding, String version) throws XMLStreamException {\n    closeEmptyElementIfNecessary();\n    this.eventWriter.add(this.eventFactory.createStartDocument(encoding, version));\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "example.type.TestNonInheritingClass",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "lazy loading",
      "tail_type": "apiFunction"
    },
    {
      "head": "example.type.TestNonInheritingClass",
      "head_type": "class",
      "relation": "constrained_by",
      "tail": "circular aliases are prohibited",
      "tail_type": "useConstraint"
    },
    {
      "head": "example.type.TestNonInheritingClass",
      "head_type": "class",
      "relation": "applied_to",
      "tail": "multiple aliases for a single name",
      "tail_type": "useScenario"
    },
    {
      "head": "example.type.TestNonInheritingClass",
      "head_type": "class",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "example.type.TestNonInheritingClass",
      "head_type": "class",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "example.type.TestNonInheritingClass",
      "head_type": "class",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "example.type.TestNonInheritingClass",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.core.SimpleAliasRegistryTests",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#isAccessibleWhenPublicVisibilityInSamePackage()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "Access Control",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#isAccessibleWhenPublicVisibilityInSamePackage()",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.aot.generate.AccessControlTests",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.AccessControl",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#isAccessibleWhenPublicVisibilityInSamePackage()",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#isAccessibleWhenPublicVisibilityInSamePackage()",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.AccessControlTests#isAccessibleWhenPublicVisibilityInSamePackage()",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.ClassNameGeneratorTests#generateClassNameWithClassWhenLowercaseFeatureNameGeneratesName()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "generateClassName",
      "tail_type": "apiFunction"
    },
    {
      "head": "generateClassName",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "generateClassNameWithClassWhenLowercaseFeatureNameGeneratesName() sample code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "generateClassNameWithClassWhenLowercaseFeatureNameGeneratesName() sample code",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "org.springframework.aot.generate.ClassNameGeneratorTests",
      "tail_type": "class"
    },
    {
      "head": "generateClassNameWithClassWhenLowercaseFeatureNameGeneratesName() sample code",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "generateClassNameWithClassWhenLowercaseFeatureNameGeneratesName() related concept interpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "generateClassNameWithClassWhenLowercaseFeatureNameGeneratesName() sample code",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "generateClassNameWithClassWhenLowercaseFeatureNameGeneratesName() design principle interpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassesTests#createWhenClassNameGeneratorIsNullThrowsException()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "generate",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassesTests#createWhenClassNameGeneratorIsNullThrowsException()",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "null value constraint",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassesTests#createWhenClassNameGeneratorIsNullThrowsException()",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassesTests#createWhenClassNameGeneratorIsNullThrowsException()",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassesTests",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.GeneratedClasses",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassesTests#createWhenClassNameGeneratorIsNullThrowsException()",
      "head_type": "method",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedClassesTests",
      "head_type": "class",
      "relation": "haveFunction",
      "tail": "getOrAddForFeatureWhenRepeatReturnsSameGeneratedClass",
      "tail_type": "apiFunction"
    },
    {
      "head": "getOrAddForFeatureWhenRepeatReturnsSameGeneratedClass",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "getOrAddForFeatureWhenRepeatReturnsSameGeneratedClass() Sample Code",
      "tail_type": "useSampleCode"
    },
    {
      "head": "getOrAddForFeatureWhenRepeatReturnsSameGeneratedClass() Sample Code",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "Complete Example for getOrAddForFeatureWhenRepeatReturnsSameGeneratedClass()",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests#addSourceFileWithCharSequenceWhenClassNameIsEmptyThrowsException()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "addSourceFileWithCharSequence",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests#addSourceFileWithCharSequenceWhenClassNameIsEmptyThrowsException()",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "classNameMustNotBeEmpty",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests#addSourceFileWithCharSequenceWhenClassNameIsEmptyThrowsException()",
      "head_type": "method",
      "relation": "have",
      "tail": "addSourceFileWithCharSequenceWhenClassNameIsEmptyThrowsExceptionSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "addSourceFileWithCharSequenceWhenClassNameIsEmptyThrowsExceptionSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "org.springframework.aot.generate.GeneratedFilesTests",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests#addSourceFileWithCharSequenceWhenClassNameIsEmptyThrowsException()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.GeneratedFilesTests",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests#handleFileWhenFileExistsCanOverrideUsingExistingContent()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "override file content",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests#handleFileWhenFileExistsCanOverrideUsingExistingContent()",
      "head_type": "method",
      "relation": "have",
      "tail": "AtomicBoolean called = new AtomicBoolean(false); this.generatedFiles.handleFile(Kind.RESOURCE, \"META-INF/test\", handler -> { called.set(true); assertThat(handler.getContent()).isNotNull(); String existing = readSource(handler.getContent()); handler.override(createSource(existing + \"-override\")); }); assertThat(called).isTrue(); assertThatFileAdded(Kind.RESOURCE, \"META-INF/test\").isEqualTo(\"existing-override\").hasOverride(true);",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests#handleFileWhenFileExistsCanOverrideUsingExistingContent()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.GeneratedFilesTests",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests#handleFileWhenFileExistsCanOverrideUsingExistingContent()",
      "head_type": "method",
      "relation": "have",
      "tail": "This method tests the ability to override existing file content when handling files. It verifies that the file handler can read the existing content, override it with new content, and ensure that the override is correctly applied.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedFilesTests#handleFileWhenFileExistsCanOverrideUsingExistingContent()",
      "head_type": "method",
      "relation": "have",
      "tail": "The design principle demonstrated in this method is the importance of ensuring that file operations are atomic and consistent. It emphasizes the need for thorough testing of file handling mechanisms to ensure that overrides are correctly applied and that the system behaves as expected under various conditions.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedMethodsTests#createWithExistingGeneratorUsesGenerator()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "generate methods",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedMethodsTests#createWithExistingGeneratorUsesGenerator()",
      "head_type": "method",
      "relation": "have",
      "tail": "sample code for generate methods",
      "tail_type": "useSampleCode"
    },
    {
      "head": "sample code for generate methods",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "org.springframework.aot.generate.GeneratedMethodsTests#createWithExistingGeneratorUsesGenerator()",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedMethodsTests",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.GeneratedMethodsTests#createWithExistingGeneratorUsesGenerator()",
      "tail_type": "method"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedMethodsTests#createWithExistingGeneratorUsesGenerator()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.GeneratedMethodsTests",
      "tail_type": "class"
    },
    {
      "relationships": [
        {
          "tail": "generateMethodWithPrefix",
          "head_type": "method",
          "relation": "haveFunction",
          "head": "org.springframework.aot.generate.GeneratedMethodsTests#withPrefixWhenGeneratingIsMethodUsesPrefix()",
          "tail_type": "apiFunction"
        },
        {
          "tail": "GeneratedMethodExample",
          "head_type": "method",
          "relation": "have",
          "head": "org.springframework.aot.generate.GeneratedMethodsTests#withPrefixWhenGeneratingIsMethodUsesPrefix()",
          "tail_type": "useSampleCode"
        },
        {
          "tail": "prefixBasedMethodNameGeneration",
          "head_type": "apiFunction",
          "relation": "applied_to",
          "head": "generateMethodWithPrefix",
          "tail_type": "useScenario"
        },
        {
          "tail": "GeneratedMethodExample",
          "head_type": "useScenario",
          "relation": "have",
          "head": "prefixBasedMethodNameGeneration",
          "tail_type": "useSampleCode"
        },
        {
          "tail": "org.springframework.aot.generate.GeneratedMethodsTests",
          "head_type": "method",
          "relation": "associated_with",
          "head": "org.springframework.aot.generate.GeneratedMethodsTests#withPrefixWhenGeneratingIsMethodUsesPrefix()",
          "tail_type": "class"
        },
        {
          "tail": "GeneratedMethodDesignPrinciples",
          "head_type": "class",
          "relation": "have",
          "head": "org.springframework.aot.generate.GeneratedMethodsTests",
          "tail_type": "designPrincipleInterpretation"
        },
        {
          "tail": "GeneratedMethodConceptInterpretation",
          "head_type": "class",
          "relation": "have",
          "head": "org.springframework.aot.generate.GeneratedMethodsTests",
          "tail_type": "relatedConceptInterpretation"
        }
      ]
    },
    {
      "relationships": [
        {
          "tail": "generateMethodWithPrefix",
          "head_type": "method",
          "relation": "haveFunction",
          "head": "org.springframework.aot.generate.GeneratedMethodsTests#withPrefixWhenGeneratingIsMethodUsesPrefix()",
          "tail_type": "apiFunction"
        },
        {
          "tail": "GeneratedMethodExample",
          "head_type": "method",
          "relation": "have",
          "head": "org.springframework.aot.generate.GeneratedMethodsTests#withPrefixWhenGeneratingIsMethodUsesPrefix()",
          "tail_type": "useSampleCode"
        },
        {
          "tail": "prefixBasedMethodNameGeneration",
          "head_type": "apiFunction",
          "relation": "applied_to",
          "head": "generateMethodWithPrefix",
          "tail_type": "useScenario"
        },
        {
          "tail": "GeneratedMethodExample",
          "head_type": "useScenario",
          "relation": "have",
          "head": "prefixBasedMethodNameGeneration",
          "tail_type": "useSampleCode"
        },
        {
          "tail": "org.springframework.aot.generate.GeneratedMethodsTests",
          "head_type": "method",
          "relation": "associated_with",
          "head": "org.springframework.aot.generate.GeneratedMethodsTests#withPrefixWhenGeneratingIsMethodUsesPrefix()",
          "tail_type": "class"
        },
        {
          "tail": "GeneratedMethodDesignPrinciples",
          "head_type": "class",
          "relation": "have",
          "head": "org.springframework.aot.generate.GeneratedMethodsTests",
          "tail_type": "designPrincipleInterpretation"
        },
        {
          "tail": "GeneratedMethodConceptInterpretation",
          "head_type": "class",
          "relation": "have",
          "head": "org.springframework.aot.generate.GeneratedMethodsTests",
          "tail_type": "relatedConceptInterpretation"
        }
      ]
    },
    {
      "head": "org.springframework.aot.generate.GeneratedMethodTests#getNameReturnsName()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "getNameReturnsName",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedMethodTests#getNameReturnsName()",
      "head_type": "method",
      "relation": "have",
      "tail": "GeneratedMethod.getName() returns the name of the generated method.",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedMethodTests#getNameReturnsName()",
      "head_type": "method",
      "relation": "have",
      "tail": "Testing the GeneratedMethod class to ensure its getName() method returns the correct method name.",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedMethodTests#getNameReturnsName()",
      "head_type": "method",
      "relation": "have",
      "tail": "package org.springframework.aot.generate;\n\nimport org.junit.jupiter.api.Test;\nimport static org.assertj.core.api.Assertions.assertThat;\n\npublic class GeneratedMethodTests {\n\n    @Test\n    void getNameReturnsName() {\n        GeneratedMethod generatedMethod = new GeneratedMethod(TEST_CLASS_NAME, NAME, emptyMethod);\n        assertThat(generatedMethod.getName()).isSameAs(NAME);\n    }\n\n    // Additional methods and necessary imports can be added here\n}",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedMethodTests#getNameReturnsName()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.GeneratedMethod",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedMethodTests#generateMethodSpecWhenMethodNameIsChangedThrowsException()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "generateMethodSpec",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedMethodTests#generateMethodSpecWhenMethodNameIsChangedThrowsException()",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "methodNameChangeProhibited",
      "tail_type": "useConstraint"
    },
    {
      "head": "generateMethodSpec",
      "head_type": "apiFunction",
      "relation": "applied_to",
      "tail": "methodNameValidation",
      "tail_type": "useScenario"
    },
    {
      "head": "generateMethodSpec",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "useSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "generateMethodSpec",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "generateMethodSpec",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.GeneratedMethodTests#generateMethodSpecWhenMethodNameIsChangedThrowsException()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.GeneratedMethodTests",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.ExceptionTests#generateWhenUnsupportedDataTypeThrowsException()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "generateCode",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.generate.ExceptionTests#generateWhenUnsupportedDataTypeThrowsException()",
      "head_type": "method",
      "relation": "constrained_by",
      "tail": "unsupportedDataType",
      "tail_type": "useConstraint"
    },
    {
      "head": "org.springframework.aot.generate.ExceptionTests#generateWhenUnsupportedDataTypeThrowsException()",
      "head_type": "method",
      "relation": "have",
      "tail": "sampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.generate.ExceptionTests#generateWhenUnsupportedDataTypeThrowsException()",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.ExceptionTests#generateWhenUnsupportedDataTypeThrowsException()",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.generate.ExceptionTests#generateWhenUnsupportedDataTypeThrowsException()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate.ValueCodeGenerationException",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.generate.ExceptionTests#generateWhenUnsupportedDataTypeThrowsException()",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.generate",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.hint.annotation.SampleMethodAnnotatedBeanWithInterface#managed()",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "managedFunction",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.hint.annotation.SampleMethodAnnotatedBeanWithInterface#managed()",
      "head_type": "method",
      "relation": "have",
      "tail": "org.springframework.aot.hint.annotation.SampleMethodAnnotatedBeanWithInterface",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.hint.annotation.SampleMethodAnnotatedBeanWithInterface",
      "head_type": "class",
      "relation": "associated_with",
      "tail": "org.springframework.aot.hint.annotation",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.hint.annotation.SampleMethodAnnotatedBeanWithInterface#managed()",
      "head_type": "method",
      "relation": "have",
      "tail": "sampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.hint.annotation.SampleMethodAnnotatedBeanWithInterface#managed()",
      "head_type": "method",
      "relation": "have",
      "tail": "relatedConceptInterpretation",
      "tail_type": "relatedConceptInterpretation"
    },
    {
      "head": "org.springframework.aot.hint.annotation.SampleMethodAnnotatedBeanWithInterface#managed()",
      "head_type": "method",
      "relation": "have",
      "tail": "designPrincipleInterpretation",
      "tail_type": "designPrincipleInterpretation"
    },
    {
      "head": "org.springframework.aot.hint.annotation.TestMethodHintReflectiveProcessor#registerMethodHint(ReflectionHints,Method)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "registerMethodHint",
      "tail_type": "apiFunction"
    },
    {
      "head": "registerMethodHint",
      "head_type": "apiFunction",
      "relation": "have",
      "tail": "registerMethodHintSampleCode",
      "tail_type": "useSampleCode"
    },
    {
      "head": "registerMethodHintSampleCode",
      "head_type": "useSampleCode",
      "relation": "have",
      "tail": "registerMethodHintCodeContent",
      "tail_type": "useSampleCode"
    },
    {
      "head": "org.springframework.aot.hint.annotation.RegisterReflectionReflectiveProcessorTests#registerReflectionHints(AnnotatedElement)",
      "head_type": "method",
      "relation": "haveFunction",
      "tail": "registerReflectionHints",
      "tail_type": "apiFunction"
    },
    {
      "head": "org.springframework.aot.hint.annotation.RegisterReflectionReflectiveProcessorTests#registerReflectionHints(AnnotatedElement)",
      "head_type": "method",
      "relation": "associated_with",
      "tail": "org.springframework.aot.hint.annotation.RegisterReflectionReflectiveProcessorTests",
      "tail_type": "class"
    },
    {
      "head": "org.springframework.aot.hint.annotation.RegisterReflectionReflectiveProcessorTests",
      "head_type": "class",
      "relation": "have",
      "tail": "org.springframework.aot.hint.annotation.RegisterReflectionReflectiveProcessorTests#registerReflectionHints(AnnotatedElement)",
      "tail_type": "method"
    }
  ]
}